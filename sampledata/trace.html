<!DOCTYPE html>
<html>
  <head i18n-values="dir:textdirection;">
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>Trace from trace.json</title>
  <!--
Polymer is imported through third-party HTML files, which means that we have to
manually list all recursive imports.
--><style>
* /deep/ .labeled-checkbox {
  display: flex;
  white-space: nowrap;
}
</style><dom-module id="tr-ui-a-analysis-link">
  <template>
    <style>
    :host {
      display: inline;
      cursor: pointer;
      cursor: pointer;
      white-space: nowrap;
    }
    a {
      text-decoration: underline;
    }
    </style>
    <a href="{{href}}" on-click="onClicked_" on-mouseenter="onMouseEnter_" on-mouseleave="onMouseLeave_"><content></content></a>

  </template>
</dom-module><!--
@fileoverview Polymer element for various analysis sub-views.
--><!--
@fileoverview A container that constructs a table-like container.
--><dom-module id="tr-ui-b-table">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      table {
        flex: 1 1 auto;
        align-self: stretch;
        border-collapse: separate;
        border-spacing: 0;
        border-width: 0;
        -webkit-user-select: initial;
      }

      tr > td {
        padding: 2px 4px 2px 4px;
        vertical-align: top;
      }

      table > tbody:focus {
        outline: none;
      }
      table > tbody:focus[selection-mode="row"] > tr[selected],
      table > tbody:focus[selection-mode="cell"] > tr > td[selected],
      table > tbody:focus > tr.empty-row > td {
        outline: 1px dotted #666666;
        outline-offset: -1px;
      }

      button.toggle-button {
        height: 15px;
        line-height: 60%;
        vertical-align: middle;
        width: 100%;
      }

      button > * {
        height: 15px;
        vertical-align: middle;
      }

      td.button-column {
        width: 30px;
      }

      table > thead > tr > td.sensitive:hover {
        background-color: #fcfcfc;
      }

      table > thead > tr > td {
        font-weight: bold;
        text-align: left;

        background-color: #eee;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        border-top: 1px solid #ffffff;
        border-bottom: 1px solid #aaa;
      }

      table > tfoot {
        background-color: #eee;
        font-weight: bold;
      }

      /* Light row and cell highlight. */
      table > tbody[row-highlight-style="light"] > tr[selected],
      table > tbody[cell-highlight-style="light"] > tr > td[selected] {
        background-color: rgb(213, 236, 229);  /* light turquoise */
      }
      table > tbody[row-highlight-style="light"] >
          tr:not(.empty-row):not([selected]):hover,
      table > tbody[cell-highlight-style="light"] >
          tr:not(.empty-row):not([selected]) > td:hover {
        background-color: #f6f6f6;  /* light grey */
      }

      /* Dark row and cell highlight. */
      table > tbody[row-highlight-style="dark"] > tr[selected],
      table > tbody[cell-highlight-style="dark"] > tr > td[selected] {
        background-color: rgb(103, 199, 165);  /* turquoise */
      }
      table > tbody[row-highlight-style="dark"] >
          tr:not(.empty-row):not([selected]):hover,
      table > tbody[cell-highlight-style="dark"] >
          tr:not(.empty-row):not([selected]) > td:hover {
        background-color: #e6e6e6;  /* grey */
      }
      table > tbody[row-highlight-style="dark"] > tr:hover[selected],
      table > tbody[cell-highlight-style="dark"] > tr[selected] > td:hover {
        background-color: rgb(171, 217, 202);  /* semi-light turquoise */
      }

      table > colgroup > col[selected] {
        background-color: #e6e6e6;  /* grey */
      }

      table > tbody > tr.empty-row > td {
        color: #666;
        font-style: italic;
        text-align: center;
      }

      table > tbody.has-footer > tr:last-child > td {
        border-bottom: 1px solid #aaa;
      }

      table > tfoot > tr:first-child > td {
        border-top: 1px solid #ffffff;
      }

      :host([zebra]) table tbody tr:nth-child(even) {
        background-color: #f4f4f4;
      }

      expand-button {
        -webkit-user-select: none;
        cursor: pointer;
        margin-right: 3px;
        font-size: smaller;
        height: 1rem;
      }

      expand-button.button-expanded {
        transform: rotate(90deg);
      }
    </style>
    <table>
      <colgroup id="cols">
      </colgroup>
      <thead id="head">
      </thead>
      <tbody id="body">
      </tbody>
      <tfoot id="foot">
      </tfoot>
    </table>
  </template>
</dom-module><dom-module id="tr-ui-b-table-header-cell">
  <template>
  <style>
    :host {
      -webkit-user-select: none;
      display: flex;
    }

    span {
      flex: 0 1 auto;
    }

    #side {
      -webkit-user-select: none;
      flex: 0 0 auto;
      padding-left: 2px;
      padding-right: 2px;
      vertical-align: top;
      font-size: 15px;
      font-family: sans-serif;
      line-height: 85%;
      margin-left: 5px;
    }

    #side.disabled {
      color: rgb(140, 140, 140);
    }

    #title:empty, #side:empty {
      display: none;
    }
  </style>

    <span id="title"></span>
    <span id="side"></span>
  </template>
</dom-module><dom-module id="tr-ui-a-alert-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-v-ui-scalar-context-controller">
  <template></template>
</dom-module><!--
@fileoverview Polymer element for controlling common context across scalar
spans. To facilitate multiple separate contexts (e.g. a separate context for
each table column), each scalar span has to specify which "context group"
it belongs to:

  +============ some container element (e.g. <div>) ============+
  |                                                             |
  |         <tr-v-ui-scalar-context-controller>                 |
  |             ^                         ^                     |
  |             |                         |                     |
  |             v                         v                     |
  | .... Context group 1 .... .... Context group 2 ....         |
  | : <tr-v-ui-scalar-span> : : <tr-v-ui-scalar-span> :         |
  | : <tr-v-ui-scalar-span> : : <tr-v-ui-scalar-span> :  . . .  |
  | :          . . .        : :         . . .         :         |
  | :.......................: :.......................:         |
  +=============================================================+

An element can find its enclosing context controller using the
getScalarContextControllerForElement(node) defined in this file. Scalar spans
can push their state to the controller using the following three methods:

  1. onScalarSpanAdded(contextGroup, span)
     This method should be called when a span is attached to the DOM tree (or
     afterwards when added to a context group).

  2. onScalarSpanRemoved(contextGroup, span)
     This method should be called when a span is detached from the DOM tree (or
     beforehand when removed from a context group).

  3. onScalarSpanUpdated(contextGroup, span)
     This method should be called when the value of a span changes.

Note: If a span wants to change its context group, it should first call
onScalarSpanRemoved with the old group and then onScalarSpanAdded with the new
group.

If one or more group contexts are modified (due to one of the three methods
above), the controller will asynchronously (at the next RAF) update them and
fire a 'context-updated' event. Scalar spans can listen for this event and
update their UI accordingly.

The context currently consists of the range of values of the associated spans.
This allows automatic display of relative sizes using sparklines.

The controller design is based on:
https://docs.google.com/document/d/16ih8yYK8kF8MMlPnB-5KlyfS_AjjtbyAfi3pkxoZ8xs/edit?usp=sharing
--><dom-module id="tr-v-ui-scalar-span">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
      position: relative;
      /* Limit the sparkline's negative z-index to the span only. */
      isolation: isolate;
    }

    :host(.left-align) {
      justify-content: flex-start;
    }

    :host(.inline) {
      display: inline-flex;
    }

    #sparkline {
      width: 0%;
      position: absolute;
      bottom: 0;
      display: none;
      height: 100%;
      background-color: hsla(216, 100%, 94.5%, .75);
      border-color: hsl(216, 100%, 89%);
      box-sizing: border-box;
      z-index: -1;
    }
    #sparkline.positive {
      border-right-style: solid;
      /* The border width must be kept in sync with buildSparklineStyle_(). */
      border-right-width: 1px;
    }
    #sparkline:not(.positive) {
      border-left-style: solid;
      /* The border width must be kept in sync with buildSparklineStyle_(). */
      border-left-width: 1px;
    }
    #sparkline.better {
      background-color: hsla(115, 100%, 93%, .75);
      border-color: hsl(118, 60%, 80%);
    }
    #sparkline.worse {
      background-color: hsla(0, 100%, 88%, .75);
      border-color: hsl(0, 100%, 80%);
    }

    #content, #significance, #warning {
      flex-grow: 0;
    }
    #content.better {
      color: green;
    }
    #content.worse {
      color: red;
    }

    #significance svg {
      margin-left: 4px;
      display: none;
      height: 1em;
      vertical-align: text-top;
      stroke-width: 4;
      fill: rgba(0, 0, 0, 0);
    }
    #significance #insignificant {
      stroke: black;
    }
    #significance #significantly_better {
      stroke: green;
    }
    #significance #significantly_worse {
      stroke: red;
    }

    #warning {
      display: none;
      margin-left: 4px;
      height: 1em;
      vertical-align: text-top;
      stroke-width: 0;
    }
    #warning path {
      fill: rgb(255, 185, 185);
    }
    #warning rect {
      fill: red;
    }
    </style>

    <span id="sparkline"></span>

    <span id="content"></span>

    <span id="significance">
      <!-- Neutral face -->
      <svg id="insignificant" viewBox="0 0 128 128">
        <circle cx="64" cy="64" r="60"></circle>
        <circle cx="44" cy="44" r="4"></circle>
        <circle cx="84" cy="44" r="4"></circle>
        <line x1="36" x2="92" y1="80" y2="80"></line>
      </svg>

      <!-- Smiling face -->
      <svg id="significantly_better" viewBox="0 0 128 128">
        <circle cx="64" cy="64" r="60"></circle>
        <circle cx="44" cy="44" r="4"></circle>
        <circle cx="84" cy="44" r="4"></circle>
        <path d="M 28 64 Q 64 128 100 64"></path>
      </svg>

      <!-- Frowning face -->
      <svg id="significantly_worse" viewBox="0 0 128 128">
        <circle cx="64" cy="64" r="60"></circle>
        <circle cx="44" cy="44" r="4"></circle>
        <circle cx="84" cy="44" r="4"></circle>
        <path d="M 36 96 Q 64 48 92 96"></path>
      </svg>
    </span>

    <svg id="warning" viewBox="0 0 128 128">
      <path d="M 64 0 L 128 128 L 0 128 L 64 0"></path>
      <rect height="84" width="8" x="60" y="0"></rect>
      <rect height="24" width="8" x="60" y="100"></rect>
    </svg>
  </template>
</dom-module><!--
@fileoverview A view that allows the user to control which single tab is
displayed.

We follow a fairly standard web convention of backing our tabs with hidden radio
buttons but visible radio button labels (the tabs themselves) which toggle the
input element when clicked. Using hidden radio buttons makes sense, as both tabs
and radio buttons are input elements that allow user selection through clicking
and limit users to having one option selected at a time.
--><dom-module id="tr-ui-b-tab-view">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #selection_description, #tabs {
        font-size: 12px;
      }

      #selection_description {
        display: inline-block;
        font-weight: bold;
        margin: 9px 0px 4px 20px;
      }

      #tabs {
        flex: 0 0 auto;
        border-top: 1px solid #8e8e8e;
        border-bottom: 1px solid #8e8e8e;
        background-color: #ececec;
        overflow: hidden;
        margin: 0;
      }

      #tabs input[type=radio] {
        display: none;
      }

      #tabs tab label {
        cursor: pointer;
        display: inline-block;
        border: 1px solid #ececec;
        margin: 5px 0px 0px 15px;
        padding: 3px 10px 3px 10px;
      }

      #tabs tab label span {
        font-weight: bold;
      }

      #tabs:focus input[type=radio]:checked ~ label {
        outline: dotted 1px #8e8e8e;
        outline-offset: -2px;
      }

      #tabs input[type=radio]:checked ~ label {
        background-color: white;
        border: 1px solid #8e8e8e;
        border-bottom: 1px solid white;
      }

      #subView {
        flex: 1 1 auto;
        overflow: auto;
      }
    </style>
    <div hidden="[[tabsHidden]]" id="tabs">
      <label id="selection_description">[[label_]]</label>
      <template is="dom-repeat" items="[[subViews_]]">
        <tab>
          <input checked="[[isChecked_(item)]]" id$="[[computeRadioId_(item)]]" name="tabs" on-change="onTabChanged_" type="radio"/>
          <label for$="[[computeRadioId_(item)]]">
            <template if="[[item.tabIcon]]" is="dom-if">
              <span style$="[[item.tabIcon.style]]">[[item.tabIcon.text]]</span>
            </template>
            [[item.tabLabel]]
          </label>
        </tab>
      </template>
    </div>
    <div id="subView"></div>
    <content>
    </content>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-heap-details-breakdown-view">
  <template>
    <tr-ui-b-tab-view id="tabs"></tr-ui-b-tab-view>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-heap-details-breakdown-view-tab">
  <template>
    <tr-v-ui-scalar-context-controller></tr-v-ui-scalar-context-controller>
    <tr-ui-b-info-bar hidden="" id="info"></tr-ui-b-info-bar>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-heap-details-path-view">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }
    </style>
    <tr-v-ui-scalar-context-controller></tr-v-ui-scalar-context-controller>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><!--
@fileoverview Analysis view stacked pane. See the stacked pane view element
(tr-ui-a-stacked-pane-view) documentation for more details.
--><dom-module id="tr-ui-b-drag-handle">
  <template>
    <style>
    :host {
      -webkit-user-select: none;
      box-sizing: border-box;
      display: block;
    }

    :host(.horizontal-drag-handle) {
      background-image: -webkit-gradient(linear,
                                         0 0, 0 100%,
                                         from(#E5E5E5),
                                         to(#D1D1D1));
      border-bottom: 1px solid #8e8e8e;
      border-top: 1px solid white;
      cursor: ns-resize;
      flex: 0 0 auto;
      height: 7px;
      position: relative;
    }

    :host(.vertical-drag-handle) {
      background-image: -webkit-gradient(linear,
                                         0 0, 100% 0,
                                         from(#E5E5E5),
                                         to(#D1D1D1));
      border-left: 1px solid white;
      border-right: 1px solid #8e8e8e;
      cursor: ew-resize;
      flex: 0 0 auto;
      position: relative;
      width: 7px;
    }
    </style>
    <div></div>
  </template>
</dom-module><dom-module id="tr-ui-b-info-bar">
  <template>
    <style>
    :host {
      align-items: center;
      flex: 0 0 auto;
      background-color: rgb(252, 235, 162);
      border-bottom: 1px solid #A3A3A3;
      border-left: 1px solid white;
      border-right: 1px solid #A3A3A3;
      border-top: 1px solid white;
      display: flex;
      height: 26px;
      padding: 0 3px 0 3px;
    }

    :host([hidden]) {
      display: none !important;
    }

    #message { flex: 1 1 auto; }
    </style>

    <span id="message"></span>
    <span id="buttons"></span>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-heap-details-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #header {
        flex: 0 0 auto;
        display: flex;
        flex-direction: row;
        align-items: center;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;
      }

      #label {
        flex: 1 1 auto;
        padding: 8px;
        font-size: 15px;
        font-weight: bold;
      }

      #view_mode_container {
        display: none;
        flex: 0 0 auto;
        padding: 5px;
        font-size: 15px;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }

      #info_text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }

      #split_view {
        display: none;  /* Hide until memory allocator dumps are set. */
        flex: 1 0 auto;
        align-self: stretch;
        flex-direction: row;
      }

      #path_view {
        width: 50%;
      }

      #breakdown_view {
        flex: 1 1 auto;
        width: 0;
      }

      #path_view, #breakdown_view {
        overflow-x: auto;  /* Show scrollbar if necessary. */
      }
    </style>
    <div id="header">
      <div id="label">Heap details</div>
      <div id="view_mode_container">
        <span>View mode:</span>
        <!-- View mode selector (added in Polymer.ready()) -->
      </div>
    </div>
    <div id="contents">
      <tr-ui-b-info-bar hidden="" id="info_bar">
      </tr-ui-b-info-bar>

      <div id="info_text">No heap dump selected</div>

      <div id="split_view">
        <tr-ui-a-memory-dump-heap-details-path-view id="path_view">
        </tr-ui-a-memory-dump-heap-details-path-view>
        <tr-ui-b-drag-handle id="drag_handle"></tr-ui-b-drag-handle>
        <tr-ui-a-memory-dump-heap-details-breakdown-view id="breakdown_view">
        </tr-ui-a-memory-dump-heap-details-breakdown-view>
      </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-allocator-details-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }

      #info_text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }

      #table {
        display: none;  /* Hide until memory allocator dumps are set. */
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }
    </style>
    <div id="label">Component details</div>
    <div id="contents">
      <div id="info_text">No memory allocator dump selected</div>
      <tr-ui-b-table id="table"></tr-ui-b-table>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-vm-regions-details-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }

      #info_text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }

      #table {
        display: none;  /* Hide until memory dumps are set. */
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }
    </style>
    <div id="label">Memory maps</div>
    <div id="contents">
      <div id="info_text">No memory maps selected</div>
      <tr-ui-b-table id="table"></tr-ui-b-table>
    </div>
  </template>
</dom-module><!--
@fileoverview A component used to display a label and a color square.

The colored square is typically filled with the color associated with
that label, using the getColorId* methods from base/color_scheme.
--><dom-module id="tr-ui-b-color-legend">
  <template>
    <style>
    :host {
      display: inline-block;
    }

    #square {
      font-size: 150%;  /* Make the square bigger. */
      line-height: 0%;  /* Prevent the square from increasing legend height. */
    }
    </style>
    <span id="square"></span>
    <span id="label"></span>
  </template>
</dom-module><!--
This element handles storing and retrieving the brushing state of arbitrary
views (e.g. analysis sub-views). An element can use it by instantiating it and
appending it to itself:

  <div id="some-view-with-specific-brushing-state">
    <tr-ui-b-view-specific-brushing-state view-id="unique-view-identifier">
    </tr-ui-b-view-specific-brushing-state>
    ... other child elements ...
  </div>

The state can then be retrieved from and pushed to the state element as
follows:

  newStateElement.set(state);
  state = newStateElement.get();

Under the hood, the state element searches the DOM tree for an ancestor element
with a brushingStateController field to persist the state (see the
tr.c.BrushingStateController and tr.ui.b.BrushingState classes for more
details).
--><dom-module id="tr-ui-b-view-specific-brushing-state">
  <template></template>
</dom-module><dom-module id="tr-ui-a-memory-dump-overview-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      #label {
        flex: 0 0 auto;
        padding: 8px;

        background-color: #eee;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;

        font-size:  15px;
        font-weight: bold;
      }

      #label a {
        font-weight: normal;
        float: right;
      }

      #contents {
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
        overflow: auto;
      }

      #info_text {
        padding: 8px;
        color: #666;
        font-style: italic;
        text-align: center;
      }

      #table {
        display: none;  /* Hide until memory dumps are set. */
        flex: 1 0 auto;
        align-self: stretch;
        font-size: 12px;
      }
    </style>
    <tr-ui-b-view-specific-brushing-state id="state" view-id="analysis.memory_dump_overview_pane">
    </tr-ui-b-view-specific-brushing-state>
    <div id="label">Overview <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra">Help</a></div>
    <div id="contents">
      <div id="info_text">No memory memory dumps selected</div>
      <tr-ui-b-table id="table"></tr-ui-b-table>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-memory-dump-header-pane">
  <template>
    <style>
      :host {
        display: flex;
        flex-direction: row;
        align-items: center;

        background-color: #d0d0d0;
        border-bottom: 1px solid #8e8e8e;
        border-top: 1px solid white;
      }

      #label {
        flex: 1 1 auto;
        padding: 6px;
        font-size: 15px;
      }

      #aggregation_mode_container {
        display: none;
        flex: 0 0 auto;
        padding: 5px;
        font-size: 15px;
      }
    </style>
    
    <div id="label"></div>
    <div id="aggregation_mode_container">
      <span>Metric aggregation:</span>
      <!-- Aggregation mode selector (added in Polymer.ready()) -->
    </div>
  </template>
</dom-module><!--
@fileoverview Analysis view container which displays vertically stacked panes.
The panes represent a hierarchy where a child pane contains the details of the
current selection in its parent pane. The container provides simple primitives
for panes to request changing their child pane:

  +=<tr-ui-a-stacked-pane-view>=+              +=<tr-ui-a-stacked-pane-view>=+
  |+.<tr-ui-a-stacked-pane>....+|              |+.<tr-ui-a-stacked-pane>....+|
  |: Pane 1                    +| ===========> |: Pane 1                    +|
  |+...........................+|    Pane 1    |+...........................+|
  |+.<tr-ui-a-stacked-pane>....+|   requests   |+.<tr-ui-a-stacked-pane>....+|
  |: Pane 2 (detail of Pane 1) +|  child pane  |: Pane 4 (detail of Pane 1) +|
  |+...........................+| change (e.g. |+...........................+|
  |+.<tr-ui-a-stacked-pane>....+|  selection   +=============================+
  |: Pane 3 (detail of Pane 2) +|   changed)
  |+...........................+|
  +=============================+

Note that the actual UI provided by tr-ui-a-stacked-pane-view and
tr-ui-a-stacked-pane is merely a wrapper container with flex box vertical
stacking. No other visual features (such as pane spacing or borders) is
provided by either element.

The stacked pane element (tr-ui-a-stacked-pane) is defined in a separate file.

Sample use case:

  Create an empty stacked pane view and add it to the DOM:

    const paneView = document.createElement('tr-ui-a-stacked-pane-view');
    Polymer.dom(someParentView).appendChild(paneView);

  Define one or more pane subclasses:

    TODO(polymer): Write this documentation
    <polymer-element name="some-pane-1" extends="tr-ui-a-stacked-pane">
      ...
    </polymer-element>

  Set the top-level pane (by providing a builder function):

    paneView.setPaneBuilder(function() {
      const topPane = document.createElement('some-pane-1');
      pane.someProperty = someValue;
      return topPane;
    });

  Show a child pane with details upon user interaction (these methods should be
  in the definition of the pane subclass Polymer element):

    ready: function() {
      this.$.table.addEventListener(
          'selection-changed', this.changeChildPane_.bind(this));
    }

    changeChildPane_: function() {
      this.childPaneBuilder = function() {
        const selectedRow = this.$.table.selectedTableRow;
        const detailsPane = document.createElement('some-pane-2');
        detailsPane.someProperty = selectedRow;
        return detailsPane;
      }.bind(this);
    }
--><dom-module id="tr-ui-a-stacked-pane-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }

    #pane_container > * {
      flex: 0 0 auto;
    }
    </style>
    <div id="pane_container">
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-container-memory-dump-sub-view">
  <template>
    <style>
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-counter-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-event-summary-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
    
  </template>
</dom-module><dom-module id="tr-ui-a-selection-summary-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
    
  </template>
</dom-module><dom-module id="tr-ui-b-radio-picker">
  <template>
    <style>
    :host([vertical]) #container {
      flex-direction: column;
    }
    :host(:not[vertical]) #container {
      flex-direction: row;
    }
    #container {
      display: flex;
    }
    #container > div {
      padding-left: 1em;
      padding-bottom: 0.5em;
    }
    </style>
    <div id="container"></div>
  </template>
</dom-module><dom-module id="tr-ui-b-chart-legend-key">
  <template>
    <style>
      #checkbox {
        margin: 0;
        visibility: hidden;
        vertical-align: text-top;
      }
      #label, #link {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
        display: inline-block;
      }
    </style>

    <input checked="" id="checkbox" type="checkbox"/>
    <tr-ui-a-analysis-link id="link"></tr-ui-a-analysis-link>
    <label id="label"></label>
  </template>
</dom-module><style>
  * /deep/ .chart-base {
    -webkit-user-select: none;
    cursor: default;
  }

  * /deep/ .chart-base .axis path,
  * /deep/ .chart-base .axis line {
    fill: none;
    shape-rendering: crispEdges;
    stroke: #000;
  }
</style><template id="chart-base-template">
  <svg> <!-- svg tag is dropped by ChartBase.decorate. -->
    <g id="chart-area" xmlns="http://www.w3.org/2000/svg">
      <g class="x axis"></g>
      <g class="y axis"></g>
      <text id="title"></text>
    </g>
  </svg>
</template><style>
  * /deep/ .chart-base-2d.updating-brushing-state #brushes > * {
    fill: rgb(103, 199, 165)
  }

  * /deep/ .chart-base-2d #brushes {
    fill: rgb(213, 236, 229)
  }
</style><dom-module id="tr-v-ui-breakdown-span">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table_container {
      display: flex;
      flex: 0 0 auto;
    }
    #table {
      max-height: 150px;
      overflow-y: auto;
    }
    </style>

    <div id="empty">(empty)</div>
    <div id="table_container">
      <div id="container"></div>
      <span>
        <tr-ui-b-table id="table"></tr-ui-b-table>
      </span>
    </div>
  </template>
</dom-module><dom-module id="tr-v-ui-collected-related-event-set-span">
</dom-module><dom-module id="tr-v-ui-date-range-span">
  <template>
    <content></content>
  </template>
</dom-module><dom-module id="tr-ui-a-generic-object-view">
  <template>
    <style>
    :host {
      display: block;
      font-family: monospace;
    }
    </style>
    <div id="content">
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-generic-object-view-with-label">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
  </template>
</dom-module><dom-module id="tr-v-ui-generic-set-span">
  <template>
    <style>
      a {
        display: block;
      }
    </style>

    <tr-ui-a-generic-object-view id="generic"></tr-ui-a-generic-object-view>

    <div id="links"></div>
  </template>
</dom-module><dom-module id="tr-v-ui-related-event-set-span">
</dom-module><dom-module id="tr-v-ui-related-histogram-map-span">
  <template>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-v-ui-scalar-diagnostic-span">
  <template>
    <tr-v-ui-scalar-span id="scalar"></tr-v-ui-scalar-span>
  </template>
</dom-module><dom-module id="tr-v-ui-tag-map-span">
  <template>
    <style>
    #hide, #generic {
      display: none;
    }
    </style>
    <button id="show" on-click="onShow_">Show</button>
    <button id="hide" on-click="onHide_">Hide</button>
    <tr-ui-a-generic-object-view id="generic"></tr-ui-a-generic-object-view>
  </template>
</dom-module><dom-module id="tr-v-ui-unmergeable-diagnostic-set-span">
</dom-module><dom-module id="tr-v-ui-diagnostic-map-table">
  <template>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-v-ui-scalar-map-table">
  <template>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-v-ui-histogram-span">
  <template>
    <style>
    #container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
    }
    #chart {
      flex-grow: 1;
      display: none;
    }
    #drag_handle, #diagnostics_tab_templates {
      display: none;
    }
    #chart svg {
      display: block;
    }
    #stats_container {
      overflow-y: auto;
    }
    </style>

    <div id="container">
      <div id="chart"></div>
      <div id="stats_container">
        <tr-v-ui-scalar-map-table id="stats"></tr-v-ui-scalar-map-table>
      </div>
    </div>
    <tr-ui-b-drag-handle id="drag_handle"></tr-ui-b-drag-handle>

    <tr-ui-b-tab-view id="diagnostics"></tr-ui-b-tab-view>

    <div id="diagnostics_tab_templates">
      <tr-v-ui-diagnostic-map-table id="metric_diagnostics"></tr-v-ui-diagnostic-map-table>

      <tr-v-ui-diagnostic-map-table id="metadata_diagnostics"></tr-v-ui-diagnostic-map-table>

      <div id="sample_diagnostics_container">
        <div id="merge_sample_diagnostics_container">
          <input checked="" id="merge_sample_diagnostics" on-change="updateDiagnostics_" type="checkbox"/>
          <label for="merge_sample_diagnostics">Merge Sample Diagnostics</label>
        </div>
        <tr-v-ui-diagnostic-map-table id="sample_diagnostics"></tr-v-ui-diagnostic-map-table>
      </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      overflow: auto;
    }
    #content {
      display: flex;
      flex-direction: column;
      flex: 0 1 auto;
      align-self: stretch;
    }
    #content > * {
      flex: 0 0 auto;
      align-self: stretch;
    }
    #histogramContainer {
      display: flex;
    }

    tr-ui-a-multi-event-summary-table {
      border-bottom: 1px solid #aaa;
    }

    tr-ui-a-selection-summary-table  {
      margin-top: 1.25em;
      border-top: 1px solid #aaa;
      background-color: #eee;
      font-weight: bold;
      margin-bottom: 1.25em;
      border-bottom: 1px solid #aaa;
    }
    </style>
    <div id="content">
      <tr-ui-a-multi-event-summary-table id="eventSummaryTable">
      </tr-ui-a-multi-event-summary-table>
      <tr-ui-a-selection-summary-table id="selectionSummaryTable">
      </tr-ui-a-selection-summary-table>
      <tr-ui-b-radio-picker id="radioPicker">
      </tr-ui-b-radio-picker>
      <div id="histogramContainer">
        <tr-v-ui-histogram-span id="histogramSpan">
        </tr-v-ui-histogram-span>
      </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-related-events">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #table {
      flex: 1 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-async-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #container {
      display: flex;
      flex: 1 1 auto;
    }
    #events {
      margin-left: 8px;
      flex: 0 1 200px;
    }
    </style>
    <div id="container">
      <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
      <div id="events">
        <tr-ui-a-related-events id="relatedEvents"></tr-ui-a-related-events>
      </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-cpu-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      flex: 1 1 auto;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-flow-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-instant-event-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-object-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>
</dom-module><!--
@fileoverview A line chart showing milliseconds since the start of the frame on
the x-axis and power consumption on the y-axis. Each frame is shown as a
separate line in the chart. Vertical sync events are used as the start of each
frame.

This chart aims to help users understand the shape of the power consumption
curve over the course of a frame or set of frames.
--><dom-module id="tr-ui-a-frame-power-usage-chart">
  <template>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-power-sample-summary-table">
  <template>
    <style>
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-power-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #tables {
      display: flex;
      flex-direction: column;
      width: 50%;
    }
    #chart {
      width: 50%;
    }
    </style>
    <div id="tables">
      <tr-ui-a-power-sample-summary-table id="summaryTable">
      </tr-ui-a-power-sample-summary-table>
    </div>
    <tr-ui-a-frame-power-usage-chart id="chart">
    </tr-ui-a-frame-power-usage-chart>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-sample-sub-view">
  <template>
    <style>
    :host { display: block; }
    #control {
      background-color: #e6e6e6;
      background-image: -webkit-gradient(linear, 0 0, 0 100%,
                                         from(#E5E5E5), to(#D1D1D1));
      flex: 0 0 auto;
      overflow-x: auto;
    }
    #control::-webkit-scrollbar { height: 0px; }
    #control {
      font-size: 12px;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      margin: 1px;
      margin-right: 2px;
    }
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>
    <div id="control">
      Sample View Option
    </div>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-thread-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      display: flex;
      flex: 1 1 auto;
    }
    #content > tr-ui-a-related-events {
      margin-left: 8px;
      flex: 0 1 200px;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-thread-time-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      flex: 1 1 auto;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="content"></tr-ui-a-multi-event-sub-view>
  </template>
</dom-module><dom-module id="tr-ui-a-user-expectation-related-samples-table">
  <template>
    <style>
    #table {
      flex: 1 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-multi-user-expectation-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex: 1 1 auto;
    }
    #events {
      margin-left: 8px;
      flex: 0 1 200px;
    }
    </style>
    <tr-ui-a-multi-event-sub-view id="realView"></tr-ui-a-multi-event-sub-view>
    <div id="events">
      <tr-ui-a-user-expectation-related-samples-table id="relatedSamples"></tr-ui-a-user-expectation-related-samples-table>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-stack-frame">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
      align-items: center;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-event-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex: 0 1;
      flex-direction: column;
    }
    #table {
      flex: 0 1 auto;
      align-self: stretch;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table">
    </tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-async-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #events {
      display:flex;
      flex-direction: column;
    }
    </style>
    <tr-ui-a-single-event-sub-view id="content"></tr-ui-a-single-event-sub-view>
    <div id="events">
      <tr-ui-a-related-events id="relatedEvents"></tr-ui-a-related-events>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-single-cpu-slice-sub-view">
  <template>
    <style>
    table {
      border-collapse: collapse;
      border-width: 0;
      margin-bottom: 25px;
      width: 100%;
    }

    table tr > td:first-child {
      padding-left: 2px;
    }

    table tr > td {
      padding: 2px 4px 2px 4px;
      vertical-align: text-top;
      width: 150px;
    }

    table td td {
      padding: 0 0 0 0;
      width: auto;
    }
    tr {
      vertical-align: top;
    }

    tr:nth-child(2n+0) {
      background-color: #e2e2e2;
    }
    </style>
    <table>
      <tbody><tr>
        <td>Running process:</td><td id="process-name"></td>
      </tr>
      <tr>
        <td>Running thread:</td><td id="thread-name"></td>
      </tr>
      <tr>
        <td>Start:</td>
        <td>
          <tr-v-ui-scalar-span id="start">
          </tr-v-ui-scalar-span>
        </td>
      </tr>
      <tr>
        <td>Duration:</td>
        <td>
          <tr-v-ui-scalar-span id="duration">
          </tr-v-ui-scalar-span>
        </td>
      </tr>
      <tr>
        <td>Active slices:</td><td id="running-thread"></td>
      </tr>
      <tr>
        <td>Args:</td>
        <td>
          <tr-ui-a-generic-object-view id="args">
          </tr-ui-a-generic-object-view>
        </td>
      </tr>
    </tbody></table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-flow-event-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
    <tr-ui-a-single-event-sub-view id="singleEventSubView">
    </tr-ui-a-single-event-sub-view>
  </template>
</dom-module><dom-module id="tr-ui-a-single-frame-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #asv {
      flex: 0 0 auto;
      align-self: stretch;
    }
    </style>
    <tr-ui-a-alert-sub-view id="asv">
    </tr-ui-a-alert-sub-view>
  </template>
</dom-module><dom-module id="tr-ui-a-single-instant-event-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-single-object-instance-sub-view">
  <template>
    <style>
    :host {
      display: block;
    }

    #snapshots > * {
      display: block;
    }

    :host {
      overflow: auto;
      display: block;
    }

    * {
      -webkit-user-select: text;
    }

    .title {
      border-bottom: 1px solid rgb(128, 128, 128);
      font-size: 110%;
      font-weight: bold;
    }

    td, th {
      font-family: monospace;
      vertical-align: top;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-a-single-object-snapshot-sub-view">
  <template>
    <style>
    #args {
      white-space: pre;
    }

    :host {
      overflow: auto;
      display: flex;
    }

    ::content * {
      -webkit-user-select: text;
    }

    ::content .title {
      border-bottom: 1px solid rgb(128, 128, 128);
      font-size: 110%;
      font-weight: bold;
    }

    ::content td, th {
      font-family: monospace;
      vertical-align: top;
    }
    </style>
    <content></content>
  </template>
</dom-module><dom-module id="tr-ui-a-power-sample-table">
  <template>
    <style>
    :host {
      display: flex;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-power-sample-sub-view">
  <template>
    <style>
    :host { display: block; }
    </style>
    <tr-ui-a-power-sample-table id="samplesTable">
    </tr-ui-a-power-sample-table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-sample-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-thread-slice-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #events {
      display: flex;
      flex-direction: column;
    }

    </style>
    <tr-ui-a-single-event-sub-view id="content"></tr-ui-a-single-event-sub-view>
    <div id="events">
      <tr-ui-a-related-events id="relatedEvents">
      </tr-ui-a-related-events>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-a-single-thread-time-slice-sub-view">
  <template>
    <style>
    table {
      border-collapse: collapse;
      border-width: 0;
      margin-bottom: 25px;
      width: 100%;
    }

    table tr > td:first-child {
      padding-left: 2px;
    }

    table tr > td {
      padding: 2px 4px 2px 4px;
      vertical-align: text-top;
      width: 150px;
    }

    table td td {
      padding: 0 0 0 0;
      width: auto;
    }
    tr {
      vertical-align: top;
    }

    tr:nth-child(2n+0) {
      background-color: #e2e2e2;
    }
    </style>
    <table>
      <tbody><tr>
        <td>Running process:</td><td id="process-name"></td>
      </tr>
      <tr>
        <td>Running thread:</td><td id="thread-name"></td>
      </tr>
      <tr>
        <td>State:</td>
        <td><b><span id="state"></span></b></td>
      </tr>
      <tr>
        <td>Start:</td>
        <td>
          <tr-v-ui-scalar-span id="start">
          </tr-v-ui-scalar-span>
        </td>
      </tr>
      <tr>
        <td>Duration:</td>
        <td>
          <tr-v-ui-scalar-span id="duration">
          </tr-v-ui-scalar-span>
        </td>
      </tr>

      <tr>
        <td>On CPU:</td><td id="on-cpu"></td>
      </tr>

      <tr>
        <td>Running instead:</td><td id="running-instead"></td>
      </tr>

      <tr>
        <td>Args:</td><td id="args"></td>
      </tr>
    </tbody></table>
  </template>
</dom-module><dom-module id="tr-ui-a-single-user-expectation-sub-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: row;
    }
    #events {
      display: flex;
      flex-direction: column;
    }
    </style>
    <tr-ui-a-single-event-sub-view id="realView"></tr-ui-a-single-event-sub-view>
    <div id="events">
      <tr-ui-a-user-expectation-related-samples-table id="relatedSamples"></tr-ui-a-user-expectation-related-samples-table>
    </div>
  </template>
</dom-module><!--
@fileoverview A component used to display an analysis of a selection,
using custom elements specialized for different event types.
--><dom-module id="tr-ui-a-analysis-view">
  <template>
    <style>
      :host {
        background-color: white;
        display: flex;
        flex-direction: column;
        height: 275px;
        overflow: auto;
      }

      :host(.tall-mode) {
        height: 525px;
      }
    </style>
    <content></content>
  </template>
</dom-module><dom-module id="tr-ui-b-dropdown">
  <template>
    <style>
    :host {
      position: relative;
      display: flex;
    }
    #outer {
      display: flex;
      flex: 0 0 auto;
      padding: 1px 4px 1px 4px;
      -webkit-user-select: none;
      cursor: default;
    }

    #state {
      display: flex;
      flex: 0 0 auto;
      margin-left: 2px;
      margin-right: 0px;
      flex: 0 0 auto;
    }

    #icon {
      display: flex;
      flex: 0 0 auto;
      flex: 0 0 auto;
    }
    dialog {
      position: absolute;
      padding: 0;
      border: 0;
      margin: 0;
    }
    dialog::backdrop {
      background: rgba(0,0,0,.05);
    }

    #dialog-frame {
      background-color: #fff;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      padding: 6px;
      border: 1px solid black;
      -webkit-user-select: none;
      cursor: default;
    }
    </style>
    <tr-ui-b-toolbar-button id="outer" on-click="onOuterClick_" on-keydown="onOuterKeyDown_">
      <div id="icon">⚙</div>
      <div id="state">▾</div>
    </tr-ui-b-toolbar-button>
    <dialog id="dialog" on-cancel="onDialogCancel_" on-click="onDialogClick_">
      <div id="dialog-frame">
        <content></content>
      </div>
    </dialog>
  </template>
</dom-module><dom-module id="tv-ui-b-hotkey-controller">
  <template>
    <div></div>
  </template>
</dom-module><dom-module id="tr-ui-b-info-bar-group">
  <template>
    <style>
    :host {
      flex: 0 0 auto;
      flex-direction: column;
      display: flex;
    }
    </style>
    <div id="messages"></div>
  </template>
</dom-module><template id="overlay-template">
  <style>
    overlay-mask {
      left: 0;
      padding: 8px;
      position: absolute;
      top: 0;
      z-index: 1000;
      font-family: sans-serif;
      -webkit-justify-content: center;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      height: 100%;
      left: 0;
      position: fixed;
      top: 0;
      width: 100%;
    }
    overlay-mask:focus {
      outline: none;
    }
    overlay-vertical-centering-container {
      -webkit-justify-content: center;
      flex-direction: column;
      display: flex;
    }
    overlay-frame {
      z-index: 1100;
      background: rgb(255, 255, 255);
      border: 1px solid #ccc;
      margin: 75px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    title-bar {
      -webkit-align-items: center;
      flex-direction: row;
      border-bottom: 1px solid #ccc;
      background-color: #ddd;
      display: flex;
      padding: 5px;
      flex: 0 0 auto;
    }
    title {
      display: inline;
      font-weight: bold;
      flex: 1 1 auto;
    }
    close-button {
      -webkit-align-self: flex-end;
      border: 1px solid #eee;
      background-color: #999;
      font-size: 10pt;
      font-weight: bold;
      padding: 2px;
      text-align: center;
      width: 16px;
    }
    close-button:hover {
      background-color: #ddd;
      border-color: black;
      cursor: pointer;
    }
    overlay-content {
      display: flex;
      flex: 1 1 auto;
      flex-direction: column;
      overflow-y: auto;
      padding: 10px;
      min-width: 300px;
      min-height: 0;
    }
    button-bar {
      -webkit-align-items: baseline;
      border-top: 1px solid #ccc;
      display: flex;
      flex: 0 0 auto;
      flex-direction: row-reverse;
      padding: 4px;
    }
  </style>

  <overlay-mask>
    <overlay-vertical-centering-container>
      <overlay-frame>
        <title-bar>
          <title></title>
          <close-button>✕</close-button>
        </title-bar>
        <overlay-content>
          <content></content>
        </overlay-content>
        <button-bar></button-bar>
      </overlay-frame>
    </overlay-vertical-centering-container>
  </overlay-mask>
</template><dom-module id="tr-ui-b-toolbar-button">
  <template>
    <style>
    :host {
      display: flex;
      background-color: #f8f8f8;
      border: 1px solid rgba(0, 0, 0, 0.5);
      color: rgba(0,0,0,0.8);
      justify-content: center;
      align-self: stretch;
      min-width: 23px;
    }

    :host(:hover) {
      background-color: rgba(255, 255, 255, 1.0);
      border-color: rgba(0, 0, 0, 0.8);
      box-shadow: 0 0 .05em rgba(0, 0, 0, 0.4);
      color: rgba(0, 0, 0, 1);
    }

    #aligner {
      display: flex;
      flex: 0 0 auto;
      align-self: center;
    }
    </style>
    <div id="aligner">
      <content></content>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-b-mouse-mode-icon">
  <template>
    <style>
    :host {
      display: block;
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAChCAYAAACbBNzvAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABV0RVh0Q3JlYXRpb24gVGltZQA3LzE2LzEzRNEKUwAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAA9aSURBVHic7V1rTFvl//+UrgUmZWMpbLa6cLErwpYxkqLGkjAG88WSbmumGUllvlmAJctMRtybvlHrLXiJUekMIZuYSCL5gS+EuLIXGEGjqCsllCEW6xQECgzWG7S05/+C/zkp9LTn0gsL6ych9JzznOdzPj19Luf5PN/nCN59913ixRdfRFdXFxLx/2GDgCAIYmpqCoWFhUjE/4cNae+99x4AIFH/Hzak7nDqDu+wOyyw2WzEdl9EMpG23ReQbKQE73Q8coJ3bfcFWK1W/Pbbb/D7/UhLi/37DwaDEIvFKC8vR0lJSdjxbRVstVoxPDyMxx9/HAUFBcjMzIRAIOCdXzAYhNvtht1ux/DwMACEid5WwSMjI3jyySdRXFwMsVgMoVAYk2CCIJCZmYns7GyMjo5iZGQkPoKXl5exd+9e3hdGIhgMIj8/H5mZmRCJRIyCyQ5NJBAEgUAgAKFQiIKCAiwsLISl4VxoHA4H+vv74Xa7uZ4aBqFQiOzsbIhEIojFYojFYohEItq/8fFxXLlyBUtLSxHThOaxZ88eCIXC2AWPj48DAH799deYBaelpUEoFLL6++qrrwAAH3zwAav0YrGYthLkJHh6ehpzc3MAgPn5eUxPT8csWiAQMJbboaEhmM1mAIDFYsHQ0BDvPDkJtlgsYdt+v59LFrxw/fr1sG2Xy8UrL06C6+vrw7bFYjEvYi747rvvwrYlEgmvvDjV0g6HI+p2ohBP3qh32OFwoLe3l1VGvb29sNvtvC8kFCMjI9DpdKzS6nQ6mEwm1nnTPg/7/X6MjY1hcnKS/VX+P/bu3YuysjLk5uYypv36669x8uRJZGRkQCQSwev1oqOjAz09PZx5CwsLcenSJRw+fBh+vx+rq6swmUx46aWXNqWjvcMDAwO8xAIbnZKBgQFeNXhzczMvscBGp6S5uRk//vhj1HS0grVaLYqLi3kRy+Vy1NXVRe0RRcKNGzeg0Wh48apUKnR1daG6ujpqOtpKy+VyQa1Wo6SkBLdv38aFCxeoY5988gn1+fLly9TnL774ApWVlXjiiSfgdDqxtrbG+aJ9Ph/0ej3OnDkDvV6PW7duUceOHDlCfR4dHaU+v/DCC7h27RrUajWcTidWV1ejctAKJggCKysryMzMhE6nw+zsLO3Joft1Oh0ePHiApaUlduqi8BYVFaGvr48Vb19fHyfeqM2Sz+dj3QTEs4lKJC+njsfWJoptkxUrtjZRbJssOnASXFtbG3U7UXjrrbeibnMBJ8FZWVkoKysDABQUFCArK4s3MRcoFArqrlZXV0OhUPDOi5Ngn8+Hw4cPQyqV4tlnn4XP5+NNTIIgmH0An8+HV155BUqlEq+++ior3kAgQLuf84jH2toajh8/jvX1da6n0sLj8SAjI4MxHUEQ+PTTT1nlSRAEHjx4QHtsW8e0RCIR7HY79uzZE/GOcEUgEEAgEMDff/8NkUgUdnxbBR85cgRmsxkCgQD5+fkRh2XYIhAI4P79+5iamoLD4cCxY8fC0myr4KeeegoCgQBWqxVzc3NIS0uLedQyGAxi165dKC8vR1FRUVialHu405ESvNPxyAlOuYfJRMo9fFjdw3iBq3vIBDbu4bYK3uoextKtJEH2yWNyD8nyEG8wuYcffvgha3cxru6h3W5Hf39/QoyzaE6fyWRCQ0MDZ+MsLu7h8vIyent7sby8zIk8VkxNTUGn08Fms8UlP04Nn9/vR39/f9w8JLZwu91obGzk5CFFAq+Wfnh4mDKok4mWlha0trbGlAfvrs3k5CQGBgaSYoiHoqenB1evXk2OIb4VDocDJpMp6eXaYrGgsbGRV7mOufPq8XgwMDCQ9HI9NzeHq1evci7XvDseUqkUWq0W6enpCAaDcDqd8Hq9fLNjDaVSiRs3bkAikfDi5XSHxWIxampqAAALCwsYGhrC7Ows5ufnEypWIpHAYDAAACYmJnD9+nXevJwEnzp1CjKZDBUVFQCAsbGxpJTfjz76CFVVVWhqagIAdHR08G6XWQuuqanB7t274fV6UVpaiuzsbAAbTzyJhMFggEKhgNfrRX19PWQyGQDAaDTyyo+V4JqaGshkMsricLlcOH78OICNCWp8p0cwwWAwoKqqahPvG2+8AWDji+7u7uacJyvBMpksrKxkZWVR0yLGxsY4E7NBVVVVGK9CoaCmRXR0dHDOk5VguorB5/OhoqICYrE4YZ2PSLxXrlyBRCLhNcE1pufh1dVVXLx4EWlpaRGnJzCBjXtId87g4GBU3ri5h1uJ5+fnY8mCtXvIhTflHoYg5R4mEyn3MAl45KyWlOCdjkdOcMo9TCZS7mHKPeSGhLmH5LBOrAGXXN1DcliHrgdFgsk95CzYbrfDbDbD7/ejrKwstpmtNO5hJJhMJrS2tsLtdqOpqQlarTZi2mjuIWvBfr8fZrN50/iz2WzG9PQ0nn/+edonEzZgij10uVwwGo2bxp+NRiOGhobw+uuv005hjtk9JENz6AbbyWCuRESp2Ww2NDc30w62WywW6HQ6zoOIrO5wbm4uzp8/j5WVFXR2dm46VldXh3379mF5eTku86dDUVxcjK6uLthstrClqrq6unDo0CHOvKwE+/1+LC4uUqG0oZiYmIhaicQCkvfu3bthxwYGBnhVmpy6NnSD7kxxQvEA3Zo+fIsQJ8F040j379/nRcwFdF4037FwToLphkUXFxd5EXMB3chkUgQ7nc6wfT6fL+Gm+H///Re2z+Vy8TLFGSut/v5+RsPsm2++AbDR84pXLFNDQwPjelxnz54FsBFK+/nnn7PKl/EOa7VaVmHvYrE4au+HK27evMkq7F0ikeDmzZus82UU7HK5qG8yGs6ePct73gUdfD4f2tvbGdO1t7dzaocZBRMEAaFQSBnhdKipqYFQKORlm0TjzcvLo4xwOhgMBuTl5XHiZVVp+f1+yGQy2iDq4uJiyGSyhFRcfr8fVVVVtEHUGo0GVVVVnHlZ19JerxdqtRpSqZTaJ5VKoVarEzrdwev1Qq/XQ6lUUvuUSiX0ej0vXk7N0srKCjQaDbXmjUajwcrKCmfSULD5Oa6srKCtrQ0SiQQSiQRtbW2MvHFzD0MrsXhUUmzdw9BKjKmSiqt7SBBE3Conru4hOa8kWqBnyj3cgl0EQcQ0cMYWW3kIgkiKe7iVV2C1Won09PSYxLCB1+tFZmYmtb22tobt4E1LBimATaQAkiKWjveR85ZSgnc6Uu5hMpFyD1PuITekYg/ZxB52dXXFTMo2n1D38NSpU7zjDEP/yHzisnJpIsBm5dJ45rntgpONuITTJirctqWlJabjdGAUvNUEp0NouxcvtLa2MgZhmUwmzqKjCrbb7aw9HC5pmWAymVivb2kymTgFe0RslrbeNTa1rtlshkgkQn5+PusL2Iqtd42NdWM0GpGVlYWTJ08ypo14h/nGI8Uax8Q3XJbteREFV1ZW8iLmex6Ja9euJfS8iD9puVyOmpoa3L59G8DmVUq3glzNlAzoimVgvrq6GmlpadDr9QA2r1K6FeRqpmRAFxveiIK9Xi8VZ/jLL78whulUVFTELJbkJeMMjUYjI29TUxNrsQBDX5qMM4w0qE2iuLgYpaWlcXMPyThDphWMNRoN6uvrOfGyskvVanXUNGq1Oq5WKclL/qwjQa/Xc+Zl1dNi8nFi9ZeSyZvqS0erjbmAbT6kT7X1lQp8QeYTyasKE8w3aJJvPh6PBwRBYGZmJi68MzMzqdjDUDx67mEsFxwrUrGHSUCqWdrpSAne6dix7uFzzz1HW0s/FO7h/v37UVBQgMceeyxm99DlcsFut2NwcBACgSDsnTHb7h4ePHgQxcXFcTPTMjIyIJFIcOfOHfz+++8Pl2DSPSTftxQv93DXrl0oKirCnTt3wtIwFhq62aputxtms5maCR8pHROEQiEkEgntew/X1tbC3mu4tLSE9vZ2nD9/njZd6Pn79u3jHoo3OTmJsbExnDlzBsDGWLXdbqcNoent7YVCocChQ4dYh+VFij3s7u5GR0cH9YWaTCbcunVr0yMkmfbChQvQarXQarVUWF4wGER6ejp7wdPT0zCbzfB4PJv2R7NT/H4/rFYrJicnUVZWxnowPtTpGxoagtFoDAsIi2anuN1ufPnll+ju7salS5dw4sQJKk+64hH2FTgcDgwPD4eJZQu/3w+bzcZ5JSSLxYL333+fNvqNDdxuN3p6ehjPDxMsl8tjjkw5ceIENfOVLVQqFd58882YeA0GA7WiWiSECfb5fPjpp58AbKyBx/bCpVIp6urqAADff/895wf6tbU1fPbZZwCAjz/+mPHCSSiVSsr3eueddxh5aWtpMrwuJyeH9cuczp07R5UZvktO/fnnnwCAY8eOoa+vj9U5nZ2d1CsH2fhaUZulwcFB1kGNi4uLjK/gYwuDwcCJ9+2332add9RmyW63w+12Q6FQIC8vD5cvX8bCwgI19VcqlcJms8HhcGBycjJuSz6aTCbMzs5Cq9Xi6NGjGB0dxcTEBJxOJyQSCZRKJUZGRjAyMoL//e9/jBFsoaAVLJfLKZvD4XBQ37ZEItlUph0OB238gVwu5ySQhEqlopo+i8VCtbsymWxTmb579y6t46BSqRg5aAXX1tbi22+/DZvY5XQ6aQMuQyGVSlFbW8trgb6WlhY0NDRgYmJi0/6ZmRnGYVylUomWlhbGeGbaMuzxeKDRaKhVDdkgOzsblZWVOHfuHO82fH19HW1tbWhqamL9ul2ZTIbXXnsNnZ2drN7yFfFFjy6XC6WlpVCpVFhaWsK///5LVfnz8/PIy8sDAOzevRu5ubnIycmBx+OJKZ6YIAj4fD7U19ejsbERf/zxB4aHhykrdHx8HE8//TQAYP/+/VAqlVAoFJx4I1ZapGiyrBw4cAD37t2DXC7HgQMHAGx0QXNycrC+vh63VR5Cecnw3J6eHqhUKpSXlwPY6OI+88wzALiHxnN6PPz555/D9h08eJATIR/Qzd9gE/FKh9SYFlvI5XKqPMUCrlFuKpUKp0+fZkwXDAZp93MSLBaLUVJSgqNHjyIjIwNerzfmOR0ul4sx9lAikeD06dN4+eWXIZVKGXnj5h5evHgRXq8XHo+Hd9MTCpFIhHv37iEnJydqp/+HH36A1+uFy+VirKTi6h7Gug7tVpDuIUEQKCwsjOge/vPPP6zyCwQCWF5exl9//YX5+Xla93DbzTSbzQar1Yr19fW4uoclJSUp9xB4BJullOCdjkdO8P8BGCQ0hnF1DxUAAAAASUVORK5CYII=);
      width: 27px;
      height: 30px;
    }
    :host.active {
      cursor: auto;
    }
    </style>
  </template>
</dom-module><dom-module id="tr-ui-b-mouse-mode-selector">
  <template>
    <style>
    :host {

      -webkit-user-drag: element;
      -webkit-user-select: none;

      background: #DDD;
      border: 1px solid #BBB;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
      left: calc(100% - 120px);
      position: absolute;
      top: 100px;
      user-select: none;
      width: 29px;
      z-index: 20;
    }

    .drag-handle {
      background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAChCAYAAACbBNzvAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABV0RVh0Q3JlYXRpb24gVGltZQA3LzE2LzEzRNEKUwAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAA9aSURBVHic7V1rTFvl//+UrgUmZWMpbLa6cLErwpYxkqLGkjAG88WSbmumGUllvlmAJctMRtybvlHrLXiJUekMIZuYSCL5gS+EuLIXGEGjqCsllCEW6xQECgzWG7S05/+C/zkp9LTn0gsL6ych9JzznOdzPj19Luf5PN/nCN59913ixRdfRFdXFxLx/2GDgCAIYmpqCoWFhUjE/4cNae+99x4AIFH/Hzak7nDqDu+wOyyw2WzEdl9EMpG23ReQbKQE73Q8coJ3bfcFWK1W/Pbbb/D7/UhLi/37DwaDEIvFKC8vR0lJSdjxbRVstVoxPDyMxx9/HAUFBcjMzIRAIOCdXzAYhNvtht1ux/DwMACEid5WwSMjI3jyySdRXFwMsVgMoVAYk2CCIJCZmYns7GyMjo5iZGQkPoKXl5exd+9e3hdGIhgMIj8/H5mZmRCJRIyCyQ5NJBAEgUAgAKFQiIKCAiwsLISl4VxoHA4H+vv74Xa7uZ4aBqFQiOzsbIhEIojFYojFYohEItq/8fFxXLlyBUtLSxHThOaxZ88eCIXC2AWPj48DAH799deYBaelpUEoFLL6++qrrwAAH3zwAav0YrGYthLkJHh6ehpzc3MAgPn5eUxPT8csWiAQMJbboaEhmM1mAIDFYsHQ0BDvPDkJtlgsYdt+v59LFrxw/fr1sG2Xy8UrL06C6+vrw7bFYjEvYi747rvvwrYlEgmvvDjV0g6HI+p2ohBP3qh32OFwoLe3l1VGvb29sNvtvC8kFCMjI9DpdKzS6nQ6mEwm1nnTPg/7/X6MjY1hcnKS/VX+P/bu3YuysjLk5uYypv36669x8uRJZGRkQCQSwev1oqOjAz09PZx5CwsLcenSJRw+fBh+vx+rq6swmUx46aWXNqWjvcMDAwO8xAIbnZKBgQFeNXhzczMvscBGp6S5uRk//vhj1HS0grVaLYqLi3kRy+Vy1NXVRe0RRcKNGzeg0Wh48apUKnR1daG6ujpqOtpKy+VyQa1Wo6SkBLdv38aFCxeoY5988gn1+fLly9TnL774ApWVlXjiiSfgdDqxtrbG+aJ9Ph/0ej3OnDkDvV6PW7duUceOHDlCfR4dHaU+v/DCC7h27RrUajWcTidWV1ejctAKJggCKysryMzMhE6nw+zsLO3Joft1Oh0ePHiApaUlduqi8BYVFaGvr48Vb19fHyfeqM2Sz+dj3QTEs4lKJC+njsfWJoptkxUrtjZRbJssOnASXFtbG3U7UXjrrbeibnMBJ8FZWVkoKysDABQUFCArK4s3MRcoFArqrlZXV0OhUPDOi5Ngn8+Hw4cPQyqV4tlnn4XP5+NNTIIgmH0An8+HV155BUqlEq+++ior3kAgQLuf84jH2toajh8/jvX1da6n0sLj8SAjI4MxHUEQ+PTTT1nlSRAEHjx4QHtsW8e0RCIR7HY79uzZE/GOcEUgEEAgEMDff/8NkUgUdnxbBR85cgRmsxkCgQD5+fkRh2XYIhAI4P79+5iamoLD4cCxY8fC0myr4KeeegoCgQBWqxVzc3NIS0uLedQyGAxi165dKC8vR1FRUVialHu405ESvNPxyAlOuYfJRMo9fFjdw3iBq3vIBDbu4bYK3uoextKtJEH2yWNyD8nyEG8wuYcffvgha3cxru6h3W5Hf39/QoyzaE6fyWRCQ0MDZ+MsLu7h8vIyent7sby8zIk8VkxNTUGn08Fms8UlP04Nn9/vR39/f9w8JLZwu91obGzk5CFFAq+Wfnh4mDKok4mWlha0trbGlAfvrs3k5CQGBgaSYoiHoqenB1evXk2OIb4VDocDJpMp6eXaYrGgsbGRV7mOufPq8XgwMDCQ9HI9NzeHq1evci7XvDseUqkUWq0W6enpCAaDcDqd8Hq9fLNjDaVSiRs3bkAikfDi5XSHxWIxampqAAALCwsYGhrC7Ows5ufnEypWIpHAYDAAACYmJnD9+nXevJwEnzp1CjKZDBUVFQCAsbGxpJTfjz76CFVVVWhqagIAdHR08G6XWQuuqanB7t274fV6UVpaiuzsbAAbTzyJhMFggEKhgNfrRX19PWQyGQDAaDTyyo+V4JqaGshkMsricLlcOH78OICNCWp8p0cwwWAwoKqqahPvG2+8AWDji+7u7uacJyvBMpksrKxkZWVR0yLGxsY4E7NBVVVVGK9CoaCmRXR0dHDOk5VguorB5/OhoqICYrE4YZ2PSLxXrlyBRCLhNcE1pufh1dVVXLx4EWlpaRGnJzCBjXtId87g4GBU3ri5h1uJ5+fnY8mCtXvIhTflHoYg5R4mEyn3MAl45KyWlOCdjkdOcMo9TCZS7mHKPeSGhLmH5LBOrAGXXN1DcliHrgdFgsk95CzYbrfDbDbD7/ejrKwstpmtNO5hJJhMJrS2tsLtdqOpqQlarTZi2mjuIWvBfr8fZrN50/iz2WzG9PQ0nn/+edonEzZgij10uVwwGo2bxp+NRiOGhobw+uuv005hjtk9JENz6AbbyWCuRESp2Ww2NDc30w62WywW6HQ6zoOIrO5wbm4uzp8/j5WVFXR2dm46VldXh3379mF5eTku86dDUVxcjK6uLthstrClqrq6unDo0CHOvKwE+/1+LC4uUqG0oZiYmIhaicQCkvfu3bthxwYGBnhVmpy6NnSD7kxxQvEA3Zo+fIsQJ8F040j379/nRcwFdF4037FwToLphkUXFxd5EXMB3chkUgQ7nc6wfT6fL+Gm+H///Re2z+Vy8TLFGSut/v5+RsPsm2++AbDR84pXLFNDQwPjelxnz54FsBFK+/nnn7PKl/EOa7VaVmHvYrE4au+HK27evMkq7F0ikeDmzZus82UU7HK5qG8yGs6ePct73gUdfD4f2tvbGdO1t7dzaocZBRMEAaFQSBnhdKipqYFQKORlm0TjzcvLo4xwOhgMBuTl5XHiZVVp+f1+yGQy2iDq4uJiyGSyhFRcfr8fVVVVtEHUGo0GVVVVnHlZ19JerxdqtRpSqZTaJ5VKoVarEzrdwev1Qq/XQ6lUUvuUSiX0ej0vXk7N0srKCjQaDbXmjUajwcrKCmfSULD5Oa6srKCtrQ0SiQQSiQRtbW2MvHFzD0MrsXhUUmzdw9BKjKmSiqt7SBBE3Conru4hOa8kWqBnyj3cgl0EQcQ0cMYWW3kIgkiKe7iVV2C1Won09PSYxLCB1+tFZmYmtb22tobt4E1LBimATaQAkiKWjveR85ZSgnc6Uu5hMpFyD1PuITekYg/ZxB52dXXFTMo2n1D38NSpU7zjDEP/yHzisnJpIsBm5dJ45rntgpONuITTJirctqWlJabjdGAUvNUEp0NouxcvtLa2MgZhmUwmzqKjCrbb7aw9HC5pmWAymVivb2kymTgFe0RslrbeNTa1rtlshkgkQn5+PusL2Iqtd42NdWM0GpGVlYWTJ08ypo14h/nGI8Uax8Q3XJbteREFV1ZW8iLmex6Ja9euJfS8iD9puVyOmpoa3L59G8DmVUq3glzNlAzoimVgvrq6GmlpadDr9QA2r1K6FeRqpmRAFxveiIK9Xi8VZ/jLL78whulUVFTELJbkJeMMjUYjI29TUxNrsQBDX5qMM4w0qE2iuLgYpaWlcXMPyThDphWMNRoN6uvrOfGyskvVanXUNGq1Oq5WKclL/qwjQa/Xc+Zl1dNi8nFi9ZeSyZvqS0erjbmAbT6kT7X1lQp8QeYTyasKE8w3aJJvPh6PBwRBYGZmJi68MzMzqdjDUDx67mEsFxwrUrGHSUCqWdrpSAne6dix7uFzzz1HW0s/FO7h/v37UVBQgMceeyxm99DlcsFut2NwcBACgSDsnTHb7h4ePHgQxcXFcTPTMjIyIJFIcOfOHfz+++8Pl2DSPSTftxQv93DXrl0oKirCnTt3wtIwFhq62aputxtms5maCR8pHROEQiEkEgntew/X1tbC3mu4tLSE9vZ2nD9/njZd6Pn79u3jHoo3OTmJsbExnDlzBsDGWLXdbqcNoent7YVCocChQ4dYh+VFij3s7u5GR0cH9YWaTCbcunVr0yMkmfbChQvQarXQarVUWF4wGER6ejp7wdPT0zCbzfB4PJv2R7NT/H4/rFYrJicnUVZWxnowPtTpGxoagtFoDAsIi2anuN1ufPnll+ju7salS5dw4sQJKk+64hH2FTgcDgwPD4eJZQu/3w+bzcZ5JSSLxYL333+fNvqNDdxuN3p6ehjPDxMsl8tjjkw5ceIENfOVLVQqFd58882YeA0GA7WiWiSECfb5fPjpp58AbKyBx/bCpVIp6urqAADff/895wf6tbU1fPbZZwCAjz/+mPHCSSiVSsr3eueddxh5aWtpMrwuJyeH9cuczp07R5UZvktO/fnnnwCAY8eOoa+vj9U5nZ2d1CsH2fhaUZulwcFB1kGNi4uLjK/gYwuDwcCJ9+2332add9RmyW63w+12Q6FQIC8vD5cvX8bCwgI19VcqlcJms8HhcGBycjJuSz6aTCbMzs5Cq9Xi6NGjGB0dxcTEBJxOJyQSCZRKJUZGRjAyMoL//e9/jBFsoaAVLJfLKZvD4XBQ37ZEItlUph0OB238gVwu5ySQhEqlopo+i8VCtbsymWxTmb579y6t46BSqRg5aAXX1tbi22+/DZvY5XQ6aQMuQyGVSlFbW8trgb6WlhY0NDRgYmJi0/6ZmRnGYVylUomWlhbGeGbaMuzxeKDRaKhVDdkgOzsblZWVOHfuHO82fH19HW1tbWhqamL9ul2ZTIbXXnsNnZ2drN7yFfFFjy6XC6WlpVCpVFhaWsK///5LVfnz8/PIy8sDAOzevRu5ubnIycmBx+OJKZ6YIAj4fD7U19ejsbERf/zxB4aHhykrdHx8HE8//TQAYP/+/VAqlVAoFJx4I1ZapGiyrBw4cAD37t2DXC7HgQMHAGx0QXNycrC+vh63VR5Cecnw3J6eHqhUKpSXlwPY6OI+88wzALiHxnN6PPz555/D9h08eJATIR/Qzd9gE/FKh9SYFlvI5XKqPMUCrlFuKpUKp0+fZkwXDAZp93MSLBaLUVJSgqNHjyIjIwNerzfmOR0ul4sx9lAikeD06dN4+eWXIZVKGXnj5h5evHgRXq8XHo+Hd9MTCpFIhHv37iEnJydqp/+HH36A1+uFy+VirKTi6h7Gug7tVpDuIUEQKCwsjOge/vPPP6zyCwQCWF5exl9//YX5+Xla93DbzTSbzQar1Yr19fW4uoclJSUp9xB4BJullOCdjkdO8P8BGCQ0hnF1DxUAAAAASUVORK5CYII=) 2px 3px no-repeat;
      background-repeat: no-repeat;
      border-bottom: 1px solid #BCBCBC;
      cursor: move;
      display: block;
      height: 13px;
      width: 27px;
    }

    .tool-button {
      background-position: center center;
      background-repeat: no-repeat;
      border-bottom: 1px solid #BCBCBC;
      border-top: 1px solid #F1F1F1;
      cursor: pointer;
    }

    .buttons > .tool-button:last-child {
      border-bottom: none;
    }

    </style>
    <div class="drag-handle"></div>
    <div class="buttons">
    </div>
  </template>
</dom-module><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.track-button {
  background-color: rgba(255, 255, 255, 0.5);
  border: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(0,0,0,0.2);
  font-size: 10px;
  height: 12px;
  text-align: center;
  width: 12px;
}

.track-button:hover {
  background-color: rgba(255, 255, 255, 1.0);
  border: 1px solid rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 .05em rgba(0, 0, 0, 0.4);
  color: rgba(0, 0, 0, 1);
}

.track-close-button {
  left: 2px;
  position: absolute;
  top: 2px;
}

.track-collapse-button {
  left: 3px;
  position: absolute;
  top: 2px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.drawing-container {
  display: inline;
  overflow: auto;
  overflow-x: hidden;
  position: relative;
}

.drawing-container-canvas {
  display: block;
  pointer-events: none;
  position: absolute;
  top: 0;
}

</style><dom-module id="tr-ui-b-heading">
  <template>
    <style>
    :host {
      background-color: rgb(243, 245, 247);
      border-right: 1px solid #8e8e8e;
      display: block;
      height: 100%;
      margin: 0;
      padding: 0 5px 0 0;
    }

    heading {
      display: block;
      overflow-x: hidden;
      text-align: left;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #arrow {
      flex: 0 0 auto;
      font-family: sans-serif;
      margin-left: 5px;
      margin-right: 5px;
      width: 8px;
    }

    #link, #heading_content {
      display: none;
    }
    </style>
    <heading id="heading" on-click="onHeadingDivClicked_">
      <span id="arrow"></span>
      <span id="heading_content"></span>
      <tr-ui-a-analysis-link id="link"></tr-ui-a-analysis-link>
    </heading>
  </template>
</dom-module><style>
.letter-dot-track {
  height: 18px;
}
</style><style>
.chart-track {
  height: 30px;
  position: relative;
}
</style><style>
.cpu-usage-track {
  height: 90px;
}
</style><style>
.power-series-track {
  height: 90px;
}
</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */
.spacing-track {
  height: 4px;
}

</style><style>
/* Copyright (c) 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.rect-track {
  height: 18px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.object-instance-track {
  height: 18px;
}

</style><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.thread-track {
  flex-direction: column;
  display: flex;
  position: relative;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.process-track-header {
  flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  font-size: 75%;
}

.process-track-name:before {
  content: '\25B8'; /* Right triangle */
  padding: 0 5px;
}

.process-track-base.expanded .process-track-name:before {
  content: '\25BE'; /* Down triangle */
}

</style><style>
.model-track {
  flex-grow: 1;
}
</style><style>
.x-axis-track {
  height: 12px;
}

.x-axis-track.tall-mode {
  height: 30px;
}
</style><!--
  Interactive visualizaiton of Model objects based loosely on gantt charts.
  Each thread in the Model is given a set of Tracks, one per subrow in the
  thread. The TimelineTrackView class acts as a controller, creating the
  individual tracks, while Tracks do actual drawing.

  Visually, the TimelineTrackView produces (prettier) visualizations like the
  following:
    Thread1:  AAAAAAAAAA         AAAAA
                  BBBB              BB
    Thread2:     CCCCCC                 CCCCC
--><dom-module id="tr-ui-timeline-track-view">
  <template>
    <style>
    :host {
      flex-direction: column;
      display: flex;
      position: relative;
    }

    :host ::content * {
      -webkit-user-select: none;
      cursor: default;
    }

    #drag_box {
      background-color: rgba(0, 0, 255, 0.25);
      border: 1px solid rgb(0, 0, 96);
      font-size: 75%;
      position: fixed;
    }

    #hint_text {
      position: absolute;
      bottom: 6px;
      right: 6px;
      font-size: 8pt;
    }
    </style>
    <content></content>

    <div id="drag_box"></div>
    <div id="hint_text"></div>

    <tv-ui-b-hotkey-controller id="hotkey_controller">
    </tv-ui-b-hotkey-controller>
  </template>
</dom-module><dom-module id="tr-ui-find-control">
  <template>
    <style>
      :host {
        -webkit-user-select: none;
        display: flex;
        position: relative;
      }
      input {
        -webkit-user-select: auto;
        background-color: #f8f8f8;
        border: 1px solid rgba(0, 0, 0, 0.5);
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        width: 170px;
      }
      input:focus {
        background-color: white;
      }
      tr-ui-b-toolbar-button {
        border-left: none;
        margin: 0;
      }
      #hitCount {
        left: 0;
        opacity: 0.25;
        pointer-events: none;
        position: absolute;
        text-align: right;
        top: 2px;
        width: 167px;
        z-index: 1;
      }
      #spinner {
        visibility: hidden;
        width: 8px;
        height: 8px;
        left: 154px;
        pointer-events: none;
        position: absolute;
        top: 4px;
        z-index: 1;

        border: 2px solid transparent;
        border-bottom: 2px solid rgba(0, 0, 0, 0.5);
        border-right: 2px solid rgba(0, 0, 0, 0.5);
        border-radius: 50%;
      }
      @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <input id="filter" on-blur="filterBlur" on-focus="filterFocus" on-input="filterTextChanged" on-keydown="filterKeyDown" on-mouseup="filterMouseUp" type="text"/>
    <div id="spinner"></div>
    <tr-ui-b-toolbar-button on-click="findPrevious">
      ←
    </tr-ui-b-toolbar-button>
    <tr-ui-b-toolbar-button on-click="findNext">
      →
    </tr-ui-b-toolbar-button>
    <div id="hitCount">0 of 0</div>
  </template>
</dom-module><dom-module id="tr-ui-scripting-control">
  <template>
    <style>
      :host {
        flex: 1 1 auto;
      }
      .root {
        font-family: monospace;
        cursor: text;

        padding: 2px;
        margin: 2px;
        border: 1px solid rgba(0, 0, 0, 0.5);
        background: white;

        height: 100px;
        overflow-y: auto;

        transition-property: opacity, height, padding, margin;
        transition-duration: .2s;
        transition-timing-function: ease-out;
      }
      .hidden {
        margin-top: 0px;
        margin-bottom: 0px;
        padding-top: 0px;
        padding-bottom: 0px;
        height: 0px;
        opacity: 0;
      }
      .focused {
        outline: auto 5px -webkit-focus-ring-color;
      }
      #history {
        -webkit-user-select: text;
        color: #777;
      }
      #promptContainer {
        display: flex;
      }
      #promptMark {
        width: 1em;
        color: #468;
      }
      #prompt {
        flex: 1;
        width: 100%;
        border: none !important;
        background-color: inherit !important;
        font: inherit !important;
        text-overflow: clip !important;
        text-decoration: none !important;
      }
      #prompt:focus {
        outline: none;
      }
    </style>

    <div class="root hidden" id="root" on-focus="onConsoleFocus" tabindex="0">
      <div id="history"></div>
      <div id="promptContainer">
        <span id="promptMark">&gt;</span>
        <input id="prompt" on-blur="onConsoleBlur" on-keydown="promptKeyDown" on-keypress="promptKeyPress" type="text"/>
       </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-side-panel-container">
  <template>
    <style>
    :host {
      align-items: stretch;
      display: flex;
      background-color: white;
    }

    :host([expanded]) > #side_panel_drag_handle,
    :host([expanded]) > active-panel-container {
      flex: 1 1 auto;
      border-left: 1px solid black;
      display: flex;
    }

    :host(:not([expanded])) > #side_panel_drag_handle,
    :host(:not([expanded])) > active-panel-container {
      display: none;
    }

    active-panel-container {
      display: flex;
    }

    tab-strip {
      flex: 0 0 auto;
      flex-direction: column;
      -webkit-user-select: none;
      background-color: rgb(236, 236, 236);
      border-left: 1px solid black;
      cursor: default;
      display: flex;
      min-width: 18px; /* workaround for flexbox and writing-mode mixing bug */
      padding: 10px 0 10px 0;
      font-size: 12px;
    }

    tab-strip > tab-strip-label {
      flex-shrink: 0;
      -webkit-writing-mode: vertical-rl;
      white-space: nowrap;
      display: inline;
      margin-right: 1px;
      min-height: 20px;
      padding: 15px 3px 15px 1px;
    }

    tab-strip >
        tab-strip-label:not([enabled]) {
      color: rgb(128, 128, 128);
    }

    tab-strip > tab-strip-label[selected] {
      background-color: white;
      border: 1px solid rgb(163, 163, 163);
      border-left: none;
      padding: 14px 2px 14px 1px;
    }

    #active_panel_container {
      overflow: auto;
    }
    </style>

    <tr-ui-b-drag-handle id="side_panel_drag_handle"></tr-ui-b-drag-handle>
    <active-panel-container id="active_panel_container">
    </active-panel-container>
    <tab-strip id="tab_strip"></tab-strip>
  </template>
</dom-module><dom-module id="tr-ui-timeline-view-help-overlay">
  <template>
    <style>
    :host {
      flex: 1 1 auto;
      flex-direction: row;
      display: flex;
      width: 700px;
    }
    .column {
      width: 50%;
    }
    h2 {
      font-size: 1.2em;
      margin: 0;
      margin-top: 5px;
      text-align: center;
    }
    h3 {
      margin: 0;
      margin-left: 126px;
      margin-top: 10px;
    }
    .pair {
      flex: 1 1 auto;
      flex-direction: row;
      display: flex;
    }
    .command {
      font-family: monospace;
      margin-right: 5px;
      text-align: right;
      width: 150px;
    }
    .action {
      font-size: 0.9em;
      text-align: left;
      width: 200px;
    }
    tr-ui-b-mouse-mode-icon {
      border: 1px solid #888;
      border-radius: 3px;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.3);
      display: inline-block;
      margin-right: 1px;
      position: relative;
      top: 4px;
    }
    .mouse-mode-icon.pan-mode {
      background-position: -1px -11px;
    }
    .mouse-mode-icon.select-mode {
      background-position: -1px -41px;
    }
    .mouse-mode-icon.zoom-mode {
      background-position: -1px -71px;
    }
    .mouse-mode-icon.timing-mode {
      background-position: -1px -101px;
    }
    </style>
    <div class="column left">
      <h2>Navigation</h2>
      <div class="pair">
        <div class="command">w/s</div>
        <div class="action">Zoom in/out (+shift: faster)</div>
      </div>

      <div class="pair">
        <div class="command">a/d</div>
        <div class="action">Pan left/right (+shift: faster)</div>
      </div>

      <div class="pair">
        <div class="command">→/shift-TAB</div>
        <div class="action">Select previous event</div>
      </div>

      <div class="pair">
        <div class="command">←/TAB</div>
        <div class="action">Select next event</div>
      </div>

      <h2>Mouse Controls</h2>
      <div class="pair">
        <div class="command">click</div>
        <div class="action">Select event</div>
      </div>
      <div class="pair">
        <div class="command">alt-mousewheel</div>
        <div class="action">Zoom in/out</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon mode-name="SELECTION"></tr-ui-b-mouse-mode-icon>
        Select mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Box select</div>
      </div>

      <div class="pair">
        <div class="command"><span class="mod"></span>-click/drag</div>
        <div class="action">Add events to the current selection</div>
      </div>

      <div class="pair">
        <div class="command">double click</div>
        <div class="action">Select all events with same title</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon mode-name="PANSCAN"></tr-ui-b-mouse-mode-icon>
        Pan mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Pan the view</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon mode-name="ZOOM"></tr-ui-b-mouse-mode-icon>
        Zoom mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Zoom in/out by dragging up/down</div>
      </div>

      <h3>
        <tr-ui-b-mouse-mode-icon mode-name="TIMING"></tr-ui-b-mouse-mode-icon>
        Timing mode
      </h3>
      <div class="pair">
        <div class="command">drag</div>
        <div class="action">Create or move markers</div>
      </div>

      <div class="pair">
        <div class="command">double click</div>
        <div class="action">Set marker range to slice</div>
      </div>
    </div>

    <div class="column right">
      <h2>General</h2>
      <div class="pair">
        <div class="command">1-4</div>
        <div class="action">Switch mouse mode</div>
      </div>

      <div class="pair">
        <div class="command">shift</div>
        <div class="action">Hold for temporary select</div>
      </div>

      <div class="pair">
        <div class="command">space</div>
        <div class="action">Hold for temporary pan</div>
      </div>

      <div class="pair">
        <div class="command">/</div>
        <div class="action">Search</div>
      </div>

      <div class="pair">
        <div class="command">enter</div>
        <div class="action">Step through search results</div>
      </div>

      <div class="pair">
        <div class="command">f</div>
        <div class="action">Zoom into selection</div>
      </div>

      <div class="pair">
        <div class="command">z/0</div>
        <div class="action">Reset zoom and pan</div>
      </div>

      <div class="pair">
        <div class="command">g/G</div>
        <div class="action">Toggle 60hz grid</div>
      </div>

      <div class="pair">
        <div class="command">v</div>
        <div class="action">Highlight VSync</div>
      </div>

      <div class="pair">
        <div class="command">h</div>
        <div class="action">Toggle low/high details</div>
      </div>

      <div class="pair">
        <div class="command">m</div>
        <div class="action">Mark current selection</div>
      </div>

      <div class="pair">
        <div class="command">p</div>
        <div class="action">Select power samples over current selection interval</div>
      </div>

      <div class="pair">
        <div class="command">`</div>
        <div class="action">Show or hide the scripting console</div>
      </div>

      <div class="pair">
        <div class="command">?</div>
        <div class="action">Show help</div>
      </div>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-timeline-view-metadata-overlay">
  <template>
    <style>
    :host {
      width: 700px;

      overflow: auto;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-timeline-view">
  <template>
    <style>
    :host {
      flex-direction: column;
      cursor: default;
      display: flex;
      font-family: sans-serif;
      padding: 0;
    }

    #control {
      background-color: #e6e6e6;
      background-image: -webkit-gradient(linear, 0 0, 0 100%,
          from(#E5E5E5), to(#D1D1D1));
      flex: 0 0 auto;
      overflow-x: auto;
    }

    #control::-webkit-scrollbar { height: 0px; }

    #control > #bar {
      font-size: 12px;
      display: flex;
      flex-direction: row;
      margin: 1px;
    }

    #control > #bar > #title {
      display: flex;
      align-items: center;
      padding-left: 8px;
      padding-right: 8px;
      flex: 1 1 auto;
    }

    #control > #bar > #left_controls,
    #control > #bar > #right_controls {
      display: flex;
      flex-direction: row;
      align-items: stretch;
    }

    #control > #bar > #left_controls > * { margin-right: 2px; }
    #control > #bar > #right_controls > * { margin-left: 2px; }
    #control > #collapsing_controls { display: flex; }

    middle-container {
      flex: 1 1 auto;
      flex-direction: row;
      border-bottom: 1px solid #8e8e8e;
      display: flex;
      min-height: 0;
    }

    middle-container ::content track-view-container {
      flex: 1 1 auto;
      display: flex;
      min-height: 0;
      min-width: 0;
      overflow-x: hidden;
    }

    middle-container ::content track-view-container > * { flex: 1 1 auto; }
    middle-container > x-timeline-view-side-panel-container { flex: 0 0 auto; }
    tr-ui-b-drag-handle { flex: 0 0 auto; }
    tr-ui-a-analysis-view { flex: 0 0 auto; }
    </style>

    <tv-ui-b-hotkey-controller id="hkc"></tv-ui-b-hotkey-controller>
    <div id="control">
      <div id="bar">
        <div id="left_controls"></div>
        <div id="title">^_^</div>
        <div id="right_controls">
          <tr-ui-b-toolbar-button id="view_metadata_button">
            M
          </tr-ui-b-toolbar-button>
          <tr-ui-b-dropdown id="view_options_dropdown"></tr-ui-b-dropdown>
          <tr-ui-find-control id="view_find_control"></tr-ui-find-control>
          <tr-ui-b-toolbar-button id="view_console_button">
            »
          </tr-ui-b-toolbar-button>
          <tr-ui-b-toolbar-button id="view_help_button">
            ?
          </tr-ui-b-toolbar-button>
        </div>
      </div>
      <div id="collapsing_controls"></div>
      <tr-ui-b-info-bar-group id="import-warnings">
      </tr-ui-b-info-bar-group>
    </div>
    <middle-container>
      <content></content>

      <tr-ui-side-panel-container id="side_panel_container">
      </tr-ui-side-panel-container>
    </middle-container>
    <tr-ui-b-drag-handle id="drag_handle"></tr-ui-b-drag-handle>
    <tr-ui-a-analysis-view id="analysis"></tr-ui-a-analysis-view>

    <tr-v-ui-preferred-display-unit id="display_unit">
    </tr-v-ui-preferred-display-unit>
  </template>
</dom-module><style>
/* Copyright (c) 2012 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .x-list-view {
  -webkit-user-select: none;
  display: block;
}
* /deep/ .x-list-view:focus {
  outline: none;
}

* /deep/ .x-list-view * {
  -webkit-user-select: none;
}

* /deep/ .x-list-view > .list-item {
  padding: 2px 4px 2px 4px;
}

* /deep/ .x-list-view:focus > .list-item[selected] {
  background-color: rgb(171, 217, 202);
  outline: 1px dotted rgba(0,0,0,0.1);
  outline-offset: 0;
}

* /deep/ .x-list-view > .list-item[selected] {
  background-color: rgb(103, 199, 165);
}

</style><dom-module id="tr-ui-e-chrome-cc-display-item-list-item">
  <template>
    <style>
      :host {
        border-bottom: 1px solid #555;
        display: block;
        font-size: 12px;
        padding: 3px 5px;
      }

      :host(:hover) {
        background-color: #f0f0f0;
        cursor: pointer;
      }

      .header {
        font-weight: bold;
        margin: 2px 0;
      }

      .header > .extra {
        background-color: #777;
        border-radius: 4px;
        color: white;
        margin: 0 6px;
        text-decoration: none;
        padding: 2px 4px;
      }

      .raw-details {
        white-space: pre-wrap;
      }

      .details > dl {
        margin: 0;
      }

      :host(:not([selected])) .details {
        display: none;
      }
    </style>
    <div class="header">
      {{name}}
      <template if="{{_computeIf(richDetails)}}" is="dom-if">
        <a class="extra" download="drawing.skp" href$="{{_computeHref(richDetails)}}" on-click="{{stopPropagation}}">SKP</a>
      </template>
    </div>
    <div class="details">
      <template if="{{rawDetails}}">
        <div class="raw-details">{{rawDetails}}</div>
      </template>
      <template bind="{{richDetails}}" if="{{richDetails}}" is="dom-if">
        <dl>
          <template bind="{{cullRect}}" if="{{cullRect}}" is="dom-if">
            <dt>Cull rect</dt>
            <dd>{{x}},{{y}} {{width}}×{{height}}</dd>
          </template>
          <template bind="{{visualRect}}" if="{{visualRect}}" is="dom-if">
            <dt>Visual rect</dt>
            <dd>{{x}},{{y}} {{width}}×{{height}}</dd>
          </template>
        </dl>
      </template>
    </div>
  </template>

</dom-module><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* * /deep/ tr-ui-e-chrome-cc-picture-ops-list-view {
  flex-direction: column;
  border-top: 1px solid grey;
  display: flex;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view > .x-list-view {
  flex: 1 1 auto;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view > .x-list-view .list-item {
  border-bottom: 1px solid #555;
  font-size: small;
  font-weight: bold;
  padding-bottom: 5px;
  padding-left: 5px;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item:hover {
  background-color: #f0f0f0;
  cursor: pointer;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > * {
  color: #777;
  font-size: x-small;
  font-weight: normal;
  margin-left: 1em;
  max-width: 300px; /* force long strings to wrap */
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > .elementInfo {
  color: purple;
  font-size: small;
  font-weight: bold;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view >
      .x-list-view .list-item > .time {
  color: rgb(136, 0, 0);
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view .x-list-view:focus >
      .list-item[beforeSelection] {
  background-color: rgb(171, 217, 202);
  outline: 1px dotted rgba(0, 0, 0, 0.1);
  outline-offset: 0;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-list-view .x-list-view >
      .list-item[beforeSelection] {
  background-color: rgb(103, 199, 165);
}

</style><template id="tr-ui-e-chrome-cc-display-item-debugger-template">
  <style>
  * /deep/ tr-ui-e-chrome-cc-display-item-debugger {
    flex: 1 1 auto;
    display: flex;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel {
    flex-direction: column;
    display: flex;
    min-width: 300px;
    overflow-y: auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info {
    flex: 1 1 auto;
    padding-top: 2px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info .title {
    font-weight: bold;
    margin-left: 5px;
    margin-right: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
        display-item-info .export {
    margin: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > tr-ui-b-drag-handle {
    flex: 0 0 auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel {
    flex: 1 1 auto;
    display: flex;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > left-panel >
      display-item-info > header {
    border-bottom: 1px solid #555;
  }

  /*************************************************/

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
      tr-ui-e-chrome-cc-picture-ops-list-view.hasPictureOps {
    display: block;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        tr-ui-b-drag-handle.hasPictureOps {
    display: block;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        tr-ui-e-chrome-cc-picture-ops-list-view {
    display: none;
    overflow-y: auto;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger > right-panel >
        tr-ui-b-drag-handle {
    display: none;
  }

  * /deep/ tr-ui-e-chrome-cc-display-item-debugger raster-area {
    flex: 1 1 auto;
    background-color: #ddd;
    min-height: 200px;
    min-width: 200px;
    overflow-y: auto;
    padding-left: 5px;
  }
  </style>

  <left-panel>
    <display-item-info>
      <header>
        <span class="title">Display Item List</span>
        <span class="size"></span>
        <div class="export">
          <input class="dlfilename" type="text" value="displayitemlist.json"/>
          <button class="dlexport">Export display item list</button>
        </div>
        <div class="export">
          <input class="skpfilename" type="text" value="skpicture.skp"/>
          <button class="skpexport">Export list as SkPicture</button>
        </div>
      </header>
    </display-item-info>
  </left-panel>
  <right-panel>
    <raster-area><canvas></canvas></raster-area>
  </right-panel>
</template><style>
/* Copyright (c) 2015 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-display-item-list-view {
  flex: 1 1 auto !important;
  display: flex;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-layer-picker {
  flex-direction: column;
  display: flex;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > top-controls {
  flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  display: inline;
  font-size: 14px;
  padding-left: 2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > top-controls input[type='checkbox'] {
    vertical-align: -2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > .x-list-view {
  flex: 1 1 auto;
  font-family: monospace;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > tr-ui-a-generic-object-view {
  flex: 0 0 auto;
  height: 200px;
  overflow: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-picker > tr-ui-a-generic-object-view * {
  -webkit-user-select: text !important;
  cursor: text;
}

</style><style>
* /deep/ quad-stack-view {
  display: block;
  float: left;
  height: 100%;
  overflow: hidden;
  position: relative; /* For the absolute positioned mouse-mode-selector */
  width: 100%;
}

* /deep/ quad-stack-view > #header {
  position: absolute;
  font-size: 70%;
  top: 10px;
  left: 10px;
  width: 800px;
}
* /deep/ quad-stack-view > #stacking-distance-slider {
  position: absolute;
  font-size: 70%;
  top: 10px;
  right: 10px;
}

* /deep/ quad-stack-view > #chrome-left {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMcAAABICAYAAABC4+HLAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH3QcNFyMmV/Pm9QAAIABJREFUeNrtvXmwXdd13vlbe9/7BgzEQAIcQAIEQYKjSAokLVlOW5Fk2nLKmqx0J2Wp0k652h13uiy5XYqdwU7sSnckpZ1yV3U75apU4kos27Elu9NlyRXZjiiRomSTIiWZs0hwHsABJIY33rPX6j/W2ueed3DvAyDKKoGFW0UCeO/ec/fZZ+29v7XWt74lAIuLi7tXV1f/raq+zcy2AogIZsbpvrqfMzNE5IS/1/fVn5sZKaUTrtX9/v7nT+fn9e/1e052X/3r1THWa3R/37+miKCq7c+mjW/a+F/P57vj6/45bayn+wzXs4n+794Q9nP8+PHdS0tL31LVmfpGVQU4YSInGUb/YfZvpn+zp/LQu4Y27X31d933nurkq+qaa08yotO55npG0v2O+r1/XZ9fb2FMWoD9Oe5+pju//e+fdP3u83+j2I+89NJLn11dXf1bdSCTJnnSSpz2+/VWZ/8m+w+g/zD616yT2P9733BOZ5f4dhbCevPQHet63zVtV3y9n1/v/k9nZ562SNY7Gd5o9iPPP//8qxVKrQdL+hOy3qqdNEnTjv1JA+vuRpMGvd7kn8oCqded9B2THuJ6u/Kk7+vuiNOgQH8OX+/np813/376O/CkU2EavDwVWPiGsp9nn33WJt3ItF2ne2xOe2jTHuTJMOS0He1UcG33791JmWQYkzB6dyfp7tynsktPG8/Jdv2TGcLpfH7Sc5m0EKZBsPV+tp4PMe39bwj7efrpp229G5u2O3WPplN1cE/XQZsENybtnNN2pv4x3N1Fpu2S/SO6j6fXgz6n4gRPGmMfR7/ez/cXd/1798Tsfr4PMU52Oq4Hp95I9jPor7ZJ+G7STlEnvN7gesfXpB2tH5lZzynrO07Txtb92aQTY9rv+3i1v4jqv5umOSEq0r9O3/iqEUx6MPXnqjpxrk73812oMQmP968zyUj68zPp+U1bxG80+5GnnnrKpkVxTiWUuN4q7+96/YFXp6pvANN8hD7MmRbF6O7200KR9ed9CDbpSF4v6jIJtnQjQdPGOylK9p34/HowaFL0Z73IUNex7Z5Gk3bkN6L9yBNPPGHdY3fayu3uSP0dqH62uyP0w4XrDWo957gPEfqf78e4p4U8+0Y86R6711pvAUyL3vTvd9ou238Q/Xn4dj4/Cd6d7BlMC532534S9OnO8xvVfuTxxx+39RJlk/DtpAGc6k6hquScp+7EkyIn0+LV60Ufpu2q05zN/sOYFIfvP8CT5VEmGWN/h5w0zm/38+sl7/r3drLntt58rzdXbyT7kccee8z6O2b3JnLO6zpjk47nkyVg1pu07muas9b3CaZh4f5uPMn4Sikn7Jj9RTEJMnQfVHdck4x3Wt5i0qL6dj8/6WQ5GcSYBiEn+STrhT/fqPYzmJYxrRcopax5eH18Oi38WI2ulLImYTPNMavv716z/93rRXUmOZXVgZ5kePX7+hPeN5xJTmx3MdXf9zHyM888w8LCwgn30IUQ0xzWSYvhVD4/LarTzpWBpOl+zqRQ9lqjE2DCtbH2x9MW3XA45JxzzmHnzp0njYp9r9jPoH75Gkekc8SZ2ZpjrH/Ez8wMSSmHMY4YjZp2MDnniVGT/sPvRhxmZ2fJOWHmxj0ajU7AtvV6k4727gSklMg5M4jdq6iyuro69bv799fNptYF0X3vJKjz8MMPMz+/gWuvuYatW7eScgIEwTADEwEUAZDkBgtuYONlCCJgAuZ/N5QkCcP8avFzUH8fsZgNEoJJLAakc+2TjENi90RQjGSCJm1/hwlmgmRFFIwEYoiNxyPxvYZ07gVKUzh8+DD333cfRZXLLrvsBLxfjbl76pyO/ZRS1thq325O137k4YcftvUSOf1Ufdco/uwLX+LOv7ibZ194EYBdF+zkB956C+98+99ARE64ue6XqyqDwaDdGZqm4Qtf/DK3f+UveO7QS2uu944f/IH2WpNwdp2U/oT8+W23c8dX7+K5GN9FF+zkb7zlZt71jh9cswNPw8uTsPU0h19VeeSRR7j55lvYumUzK6MCpqTs9p2AAiRLmChWBBIIiqZEMkVUMAQTJZtQSCCKkDE0/h+7twkKpCSYxrhVMTGyCYogohRLCGvHoYD0xyGKScIUpC5AVSQl/0ACaxeCkJJhakDCTJEEiKAmDMx8XSdAY6lZQjHmZoa89NLL3Pv1r3PVVVeesDH3T+FTtZ/uguhu8v3o36naj4ggjzzyiPXhwtRjOf6+tLjEP//4r3HOuRfw5psPsOeSXQA8+dQz3Pu1ezl2+BC//I9+jvn5uXWjDfW1uLjIr37y19m8/fzJ13vlBf75L/48c3Oza3aWadSP5eUVfuUT/2bd6/3yL/xvbNgwv2Y3qbtOF0J2MfN6ka7nnnuOvZfuZcfO8xitKnloFBXEBHGLc4MTQwVEDeIkyAqa/Pdh9z5vaqgkUuz8akYGVATEHOYYiCSUQtJqkCDJsJJIvXFYNRIzLGWQQqqLEiOhqKS6gnzhqJ9cJplsiiXBSnfBJF957TEoJBKYYskwFUSgWCKnBkmZp59+mpdfepmdO3eu2USn+V/r2c/JWAX9CN/J7KdNiD744IO2nqM0Cff+01/9P7js6gP8d29/C5detJNtmzYC8OrxBZ547kVu/+JfcPDBe/iXv/xPkCnkvHalm/HPTvV6v/SP25vs3mB3fKurI37pX36cfdesf73HHriH//2X/3Fr/NOSTZMyzn0n0sx47LHH+JEf+REWFhd8pzcliRtyBVbFYlcTN0bfpoWEYiaxENTtjOQwByOZ7+r+b/zacY5YICvH/iDmBurjmzQOKMlIWkPThpohkuN0iwWI+YrNGkdeQswwcbhlWEAzw8wXazZDJfsYMP84ghXzxSHip5rB/IY5/sv/+0dc96Y3rdmA2uz0YDA1EHIqDNv1KDAVvk2yn64vOujHlqdlJ+vv/+wLX2JuywVcfOkeXj2ywGtHn0C1Hov+uUsu3cNzzz/Hf7vtdm5959snRknq6wtfvOOUr/fnX7yDH37n29fccBdG5Zy57fYvs2HrqV7vdm59x9vXJeqtx6WqD+T555/nyiv3s7y8TMLhSgLMElkURx+KENi+7uzi0EgtIUCi+OmSwIpjmYTSAIN6uiSDkkAKQgp/IgON+yaGnxIBz/rjcPckj30LU5I5rCsJsiYsafgjCbXEUIwiiqq4e1J9FjVfNCioYMlPC/eJIFuisTiN0oBkhllBcmJlaYnL9+/n0KFD7Nixg5xza6hPP/00S0tLzM7Mho/lfpGicW/hyyCQAv75Nuw+UOwi/o7WmXLfClhYOMaWLVvZtWtXG7TpRibrMx/0V1j34XcdT4DBYMA933yQnRdeymhUOHZsCZFEqrurORRZHRV2XrCLr33jft596zsZjUbtiuzGqQeDAXd//T52Xrj3lK53zzce4G/d+k6WlpfXOF5jSAhf+8YD7DjF8d3zjQf50VvfRdM0LYzqv/pHcH9napqGF154gb/59rdz7PhxTPCdNSliisYuK5rjIRsWPyeJQyGhWhyNCEn9sbrPIGRJmBRfeCb+kEXQwDZG49AFIYmh4kvmhHGYISTEGl9YBimPoZypvx8VJA3R5IurMcdrSTrjLuGjGJCNpJnGlCwWp6CRMLIoMCBhFJPYIAxNxjVXX83v//7vs337dnLONE1DzpmXX36Zt73tB1g8fhwzh3OIObyrp60IWp9XNlBfRtkCPqWIM9T5x+GhDIQN8/O88srLfPWrX+WWW245IeLVPvvubt49biZRMTDj6MISGzdt9i81YTjIzM/OMjc7w3AwANwp27hpM0cWln0iOt9RowruSAlHFpZP43pLJxAB68lnZuSUOXJa41tCIuQ7jYBWf9fnP5kZo9GIlZUVLrzwQpaXVzxihGHJEE1ucdlIkgOwKMncj5Ds0SjfZd2R9re7AeWkGOFUhuOrrd+jFDPMEkJ1XGPhxdY+cRzZARPJfR9Jiqm/P2wONKHJwJRs6jt0Su5nWHJfQj2IYBQIp14xBkI47OE/BVyUFI6/KCk5zJOSGY1W2bFjB03TrOGtzQyHNKNRnTGQghWjWInxGI0phvtyNOZg0GAU86hmlMYw9c9qMYyCjgpHjx9ndmYD3//Wt3LPPfdM9FtUlYGqUko5IbzVdUi7WHw4M8vc3CxzczNsmnejq6HSphSWVlYBWF2ZY2Z2tt2tuwuw/ruUwszs6V2vuxi6TlYd48zM6V+vC8/qYqgnZT861Y+dP/bYo/zoj/4Yo3o8u1PgoVRJiPqJBRkRo6C+oxchSaGIxC5uJHEfwDdqN3xTg+wRKXd2EyRIBppjy/fLY02CWCzTxuHX91MAEfdPNJESqBopFcwyJurAqg3jWpx6DqkExVIiNwIDQa1BAWRAQiE5XExJ/URCyQgFIZlB9rk8cOAAt912G/v3728jiMOZGVQDEShoSUhuEM2U5CecFHWIGbAzlwZJghRDs0AJ2FVdu2wUMxI+XyqFpjF27drF0aNH2bRpU7txt455fcjVuCrE6Ds6DkdW2bF9C1lg49wsG+ZmOWfjHNu3bGL7lk1s2TjPpvlZNszOkMTYsW0LWvSEHbhraDu2nfr1ztu6haa3uLqn0qhpOO+0rncOTWcy+vmMesLVxVgXdimFpmligWbmZgZtLN8vFmFZbbBGHfdSwo9whxot8ZAdMydzTG9aUDGKGlZ8QaiGU6wGVtDSUChIY6j6gqOBTHPScZj5qVHUoAg0DaYlIIWhlj2qFUhBDUwLNH4tMCgKZqRSGMwO+PM//VOGgznPe2jDYGbIvfd8g5mZAapCMcEEv6cK8RpFLLFp06Z2Lqvt7dmzh4cfeRBTQ1E04GXBEG187pLSqNKYbyBm0IQda6MoDUbB1DwQUvyE1tJgKFqM1dJw6Z5Lefzxx1vb7B4EqbtSJjmmXYjVNIXrr7mCI68dZmaQmJ8dsu2cTezYtpkd2zaz9ZyNzM8OmRlkjr52mBuu2c/qaHRCZGcMSxpuuGb/qV/v2isYxfW6GdFqtE3TcMNpjq8mGbs+xyRSX520GhMvpfDC889z7XXXsdKsYMV8t7fA3ChYJmWgGKkIlh3SWeQEwJDkp0UJKKIioGNXW9R3PnKKEK+E32BYDlxvUMTQzEnHIREQSCQaMSRn9+dlvKOmMUr3aFRKcco43JIUicWU+G+3fYHf/c+/x6c+9R+ZGQ6ZmZ3jtz/1Kf7PX/vX3HPvvTHaQsYgKUnFo9C5oBirKytcdeVVvPjii+1zEBGOHTvGxk0bfXGabyxGQ1GHmaYB4YqRLDYIIXyw4vDQ/HoJQ61BTHyPKeZ3aMbxhQXm5+dPSDCaGamPt7pQZRJL8qYbrmP56KscPnwYEZgZJAbZ/5sZZMA4fPgVlo++yoEbrqXCtq4Bdv2bm9/8JpaPvXZq17v+2hNgTXcxN03DzQeuP+Xx3XLg+hNoGN1Togsxu4umnijPv/AC+6/YTxlZZIo1YJIf5yLmBpeFMhCwEg67J8QkVacyRe66eLg1aRtcUVFSgmzFsx3uWSKSkWIUibiSpcD1648DMU/ggTvP6r5PskhrmEMfRFEJKBcZfJPkjq4nQTA13vk338mHfuJDfOXOr/J7v/t7/M7v/A53fvlOfuqnfoqbbjhA8di1/2nZr5kU0YQlhz7XvukannrqqTW2snXrVpYXFrBmBH5+OBnA/CRxP0NJVjySZoo2DrLcbhu0eDTORONnxde3FUQLqoVmtMreS/fwzDPPnOBe5J/+6Z/+F/1dvZ9V7BqHiHDDtVdy51f/ktVRw9ZzNpMkMRo1HD16jAce/hbPPv0k/+N//941Wcr1CoNuvO4q7vjKetd7gr/3t98zkXJ8QpTJjBuuu5IvTxnf/Q9/i+effpIPf/DHJiqO9EPX/Yhd9UuWl5fZMD/ProsupJhDBEniOzaCWMakuNMsjp0znhzTSv0wRbL4yYCQyWgliJhTMzKZRty3cNhDJNgMY0ACz66H333ScRSHVSnCrZbdfzFpc4okFLHsvkEkBE0E6YSPfXxQrHDF/suZnZ3jttu+wHPPPcv73vdefuiHfpiVZrlNbLYJy4Hfm9uSn4jaFF47coScUuvnbd26lccOPsa27eehxXd/JO7LQAZgJRZ84+epZM8JeYwtIaKIRZpGxXNFLTvMIuye2LRxE48++ig7d+5c48/KPffcY5O4+11nvOsj1N/Pz2/ggYe/xaNPPUcTGHc4GLBvz0Vcc8U+VlZXpkrgTCrPrNf71pPPnnC9a6+8gqWlxTUOUx1T/VmfGbphw0buf+gRHn3yudavaMe3/3JWVpZPYOXW+6vX7CYcu9GUpmm47777+OAHP+h4NxYlSdr8gOGOY45TwCpIsRQwxkjqxi7iECCJY3MBj91L8viXKSlFrN7iG6SyrOp1OaVxEAlB1EPFyTzSVCkjmgSp2XGNPALBO2kMy0JW8YhW8VNpODvLp//g03zjG/diCDfeeAN/+8c/yOrqClgOLpZgA8NGKU6vOI0QhMzK8iL/9fOf58orr2QwGJBz5v777+etb/l+jh096rAzCNApbhMqRItTRVKHGBmcF6CYkSUjWlr+pNNrIodiwlNPP8WuXbvWJKoHXew+GAwYjUYnxPS78d9q3EtLi+zfdym3HLiBuVlP1qyurPLakSMsryxPrNfuhnL7hLKFhePs33cpN9/4Jubm58BgeWWFI0eOsLBwfM3i7BrytLrlhYXjXL1/H993043MzsyAwMrKKseOHWNxcWEq6a3PzO0nSFWV0WjE7OwsMzOzLC8teagTQ5w8FVljZ8B6bD/Ig2YkUaz4I1Tx06Sh+E4cxuIZcHdAU8Ak0+T2ihtWzYSj1NThScfhYM4dbne6fVcV8bCx5zpicanvvO2qix+bepSrFMgizM7O8h8/9Z/46p1f4f0f+HEA/ugP/5CVpRU+/KEPsTxa8XAxhpRUM6C+IFViDgqbNp3Tnso153HhhRfyyuGXyGmGOjtJxfliqYbFPX+hpiQKWIoNB1CFQYrTsqGIRLTKT+xk0ChA4Yr9+3ng/vvZu3dvaw+D7mmxsrLCYDBY44TWf3eNsJsPeeWVV9aVdekvvm7Uql88tLq6yksvvzy1sH+aSkh9NU3T+k0iwuLiIouLi+0J2K8zmERP7+Z2qvPdz3EcOnSI6667jtXVZTQZ0pgf81KZrNWgAuNWrlJSSolEWPL9WqWGOt2eJSlaguJhvusnEc/yV0ygRkkpiH+QRSnCScfhnCl1smM44BVIdVnBnnFOEfpMiBVUnMxYeWFZ3FP6/z77x9x5x528//0f4F3vfAdigpbCZ/7wM1yyezdveetbnL8lCbNC5cAUJ7d4SFoSS6Nlrrnmap555ll27tzJcDjk3HPP5eDBg1x2+RU0qytgQol5dNaDopactoLFCVyQLKhCSua+hQTzWD33YwKpcUaA/8ztbBRRs/bk6OPsLkTRoHj3C/Yn1Rv0/ZJJBSarq6troEr3c/XPmvnuQ7FJmfu+sMAkI+/WpPQTndMURGqCr8/6rD8/dOgQ73nPezh27HhEYzzk6Md6pX8bFbAIhonDJKhoxWLXTwFp1NdPY8EgFzT8Dv+AOwbOrjWPgKXKbfLo1CmNo15HPHFmUhgTVQh+lOOWLM641aCFWEtbj+cgyo/+yLvZtnUb3//Wt7G6OkIwfviHb2Xnzgu48c3Xs7K86idNzTGUoLlLxUdOiMwI1159NX/5l3exbdu29jkuLi4yPzvL8dUVSoNDtDjJLKBRI0YmkqXOcEQSFI2cShKkLowSSUlLkU+CZMbi4iLnbt/O8vIyMzMzbkt33nmnTaqK6lZx1aOuX7vcx+yTanq7MKpbfNR1quvu3F8wfQp5d7ev4+v6Al3o0/eX1hMHm1aLPEl8YWFhgZWVZd7+gz/IatOEPzDwya8bdXLoQwnqglR6OBFNcqhDOLbq22dEIiM513iUR8woyZ32XJ3sFDukuPtSKhnxFMbRJgZjx0ymIIM2CWkBO6xS4FNk7cVQC1jia6UNh1rOfgKotgnLFGOWDkFRTZyuUmodSaX1BNoYCF+548vMDGeYn59nZmYGVeXwK4fZef4FqFkEH2owISElnil+X77Ak/PQLBYzYNKQbNDys2rEziJQkFDO2bKVu+6+i71797q9dxNp/d247yfUnMC00Gw3kdNNltXPTitb7VZ91YRQn6zY/96+L1TDq30nvY6l+2fNldSxdU/Mfji3C+1WVlZ45JFHeOtb3sZodTWIbL4raTAKa8UFxTlOTlfxZJRU34DkcXuLRG6p4VdAszu+QZZTBSkOY6zu/MUJWaYRTTuNcfhxlaIOQ+Ik8ARhqZBNPOyMJFLkFDTGX0wpJUCYiI+ztaHY7ASsGRuemS+iZCCqEbiKMKv6ovRxKbccuIWDBw+2lBIR4YVDLzAzHJLQCF1bhzZSPKnZEjiDvqLmi5sCyfMeJpU640466uPT5Pe4PFohDTLD4dARQ3e3rYbdzRB3F0mfqj0pD9CFL12sXiM+1ZDrd9WfdSejv+C6pMWukXezmv3/uhCpe63uoqvjrYuq6WHOetp1v3N+fp65+TnMMpTShjOt3QE9ROvYPI5/83oKlRL1FIrzNSRyAJXFamBNLexzjJ78mqq+YFJxACZ4dvB0xqFBFycpUMhmlBw0k6CxWnJDdlqKnwR+gezcrmD+WkR+tN1/jUJARRM/tSg+1mSU8K80KCGkgiEeoFAfkqkyt2kD8/PzLVlVVbn22mu57YtfYLUUNm7cgBYfmgUb2BduHJfFKBRnAqRIXBZnKIuCNMWTirFo0eKUEwEdGcuLy2MbuP32260LfU6m0zRNm3Q9XdZazDIajRgOh+2C6Auk9X2e9dQpJtU+96HSYDA4IYk5TVh4Te1w+Br9U+PFF1/kyquuYu/eS50KkiQoHtLmCHJEhGosnRrPD6IgOaIl5rAJ8YSYJoWSUSnk5Bwqq5gjJUyLR4tybhm8vkA4rXFIMmiEkqSlswseyclSTxL3XzyRCGLF5QaiZLZSw2t+JuHObaJuAuo8KLF6i/V/Dgu1pk+C1hEOcRLP8D/1zFM89NBDnH/++QyHQy91Hgx44IEHKKUwPz9PaZq4txpVq5WINZIXLoJGwZa4RyZtrNzvQVGSed3LzOwsKQm7du0aEw+7jmyfaDiJRtENuU2Td+z/vMvd6i6++u8uhOpHlyoEqousr3LXvYd+sq7eU9c3miSjWRdJ9WO6i7DuYIcOHeLHP/B+ji0skSWyA6kWKKU2x13LUn3HcuydUoSjgk6NJqwUkNziYMtK1hTwSONKvggk+WJJgbFNGswyScopj6MN+yZjkEAbQwYNlMwwfKKSPN8S9u9JNcmIRj1HkByliEfGRoKm5KzxONMkxpCjTEDw7L1FWUESpWgIX2SLkoKoGMzC/iuu4Mtf/jI7duxobWJ5eZnLLrusjXh2Swb69tO3iYpQuqWw1fftRkyHw+GaIM2gL0ZQv7juntN0nLoZ9a5D3GXdttTfyHr2F0QdcH8xdk+P6kt0F0w3RNyv0OtH37rXn8TA7YsorK6unlBPXEphYWGByy+7jMWlZa+YK8kd5sDqKejfRkNmgBaPubvwgNKUQYxRIZnvxil2VC3+WREnFOILysSDrKoCNAgShU/J687l9MeRygCNYqriTA7PyquzcX0z953fiIRMtnEJbQ7elnrQQHMhaaIBp8cHLPOKkUqV0VYvQsy8ZiVqQ8Tpu2OonmBlZYX9+/dz5MgRtmzZsqaMtm8bw+FwzabaZ23X1+zs7Bok008kT5JYSl0j74ZtR6PRGojV3fFreLOLxfs+S5f+XXfe6mtMKputi6DrVPfpIX1fon5n15/o+g2T9GHrOJaXl9fkbUoprTJJHWddwE3T8MQTT/COH3oXpSmRqnP6tyexvKRUUMQG7luY1GgqiSF5UDynkSzwdZSamkQxj4dXsyWyQE7uvFrUwWrKEIVPOqgV36c/Do3TS6VGsiLWr2PlkAxYKo5zaiYcozHncGlAGEsgJUUdObhn4ZAmp2Acx2JHpBO50tZvMrE2ny1RHKXA277/bRw8eHCNXX237Sd1C4e6cKceMd2sdI3ydJ31SYXsdYDd1djdyfuwqgt3BoPBCSJjNRFZrzccDtes+vWUUvqJwvr+4XC4Jsxcd4+6+6SUGI1GHD16lAcffJD/4e/8HZaPL3nVWXCSPLTpLB1LbqopZGsQT4aliB5pyaTAtwWQQfAhtJCDqaqRlCtBabBhwnKJIiOLTDfQSOQrTn8czsNIHhUL6J0HOGwzJxUWEZJKsDIEy4ZJ9ipDrUojGg67JwuCKxwejuc1LIfJB8YXEY9WRZGXImQN1i+GpuSnWTGWV5b48Ic/zNfvvZejR4+uQTffLfuR27/0pdhCiAL6MUmM4J7Uyq5WmiU0kmqEo2oj1Z9JyLVU3GqRFfU5Cp+ge52uDx+7UJ3kVgFJWPO++pska+Vqqq+FdcbT+S4i4tJqRdXQUCSU3JeTljM1HA64+qorWS4N2VJ8jQYBLpMoQUWHAUKDix9U+ptj/cBI4nymAEvxQBwe+XXjHlJBtdIQ05hwh6JZSPo6xtFm68f3i4IFnZycQhBhnJF3H1yD4hIlsCpjxq6M6+NpqTIhAySKFKfiD5K11A93xI0qFlRTqV42HLkhEyQJDz74wASxD9pn1SGutQteqM+acRBhLBI2wZ7Hw2+t6/lDh2woQhG8drkaazUUBI00ewpqDClR1EXGqiZRq2IR0jE5HM+avZWITzsTMqInEb2oC0BDoCxJ8IoiopCCy+OsS6c1iPiR7xFFI6dQvqhiCjHlLfwQN6Lx/Xssp5iQrBpK5JJbdqrXSYiF1kegDM8ZBDkvplIl5igHLSMoH9XZFIOSa2WdeXVbZGpdWMfxuVRHH39fLFvPVai87nH4JsDaZ6WG5SBFVl6X1PmHsV5QhEQcCZcsAAAWiUlEQVTN/3S+VfIipBosE0FLzWRnf1Z4Vtp9J/WAXcpRvBVUrprIi/vGxpG2yOWf5FkJRdx+Bh6DeN32nCRKFyV2No1Yd12ViguMpZRiB/AEVor4u0VM2+LYN/Hj2LO6cXhGFVjoVDjetnqsBMUnDuVURS1IpOw7TqP12K8Lw5Nm7vA5dUDVs8MSnl8hwpKhzKfqIgWu3RScHgtjSw4l6s6SgtWKuhqHU9OkzbYWMyx1ggPm7FZJyZ1UBIsyToschguG+HcXxZN+kdmuQVdNJRJw1jlVtS2W+k6MQ8W8bDcMMhWjSfgmY8Vza6o+P8Hd0wjFWlQG1mNc8OfqGWev2WgipKzqBuf+T4kyFB9f0TzOktdEqLoWlpl4HQaN86LsVJ+VeaTvO2jPg6B6erRDIIdR13oD/02s+uQTSJvrdfwpUTBjA2sTR9IINlCkyWiuzM/sD0DMSS0mTkqzhKbiANpo2aClEXLc2LhYP7Kfgb/rSSvWtMk2y7G7hbSHVUigtcjIKMUX60iEQQOWa/DU0BIs2ahRdqLOd2aOihZee+UwRYsbQ3a2qmbIxb1hC1U3oQ1ZjRm7GnkFEXKLIYmEn4zRRYp6kXofFYIEydHLB4OK0RmHf5eChOYVY2q81edWhdrCc3B4GBC3as3Fs0rFoaDXllQYowEVfcMiiJh10Yt2TqzkTGE/GeS7OkeDFD5CSfFnOFxSAjRKwKIUxklGvC4TGRSk8aIXk8bLO1NyxuQgao6roYaRWlSEWZhiIlFaAw+tpMANKeHx8Ip5Ww5NPDj1YnpPPDmFuoqMWRz1VfAMgvgnhpVwxIrn5Er2IqEkvjMnySjFT6SUnX/0HZij44tHWVkdccnu3Zx9fe+/Btr4DuvUBW1hjiTfL1IpNAKDyNiqFefN+Kbv8Wp1LaVKoSdi89Iq7/lRlc0jKJqsfW9JNi7cJ3mMPRwlrUzTtoYldokorjZxcKniO4e6DIWvfMVLSXODufU7wcE8yVZq2FDHO3xj1SeSVr0jWUE1ofL65shILC6tsG/fZW3M/ezre/uVkBJVZo5HCacxyDruuJkTzqzSHrK4WFqFKWLkyOWk6kTWLHllZhYP3UXZekRliFj4uHorBSFMzOPdFllaB8w4F0Y8sqJVXdzEaxnCaTXxMkpxBVn/uqSh9FcimuEOutQQRUrOdkU8vBo+kNcCvP45SiI0zejswjiTFodLODaUCJ21YbzgpKSICnn9rbSliCYRprOE5OTOoLg2kJHIUQYq2aMKOVVpRtpoeKoymVLpy0FbSA66UjinxRLJ7RfLGUWcyyMOzCLC6pg4uUaTmKDZa4fropFU2miNk3BaXgdSwqlLige1amVdcvr2654j9zfOvs4gWEVxVW2rNc2iHg7P7qiJiDujppTqtBSw1CDmcXRWidqA8LOtuAYTTlOQKOUZkwIrv8ZFugbqWqzSOulxZBQNOU+HLSkcNi3GAEHzyIPDGkxRF0cKCqpiKaT7i7rwWBX6ipNINbtoQHJGJjmFbEsVFNOWkWq8zjkadRzDs68zBVa5wQ2DgpAkObOsRFSiCsdJxdgZyKHm4OFbBhG4SZW373FzHUR7lKBGWIT2UieLOtTIaUQtmvsblT7txDUlkzRXIqUnk5LnHyQWBknIqDvFklxVQ2sCLBYdCcmGWnJJTvFQoRYhDYKBKhGxyQRPKLVhz29njlxMwDVaObs2zjBYFUmdxqzF3yI1l5DaTKSiaEkgrhhHEmaGmc2bNjM7mHF4o5HOi2qvXEJu3/DC/uAQEU53FokkWxDGUtVX9TLHpDkUx+tWPBYTm8kDl6jJngjy/GotAfUQclRTen11VMah47BdUUgpBJ6DFaCUEAwzJGVmN8yxYdM8m+Y3QM7Vg4kkkTE7nJ06R5VHZHEAnV0bZxysiqysefioiDCIWmQstbyYZMllKkMndX5mA//3b/w//MnnPsett97K//qz/wuriwbZd+IaXUo11m8pdFIjc12MJJGbiOIUzFzvtR1P01bOEUS9lDOPPPQQr7z6Kju2n8cVV1zuSStxaUxyiCfXa5iHgEuQ5VxCMORhUE/IVapQUGFTSqwsL/E7v/uf+eY3v86RI0eYGQ65/PLLee973su1N1xPWVnh2OICn/+jz/P+D3wgAgedOTJXRS8mDCIjXSkjZ19nCqyKrKMUT+J5mt4CK9MamAZRKhnMzczyG//2N3jowQe56aab+PrX7yUxJCWLCJLDnMoZwlwNIqc4naQySR1Mlcp5CQl8SSn8F2lT+W5YnpRqSmHvnktJOfHoY4+ShkFYyzkSSNYqjbcyXuKEEq1Z+6iuz4RAcpw6szNz/Pmf/lf+3k/+JN969GG2bd/Gvn37uPiSSzh+fIGPf/IT/Itf+iWOHDvGRz/yc+Q8OHGOYuJUPNTbWGkTY2dfZ9DiKADFG5aIppYe4KJi2qrsIQ2iwuzcLP/+t/4D9993H9u2bUO1cPPNN6Ml5F5qWNZLgl260Wruo6qMp7arllrxgFHtHyFgxeVUUggwN5W8KL7INm3eiKJs2LQRBQ5+63FyErSx4PxUiFfpGR4CdqFwRTUFT6j4Yo6SycEg8cd//F/49Gf+kBuuvx5B2LZ1G9deey2X7N5N0YZ9+/axuLTEz/7sz7Jnz+4WgnbnyKNmrhiokS23s7DqzINViaalbZQcNGXR0AbKThxIgllhbm6WT/32b3P3XXezY8cOzIwtW7byD3/mH7K4shzdiYxG8IRfKzwfLMiiYeAaxfnFI0ollMilbY4HRaNqLXnmXDJWCkVgzyWX8sSTjzOcmWPzhs0cOX6EJ558kt2790TysJCCJtBUVTypQoBGyRp98ELmrHgTl8OHD/MHf/Bp9u3bx2g04qMf/Qh7du9meWWZLENKafh3/+Hf8/xzz3HFFVcE6zeoJDFHLvDhVBlVF1FGcoSlzxrcmeVz2ABSoYTSRAlYoCl7D4eggc8Mh3zmM3/A7bffwfnnnw/Azp07+djHPkajDefMDUNhI1rwBllNVVlcWvRdNFid3quCwP7aGo5ZioYr3gekcnA8cqWklMMHSly+7woee+IgOQ3YumULh189zLPPPsPFF+9qWxRr66iH6oc60SxriBCrO82ShJQGfPozf8TevXs5duwYv/iLv8imTedw7PhxhEQjixxfXOa+b/4V5+04b1xGGwVHqXK7teZSSnTZqnUTejaSe+YtDu82mkU6HYEyYh5gFVNSHvC5P/kTPv/5P+Oiiy5sDeOhhx7i3e9+d0igyLgntYybtm/cuJFf/79+nXM2nxPKEwnJ2tJKUu0BIerZZIWmKdx11x1ITuOWXLjgGSHfLyS2bN3Cls3nUFTZunUbrx0+zPPPvsCFF1zoY8rR6kqcqGgaogiR6fYwrUfWBnOzPPLwg2zffi6X7buM7du2szJaDSq28OLLr/LRj3yEiy++mKNHj3p8S4RmtQkWLeHZV3GxqvAXGFNbZvnZ15myOEwsIq+1j0EmpdKqSKDG7Pw8n/7MZ9izZ8+a6r9zzz2X8847b90vKKXhi1/8Eu99z4+5+28lEhgS7EpXscgpuzyKKK+8dIiLd+9hkMQ1YtMIs2FIygS1pOo6hR9hZLZu386hFw6x6+JdjJrGe3lHEZEnxx37ayTzarPHJmU2JGNpyWVZLrrgQlaa1SBOehRr1wUX8NnPfg60RPbeN4Dl0QrLxxfbXuKo530oNm4qGYIHdhZXnWGLwxVhnJEq4lDDosREjZShrK5y1VVXsbS0dNpfsLo6YveuXWhxDySJdy8ySSRV1LIr1WlpT565jZs5fuwIaWbW9Y0sk5JGHsPFYES974KKMDDH+0X9NGmaEs0nvejHlFbqsu19h4euNdiBRYW5uVnX2F1aIqsXz2jxSpOl0SrLr7ziaRJlXAVnRm6VA6tgW/FkYuuE51pOefZ1Ri0OCrkMKGmsnySB2ZNAo0JZXuEjH/kon/zkJ9bUY59//vlcffVV3tpM2sLTtrZPzNiydQs33ngTy6tLkSj0uolkng/IOHFPa2mjGlu3biJnf2+tx0gdSYFg/XPs+AJZ1DsUkVhZXuDSSy9DKYg5M9ijYt4FqaiQcnFNpWxYyd5ZVYSiDeeffz5NU7j77rv50E98iIWlBVqhm5JdtsYysxtmKKPG+wCKK3VX9JSTM38tNFqrOksKn+fs68x5ydPPPF116sPochSF+C5emyFIRGQ+8YmPt7W8zz77HH//7/8kb37zAe+akw1TbwxZBbUV7yCkVW81HOycDG0kmh5KW8stVVM1VUHxCO9aFMvgnKnXXn2Nlw4dYtu554IVFldX2Lt7D6Vx/ydngvIuURIqQYyM8leSJzsju52ScMcdt/OlL93O4uIiBw68mb/7d3+C5ZXlqGly3+uVl17iV37lV7nxxhv4n/7B/8xoZTWKZizyi937SO6UR4vjFw49z00HbjprdWdKnsOakFUxjQ6exYnehdDmHtdooIWPfexjlJDc2bXrIn7zN3+Tv/rmN5zuPYrrFHXcrRaG6Ht+MYNSEFXKyHMSpp4LMNShkXmyT83afm+VKFi1/I6+eoRnn3uGrdu3oRiLSyvsufgSmlGlo9decNCkWn9hjKJGo4QAcqNOFUmmFFPe8a53ISJs3ryZ2277Iv/q4/+Kl156iY0bNoHC5z77x/yjX/gFzr/gfP7irr9kNg+pnQHaA7VoKwEKhjVB3bez2fEz7uR48qknLJNbdQ9LtaC4qkDUckZvmSXJM9Sf/OQnWxmUgwcP8lu/9VssLi4g5CASWtCVkq+TWmgURfFAiHpVXaZg9YpHtCza9bbyjeIwaSYP+NrXv8auCy6ClFg8vsieS/d4F9bIp2RxkWLNtLXX0Zpi3M8uKPBaO8DEybi0uMSv/ZtfY252luXlZR5//HEWFhYYDAZccsklbN++nYWFBd73vvdx0803U7Q5YY6INsaVGZ+Sy8+8+PwhDhw4cNbqzqSTo2BRqFOiFtuL8FMIFFA0+jQ03p8tZX7+536e5RWP7uw4b4d/Pqjpg2gmoqqIGk2IhlkqFINGjSZOBFXvEJpKQa2BQqhIBPtcFGu8GaIUb86+aX4TBeP48aPs3rMbbUY0USCF+omgRKticzHjohpL1JeHJqUpTl+36HmtpmyY38A/+6f/hAsvuojRaMT+/fu5+aabuf6GG5ifn2eQB/zMz/wDvu+W76OUZuIcWaijazFUCqWRXlHX2dcZcXI88eTjZpJoJYTa5iJjwYFKwo7MhwscZKGMCnd/7S7edMONbJyb94hTkii2DwVwAaxBZNCWt0rkARSviZBilARZw1hTLcgfh4UsKvEkpPEXFo6zcdNm12K1VjmrrfKr2lOefmg1WECdS+b6JjZuqFgpLHhgYn7DPMeOH+eRRx7m6NGjzM7NcsnFl7D3sr0cO7rg2XCxqXOU1JuqJFwsLQ0yh154nptuOutznDmL44knDPHqORt4Ew/VHPUXIeyg4pSLUK3TkHMPcaiqTeFwJVH14d2g1ZyqHmL1Xq0aelUaurBZooVCrdgLmJNrfTmtTlGKL9boA6HiDUwkh8SPiod9XUCD1EQ31VSbqsQCiSYsYhJtvdplBGY0SRhaFc2JTqbqQoGCYqc4RzUhmtOAF188C6vOLFhFzYr7jq5BIdeooZBUQg3PXD+1lOiyGBhe3dFurGqQatvpE6JKLjXeQ6HVEKoOdpwQxXMY3qXHG40UDGk80lTEe+URkvtaqScWPSrCnyBgVJXsMUtobtqGj973O8iUNCGr0zj3KciNqr7gBhqkkLZ3hYXBW0uzP5U5MhOn47SaT2dfZ8zi0Ej21cahRLzes9niESh1yEEJdZCIHCW1tr2UiF+H6Nmg0RWxrbQTV6zTKmxEkPQ6X1xlHNUKAwnZzuR1TqUEEz3V0m9DdeCD01Atz3jVYTSalOLYvwRd3YoLOlSVESxakdnIGzhqRJWiM5IFrUXR1z1HVb3x7OsMSgIGEhmTG6L/AsGXkoznMGosn+QVdC01PYWyRwqZ+mjxS9u1xHddBMvFdYdLaRuyCDky8jXWFO1QrLiUTklRo+Rqikkt1MktZEejM1UIK9RbkFQV1r1iRC17UZVEaxcpURUYcEqhiPsz0nj0rKr6IfK650gH5ezaONNODqnE1xAIIKIsVVXDosmIR1b94edsnUIoGxtRLm1OoVXwVWtVDnNTF03VeM1eUpqsbdjYRKKvsg0zDmUkKSKlI1Zcuw+NW+VWX8ePIRdSbheLjFwNBD8NBiWa1BOOe/gG5rMShUoBM78Dc+Slv+msxZ1RPkfoQbmYQY3qgI4E1QYzx+Zq3uAU9SyzVawfjd2LetMUxXtEW/SK8B50OT4T6iMaHY5QShVIEPH6h+TizVWlRIMoWFTRIjTi/kkJyCYWbFtTirijXlXNVUucHrX/t2vrWiNOlykuueNhZ1opTO/zEi20NNqhvc450qawYX4Df3XffWsoOGdf38PRqscOPmYpFG1ShlSyc5kyUQvurXSlNBGFicBU1F20WlPquk2VLlLFvzUUsVPrRIdvUCKqU6nudY83acNg1tK9MySvIHRIpeTk6iWErGfkMaM/orcPQ1rdbvdtShrXkVeyjCilqrkXVzqR6NtXhcorn+t1z1HxnNIrr77KyspS9LUIXtkayFUZPbV1g7WdWaPXfCsKYViwVySawXTeYIzJjq3av7Tq7bWPNxEKr+OQWrIs2p6I1umjN+011oSvrSfCyOrvpBaGhSp7R4e3+px0tXbbga+9le/WHMljjx70pHg4qSqCyMhLSU1c87XqzVpoCIbUjSuXgKYQcDbI4vKZskauvmrcgmhGJSRzglflSt/RtsBcMsc0t4TDksbibN4ZKSrwxJCiHnatRVFt96DIrkdttySX1K+ZE4v0dTXmFCdUFonmMcEOiJyMiLbq79+xOZJOo4ToAe6+j7WLX6r5mDe7SUGt8QaQHgk0Fd94skb9irR+XKp6KTIOr0t0lR1InKhrxkGba5LiRNRstZeGz1OTooePpjVtjMfPKuar6kNXKqq6ovugfVZEi4BoU2AaWsUhB0vQ1uJ5EJWX3605annVIkKREp1Ds3cBjRZZIeCHiIuU1V3FzBscinn72kQJ/K2RSIwFIJVHFUVNRNutCN820SvDdbAij5E1yIdGrhQMIWTjSyvCTU7MRqjUhZ4tdi6NZF9oZsVNSLZxf47sLYNTZMyl+hrRMyKpRueMyHN8p+coKqBU1GnuGCWVttNq7R8jql6LbnGaRu9AojamCm1HcUtUZDZutBqSQeoVj2hBtbgGcJETx4GXAljxZ+bs6WjtXIxRSLYq6gvDAqKGwkpSIoEM0gQnwSo1SZgp3tO8RBsJgnemMVduG+NnpbUeJ/Fdn6OBVme0hmKJTp9tljlk4iWq8qLfRirxuTJuQqPRJqgemVrPqugYlELbqf62WHSASuIdf1o2cNDMq9+SQqbexp2anKBo0fsiGMSR3EvW0ERfDRkYTSPef1oEHakLrJVEoYE09Aw+CVd/tKCwZ3IqSBn4Qygh+fnXNEeSBt8T4zj7rMZzNPjKV75KbbLT9idogVhIeNZjrdvaqsrsmESuo9Mjq6NCMq61DvwvXdzr35GihUBtKmNRm60hNh05OMfHMZQkqdN2rYtvg9LRJiSqhm0kO10BoZUBSiYtDBtLhNSuFFVwOnlo+K9xjhLfG+M4+6zGc/T/A8/G/snZpSWJAAAAAElFTkSuQmCC);
  display: none;
}

* /deep/ quad-stack-view > #chrome-mid {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAABICAYAAADRa1RpAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH3QcNFycE5v9iFQAAAQtJREFUOMvtkjGSWzEMQx/0eYrM3v8k3vgqycalSwlI8Ufyl3OBFMtGIgUCIEd6PB6RBEASqvfONSrJXrDNbNkQ8ywA2y/SmayW+ZIESTsiyQsxo40xmMS2aUmYbheHpCVd0+UqJGGMsey3mUyldoUvlY3D9rIN0K7Wbe/WbZ+y1yWtaVtrp3VJzAEX6ZVjc2p7b2mtnYhNdl6m05rwtfV/ltx7XypJTpXeO7Y5juOlchzHaWxyrJmuhLapqgIJONv05+srThBgiQpBTSRwGOr3rwccgWHUhJ7P5/YNlbd/2XiL78L/WajP240AQUihfnx84EDJjCHKHjTAbkimQDgBjAJ1/3kHAgEk/gL71AHEWVXPGQAAAABJRU5ErkJggg==);
  display: none;
}

* /deep/ quad-stack-view > #chrome-right {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAABICAYAAACaw4eEAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH3QcNFyghKmOqnQAADE1JREFUaN6dmsuyZsdRhb/M2uf07bREYDykPeIleAMibNx92i9BgEPBgyB5xlvgtgI8VDNBI41xhGkpQowERgqw3H0ue1cuBlm1T/3Vu4XNiWj9l12XrMyVK1fWL/v6668lCXdHEt/1Z2YnnyUhCTPbX8dn45pmRkR81z7/XUr59Pz8/K8ePnz47/bVV19pnDhu0t+Pmx0Z+Pv8zWv1/eZnZ2dntw8ePPizZXw4bj5/P3vq6G/eePZiX9fd9/Xng6/reg78/dInzxPG9+/auH83GjEbPUahj6m1Hoa6v1/X9c+XPrlP7INqrfuru7+10WzUkUHvOtTojPF1mPdHSzdqPPXo5vm046bdq0fhGr+bvXZk6OgAM2OZBx7hZD7hnCzbtp149Wid0YOjx+eE6t8tMzb659Ebkg5PPY8ZvXpEQWNCzck2M4H3BWeM1Fr31/6+GziPmTefM3tcYzQoIt4a3+cso2EzhsYTzAAdw9M9M3rviPv683dl/Oi9pdZKKeVk4piVRyDu1NI3mCtARFBKeWeGbtt2yHV9HXdnGUMyGjSfZq4K42ajYbPXx836XjO+jsj3rawcFx5dPgK8bzJ6eGbzI8yO3j4yaMToiWF98fl0c4bNSXBEJ/Ozd1HSEY8BLGOIxlONeCqlnHyWtGNoxteRMX38uP44fkyyPnfpp58zqy/s7jsGj0rOEcvPVaMD/sj4I/zWWllmMB/VviOwHumv+dkRGc9EOtOUu6fHZteOGBtDN/+NeJwPNRsxl54RU3PIO4x827a3wNwfdr45kib92WhAf9+fHem1I7FZa31rr+WIr45kzrjZsixvZWHHYcfqXFHGctM9ta7ridcigmVZWNf1DvyllN2wkatmHIxCby7kYzbPOD2qFCN39efrut55rE8YM3I+8VENHPFVa2VZlkOSdXe2bTuhmHdl+W5ox8T8YCbD/l2t9YQqRiNGjx8l1JEamVXKri56doyTuzfGhWd+OyLJjsNRlo+eHaX63Iy8ldnjQn3hbmA/yagGusfG7JwrxZytcxMyjpnH77VyPEEP65iVs5tntp4ldp8zlrG+x8z2Y9L1f91Jy+zeccGZn0Zv9nFHTH500BGbM6HOojMiWEZQf1cN7Aut68qyLCdeGFN+xuRYJ7tXu5fetU9EZCiPOp8xm8bTzLqpe2jkoDnzxjCOa8/VZByzzG7t8gQ4eT+GdO4Be0kZDTgq5kea/0g0RgS+rushNkbg93o6aqeejUeNR/fcUWmaqWLbtn39MdGWGcRHUrcb17E1jhszq3tvxNCsJuaE6VGZMbeMKTrL6LGelVL2k41jx6zuRbknSS9BI7WMdDRTxLi3z+VkDl3/7vb29oS3xhoZESdZOm4whrW/7/NHT83UtNze3u6c1I06Ozs7wdjc7PaQzsV8JNSOp7k97IDvtDPDYTdsvts6Pz8/MXCsm2PD2g/Tm+Vx0bHZHTNvjMyRyh2pajk/P0cIZEAHLLgXQLg5ckDCAFsKCwtIeHHAQGAmSnEkMAyZMBkin4lc3jBEM4a7MZgo7mBGhLD/+M1/qiCqDJflIjICYbknjlEtQEl81cBDYIaUi3aDwoEQ7mABuFMjcHOMQHLMRLSDhhlFQk4+k9IhLggZBREeVLN+NNwNCAhRwjGMimGyPJlA3owyIwiKEltWjTBHNchIGpLleIS5ITNKQHVDYRiBGUQI/83X/0XUyorhm2EKAsvT1IqFgwusgglCWARV3SuGmdNchwgiRHWQagcHIqCNJ7whJ6AI20AeUJ3A0ilP/vQJ33zzDdvNDbWkO91oAwphrah7wVGG1cHMqSHkggiwDJthmAcgjIIVg5rfWc1h2AZ7AgBLpMElMpQCUyOSX/3rr/j+9/+EGoEQTgKxKnDADRROmCiWySJBeILbMCxENVhwBISCnldm4EBEeiQRk1AJs/Y5ER2q7BX03v17SQnumDeXRqXgDaSA1cSdIExQDM+UgtoArTyMIjABJUPt4S2hRHEIgbdstV5LI4OusDvDMgMNqw3sHqi0HPcMotyRNqp5ArnmRrkLuBm4kHmjDAeEDMICk2PFMwomqjI2xYSHsJIUUnxoeBO7rdQUJ2qeJk8SLfdLGtgWCouEVzFUG7NXMAXVG1YqyDdMhSDgFuTpabUEiUguUw3AiAafbhoR4EtmpJknKArgytMaBHBmIozEIQ41M1dK7ySGEvxQ8NoI1w2WFh0XlsUaFYilJ5zhpuGKwBxXeygIqxlrE6Ih1wKPgi8L799/QGcJo4M5o9oYDfcKUZJmEFdX12zrikh2xwwrQA2KOeqETRlCGaKaUFXLpjQwy5Elu4dzflb4uw8/5MXP/wEsE6ORVX8hbVRzTVcN4ic/ec4HH3zA7XaTC1sQtZUXAm98Z7I7uvjii8+5ePw4pUiwu7TXuogM3cX7j/jhX/yIJz948gf/NPjll1/yy1/+E//z299RCGrL+AxI8krQfhk5Ab+6LmrGyDA1dvfkqOvXNzy7fMonn7w8umjafabmsDuowPPnz3nz5joLiN9VCwIqJDGHweixV59/weNHF4itZSMJbGq61kg3h3N2fs7D9x7jIdTwIzw3tCxrZo560U5U8frNFdu6URWJS8RmRukto3smv07uxwJrMa9uLDJCG1ZKI87AWJBvhEOsG9WEhSVcWBtu1A615da2kboiPaRW4hSRcBGEClhg0cTDycWdJR1XgUdkrN2hRqslGapydo+fffgRL37+Ir1opzrrJHZDAiB49vySv/3gp9zcRiqLCpsrjSLrnpQ27KH8/ItXPHz4PtRbRMoTajrBw6Hk4o8vLvjhj/6SH/w/wf/xx//I629/u9fPjkxLIZfVwmLwWBhQqUqgU1NZlCrkQVRwGW9urrl89pRPXr78gw27vHzO9dVVI2cIOYVIGHkrYXVDUQaPvXrFo4tHbFV7dnkjzGT+5BjXwnK/cPHovcRLI9hME3ZeM2+HtRwQAVdXb1ivr6ldzfYC3sSnPFAUZHW+HE7WtqamZL07avrcnYgKKtR6m/VKQTR9n0JQjZj7KqD2LCLY2h4quqsKNUWA5BQPatjAY1hTpuAO2iqlGLV1EQJ8C87vnfOzjz7ixS8+5vf93y+sFeZnl5f89K//htttw1bAW5d05rAK90awjOD//BUPHtynblmInXStyUHJR3jw3sV7/PjpU548eXJArvZ/gv/Fx7/g9bfftug4NfVKa7byd8pN9ZT5I9rFSM/wSPFXrOn5Tby5vubp0x/z8uU/t1Jx5/H9v3b3/q4YGJfPLrl+c0Pde8lgEWxN0znG1jG6e+zfXnHvwQNETdmMINqlSEeZJ1Dvn93j4uJiL+6jv8TQO9L6lya9f/fta26228wodVwZboFU2gLbqbqglZLarzTbdpvBEhWxNJI1bq5uuV6/SRCHt35AyAwPo5aKZzlIHRb5SqTR1nRSnitQtC4phNlyqvlTppRUlmZEQJizhCErbYSa57J8SNkLRm3s7RV54AHymjK9cYjUyg+wqV8XRCtfdzea+IZiFIoSsFKBEm1SE26SpXZCeDh7g9P64R4SrU2ZkC1btea5TMDsqCJ5UfUuZwO1BlnZ6tkgrWWWqjOgqhJmsLWa2dowsKZK0nuKlMWokWWBoBIeiJpZF6CqhtnMdHSHW6PdZLfijjISu2HX11dEjURrTza3BtymzaLV5NZwEGQYW4ekaLdCkXSDRCkidr2n/XKGUlOKjxc6oXZN0H4ZefXrVxQ3atTsjD1lkJpIDNEwlSCRZ53rp4zViNiQtqwEStHT1YoUOaclSY1MmmjXCelNz2Q1T5L/7LPPYDEePXqYNa0ENHnd7xeKKUFiAO2HBM97DZMoS1prMmQLrqCE8uZHIgVDNAFpFEW7BnGKWQtnYJ6GOmL54+99D0JEzfT1alRzikHtda+1/4nsxk/VqQZmlXXzJMUiqFu7nrJMe8v2LhteteuAvEcrVqk1m+Owdn9h7ZYSE6WAIrkjPCVIFua8s0jhWHfhZ5YZZ6rZNxoplZp3clg2uUSKAcmwYpgqUs1iFI5Z4rr3mliq3IVqVDbwM9CGkao1rN1IR6F4xepCEFht1wAhIKjRNH0Dv6ym5lHrEQw8JSlUtapghHJ+qiK13OyZ6yyf/sunSYqyVuPavVVq3bvSgrKxcKVGU7/s1U5ovXz1W5v9ftPVet68cbSehRo65ZNfUuB/AWHLchVUWJtFAAAAAElFTkSuQmCC);
  display: none;
}
</style><template id="quad-stack-view-template">
  <div id="header"></div>
  <input id="stacking-distance-slider" max="400" min="1" step="1" type="range"/>
  
  <canvas id="canvas"></canvas>
  <img id="chrome-left"/>
  <img id="chrome-mid"/>
  <img id="chrome-right"/>
</template><style>
* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view {
  position: relative;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > top-controls {
  flex: 0 0 auto;
  background-image: -webkit-gradient(linear,
                                     0 0, 100% 0,
                                     from(#E5E5E5),
                                     to(#D1D1D1));
  border-bottom: 1px solid #8e8e8e;
  border-top: 1px solid white;
  display: flex;
  flex-flow: row wrap;
  flex-direction: row;
  font-size:  14px;
  padding-left: 2px;
  overflow: hidden;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view >
      top-controls input[type='checkbox'] {
  vertical-align: -2px;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > .what-rasterized {
  color: -webkit-link;
  cursor: pointer;
  text-decoration: underline;
  position: absolute;
  bottom: 10px;
  left: 10px;
}

* /deep/ tr-ui-e-chrome-cc-layer-tree-quad-stack-view > #input-event {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAMnwAADJ8BPja39wAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAyNSURBVHic7Z1PTCPXHcc/4wWWVbJN2cJSLVqiQJuGpoIGEVWReoBNIlIF5RCRSysOK9EbksUeOHLIIQcULbLEEYk7oqduD6gSRoqUEyK7dCOabOHghCiAE/JntQtesHt4fuM3z2+MZzy2x8ZfaTTjN+Px4/fh9/7Pb6xMJkND4VGk2hloyKkGkJCpASRkagAJmRpAQqYGkJCpASRkaqp2BvzKsizf3w1z38sKc+ZUaQCuAFeB57P7q4AF/Kxsj4GnLrfL+6PDYofQAskCaAJ6gJeB6+QAFOvZpwgwPwOHwCNgN5uu/+H252raJHRALMu6ggDwCtALNAf8E88QUL5AAHqSTVcNUTU4oQBiWVYzMIiA0E3lGhtp4CsEnPtACgFDGqXiYKoKxLKsCPAaMIwojlzV1tZGV1cXHR0ddHR00N7ebh93dHQAcHh4aG/JZNI+3tvb4+jo6LzsPAY+QYA5Ix9KBsoPpmpALMt6BXgTaHe7pre3l5GREUZGRujv7/fdsspkMmxtbRGPx4nH4+zs7BS6/HtgHfgvOW9xeE05bVZxIJZldQNvATf1c5FIhMHBQYaHh7l16xbd3d1lyUMikWBtbY319XU2NzdJp9Omy74B1oAEAoa8yIZTDttVDIhlWZeB94Dfm86Pjo4SjUbLBsFNiUSCWCzG6uqq2yVfAv9CNKHTlNlbKgLEsqxrwF+BX+nnhoaGuHPnDv39/WXPRyFtbW1x9+5dNjY2TKePgBXgOwQUFUyg3lJ2IJZl9QAfAK1qek9PD9PT04yMjJT1970qHo8zPz/P7u6ufuoE+CewQw6Kw2OCsGVZgViW9SdgFNGLBqC1tZWZmRnGx8eJRMI5lJZOp1lZWWFubo7j42P1VAZR4W8gWmJn5KBAAEVYWYBkm7PvIvoWtjo7O1lYWKCvry/w3yyHtre3mZqaYn9/Xz/1EPg3ot+iQslQIpTAgWRh/A0x5GFrYGCAWCxGe7trKzeUSiaTRKNRHjx4oJ/6CvgHoigLDEo5yox30WCMjY2xtLRUczAA2tvbWVpaYmxsTD91E3gbMbTTBFxCFM0WYPntMwXqIdk64x3lM9FolMnJycB+o5paXFwkFovplfcniDrlNLvJXr4vTwnMQ7KtqVE1rZ5gAExOThKNRvXkPyMGQaWXlOQpgQDJ9jM+QGlNjY2N1RUMqcnJSb34shClwnVE8aVCAY9QSi6ysj3wv6N0+gYGBlhaWqKlpaWke4dVqVSK27dv6xX9j8AyYpDyGaL4svsqxdo5CA95DwVGZ2cnsVisbmEAtLS0EIvF6OzsVJNfQIzRlVTJlwQkO1Boj021traysLBQk60pr2pvb2dhYYHWVscAxEuI1pcKJYIHKKV6yFvqh5mZmZrp9AWhvr4+ZmZm9OQ3MAMpSr6BZOcz7CH0np4exsfH/d6uZjU+Pk5Pj6PbdR34LT69xBeQbG/8TTVteno6tGNT5VQkEmF6elpPfh24TK7VFaFIKH4t+BrKTN/Q0FDoRm0rqZGREYaGhtSkXyDqVs9Fl2cg2QUJw2ranTt3vN6m7mSwwR8R68dULzm31eXHQwZRFiSMjo5WfXIpDOrv72d01DFQcQXoQ3hI0V7iB8gr9pcjEdNQwoVVNBrV69EXcanccfEST0Cyi9jsSe/BwcGKz4GHWd3d3QwOOqaAOoDnMFfuRnn1kJfV7wwPD3v8ev1Ls4mF+Ac2FVsW5C8aLxpI9ou/U9Nu3brlOcP1LoNNbuJej+R5ihcPaQJ+Iz/09vY2iiuDuru76e3tVZN+jeiTyFHggsWWFyA9KAufL3K/4zxptrkE3MClYkcDUxQQU3HVAOIug226yHlIXvNXrUe8eEiHPGhra2v0PQqov7+ftrY2NekFzEVWSXWI3Rns6uoq6ZGyepdlWXR1dalJrRTwEFVegFyVB3L5f0Pu0mzUirC1CsPoJcUCuYLyGFkDyPnSbBQhB8VUZNm99nOBZC+8qqZdhBnBUmWw0RXMQHx5iOPpprB5yMbGBp999lm1s+GQwUZXKFBUSRULxOEhYQNy//59Hj58WO1sOOQCpGAfBOoESBhVwENMm61in/cOXRt3f3+f09NTAH766SdaWlrY29sDoLm5mevXr1cze25y9QypYoH8rH44PDwsIU/B6KOPPrLzcXBwQCQS4dNPPwXgxo0bfPzxx9XMnslGJ7h7hkX2GZOaBRKLxezjxcVFLl++zMTERBVz5JTBRseGy3zXIaEDEna5eAgENIX7WP2QTCaL/NrFlcFG0kMKLvIttsh6ilg83ATh85D3338/dGNrmo3SiAXYuvLgeImX9Rj4peHHqq5r165VOwt50mx0gjkqhJT92cvgol2P7O3thSa+VBiVyWTsJnhWsv4wBrZR5QWIjfzo6IitrS0vebxQ2tra0oPdPCbfQ4ze4gXII/VDPB73k9cLIYNtDnACUJ9td8gLkF2UiqkBxF2abc6AJOboD3lQzgWi1BWnCCgA7OzskEgk/Oa5bpVIJPTwT9+RCymoe4jvIkt+8Qs1cW1tzVem61kGm8jiKk1+gIE8eV25+Ihc3CjW19c9fr3+pdkkgwCiwsiL+oDyUKhXIE8QISUA2NzcbBRbihKJBJubm2rSD4h4KLLuOMMQRUiVn9XvdrGVTqcdg3wXXbFYTI9Op3qHuqlQHCoKSNadJNH7KGNbq6urjT4Jou+hRaVLIUoTE4zA6hD5Q5+oCXfv3vVxm/qSwQY7iG6C9BAZByWv6auOevgBIr3ke5mwsbFxofsl8XhcDw34BPgaYXg1KI0p6JlDRQPRiq0zRGQ1W/Pz827RPeta6XSa+fl5Pfl/5LxC3QrCAP9P4WYQcW2/kQm7u7usrKz4vF3tamVlRY/P+CPwLTlvcANiDN/kCYjiJXLv6AXNzc2xvb3t5ZY1re3tbebm5vRk2Vc7JReExgTDqFI8JIMIMvylTDw+PmZqaupCzCgmk0mmpqb0IJkHiLpV9Ypn5MA4oJimMDwD0eqSDCLIsD3WvL+/TzQaJZVKeb11zSiVShGNRvXgmE+Az8kVU8+UrSjvgNKCz8jxmaeIIMNyEoYHDx4wOztbwq3DrdnZWT1W1imi5XmCE0YKlyLLbYLPFxDlZhLKd4ggw/aJe/fusbi46Of2odbi4iL37t1TkzLAfxAzqmc4PcPkIQVVqofIfRrREVpXL4jFYnUFRQbB1PQIMZsqYaSUraiWlaqSQvxlV3rIFd2XEIsm/gL8Qb1ubGyMDz/8sGajzKVSKWZnZ3XPANHs/xxh+BSiyDrObifkirCiiisIDogK5TIwjvY6ijoMpHwEbCJAPCMHQIWhxl4sKmxsEEEwwQmlCQHlbeBV9do6CjX+DbBNDobqHSYYRQfCLDnimKEZfJbN0CpiENLOxf7+PhMTEywvL4d6mCWdTrO8vMzExIQOI4Pod31OPowTzHWHpz80kMjWyqpB6SXSU5oRQYbfARwVSA2+ruIU0ZrSK/ATnEBky8oxqlusnQMLNa4VXRa5Sr4JEYdwDPG8tkM18kKXJ+TmgWQ/Q3qDDsNTJa4r6NjvkA/lEsJTnkdEMX3J9N0Qv/LoAFFEyRaTbFFJGPK4ZBhQntdVgDuUZkTr6w2E1zgUspeC/YjoY3yPczgkZdhk568kGFC+F7qAE4qsU2S90owIpfo6ImCkUVV6bd4TxHzGtzgnmNThEN0rHK0pSngFUtleeeQCRa1XmhHN41eBAcRDka6qwIslU4jRhq/Jn8tQh0HUitttWtb3YvRyv4MKck8MyUeCZRGmeosMGPkiIshNpR72yCCW6hwgFiTI1pE0tDS6abDQ87BIMarEW9rAGUFNNot1MHL/HCIs3k1E8K9LAWfpDDEYepDd5Lopdc5b9Qx9r14nx/EgABhQASCQ109RizAdjApH9vhvIOJNvYCIFyJjhhSjNLlm6WMEgCS5tbbqAjbTlKsKwwTCHmCtmfcY2j/khCL3auwPNXyRGqOwifzQRq2IYk7dwDl8cYwwpjoqrRrSDYYKpdCaqpLrC5Oq8S5c+xCzx+hwTJtbEBdT3aMbUBpVXWvrtsnz+op1CNArVFXlbdEu3mICowJS9+cBsR/Exx2IaQG0af1tHggI1itUVft96vahsi/kOabPxQCRe93IaW3TAVQMhFRVgdiZMIORexOgQiDkXv3DdAObPMYIgAqBkAoFECmtJ+4Gp9Ax2rEORe51w+sQ7OOK17FhAqLKBY567AbBTSY4rsfVsktogagqACfvUpd0tz/SkR4GW9QEEFVBhtAI499ec0DqXf8H8f4X10jf2YAAAAAASUVORK5CYII=);
  display: none;
}
</style><template id="tr-ui-e-chrome-cc-layer-tree-quad-stack-view-template">
  <img id="input-event"/>
</template><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-layer-view {
  flex-direction: column;
  display:  flex;
  left: 0;
  position: relative;
  top: 0;
}

* /deep/ tr-ui-e-chrome-cc-layer-view >
      tr-ui-e-chrome-cc-layer-tree-quad-stack-view {
  flex: 1 1 100%;
  flex-direction: column;
  min-height: 0;
  display: flex;
  width: 100%;
}

* /deep/tr-ui-e-chrome-cc- layer-view > tr-ui-e-chrome-cc-layer-view-analysis {
  height: 150px; /* fixed height given by drag control */
  overflow-y: auto;
}

* /deep/ tr-ui-e-chrome-cc-layer-view >
      tr-ui-e-chrome-cc-layer-view-analysis * {
  -webkit-user-select: text;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view {
  flex: 1 1 auto !important;
  flex-direction: row;
  display: flex;
}

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view > tr-ui-e-chrome-cc-layer-picker {
  flex: 1 1 auto;
}

* /deep/ .tr-ui-e-chrome-cc-lthi-s-view > tr-ui-b-drag-handle {
  flex: 0 0 auto;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-summary-view {
  flex: 0 0 auto;
  font-size: 0;
  margin: 0;
  min-height: 200px;
  min-width: 200px;
  overflow: hidden;
  padding: 0;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-summary-view.hidden {
  display: none;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-view {
  display: block;
  height: 180px;
  margin: 0;
  padding: 0;
  position: relative;
}

* /deep/ tr-ui-e-chrome-cc-picture-ops-chart-view > .use-percentile-scale {
  left: 0;
  position: absolute;
  top: 0;
}

</style><template id="tr-ui-e-chrome-cc-picture-debugger-template">
  <style>
  * /deep/ tr-ui-e-chrome-cc-picture-debugger {
    flex: 1 1 auto;
    flex-direction: row;
    display: flex;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > tr-ui-a-generic-object-view {
    flex-direction: column;
    display: flex;
    width: 400px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel {
    flex-direction: column;
    display: flex;
    min-width: 300px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel > picture-info {
    flex: 0 0 auto;
    padding-top: 2px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > left-panel >
        picture-info .title {
    font-weight: bold;
    margin-left: 5px;
    margin-right: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > tr-ui-b-drag-handle {
    flex: 0 0 auto;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger .filename {
    -webkit-user-select: text;
    margin-left: 5px;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > right-panel {
    flex: 1 1 auto;
    flex-direction: column;
    display: flex;
  }

  * /deep/ tr-ui-e-chrome-cc-picture-debugger > right-panel >
        tr-ui-e-chrome-cc-picture-ops-chart-view {
    min-height: 150px;
    min-width : 0;
    overflow-x: auto;
    overflow-y: hidden;
  }

  /*************************************************/

  * /deep/ tr-ui-e-chrome-cc-picture-debugger raster-area {
    background-color: #ddd;
    min-height: 200px;
    min-width: 200px;
    overflow-y: auto;
    padding-left: 5px;
  }
  </style>

  <left-panel>
    <picture-info>
      <div>
        <span class="title">Skia Picture</span>
        <span class="size"></span>
      </div>
      <div>
        <input class="filename" type="text" value="skpicture.skp"/>
        <button class="export">Export</button>
      </div>
    </picture-info>
  </left-panel>
  <right-panel>
    <tr-ui-e-chrome-cc-picture-ops-chart-view>
    </tr-ui-e-chrome-cc-picture-ops-chart-view>
    <raster-area><canvas></canvas></raster-area>
  </right-panel>
</template><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

* /deep/ .tr-ui-e-chrome-cc-picture-snapshot-view {
  flex: 0 1 auto !important;
  display: flex;
}

</style><dom-module id="tr-ui-e-chrome-cc-raster-task-view">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    #heading {
      flex: 0 0 auto;
    }
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>

    <div id="heading">
      Rasterization costs in
      <tr-ui-a-analysis-link id="link"></tr-ui-a-analysis-link>
    </div>
    <tr-ui-b-table id="content"></tr-ui-b-table>
  </template>
</dom-module><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-chrome-gpu-state-snapshot-view {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dEAEwATABMYqp3KAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90JCQsBMCH7ZqYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAUElEQVRYw+3WwQkAIAiF4Vc0hTO5/wiuURvYIcQOv1cRPhDlDXffSsrMsrYiQi/zU80FAACAVX3nt3lWAABA/x+ovnPyAAAA5AHyAAAA3wMOd34Xd+lsglgAAAAASUVORK5CYII=);
  display: flex;
  overflow: auto;
}

.tr-ui-e-chrome-gpu-state-snapshot-view img {
  display: block;
  margin: 16px auto 16px auto;
}

</style><dom-module id="tr-ui-a-layout-tree-sub-view">
  <template>
    <style>
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>
    <div id="content"></div>
  </template>
</dom-module><dom-module id="tr-ui-e-s-frame-data-side-panel">
  <template>
    <style>
    :host {
      display: flex;
      width: 600px;
      flex-direction: column;
    }
    table-container {
      display: flex;
      overflow: auto;
      font-size: 12px;
    }
    </style>
    <div>
      Organize by:
      <select id="select">
        <option value="none">None</option>
        <option value="tree">Frame Tree</option>
      </select>
    </div>
    <table-container>
      <tr-ui-b-table id="table"></tr-ui-b-table>
    </table-container>
  </template>
</dom-module><dom-module id="tr-ui-e-s-input-latency-side-panel">
  <template>
    <style>
    :host {
      flex-direction: column;
      display: flex;
    }
    toolbar {
      flex: 0 0 auto;
      border-bottom: 1px solid black;
      display: flex;
    }
    result-area {
      flex: 1 1 auto;
      display: block;
      min-height: 0;
      overflow-y: auto;
    }
    </style>

    <toolbar id="toolbar"></toolbar>
    <result-area id="result_area"></result-area>
  </template>
</dom-module><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-system-stats-instance-track {
  height: 500px;
}

.tr-ui-e-system-stats-instance-track ul {
  list-style: none;
  list-style-position: outside;
  margin: 0;
  overflow: hidden;
}

</style><style>
/* Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

.tr-ui-e-system-stats-snapshot-view .subhead {
  font-size: small;
  padding-bottom: 10px;
}

.tr-ui-e-system-stats-snapshot-view ul {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  font-family: monospace;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

.tr-ui-e-system-stats-snapshot-view li {
  background-position: 0 5px;
  background-repeat: no-repeat;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding-left: 15px;
}

</style><dom-module id="tr-ui-e-v8-gc-objects-stats-table">
  <template>
    <style>
    tr-ui-b-table {
      flex: 0 0 auto;
      align-self: stretch;
      margin-top: 1em;
      font-size: 12px;
    }
    .diff {
      display: inline-block;
      margin-top: 1em;
      margin-left: 0.8em;
    }
    </style>
    <div class="diff" id="diffOption">
      Diff
    </div>
    <tr-ui-b-table id="diffTable"></tr-ui-b-table>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-e-multi-v8-gc-stats-thread-slice-sub-view">
  <template>
    <style>
    </style>
    <tr-ui-e-v8-gc-objects-stats-table id="gcObjectsStats">
    </tr-ui-e-v8-gc-objects-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-e-v8-ic-stats-table">
  <template>
    <style>
    tr-ui-b-table {
      flex: 0 0 auto;
      align-self: stretch;
      margin-top: 1em;
      font-size: 12px;
    }
    #total {
      margin-top: 1em;
      margin-left: 0.8em;
    }
    #groupOption {
      display: inline-block;
      margin-top: 1em;
      margin-left: 0.8em;
    }
    </style>
    <div style="padding-right: 200px">
      <div style="float:right;  border-style: solid; border-width: 1px; padding:20px">
        0 uninitialized<br/>
        . premonomorphic<br/>
        1 monomorphic<br/>
        ^ recompute handler<br/>
        P polymorphic<br/>
        N megamorphic<br/>
        G generic
      </div>
    </div>
    <div id="total">
    </div>
    <div id="groupOption">
      Group Key
    </div>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-e-multi-v8-ic-stats-thread-slice-sub-view">
  <template>
    <tr-ui-e-v8-ic-stats-table id="table">
    </tr-ui-e-v8-ic-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-e-v8-runtime-call-stats-table">
  <template>
    <style>
    #table, #blink_rcs_table {
      flex: 0 0 auto;
      align-self: stretch;
      margin-top: 1em;
      font-size: 12px;
    }

    #v8_rcs_heading, #blink_rcs_heading {
        padding-top: 1em;
        font-size: 18px;
    }
    </style>
    <h1 id="v8_rcs_heading"></h1>
    <tr-ui-b-table id="table"></tr-ui-b-table>
    <h1 id="blink_rcs_heading"></h1>
    <tr-ui-b-table id="blink_rcs_table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-e-multi-v8-thread-slice-sub-view">
  <template>
    <tr-ui-a-multi-thread-slice-sub-view id="content"></tr-ui-a-multi-thread-slice-sub-view>
    <tr-ui-e-v8-runtime-call-stats-table id="runtimeCallStats"></tr-ui-e-v8-runtime-call-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-e-single-v8-gc-stats-thread-slice-sub-view">
  <template>
    <tr-ui-a-single-event-sub-view id="content"></tr-ui-a-single-event-sub-view>
    <tr-ui-e-v8-gc-objects-stats-table id="gcObjectsStats"></tr-ui-e-v8-gc-objects-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-e-single-v8-ic-stats-thread-slice-sub-view">
  <template>
    <tr-ui-e-v8-ic-stats-table id="table">
    </tr-ui-e-v8-ic-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-e-single-v8-thread-slice-sub-view">
  <template>
    <tr-ui-a-single-thread-slice-sub-view id="content"></tr-ui-a-single-thread-slice-sub-view>
    <tr-ui-e-v8-runtime-call-stats-table id="runtimeCallStats"></tr-ui-e-v8-runtime-call-stats-table>
  </template>
</dom-module><dom-module id="tr-ui-b-grouping-table">
  <template>
    <style>
    :host {
      display: flex;
    }
    #table {
      flex: 1 1 auto;
      font-size: 12px;
    }
    </style>
    <tr-ui-b-table id="table"></tr-ui-b-table>
  </template>
</dom-module><dom-module id="tr-ui-b-grouping-table-groupby-picker">
  <template>
    <style>
    #container {
      display: flex;
    }
    #container *:not(:first-child) {
      padding-left: 3px;
      border-left: 1px solid black;
      margin-left: 3px;
    }
    </style>

    <div id="container"></div>
  </template>
</dom-module><dom-module id="tr-ui-b-grouping-table-groupby-picker-group">
  <template>
    <style>
    :host {
      white-space: nowrap;
    }
    #left, #right {
      user-select: none;
      cursor: pointer;
    }
    </style>

    <span id="left" on-click="moveLeft_">◀</span>
    <input id="enabled" on-change="onEnableChanged_" type="checkbox"/>
    <label for="enabled" id="label"></label>
    <span id="right" on-click="moveRight_">▶</span>
  </template>
</dom-module><dom-module id="tr-ui-sp-file-size-stats-side-panel">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    toolbar {
      align-items: center;
      background-color: rgb(236, 236, 236);
      border-bottom: 1px solid #8e8e8e;
      display: flex;
      flex-direction: row;
      flex-direction: row;
      flex: 0 0 auto;
      font-size: 12px;
      padding: 0 10px 0 10px;
    }
    table-container {
      display: flex;
      min-height: 0px;
      overflow-y: auto;
    }
    </style>

    <toolbar>
      <span><b>Group by:</b></span>
      <tr-ui-b-grouping-table-groupby-picker id="picker">
      </tr-ui-b-grouping-table-groupby-picker>
    </toolbar>
    <table-container>
      <tr-ui-b-grouping-table id="table"></tr-ui-b-grouping-table>
    </table-container>
  </template>
</dom-module><dom-module id="tr-v-ui-histogram-set-controls">
  <template>
    <style>
    :host {
      display: block;
    }

    #help, #feedback {
      display: none;
      margin-left: 20px;
    }

    #search {
      max-width: 20em;
      margin-right: 20px;
    }

    #controls {
      white-space: nowrap;
    }

    #show_overview, #hide_overview {
      height: 1em;
      margin-right: 20px;
    }

    #show_overview {
      stroke: blue;
      stroke-width: 16;
    }

    #show_overview:hover {
      background: blue;
      stroke: white;
    }

    #hide_overview {
      display: none;
      stroke-width: 18;
      stroke: black;
    }

    #hide_overview:hover {
      background: black;
      stroke: white;
    }

    #reference_display_label {
      display: none;
      margin-right: 20px;
    }

    #alpha, #alpha_slider_container {
      display: none;
    }

    #alpha {
      margin-right: 20px;
    }

    #alpha_slider_container {
      background: white;
      border: 1px solid black;
      flex-direction: column;
      padding: 0.5em;
      position: absolute;
      z-index: 10; /* scalar-span uses z-index :-( */
    }

    #alpha_slider {
      -webkit-appearance: slider-vertical;
      align-self: center;
      height: 200px;
      width: 30px;
    }

    #statistic {
      display: none;
      margin-right: 20px;
    }

    #download_csv {
      margin-right: 20px;
    }
    </style>

    <div id="controls">
      <input id="search" placeholder="Find Histogram name" value="{{searchQuery::keyup}}"/>

      <svg id="show_overview" on-click="toggleOverviewLineCharts_" viewBox="0 0 128 128">
        <line x1="19" x2="49" y1="109" y2="49"></line>
        <line x1="49" x2="79" y1="49" y2="79"></line>
        <line x1="79" x2="109" y1="79" y2="19"></line>
      </svg>
      <svg id="hide_overview" on-click="toggleOverviewLineCharts_" viewBox="0 0 128 128">
        <line x1="28" x2="100" y1="28" y2="100"></line>
        <line x1="28" x2="100" y1="100" y2="28"></line>
      </svg>

      <select id="reference_display_label" value="{{referenceDisplayLabel::change}}">
        <option value="">Select a reference column</option>
      </select>

      <button id="alpha" on-click="openAlphaSlider_">α=[[alphaString]]</button>
      <div id="alpha_slider_container">
        <input id="alpha_slider" max="18" min="0" on-blur="closeAlphaSlider_" on-input="updateAlpha_" type="range" value="{{alphaIndex::change}}"/>
      </div>

      <select id="statistic" value="{{displayStatisticName::change}}">
      </select>

      <button id="download_csv" on-click="downloadCSV_">⬇ CSV</button>

      <input checked="{{showAll::change}}" id="show_all" title="When unchecked, less important histograms are hidden." type="checkbox"/>
      <label for="show_all" title="When unchecked, less important histograms are hidden.">Show all</label>

      <a id="help">Help</a>
      <a id="feedback">Feedback</a>
    </div>

    <tr-ui-b-grouping-table-groupby-picker id="picker">
    </tr-ui-b-grouping-table-groupby-picker>
  </template>
</dom-module><dom-module id="tr-v-ui-histogram-set-table-cell">
  <template>
    <style>
    #histogram_container {
      display: flex;
      flex-direction: row;
    }

    #missing, #empty, #unmergeable, #scalar {
      flex-grow: 1;
    }

    #open_histogram, #close_histogram, #open_histogram svg, #close_histogram svg {
      height: 1em;
    }

    #open_histogram svg {
      margin-left: 4px;
      stroke-width: 0;
      stroke: blue;
      fill: blue;
    }
    :host(:hover) #open_histogram svg {
      background: blue;
      stroke: white;
      fill: white;
    }

    #scalar {
      flex-grow: 1;
      white-space: nowrap;
    }

    #histogram {
      flex-grow: 1;
    }

    #close_histogram svg line {
      stroke-width: 18;
      stroke: black;
    }
    #close_histogram:hover svg {
      background: black;
    }
    #close_histogram:hover svg line {
      stroke: white;
    }

    #overview_container {
      display: none;
    }
    </style>

    <div id="histogram_container">
      <span id="missing">(missing)</span>
      <span id="empty">(empty)</span>
      <span id="unmergeable">(unmergeable)</span>

      <tr-v-ui-scalar-span id="scalar" on-click="openHistogram_"></tr-v-ui-scalar-span>

      <span id="open_histogram" on-click="openHistogram_">
        <svg viewBox="0 0 128 128">
          <rect height="16" width="32" x="16" y="24"></rect>
          <rect height="16" width="96" x="16" y="56"></rect>
          <rect height="16" width="64" x="16" y="88"></rect>
        </svg>
      </span>

      <span id="histogram"></span>

      <span id="close_histogram" on-click="closeHistogram_">
        <svg viewBox="0 0 128 128">
          <line x1="28" x2="100" y1="28" y2="100"></line>
          <line x1="28" x2="100" y1="100" y2="28"></line>
        </svg>
      </span>
    </div>

    <div id="overview_container">
    </div>
  </template>
</dom-module><dom-module id="tr-v-ui-histogram-set-table-name-cell">
  <template>
    <style>
    #name_container {
      display: flex;
    }

    #name {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    #show_overview, #hide_overview, #show_overview svg, #hide_overview svg {
      height: 1em;
      margin-left: 5px;
    }

    #show_overview svg {
      stroke: blue;
      stroke-width: 16;
    }

    #show_overview:hover svg {
      background: blue;
      stroke: white;
    }

    #hide_overview {
      display: none;
    }

    #hide_overview svg {
      stroke-width: 18;
      stroke: black;
    }

    #hide_overview:hover svg {
      background: black;
      stroke: white;
    }

    #open_histograms, #close_histograms, #open_histograms svg, #close_histograms svg {
      height: 1em;
    }

    #close_histograms {
      display: none;
    }

    #open_histograms svg {
      margin-left: 4px;
      stroke-width: 0;
      stroke: blue;
      fill: blue;
    }
    #open_histograms:hover svg {
      background: blue;
      stroke: white;
      fill: white;
    }

    #close_histograms line {
      stroke-width: 18;
      stroke: black;
    }
    #close_histograms:hover {
      background: black;
    }
    #close_histograms:hover line {
      stroke: white;
    }

    #overview_container {
      display: none;
    }
    </style>

    <div id="name_container">
      <span id="name"></span>

      <span id="show_overview" on-click="showOverview_">
        <svg viewBox="0 0 128 128">
          <line x1="19" x2="49" y1="109" y2="49"></line>
          <line x1="49" x2="79" y1="49" y2="79"></line>
          <line x1="79" x2="109" y1="79" y2="19"></line>
        </svg>
      </span>

      <span id="hide_overview" on-click="hideOverview_">
        <svg viewBox="0 0 128 128">
          <line x1="28" x2="100" y1="28" y2="100"></line>
          <line x1="28" x2="100" y1="100" y2="28"></line>
        </svg>
      </span>

      <span id="open_histograms" on-click="openHistograms_">
        <svg viewBox="0 0 128 128">
          <rect height="16" width="32" x="16" y="24"></rect>
          <rect height="16" width="96" x="16" y="56"></rect>
          <rect height="16" width="64" x="16" y="88"></rect>
        </svg>
      </span>

      <span id="close_histograms" on-click="closeHistograms_">
        <svg viewBox="0 0 128 128">
          <line x1="28" x2="100" y1="28" y2="100"></line>
          <line x1="28" x2="100" y1="100" y2="28"></line>
        </svg>
      </span>
    </div>

    <div id="overview_container">
    </div>
  </template>
</dom-module><dom-module id="tr-v-ui-histogram-set-table">
  <template>
    <style>
    :host {
      min-height: 0px;
      overflow: auto;
    }
    #table {
      margin-top: 5px;
    }
    </style>

    <tr-ui-b-table id="table">
  </tr-ui-b-table></template>
</dom-module><dom-module id="tr-v-ui-histogram-set-view">
  <template>
    <style>
    :host {
      font-family: sans-serif;
    }

    #zero {
      color: red;
      /* histogram-set-table is used by both metrics-side-panel and results2.html.
       * This font-size rule has no effect in results2.html, but improves
       * legibility in the metrics-side-panel, which sets font-size in order to
       * make this table denser.
       */
      font-size: initial;
    }

    #container {
      display: none;
    }
    </style>

    <div id="zero">zero Histograms</div>

    <div id="container">
      <tr-v-ui-histogram-set-controls id="controls">
      </tr-v-ui-histogram-set-controls>

      <tr-v-ui-histogram-set-table id="table"></tr-v-ui-histogram-set-table>
    </div>
  </template>
</dom-module><dom-module id="tr-ui-sp-metrics-side-panel">
  <template>
    <style>
    :host {
      display: flex;
      flex-direction: column;
    }
    div#error {
      color: red;
    }
    #results {
      font-size: 12px;
    }
    </style>

    <top-left-controls id="top_left_controls"></top-left-controls>

    <tr-v-ui-histogram-set-view id="results"></tr-v-ui-histogram-set-view>

    <div id="error"></div>
  </template>
</dom-module><!--
The lean config is just enough to import uncompressed, trace-event-formatted
json blobs.
--><dom-module id="tr-ui-e-s-alerts-side-panel">
  <template>
    <style>
    :host {
      display: block;
      width: 250px;
    }
    #content {
      flex-direction: column;
      display: flex;
    }
    tr-ui-b-table {
      font-size: 12px;
    }
    </style>

    <div id="content">
      <toolbar id="toolbar"></toolbar>
      <result-area id="result_area"></result-area>
    </div>
  </template>
</dom-module><!-- The full config is all the configs slammed together. --><script>

// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* WARNING: This file is auto generated.
 *
 * Do not edit directly.
 */


'use strict';

/**
 * The global object.
 * @type {!Object}
 * @const
 */
const global = this.window || this.global;

/** Platform, package, object property, and Event support. */
this.tr = (function() {
  if (global.tr) return global.tr;

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * 'a.b.c' -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @private
   */
  function exportPath(name) {
    const parts = name.split('.');
    let cur = global;

    for (let part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  }

  function isExported(name) {
    const parts = name.split('.');
    let cur = global;

    for (let part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        return false;
      }
    }
    return true;
  }

  function isDefined(name) {
    const parts = name.split('.');

    let curObject = global;

    for (let i = 0; i < parts.length; i++) {
      const partName = parts[i];
      const nextObject = curObject[partName];
      if (nextObject === undefined) return false;
      curObject = nextObject;
    }
    return true;
  }

  let panicElement = undefined;
  const rawPanicMessages = [];
  function showPanicElementIfNeeded() {
    if (panicElement) return;

    const panicOverlay = document.createElement('div');
    panicOverlay.style.backgroundColor = 'white';
    panicOverlay.style.border = '3px solid red';
    panicOverlay.style.boxSizing = 'border-box';
    panicOverlay.style.color = 'black';
    panicOverlay.style.display = 'flex';
    panicOverlay.style.height = '100%';
    panicOverlay.style.left = 0;
    panicOverlay.style.padding = '8px';
    panicOverlay.style.position = 'fixed';
    panicOverlay.style.top = 0;
    panicOverlay.style.webkitFlexDirection = 'column';
    panicOverlay.style.width = '100%';

    panicElement = document.createElement('div');
    panicElement.style.webkitFlex = '1 1 auto';
    panicElement.style.overflow = 'auto';
    panicOverlay.appendChild(panicElement);

    if (!document.body) {
      setTimeout(function() {
        document.body.appendChild(panicOverlay);
      }, 150);
    } else {
      document.body.appendChild(panicOverlay);
    }
  }

  function showPanic(panicTitle, panicDetails) {
    if (tr.isHeadless) {
      if (panicDetails instanceof Error) throw panicDetails;
      throw new Error('Panic: ' + panicTitle + ':\n' + panicDetails);
    }

    if (panicDetails instanceof Error) {
      panicDetails = panicDetails.stack;
    }

    showPanicElementIfNeeded();
    const panicMessageEl = document.createElement('div');
    panicMessageEl.innerHTML =
        '<h2 id="message"></h2>' +
        '<pre id="details"></pre>';
    panicMessageEl.querySelector('#message').textContent = panicTitle;
    panicMessageEl.querySelector('#details').textContent = panicDetails;
    panicElement.appendChild(panicMessageEl);

    rawPanicMessages.push({
      title: panicTitle,
      details: panicDetails
    });
  }

  function hasPanic() {
    return rawPanicMessages.length !== 0;
  }
  function getPanicText() {
    return rawPanicMessages.map(function(msg) {
      return msg.title;
    }).join(', ');
  }

  function exportTo(namespace, fn) {
    const obj = exportPath(namespace);
    const exports = fn();

    for (const propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      const propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
          propertyName);
      if (propertyDescriptor) {
        Object.defineProperty(obj, propertyName, propertyDescriptor);
      }
    }
  }

  /**
   * Initialization which must be deferred until run-time.
   */
  function initialize() {
    if (global.isVinn) {
      tr.isVinn = true;
    } else if (global.process && global.process.versions.node) {
      tr.isNode = true;
    } else {
      tr.isVinn = false;
      tr.isNode = false;
      tr.doc = document;

      tr.isMac = /Mac/.test(navigator.platform);
      tr.isWindows = /Win/.test(navigator.platform);
      tr.isChromeOS = /CrOS/.test(navigator.userAgent);
      tr.isLinux = /Linux/.test(navigator.userAgent);
    }
    tr.isHeadless = tr.isVinn || tr.isNode;
  }

  return {
    initialize,

    exportTo,
    isExported,
    isDefined,

    showPanic,
    hasPanic,
    getPanicText,
  };
})();

tr.initialize();


'use strict';

tr.exportTo('tr.b', function() {
  function Base64() {
  }

  function b64ToUint6(nChr) {
    if (nChr > 64 && nChr < 91) return nChr - 65;
    if (nChr > 96 && nChr < 123) return nChr - 71;
    if (nChr > 47 && nChr < 58) return nChr + 4;
    if (nChr === 43) return 62;
    if (nChr === 47) return 63;
    return 0;
  }

  Base64.getDecodedBufferLength = function(input) {
    return input.length * 3 + 1 >> 2;
  };

  Base64.EncodeArrayBufferToString = function(input) {
    // http://stackoverflow.com/questions/9267899/
    let binary = '';
    const bytes = new Uint8Array(input);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };

  Base64.DecodeToTypedArray = function(input, output) {
    const nInLen = input.length;
    const nOutLen = nInLen * 3 + 1 >> 2;
    let nMod3 = 0;
    let nMod4 = 0;
    let nUint24 = 0;
    let nOutIdx = 0;

    if (nOutLen > output.byteLength) {
      throw new Error('Output buffer too small to decode.');
    }

    for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
      nMod4 = nInIdx & 3;
      nUint24 |= b64ToUint6(input.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
      if (nMod4 === 3 || nInLen - nInIdx === 1) {
        for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
          output.setUint8(nOutIdx, nUint24 >>> (16 >>> nMod3 & 24) & 255);
        }
        nUint24 = 0;
      }
    }
    return nOutIdx - 1;
  };

  /*
   * Wrapper of btoa
   * The reason is that window object has a builtin btoa,
   * but we also want to use btoa when it is headless.
   * For example we want to use it in a mapper
   */
  Base64.btoa = function(input) {
    return btoa(input);
  };

  /*
   * Wrapper of atob
   * The reason is that window object has a builtin atob,
   * but we also want to use atob when it is headless.
   * For example we want to use it in a mapper
   */
  Base64.atob = function(input) {
    return atob(input);
  };

  return {
    Base64,
  };
});


'use strict';

// Force Polymer into native shadowDom mode
if (window.Polymer) {
  throw new Error('Cannot proceed. Polymer already present.');
}
window.Polymer = {};
window.Polymer.dom = 'shadow';

(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());window.Polymer = {
Settings: function () {
var settings = window.Polymer || {};
if (!settings.noUrlSettings) {
var parts = location.search.slice(1).split('&');
for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
o = o.split('=');
o[0] && (settings[o[0]] = o[1] || true);
}
}
settings.wantShadow = settings.dom === 'shadow';
settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
settings.useShadow = settings.wantShadow && settings.hasShadow;
settings.hasNativeImports = Boolean('import' in document.createElement('link'));
settings.useNativeImports = settings.hasNativeImports;
settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
settings.hasNativeCSSProperties = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');
settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
settings.isIE = navigator.userAgent.match('Trident');
return settings;
}()
};(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
prototype = desugar(prototype);
var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
var ctor = document.registerElement(prototype.is, options);
return customCtor || ctor;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype;
};
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = function (prototype) {
if (!prototype.factoryImpl) {
prototype.factoryImpl = function () {
};
}
return desugar(prototype).constructor;
};
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript || {}).ownerDocument;
}
});Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
for (var i = 0; i < this._callbacks.length; i++) {
this._callbacks[i]();
}
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
},
_afterNextRenderQueue: [],
_waitingNextRender: false,
afterNextRender: function (element, fn, args) {
this._watchNextRender();
this._afterNextRenderQueue.push([
element,
fn,
args
]);
},
hasRendered: function () {
return this._ready;
},
_watchNextRender: function () {
if (!this._waitingNextRender) {
this._waitingNextRender = true;
var fn = function () {
Polymer.RenderStatus._flushNextRender();
};
if (!this._ready) {
this.whenReady(fn);
} else {
requestAnimationFrame(fn);
}
}
},
_flushNextRender: function () {
var self = this;
setTimeout(function () {
self._flushRenderCallbacks(self._afterNextRenderQueue);
self._afterNextRenderQueue = [];
self._waitingNextRender = false;
});
},
_flushRenderCallbacks: function (callbacks) {
for (var i = 0, h; i < callbacks.length; i++) {
h = callbacks[i];
h[1].apply(h[0], h[2] || Polymer.nar);
}
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;(function () {
'use strict';
var settings = Polymer.Settings;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.mixin(this, feature);
},
registerCallback: function () {
if (settings.lazyRegister === 'max') {
if (this.beforeRegister) {
this.beforeRegister();
}
} else {
this._desugarBehaviors();
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(this);
}
}
if (this.beforeRegister) {
this.beforeRegister();
}
}
this._registerFeatures();
if (!settings.lazyRegister) {
this.ensureRegisterFinished();
}
},
createdCallback: function () {
if (settings.disableUpgradeEnabled) {
if (this.hasAttribute('disable-upgrade')) {
this._propertySetter = disableUpgradePropertySetter;
this._configValue = null;
this.__data__ = {};
return;
} else {
this.__hasInitialized = true;
}
}
this.__initialize();
},
__initialize: function () {
if (!this.__hasRegisterFinished) {
this._ensureRegisterFinished(this.__proto__);
}
Polymer.telemetry.instanceCount++;
this.root = this;
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.created) {
b.created.call(this);
}
}
if (this.created) {
this.created();
}
this._initFeatures();
},
ensureRegisterFinished: function () {
this._ensureRegisterFinished(this);
},
_ensureRegisterFinished: function (proto) {
if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
if (settings.lazyRegister === 'max') {
proto._desugarBehaviors();
for (var i = 0, b; i < proto.behaviors.length; i++) {
b = proto.behaviors[i];
if (b.beforeRegister) {
b.beforeRegister.call(proto);
}
}
}
proto.__hasRegisterFinished = proto.is;
if (proto._finishRegisterFeatures) {
proto._finishRegisterFeatures();
}
for (var j = 0, pb; j < proto.behaviors.length; j++) {
pb = proto.behaviors[j];
if (pb.registered) {
pb.registered.call(proto);
}
}
if (proto.registered) {
proto.registered();
}
if (settings.usePolyfillProto && proto !== this) {
proto.extend(this, proto);
}
}
},
attachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = true;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.attached) {
b.attached.call(self);
}
}
if (self.attached) {
self.attached();
}
});
},
detachedCallback: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
self.isAttached = false;
for (var i = 0, b; i < self.behaviors.length; i++) {
b = self.behaviors[i];
if (b.detached) {
b.detached.call(self);
}
}
if (self.detached) {
self.detached();
}
});
},
attributeChangedCallback: function (name, oldValue, newValue) {
this._attributeChangedImpl(name);
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.attributeChanged) {
b.attributeChanged.call(this, name, oldValue, newValue);
}
}
if (this.attributeChanged) {
this.attributeChanged(name, oldValue, newValue);
}
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (target, source) {
if (target && source) {
var n$ = Object.getOwnPropertyNames(source);
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
this.copyOwnProperty(n, source, target);
}
}
return target || source;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_logger: function (level, args) {
if (args.length === 1 && Array.isArray(args[0])) {
args = args[0];
}
switch (level) {
case 'log':
case 'warn':
case 'error':
console[level].apply(console, args);
break;
}
},
_log: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('log', args);
},
_warn: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('warn', args);
},
_error: function () {
var args = Array.prototype.slice.call(arguments, 0);
this._logger('error', args);
},
_logf: function () {
return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.BaseDescriptors = {};
var disableUpgradePropertySetter;
if (settings.disableUpgradeEnabled) {
disableUpgradePropertySetter = function (property, value) {
this.__data__[property] = value;
};
var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
Polymer.Base.attributeChangedCallback = function (name, oldValue, newValue) {
if (!this.__hasInitialized && name === 'disable-upgrade') {
this.__hasInitialized = true;
this._propertySetter = Polymer.Bind._modelApi._propertySetter;
this._configValue = Polymer.Base._configValue;
this.__initialize();
}
origAttributeChangedCallback.call(this, name, oldValue, newValue);
};
}
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
}());(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.mixin(DomModule.prototype, {
createdCallback: function () {
this.register();
},
register: function (id) {
id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDomModulesUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
Object.defineProperty(DomModule.prototype, 'constructor', {
value: DomModule,
configurable: true,
writable: true
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDomModulesUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument || document;
var modules = doc.querySelectorAll('dom-module');
for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--) {
if (m.__upgraded__) {
return;
} else {
CustomElements.upgrade(m);
}
}
}
}
}());Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
var behaviorSet = [];
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
var b = behaviors[i];
if (behaviorSet.indexOf(b) === -1) {
this._mixinBehavior(b);
behaviorSet.unshift(b);
}
}
return behaviorSet;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
for (var i = 0; i < behaviors.length; i++) {
var b = behaviors[i];
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}
return flat;
},
_mixinBehavior: function (b) {
var n$ = Object.getOwnPropertyNames(b);
var useAssignment = b._noAccessors;
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
if (useAssignment) {
this[n] = b[n];
} else {
this.copyOwnProperty(n, b, this);
}
}
}
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_marshalBehaviors: function () {
for (var i = 0; i < this.behaviors.length; i++) {
this._marshalBehavior(this.behaviors[i]);
}
this._marshalBehavior(this);
}
});
Polymer.Base._behaviorProperties = {
hostAttributes: true,
beforeRegister: true,
registered: true,
properties: true,
observers: true,
listeners: true,
created: true,
attached: true,
detached: true,
attributeChanged: true,
ready: true,
_noAccessors: true
};Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
p = Object.create(this.getNativePrototype(tag));
var p$ = Object.getOwnPropertyNames(Polymer.Base);
for (var i = 0, n; i < p$.length && (n = p$[i]); i++) {
if (!Polymer.BaseDescriptors[n]) {
p[n] = Polymer.Base[n];
}
}
Object.defineProperties(p, Polymer.BaseDescriptors);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
for (var i = 0; i < this.behaviors.length; i++) {
info = this._getPropertyInfo(property, this.behaviors[i].properties);
if (info) {
return info;
}
}
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
},
_prepPropertyInfo: function () {
this._propertyInfo = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
}
this._addPropertyInfo(this._propertyInfo, this.properties);
this._addPropertyInfo(this._propertyInfo, this._propertyEffects);
},
_addPropertyInfo: function (target, source) {
if (source) {
var t, s;
for (var i in source) {
t = target[i];
s = source[i];
if (i[0] === '_' && !s.readOnly) {
continue;
}
if (!target[i]) {
target[i] = {
type: typeof s === 'function' ? s : s.type,
readOnly: s.readOnly,
attribute: Polymer.CaseMap.camelToDashCase(i)
};
} else {
if (!t.type) {
t.type = s.type;
}
if (!t.readOnly) {
t.readOnly = s.readOnly;
}
}
}
}
}
});
(function () {
var propertiesDesc = {
configurable: true,
writable: true,
enumerable: true,
value: {}
};
Polymer.BaseDescriptors.properties = propertiesDesc;
Object.defineProperty(Polymer.Base, 'properties', propertiesDesc);
}());Polymer.CaseMap = {
_caseMap: {},
_rx: {
dashToCamel: /-[a-z]/g,
camelToDash: /([A-Z])/g
},
dashToCamelCase: function (dash) {
return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel, function (m) {
return m[1].toUpperCase();
}));
},
camelToDashCase: function (camel) {
return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase());
}
};Polymer.Base._addFeature({
_addHostAttributes: function (attributes) {
if (!this._aggregatedAttributes) {
this._aggregatedAttributes = {};
}
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
if (this._aggregatedAttributes) {
this._applyAttributes(this, this._aggregatedAttributes);
}
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
var v = attr$[n];
this.serializeValueToAttribute(v, n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
if (this.hasAttributes()) {
for (var i in this._propertyInfo) {
var info = this._propertyInfo[i];
if (this.hasAttribute(info.attribute)) {
this._setAttributeToProperty(model, info.attribute, i, info);
}
}
}
},
_setAttributeToProperty: function (model, attribute, property, info) {
if (!this._serializing) {
property = property || Polymer.CaseMap.dashToCamelCase(attribute);
info = info || this._propertyInfo && this._propertyInfo[property];
if (info && !info.readOnly) {
var v = this.getAttribute(attribute);
model[property] = this.deserialize(v, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (property, attribute, value) {
this._serializing = true;
value = value === undefined ? this[property] : value;
this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
node = node || this;
if (str === undefined) {
node.removeAttribute(attribute);
} else {
node.setAttribute(attribute, str);
}
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value != null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value.toString();
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});Polymer.version = "1.9.3";Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._marshalBehaviors();
}
});
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && ABS_URL.test(url)) {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement('a'));
}
function pathFromUrl(url) {
return url.substring(0, url.lastIndexOf('/') + 1);
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl,
pathFromUrl: pathFromUrl
};
Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href);
}());Polymer.Base._addFeature({
_prepTemplate: function () {
var module;
if (this._template === undefined) {
module = Polymer.DomModule.import(this.is);
this._template = module && module.querySelector('template');
}
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL);
} else {
this._importPath = '';
}
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
HTMLTemplateElement.decorate(this._template);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
var baseDetachedCallback = Polymer.Base.detachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_registerHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._clients = null;
this._clientsReadied = false;
},
_beginHosting: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_endHosting: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
this._readied = false;
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
if (this._template) {
this._setupRoot();
this._readyClients();
}
this._clientsReadied = true;
this._clients = null;
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
if (c$) {
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
}
this._finishDistribute();
},
_readySelf: function () {
for (var i = 0, b; i < this.behaviors.length; i++) {
b = this.behaviors[i];
if (b.ready) {
b.ready.call(this);
}
}
if (this.ready) {
this.ready();
}
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
},
detachedCallback: function () {
if (this._readied) {
baseDetachedCallback.call(this);
} else {
this._attachedPending = false;
}
}
});
}());Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (i = 1; i < rowCount; i++) {
for (j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();(function () {
'use strict';
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeAppendChild = Element.prototype.appendChild;
var nativeRemoveChild = Element.prototype.removeChild;
Polymer.TreeApi = {
arrayCopyChildNodes: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstChild; n; n = n.nextSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopyChildren: function (parent) {
var copy = [], i = 0;
for (var n = parent.firstElementChild; n; n = n.nextElementSibling) {
copy[i++] = n;
}
return copy;
},
arrayCopy: function (a$) {
var l = a$.length;
var copy = new Array(l);
for (var i = 0; i < l; i++) {
copy[i] = a$[i];
}
return copy;
}
};
Polymer.TreeApi.Logical = {
hasParentNode: function (node) {
return Boolean(node.__dom && node.__dom.parentNode);
},
hasChildNodes: function (node) {
return Boolean(node.__dom && node.__dom.childNodes !== undefined);
},
getChildNodes: function (node) {
return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;
},
_getChildNodes: function (node) {
if (!node.__dom.childNodes) {
node.__dom.childNodes = [];
for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
node.__dom.childNodes.push(n);
}
}
return node.__dom.childNodes;
},
getParentNode: function (node) {
return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;
},
getFirstChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;
},
getLastChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;
},
getNextSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;
},
getPreviousSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;
},
getFirstElementChild: function (node) {
return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;
},
_getFirstElementChild: function (node) {
var n = node.__dom.firstChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getLastElementChild: function (node) {
return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;
},
_getLastElementChild: function (node) {
var n = node.__dom.lastChild;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
getNextElementSibling: function (node) {
return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;
},
_getNextElementSibling: function (node) {
var n = node.__dom.nextSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.nextSibling;
}
return n;
},
getPreviousElementSibling: function (node) {
return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;
},
_getPreviousElementSibling: function (node) {
var n = node.__dom.previousSibling;
while (n && n.nodeType !== Node.ELEMENT_NODE) {
n = n.__dom.previousSibling;
}
return n;
},
saveChildNodes: function (node) {
if (!this.hasChildNodes(node)) {
node.__dom = node.__dom || {};
node.__dom.firstChild = node.firstChild;
node.__dom.lastChild = node.lastChild;
node.__dom.childNodes = [];
for (var n = node.firstChild; n; n = n.nextSibling) {
n.__dom = n.__dom || {};
n.__dom.parentNode = node;
node.__dom.childNodes.push(n);
n.__dom.nextSibling = n.nextSibling;
n.__dom.previousSibling = n.previousSibling;
}
}
},
recordInsertBefore: function (node, container, ref_node) {
container.__dom.childNodes = null;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
for (var n = node.firstChild; n; n = n.nextSibling) {
this._linkNode(n, container, ref_node);
}
} else {
this._linkNode(node, container, ref_node);
}
},
_linkNode: function (node, container, ref_node) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (ref_node) {
ref_node.__dom = ref_node.__dom || {};
}
node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
if (node.__dom.previousSibling) {
node.__dom.previousSibling.__dom.nextSibling = node;
}
node.__dom.nextSibling = ref_node || null;
if (node.__dom.nextSibling) {
node.__dom.nextSibling.__dom.previousSibling = node;
}
node.__dom.parentNode = container;
if (ref_node) {
if (ref_node === container.__dom.firstChild) {
container.__dom.firstChild = node;
}
} else {
container.__dom.lastChild = node;
if (!container.__dom.firstChild) {
container.__dom.firstChild = node;
}
}
container.__dom.childNodes = null;
},
recordRemoveChild: function (node, container) {
node.__dom = node.__dom || {};
container.__dom = container.__dom || {};
if (node === container.__dom.firstChild) {
container.__dom.firstChild = node.__dom.nextSibling;
}
if (node === container.__dom.lastChild) {
container.__dom.lastChild = node.__dom.previousSibling;
}
var p = node.__dom.previousSibling;
var n = node.__dom.nextSibling;
if (p) {
p.__dom.nextSibling = n;
}
if (n) {
n.__dom.previousSibling = p;
}
node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
container.__dom.childNodes = null;
}
};
Polymer.TreeApi.Composed = {
getChildNodes: function (node) {
return Polymer.TreeApi.arrayCopyChildNodes(node);
},
getParentNode: function (node) {
return node.parentNode;
},
clearChildNodes: function (node) {
node.textContent = '';
},
insertBefore: function (parentNode, newChild, refChild) {
return nativeInsertBefore.call(parentNode, newChild, refChild || null);
},
appendChild: function (parentNode, newChild) {
return nativeAppendChild.call(parentNode, newChild);
},
removeChild: function (parentNode, node) {
return nativeRemoveChild.call(parentNode, node);
}
};
}());Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = function (node) {
this.node = needsToWrap ? DomApi.wrap(node) : node;
};
var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
DomApi.wrap = window.wrap ? window.wrap : function (node) {
return node;
};
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
deepContains: function (node) {
if (this.node.contains(node)) {
return true;
}
var n = node;
var doc = node.ownerDocument;
while (n && n !== doc && n !== this.node) {
n = Polymer.dom(n).parentNode || n.host;
}
return n === this.node;
},
queryDistributedElements: function (selector) {
var c$ = this.getEffectiveChildNodes();
var list = [];
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
list.push(c);
}
}
return list;
},
getEffectiveChildNodes: function () {
var list = [];
var c$ = this.childNodes;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
var d$ = dom(c).getDistributedNodes();
for (var j = 0; j < d$.length; j++) {
list.push(d$[j]);
}
} else {
list.push(c);
}
}
return list;
},
observeNodes: function (callback) {
if (callback) {
if (!this.observer) {
this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
}
return this.observer.addListener(callback);
}
},
unobserveNodes: function (handle) {
if (this.observer) {
this.observer.removeListener(handle);
}
},
notifyObserver: function () {
if (this.observer) {
this.observer.notify();
}
},
_query: function (matcher, node, halter) {
node = node || this.node;
var list = [];
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
return list;
},
_queryElements: function (elements, matcher, halter, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
if (this._queryElement(c, matcher, halter, list)) {
return true;
}
}
}
},
_queryElement: function (node, matcher, halter, list) {
var result = matcher(node);
if (result) {
list.push(node);
}
if (halter && halter(result)) {
return result;
}
this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
}
};
var CONTENT = DomApi.CONTENT = 'content';
var dom = DomApi.factory = function (node) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi.ctor(node);
}
return node.__domApi;
};
DomApi.hasApi = function (node) {
return Boolean(node.__domApi);
};
DomApi.ctor = DomApi;
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return DomApi.factory(obj, patch);
}
};
var p = Element.prototype;
DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return DomApi;
}();(function () {
'use strict';
var Settings = Polymer.Settings;
var DomApi = Polymer.DomApi;
var dom = DomApi.factory;
var TreeApi = Polymer.TreeApi;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var CONTENT = DomApi.CONTENT;
if (Settings.useShadow) {
return;
}
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
Polymer.Base.mixin(DomApi.prototype, {
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this.insertBefore(node);
},
insertBefore: function (node, ref_node) {
if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
if (DomApi.hasApi(parent)) {
dom(parent).notifyObserver();
}
this._removeNode(node);
} else {
this._removeOwnerShadyRoot(node);
}
}
if (!this._addNode(node, ref_node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (ref_node) {
TreeApi.Composed.insertBefore(container, node, ref_node);
} else {
TreeApi.Composed.appendChild(container, node);
}
}
this.notifyObserver();
return node;
},
_addNode: function (node, ref_node) {
var root = this.getOwnerRoot();
if (root) {
var ipAdded = this._maybeAddInsertionPoint(node, this.node);
if (!root._invalidInsertionPoints) {
root._invalidInsertionPoints = ipAdded;
}
this._addNodeToHost(root.host, node);
}
if (TreeApi.Logical.hasChildNodes(this.node)) {
TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
}
var handled = this._maybeDistribute(node) || this.node.shadyRoot;
if (handled) {
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
while (node.firstChild) {
TreeApi.Composed.removeChild(node, node.firstChild);
}
} else {
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
return handled;
},
removeChild: function (node) {
if (TreeApi.Logical.getParentNode(node) !== this.node) {
throw Error('The node to be removed is not a child of this node: ' + node);
}
if (!this._removeNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
var parent = TreeApi.Composed.getParentNode(node);
if (container === parent) {
TreeApi.Composed.removeChild(container, node);
}
}
this.notifyObserver();
return node;
},
_removeNode: function (node) {
var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
var distributed;
var root = this._ownerShadyRootForNode(node);
if (logicalParent) {
distributed = dom(node)._maybeDistributeParent();
TreeApi.Logical.recordRemoveChild(node, logicalParent);
if (root && this._removeDistributedChildren(root, node)) {
root._invalidInsertionPoints = true;
this._lazyDistribute(root.host);
}
}
this._removeOwnerShadyRoot(node);
if (root) {
this._removeNodeFromHost(root.host, node);
}
return distributed;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
var root = node._ownerShadyRoot;
if (root === undefined) {
if (node._isShadyRoot) {
root = node;
} else {
var parent = TreeApi.Logical.getParentNode(node);
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
if (root || document.documentElement.contains(node)) {
node._ownerShadyRoot = root;
}
}
return root;
},
_maybeDistribute: function (node) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this.getOwnerRoot();
if (root) {
this._lazyDistribute(root.host);
}
}
var needsDist = this._nodeNeedsDistribution(this.node);
if (needsDist) {
this._lazyDistribute(this.node);
}
return needsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = dom(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = TreeApi.Logical.getParentNode(n);
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
TreeApi.Logical.saveChildNodes(parent);
TreeApi.Logical.saveChildNodes(node);
added = true;
}
return added;
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));
}
},
_nodeNeedsDistribution: function (node) {
return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);
},
_addNodeToHost: function (host, node) {
if (host._elementAdd) {
host._elementAdd(node);
}
},
_removeNodeFromHost: function (host, node) {
if (host._elementRemove) {
host._elementRemove(node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = dom(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = TreeApi.Composed.getParentNode(node);
if (parent) {
TreeApi.Composed.removeChild(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = TreeApi.Logical.getParentNode(node);
}
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = TreeApi.Logical.getChildNodes(node);
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = dom(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = dom(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
var result = this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node, function (n) {
return Boolean(n);
})[0];
return result || null;
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return DomApi.matchesSelector.call(n, selector);
}, this.node);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._maybeDistributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._maybeDistributeParent();
},
_maybeDistributeParent: function () {
if (this._nodeNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
return true;
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = TreeApi.Logical.getChildNodes(externalNode);
var d = dom(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = dom(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
},
_getComposedInnerHTML: function () {
return getInnerHTML(this.node, true);
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var active = document.activeElement;
if (!active) {
return null;
}
var isShadyRoot = !!this.node._isShadyRoot;
if (this.node !== document) {
if (!isShadyRoot) {
return null;
}
if (this.node.host === active || !this.node.host.contains(active)) {
return null;
}
}
var activeRoot = dom(active).getOwnerRoot();
while (activeRoot && activeRoot !== this.node) {
active = activeRoot.host;
activeRoot = dom(active).getOwnerRoot();
}
if (this.node === document) {
return activeRoot ? null : active;
} else {
return activeRoot === this.node ? active : null;
}
},
configurable: true
},
childNodes: {
get: function () {
var c$ = TreeApi.Logical.getChildNodes(this.node);
return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
if (TreeApi.Logical.hasChildNodes(this.node)) {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
} else {
return TreeApi.arrayCopyChildren(this.node);
}
},
configurable: true
},
parentNode: {
get: function () {
return TreeApi.Logical.getParentNode(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return TreeApi.Logical.getFirstChild(this.node);
},
configurable: true
},
lastChild: {
get: function () {
return TreeApi.Logical.getLastChild(this.node);
},
configurable: true
},
nextSibling: {
get: function () {
return TreeApi.Logical.getNextSibling(this.node);
},
configurable: true
},
previousSibling: {
get: function () {
return TreeApi.Logical.getPreviousSibling(this.node);
},
configurable: true
},
firstElementChild: {
get: function () {
return TreeApi.Logical.getFirstElementChild(this.node);
},
configurable: true
},
lastElementChild: {
get: function () {
return TreeApi.Logical.getLastElementChild(this.node);
},
configurable: true
},
nextElementSibling: {
get: function () {
return TreeApi.Logical.getNextElementSibling(this.node);
},
configurable: true
},
previousElementSibling: {
get: function () {
return TreeApi.Logical.getPreviousElementSibling(this.node);
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = TreeApi.arrayCopyChildNodes(d);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.hasInsertionPoint = function (root) {
return Boolean(root && root._insertionPoints.length);
};
}());(function () {
'use strict';
var Settings = Polymer.Settings;
var TreeApi = Polymer.TreeApi;
var DomApi = Polymer.DomApi;
if (!Settings.useShadow) {
return;
}
Polymer.Base.mixin(DomApi.prototype, {
querySelectorAll: function (selector) {
return TreeApi.arrayCopy(this.node.querySelectorAll(selector));
},
getOwnerRoot: function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
},
getDestinationInsertionPoints: function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? TreeApi.arrayCopy(n$) : [];
},
getDistributedNodes: function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? TreeApi.arrayCopy(n$) : [];
}
});
Object.defineProperties(DomApi.prototype, {
activeElement: {
get: function () {
var node = DomApi.wrap(this.node);
var activeElement = node.activeElement;
return node.contains(activeElement) ? activeElement : null;
},
configurable: true
},
childNodes: {
get: function () {
return TreeApi.arrayCopyChildNodes(this.node);
},
configurable: true
},
children: {
get: function () {
return TreeApi.arrayCopyChildren(this.node);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardMethods = function (m$) {
for (var i = 0; i < m$.length; i++) {
forwardMethod(m$[i]);
}
};
var forwardMethod = function (method) {
DomApi.prototype[method] = function () {
return this.node[method].apply(this.node, arguments);
};
};
forwardMethods([
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild',
'setAttribute',
'removeAttribute',
'querySelector'
]);
var forwardProperties = function (f$) {
for (var i = 0; i < f$.length; i++) {
forwardProperty(f$[i]);
}
};
var forwardProperty = function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
};
forwardProperties([
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
]);
}());Polymer.Base.mixin(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_staticFlushList: [],
_finishDebouncer: null,
flush: function () {
this._flushGuard = 0;
this._prepareFlush();
while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
while (this._debouncers.length) {
this._debouncers.shift().complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._prepareFlush();
this._flushGuard++;
}
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
},
_prepareFlush: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
for (var i = 0; i < this._staticFlushList.length; i++) {
this._staticFlushList[i]();
}
},
addStaticFlush: function (fn) {
this._staticFlushList.push(fn);
},
removeStaticFlush: function (fn) {
var i = this._staticFlushList.indexOf(fn);
if (i >= 0) {
this._staticFlushList.splice(i, 1);
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});Polymer.EventApi = function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.Event = function (event) {
this.event = event;
};
if (Settings.useShadow) {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
var path = this.event.path;
if (!Array.isArray(path)) {
path = Array.prototype.slice.call(path);
}
return path;
}
};
} else {
DomApi.Event.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var current = this.rootTarget;
while (current) {
path.push(current);
var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
if (insertionPoints.length) {
for (var i = 0; i < insertionPoints.length - 1; i++) {
path.push(insertionPoints[i]);
}
current = insertionPoints[insertionPoints.length - 1];
} else {
current = Polymer.dom(current).parentNode || current.host;
}
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new DomApi.Event(event);
}
return event.__eventApi;
};
return { factory: factory };
}();(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var useShadow = Polymer.Settings.useShadow;
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this._distributeParent();
},
_distributeParent: function () {
if (!useShadow) {
this.domApi._maybeDistributeParent();
}
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.EffectiveNodesObserver = function (domApi) {
this.domApi = domApi;
this.node = this.domApi.node;
this._listeners = [];
};
DomApi.EffectiveNodesObserver.prototype = {
addListener: function (callback) {
if (!this._isSetup) {
this._setup();
this._isSetup = true;
}
var listener = {
fn: callback,
_nodes: []
};
this._listeners.push(listener);
this._scheduleNotify();
return listener;
},
removeListener: function (handle) {
var i = this._listeners.indexOf(handle);
if (i >= 0) {
this._listeners.splice(i, 1);
handle._nodes = [];
}
if (!this._hasListeners()) {
this._cleanup();
this._isSetup = false;
}
},
_setup: function () {
this._observeContentElements(this.domApi.childNodes);
},
_cleanup: function () {
this._unobserveContentElements(this.domApi.childNodes);
},
_hasListeners: function () {
return Boolean(this._listeners.length);
},
_scheduleNotify: function () {
if (this._debouncer) {
this._debouncer.stop();
}
this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
this._debouncer.context = this;
Polymer.dom.addDebouncer(this._debouncer);
},
notify: function () {
if (this._hasListeners()) {
this._scheduleNotify();
}
},
_notify: function () {
this._beforeCallListeners();
this._callListeners();
},
_beforeCallListeners: function () {
this._updateContentElements();
},
_updateContentElements: function () {
this._observeContentElements(this.domApi.childNodes);
},
_observeContentElements: function (elements) {
for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
if (!n.__observeNodesMap.has(this)) {
n.__observeNodesMap.set(this, this._observeContent(n));
}
}
}
},
_observeContent: function (content) {
var self = this;
var h = Polymer.dom(content).observeNodes(function () {
self._scheduleNotify();
});
h._avoidChangeCalculation = true;
return h;
},
_unobserveContentElements: function (elements) {
for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
if (this._isContent(n)) {
h = n.__observeNodesMap.get(this);
if (h) {
Polymer.dom(n).unobserveNodes(h);
n.__observeNodesMap.delete(this);
}
}
}
},
_isContent: function (node) {
return node.localName === 'content';
},
_callListeners: function () {
var o$ = this._listeners;
var nodes = this._getEffectiveNodes();
for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
var info = this._generateListenerInfo(o, nodes);
if (info || o._alwaysNotify) {
this._callListener(o, info);
}
}
},
_getEffectiveNodes: function () {
return this.domApi.getEffectiveChildNodes();
},
_generateListenerInfo: function (listener, newNodes) {
if (listener._avoidChangeCalculation) {
return true;
}
var oldNodes = listener._nodes;
var info = {
target: this.node,
addedNodes: [],
removedNodes: []
};
var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
info.removedNodes.push(n);
}
}
for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (j = s.index; j < s.index + s.addedCount; j++) {
info.addedNodes.push(newNodes[j]);
}
}
listener._nodes = newNodes;
if (info.addedNodes.length || info.removedNodes.length) {
return info;
}
},
_callListener: function (listener, info) {
return listener.fn.call(this.node, info);
},
enableShadowAttributeTracking: function () {
}
};
if (Settings.useShadow) {
var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var self = this;
this._mutationHandler = function (mxns) {
if (mxns && mxns.length) {
self._scheduleNotify();
}
};
this._observer = new MutationObserver(this._mutationHandler);
this._boundFlush = function () {
self._flush();
};
Polymer.dom.addStaticFlush(this._boundFlush);
this._observer.observe(this.node, { childList: true });
}
baseSetup.call(this);
},
_cleanup: function () {
this._observer.disconnect();
this._observer = null;
this._mutationHandler = null;
Polymer.dom.removeStaticFlush(this._boundFlush);
baseCleanup.call(this);
},
_flush: function () {
if (this._observer) {
this._mutationHandler(this._observer.takeRecords());
}
},
enableShadowAttributeTracking: function () {
if (this._observer) {
this._makeContentListenersAlwaysNotify();
this._observer.disconnect();
this._observer.observe(this.node, {
childList: true,
attributes: true,
subtree: true
});
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host && Polymer.dom(host).observer) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
},
_makeContentListenersAlwaysNotify: function () {
for (var i = 0, h; i < this._listeners.length; i++) {
h = this._listeners[i];
h._alwaysNotify = h._isContentListener;
}
}
});
}
}());(function () {
'use strict';
var DomApi = Polymer.DomApi.ctor;
var Settings = Polymer.Settings;
DomApi.DistributedNodesObserver = function (domApi) {
DomApi.EffectiveNodesObserver.call(this, domApi);
};
DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
},
_cleanup: function () {
},
_beforeCallListeners: function () {
},
_getEffectiveNodes: function () {
return this.domApi.getDistributedNodes();
}
});
if (Settings.useShadow) {
Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
_setup: function () {
if (!this._observer) {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
var self = this;
this._observer = Polymer.dom(host).observeNodes(function () {
self._scheduleNotify();
});
this._observer._isContentListener = true;
if (this._hasAttrSelect()) {
Polymer.dom(host).observer.enableShadowAttributeTracking();
}
}
}
},
_hasAttrSelect: function () {
var select = this.node.getAttribute('select');
return select && select.match(/[[.]+/);
},
_cleanup: function () {
var root = this.domApi.getOwnerRoot();
var host = root && root.host;
if (host) {
Polymer.dom(host).unobserveNodes(this._observer);
}
this._observer = null;
}
});
}
}());(function () {
var DomApi = Polymer.DomApi;
var TreeApi = Polymer.TreeApi;
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_setupShady: function () {
this.shadyRoot = null;
if (!this.__domApi) {
this.__domApi = null;
}
if (!this.__dom) {
this.__dom = null;
}
if (!this._ownerShadyRoot) {
this._ownerShadyRoot = undefined;
}
},
_poolContent: function () {
if (this._useContent) {
TreeApi.Logical.saveChildNodes(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._hasDistributed = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
TreeApi.Logical.saveChildNodes(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
TreeApi.Logical.saveChildNodes(c);
TreeApi.Logical.saveChildNodes(c.parentNode);
}
this.shadyRoot.host = this;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
if (this.shadyRoot._invalidInsertionPoints) {
Polymer.dom(this)._updateInsertionPoints(this);
this.shadyRoot._invalidInsertionPoints = false;
}
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (DomApi.hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
notifyContentObservers(this.shadyRoot);
} else {
if (!this.shadyRoot._hasDistributed) {
TreeApi.Composed.clearChildNodes(this);
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
if (!this.shadyRoot._hasDistributed) {
notifyInitialDistribution(this);
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return DomApi.matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = TreeApi.Logical.getChildNodes(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = TreeApi.Logical.getChildNodes(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = TreeApi.Logical.getParentNode(p);
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = TreeApi.Composed.getChildNodes(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (TreeApi.Composed.getParentNode(n) === container) {
TreeApi.Composed.removeChild(container, n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
TreeApi.Composed.insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var domHostDesc = {
get: function () {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
configurable: true
};
Object.defineProperty(Polymer.Base, 'domHost', domHostDesc);
Polymer.BaseDescriptors.domHost = domHostDesc;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = TreeApi.Logical.getParentNode(content);
if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = TreeApi.Logical.getChildNodes(host);
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName && c.localName === 'content') {
return host.domHost;
}
}
}
function notifyContentObservers(root) {
for (var i = 0, c; i < root._insertionPoints.length; i++) {
c = root._insertionPoints[i];
if (DomApi.hasApi(c)) {
Polymer.dom(c).notifyObserver();
}
}
}
function notifyInitialDistribution(host) {
if (DomApi.hasApi(host)) {
Polymer.dom(host).notifyObserver();
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLogicalChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new window.MutationObserver(function () {
Polymer.Async._atEndOfMicrotask();
}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
var self = this;
this.boundComplete = function () {
self.complete();
};
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
this.callback = null;
}
},
complete: function () {
if (this.finish) {
var callback = this.callback;
this.stop();
callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return !!(debouncer && debouncer.finish);
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
this._prepPropertyInfo();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._registerHost();
if (this._template) {
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
}
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});
(function () {
Polymer.nar = [];
var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
Polymer.Annotations = {
parseAnnotations: function (template, stripWhiteSpace) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute('strip-whitespace'));
return list;
},
_parseNodeAnnotations: function (node, list, stripWhiteSpace) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);
},
_bindingRegex: function () {
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')';
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?';
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
return new RegExp(EXPRESSION, 'g');
}(),
_parseBindings: function (text) {
var re = this._bindingRegex;
var parts = [];
var lastIndex = 0;
var m;
while ((m = re.exec(text)) !== null) {
if (m.index > lastIndex) {
parts.push({ literal: text.slice(lastIndex, m.index) });
}
var mode = m[1][0];
var negate = Boolean(m[2]);
var value = m[3].trim();
var customEvent, notifyEvent, colon;
if (mode == '{' && (colon = value.indexOf('::')) > 0) {
notifyEvent = value.substring(colon + 2);
value = value.substring(0, colon);
customEvent = true;
}
parts.push({
compoundIndex: parts.length,
value: value,
mode: mode,
negate: negate,
event: notifyEvent,
customEvent: customEvent
});
lastIndex = re.lastIndex;
}
if (lastIndex && lastIndex < text.length) {
var literal = text.substring(lastIndex);
if (literal) {
parts.push({ literal: literal });
}
}
if (parts.length) {
return parts;
}
},
_literalFromParts: function (parts) {
var s = '';
for (var i = 0; i < parts.length; i++) {
var literal = parts[i].literal;
s += literal || '';
}
return s;
},
_parseTextNodeAnnotation: function (node, list) {
var parts = this._parseBindings(node.textContent);
if (parts) {
node.textContent = this._literalFromParts(parts) || ' ';
var annote = {
bindings: [{
kind: 'text',
name: 'textContent',
parts: parts,
isCompound: parts.length !== 1
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list, stripWhiteSpace) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {
if (root.firstChild) {
var node = root.firstChild;
var i = 0;
while (node) {
var next = node.nextSibling;
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote, stripWhiteSpace);
}
if (node.localName == 'slot') {
node = this._replaceSlotWithContent(node);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = next;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
next = n.nextSibling;
root.removeChild(n);
n = next;
}
if (stripWhiteSpace && !node.textContent.trim()) {
root.removeChild(node);
i--;
}
}
if (node.parentNode) {
var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
node = next;
i++;
}
}
},
_replaceSlotWithContent: function (slot) {
var content = slot.ownerDocument.createElement('content');
while (slot.firstChild) {
content.appendChild(slot.firstChild);
}
var attrs = slot.attributes;
for (var i = 0; i < attrs.length; i++) {
var attr = attrs[i];
content.setAttribute(attr.name, attr.value);
}
var name = slot.getAttribute('name');
if (name) {
content.setAttribute('select', '[slot=\'' + name + '\']');
}
slot.parentNode.replaceChild(content, slot);
return content;
},
_parseTemplate: function (node, index, list, parent, stripWhiteSpace) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node, stripWhiteSpace);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
var attrs = Array.prototype.slice.call(node.attributes);
for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
var n = a.name;
var v = a.value;
var b;
if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
annotation.bindings.push(b);
} else if (n === 'id') {
annotation.id = v;
}
}
},
_parseNodeAttributeAnnotation: function (node, name, value) {
var parts = this._parseBindings(value);
if (parts) {
var origName = name;
var kind = 'property';
if (name[name.length - 1] == '$') {
name = name.slice(0, -1);
kind = 'attribute';
}
var literal = this._literalFromParts(parts);
if (literal && kind == 'attribute') {
node.setAttribute(name, literal);
}
if (node.localName === 'input' && origName === 'value') {
node.setAttribute(origName, '');
}
if (disableUpgradeEnabled && origName === 'disable-upgrade$') {
node.setAttribute(name, '');
}
node.removeAttribute(origName);
var propertyName = Polymer.CaseMap.dashToCamelCase(name);
if (kind === 'property') {
name = propertyName;
}
return {
kind: kind,
name: name,
propertyName: propertyName,
parts: parts,
literal: literal,
isCompound: parts.length !== 1
};
}
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
if (parent) {
for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
if (annote.index === i++) {
return n;
}
}
} else {
return root;
}
}
};
}());Polymer.Path = {
root: function (path) {
var dotIndex = path.indexOf('.');
if (dotIndex === -1) {
return path;
}
return path.slice(0, dotIndex);
},
isDeep: function (path) {
return path.indexOf('.') !== -1;
},
isAncestor: function (base, path) {
return base.indexOf(path + '.') === 0;
},
isDescendant: function (base, path) {
return path.indexOf(base + '.') === 0;
},
translate: function (base, newBase, path) {
return newBase + path.slice(base.length);
},
matches: function (base, wildcard, path) {
return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path);
}
};Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
var self = this;
Polymer.Annotations.prepElement = function (element) {
self._prepElement(element);
};
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
}
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
for (var k = 0; k < b.parts.length; k++) {
var p = b.parts[k];
if (!p.literal) {
var signature = this._parseMethod(p.value);
if (signature) {
p.signature = signature;
} else {
p.model = Polymer.Path.root(p.value);
}
}
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
var name = '_parent_' + prop;
bindings.push({
index: note.index,
kind: 'property',
name: name,
propertyName: name,
parts: [{
mode: '{',
model: prop,
value: prop
}]
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
if (p.signature) {
var args = p.signature.args;
for (var kk = 0; kk < args.length; kk++) {
var model = args[kk].model;
if (model) {
pp[model] = true;
}
}
if (p.signature.dynamicFn) {
pp[p.signature.method] = true;
}
} else {
if (p.model) {
pp[p.model] = true;
}
}
}
}
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
}
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
var notes = this._notes;
var nodes = this._nodes;
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
var node = nodes[i];
this._configureTemplateContent(note, node);
this._configureCompoundBindings(note, node);
}
},
_configureTemplateContent: function (note, node) {
if (note.templateContent) {
node._content = note.templateContent;
}
},
_configureCompoundBindings: function (note, node) {
var bindings = note.bindings;
for (var i = 0; i < bindings.length; i++) {
var binding = bindings[i];
if (binding.isCompound) {
var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
var parts = binding.parts;
var literals = new Array(parts.length);
for (var j = 0; j < parts.length; j++) {
literals[j] = parts[j].literal;
}
var name = binding.name;
storage[name] = literals;
if (binding.literal && binding.kind == 'property') {
if (node._configValue) {
node._configValue(name, binding.literal);
} else {
node[name] = binding.literal;
}
}
}
}
},
_marshalIdNodes: function () {
this.$ = {};
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}
},
_marshalAnnotatedNodes: function () {
if (this._notes && this._notes.length) {
var r = new Array(this._notes.length);
for (var i = 0; i < this._notes.length; i++) {
r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
}
this._nodes = r;
}
},
_marshalAnnotatedListeners: function () {
for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
this.listen(node, e.name, e.value);
}
}
}
}
});Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, eventName;
for (eventName in listeners) {
if (eventName.indexOf('.') < 0) {
node = this;
name = eventName;
} else {
name = eventName.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[eventName]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
if (!Polymer.Settings.isIE || target != window) {
hbl.set(target, bl);
}
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});(function () {
'use strict';
var wrap = Polymer.DomApi.wrap;
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var SUPPORTS_PASSIVE = false;
(function () {
try {
var opts = Object.defineProperty({}, 'passive', {
get: function () {
SUPPORTS_PASSIVE = true;
}
});
window.addEventListener('test', null, opts);
window.removeEventListener('test', null, opts);
} catch (e) {
}
}());
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
var sc = mouseEvent.sourceCapabilities;
if (sc && !sc.firesTouchEvents) {
return;
}
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
for (var i = 0, en; i < events.length; i++) {
en = events[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse(ev) {
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
stateObj.movefn = null;
stateObj.upfn = null;
}
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = wrap(ev.currentTarget);
var gobj = node[GESTURE_KEY];
if (!gobj) {
return;
}
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
r.reset();
}
}
}
for (i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
node = wrap(node);
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var preventer = detail.preventer || detail.sourceEvent;
if (preventer && preventer.preventDefault) {
preventer.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
},
resetMouseCanceller: function () {
if (POINTERSTATE.mouse.mouseIgnoreJob) {
POINTERSTATE.mouse.mouseIgnoreJob.complete();
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: null,
upfn: null
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);
},
fire: function (type, target, event, preventer) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
preventer: preventer,
prevent: function (e) {
return Gestures.prevent(e);
}
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: null,
upfn: null,
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
if (self.info.state === 'start') {
Gestures.prevent('tap');
}
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
if (this.info.state === 'start') {
Gestures.prevent('tap');
}
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct, e);
}
},
fire: function (target, touch, preventer) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
preventer: preventer,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0], e);
},
touchend: function (e) {
this.forward(e.changedTouches[0], e);
},
forward: function (e, preventer) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e,
preventer: preventer
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_setupGestures: function () {
this.__polymerGestures = null;
},
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());(function () {
'use strict';
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getEffectiveChildNodes: function () {
return Polymer.dom(this).getEffectiveChildNodes();
},
getEffectiveChildren: function () {
var list = Polymer.dom(this).getEffectiveChildNodes();
return list.filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
getEffectiveTextContent: function () {
var cn = this.getEffectiveChildNodes();
var tc = [];
for (var i = 0, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(Polymer.dom(c).textContent);
}
}
return tc.join('');
},
queryEffectiveChildren: function (slctr) {
var e$ = Polymer.dom(this).queryDistributedElements(slctr);
return e$ && e$[0];
},
queryAllEffectiveChildren: function (slctr) {
return Polymer.dom(this).queryDistributedElements(slctr);
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
detail = detail === null || detail === undefined ? {} : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var useCache = options._useCache;
var event = this._getEvent(type, bubbles, cancelable, useCache);
event.detail = detail;
if (useCache) {
this.__eventCache[type] = null;
}
node.dispatchEvent(event);
if (useCache) {
this.__eventCache[type] = event;
}
return event;
},
__eventCache: {},
_getEvent: function (type, bubbles, cancelable, useCache) {
var event = useCache && this.__eventCache[type];
if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {
event = new Event(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable
});
}
return event;
},
async: function (callback, waitTime) {
var self = this;
return Polymer.Async.run(function () {
callback.call(self);
}, waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this._get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror, optAsync) {
var link = document.createElement('link');
link.rel = 'import';
link.href = href;
var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
var cached = list[link.href];
var imprt = cached || link;
var self = this;
var loadListener = function (e) {
e.target.__firedLoad = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onload.call(self, e);
};
var errorListener = function (e) {
e.target.__firedError = true;
e.target.removeEventListener('load', loadListener);
e.target.removeEventListener('error', errorListener);
return onerror.call(self, e);
};
if (onload) {
imprt.addEventListener('load', loadListener);
}
if (onerror) {
imprt.addEventListener('error', errorListener);
}
if (cached) {
if (cached.__firedLoad) {
cached.dispatchEvent(new Event('load'));
}
if (cached.__firedError) {
cached.dispatchEvent(new Event('error'));
}
} else {
list[link.href] = link;
optAsync = Boolean(optAsync);
if (optAsync) {
link.setAttribute('async', '');
}
document.head.appendChild(link);
}
return imprt;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
if (!Polymer.Settings.useNativeCustomElements) {
var importHref = Polymer.Base.importHref;
Polymer.Base.importHref = function (href, onload, onerror, optAsync) {
CustomElements.ready = false;
var loadFn = function (e) {
CustomElements.upgradeDocumentTree(document);
CustomElements.ready = true;
if (onload) {
return onload.call(this, e);
}
};
return importHref.call(this, href, loadFn, onerror, optAsync);
};
}
}());Polymer.Bind = {
prepareModel: function (model) {
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (source, event, value) {
value = value === undefined ? this[source] : value;
event = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';
this.fire(event, { value: value }, {
bubbles: false,
cancelable: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else if (node[property] !== value) {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
fx.fn.call(this, property, this[property], fx.effect, old, fromAbove);
}
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (Polymer.Path.isDescendant(path, prop)) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
if (!model._propertyEffects) {
model._propertyEffects = {};
}
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
var propEffect = {
kind: kind,
effect: effect,
fn: Polymer.Bind['_' + kind + 'Effect']
};
fx.push(propEffect);
return propEffect;
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'annotatedComputation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event, negated) {
if (!model._bindListeners) {
model._bindListeners = [];
}
var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, negated) {
return function (target, value, targetPath) {
if (targetPath) {
var newPath = Polymer.Path.translate(property, path, targetPath);
this._notifyPath(newPath, value);
} else {
value = target[property];
if (negated) {
value = !value;
}
if (!isStructured) {
this[path] = value;
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
var b$ = inst._bindListeners;
for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
var node = inst._nodes[info.index];
this._addNotifyListener(node, inst, info.event, info.changedFn);
}
},
_addNotifyListener: function (element, context, event, changedFn) {
element.addEventListener(event, function (e) {
return context._notifyListener(changedFn, e);
});
}
};Polymer.Base.mixin(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this._get(effect.value);
this.__data__[effect.value] = value;
}
this._applyEffectValue(effect, value);
},
_reflectEffect: function (source, value, effect) {
this.reflectPropertyToAttribute(source, effect.attribute, value);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source, effect.event, value);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(this, args);
this.__setProperty(effect.name, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
this._applyEffectValue(effect, computedvalue);
}
} else if (effect.dynamicFn) {
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
var bailoutEarly = args.length > 1 || effect.dynamicFn;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (path === name) {
v = value;
} else {
v = model[name];
if (v === undefined && arg.structured) {
v = Polymer.Base._get(name, model);
}
}
if (bailoutEarly && v === undefined) {
return;
}
if (arg.wildcard) {
var matches = Polymer.Path.isAncestor(path, name);
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
prop.pathFn = this['_' + prop.kind + 'PathEffect'];
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });
}
if (prop.reflectToAttribute) {
var attr = Polymer.CaseMap.camelToDashCase(p);
if (attr[0] === '-') {
this._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
} else {
this._addPropertyEffect(p, 'reflect', { attribute: attr });
}
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
name: name,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'compute', {
method: sig.method,
args: sig.args,
trigger: null,
name: name,
dynamicFn: dynamicFn
});
}
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
this._addComplexObserverEffect(o);
}
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
if (!sig) {
throw new Error('Malformed observer expression \'' + observer + '\'');
}
var dynamicFn = sig.dynamicFn;
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg,
dynamicFn: dynamicFn
});
}
if (dynamicFn) {
this._addPropertyEffect(sig.method, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: null,
dynamicFn: dynamicFn
});
}
},
_addAnnotationEffects: function (notes) {
for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
var b$ = note.bindings;
for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
this._addAnnotationEffect(binding, i);
}
}
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
}
for (var i = 0; i < note.parts.length; i++) {
var part = note.parts[i];
if (part.signature) {
this._addAnnotatedComputationEffect(note, part, index);
} else if (!part.literal) {
if (note.kind === 'attribute' && note.name[0] === '-') {
this._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because "-" is not a valid attribute starting character'));
} else {
this._addPropertyEffect(part.model, 'annotation', {
kind: note.kind,
index: index,
name: note.name,
propertyName: note.propertyName,
value: part.value,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
event: part.event,
customEvent: part.customEvent,
negate: part.negate
});
}
}
}
},
_addAnnotatedComputationEffect: function (note, part, index) {
var sig = part.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
} else {
for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
}
}
if (sig.dynamicFn) {
this.__addAnnotatedComputationEffect(sig.method, index, note, part, null);
}
}
},
__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
isCompound: note.isCompound,
compoundIndex: part.compoundIndex,
kind: note.kind,
name: note.name,
negate: part.negate,
method: part.signature.method,
args: part.signature.args,
trigger: trigger,
dynamicFn: part.signature.dynamicFn
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
sig.static = false;
sig.dynamicFn = true;
}
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = { name: arg };
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.model = Polymer.Path.root(arg);
a.structured = Polymer.Path.isDeep(arg);
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
if (this._bindListeners) {
Polymer.Bind.setupBindListeners(this);
}
},
_applyEffectValue: function (info, value) {
var node = this._nodes[info.index];
var property = info.name;
value = this._computeFinalAnnotationValue(node, property, value, info);
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
var pinfo = node._propertyInfo && node._propertyInfo[property];
if (pinfo && pinfo.readOnly) {
return;
}
this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node);
}
},
_computeFinalAnnotationValue: function (node, property, value, info) {
if (info.negate) {
value = !value;
}
if (info.isCompound) {
var storage = node.__compoundStorage__[property];
storage[info.compoundIndex] = value;
value = storage.join('');
}
if (info.kind !== 'attribute') {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
}
return value;
},
_executeStaticEffects: function () {
if (this._propertyEffects && this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});(function () {
var usePolyfillProto = Polymer.Settings.usePolyfillProto;
var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, 'properties'));
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
this._handlers = [];
this._aboveConfig = null;
if (initialConfig) {
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
var info = this._propertyInfo[name];
if (!info || !info.readOnly) {
this._config[name] = value;
}
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._configureInstanceProperties();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
for (var i = 0; i < this.behaviors.length; i++) {
this._configureProperties(this.behaviors[i].properties, config);
}
this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
this.mixin(config, this._aboveConfig);
this._config = config;
if (this._clients && this._clients.length) {
this._distributeConfig(this._config);
}
},
_configureInstanceProperties: function () {
for (var i in this._propertyEffects) {
if (!usePolyfillProto && this.hasOwnProperty(i)) {
this._configValue(i, this[i]);
delete this[i];
}
}
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
var name = x.effect.propertyName;
var isAttr = x.effect.kind == 'attribute';
var hasEffect = node._propertyEffects && node._propertyEffects[name];
if (node._configValue && (hasEffect || !isAttr)) {
var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
value = this._computeFinalAnnotationValue(node, name, value, x.effect);
if (isAttr) {
value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
}
node._configValue(name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this.importPath = this._importPath;
this.rootPath = Polymer.rootPath;
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!Polymer.Bind._isEventBogus(e, e.target)) {
var value, path;
if (e.detail) {
value = e.detail.value;
path = e.detail.path;
}
if (!this._clientsReadied) {
this._queueHandler([
fn,
e.target,
value,
path
]);
} else {
return fn.call(this, e.target, value, path);
}
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2], h[3]);
}
this._handlers = [];
}
});
}());(function () {
'use strict';
var Path = Polymer.Path;
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var info = {};
var v = this._get(path, this, info);
if (arguments.length === 1) {
value = v;
}
if (info.path) {
this._notifyPath(info.path, value, fromAbove);
}
},
_notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPathUp(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array) {
var coll = Polymer.Collection.get(array);
var old, key;
if (last[0] == '#') {
key = last;
old = coll.getItem(key);
last = array.indexOf(old);
coll.setItem(key, value);
} else if (parseInt(last, 10) == last) {
old = prop[last];
key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
}
prop[last] = value;
if (!root) {
this._notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
return this._get(path, root);
},
_get: function (path, root, info) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
for (var i = 0; i < parts.length; i++) {
if (!prop) {
return;
}
var part = parts[i];
if (array && part[0] == '#') {
prop = Polymer.Collection.get(array).getItem(part);
} else {
prop = prop[part];
if (info && array && parseInt(part, 10) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
}
array = Array.isArray(prop) ? prop : null;
}
if (info) {
info.path = parts.join('.');
}
return prop;
},
_pathEffector: function (path, value) {
var model = Path.root(path);
var fx$ = this._propertyEffects && this._propertyEffects[model];
if (fx$) {
for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
var fxFn = fx.pathFn;
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (Path.matches(effect.value, false, path)) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (!effect.negate && Path.isDescendant(effect.value, path)) {
var node = this._nodes[effect.index];
if (node && node._notifyPath) {
var newPath = Path.translate(effect.value, effect.name, path);
node._notifyPath(newPath, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (Path.isDescendant(a, path)) {
this._notifyPath(Path.translate(a, b, path), value);
} else if (Path.isDescendant(b, path)) {
this._notifyPath(Path.translate(b, a, path), value);
}
}
},
_notifyPathUp: function (path, value) {
var rootName = Path.root(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, {
bubbles: false,
_useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
});
},
_EVENT_CHANGED: '-changed',
notifySplices: function (path, splices) {
var info = {};
var array = this._get(path, this, info);
this._notifySplices(array, info.path, splices);
},
_notifySplices: function (array, path, splices) {
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
var splicesPath = path + '.splices';
this._notifyPath(splicesPath, change);
this._notifyPath(path + '.length', array.length);
this.__data__[splicesPath] = {
keySplices: null,
indexSplices: null
};
},
_notifySplice: function (array, path, index, added, removed) {
this._notifySplices(array, path, [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}]);
},
push: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start) {
var info = {};
var array = this._get(path, this, info);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, info.path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var info = {};
var array = this._get(path, this, info);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, info.path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var info = {};
var array = this._get(path, this, info);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, info.path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
_getEvent: Polymer.Base._getEvent,
__eventCache: Polymer.Base.__eventCache,
notifyPath: Polymer.Base.notifyPath,
_get: Polymer.Base._get,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_notifyPathUp: Polymer.Base._notifyPathUp,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
_getPathParts: Polymer.Base._getPathParts
});
}
});
}());Polymer.Base._addFeature({
resolveUrl: function (url) {
return Polymer.ResolveUrl.resolveUrl(url, this._importPath);
}
});Polymer.CssParse = function () {
return {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = this._expandUnicodeEscapes(t);
t = t.replace(this._rx.multipleSpaces, ' ');
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
_expandUnicodeEscapes: function (s) {
return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
var code = arguments[1], repeat = 6 - code.length;
while (repeat--) {
code = '0' + code;
}
return '\\' + code;
});
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && !this._hasMixinRules(r$)) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) === 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/,
multipleSpaces: /\s+/g
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
}();Polymer.StyleUtil = function () {
var settings = Polymer.Settings;
return {
NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachRule(rules, callback);
}
return this.parser.stringify(rules, this.NATIVE_VARIABLES);
},
forRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);
}
}
},
forActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
isKeyframesSelector: function (rule) {
return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;
},
forEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
var rules = this.rulesForStyle(style);
var styleCallback, keyframeCallback;
if (styleRuleCallback) {
styleCallback = function (rule) {
styleRuleCallback(rule, style);
};
}
if (keyframesRuleCallback) {
keyframeCallback = function (rule) {
keyframesRuleCallback(rule, style);
};
}
this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);
},
forEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
if (!node) {
return;
}
var skipRules = false;
if (onlyActiveRules) {
if (node.type === this.ruleTypes.MEDIA_RULE) {
var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
if (matchMedia) {
if (!window.matchMedia(matchMedia[1]).matches) {
skipRules = true;
}
}
}
}
if (node.type === this.ruleTypes.STYLE_RULE) {
styleRuleCallback(node);
} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
keyframesRuleCallback(node);
} else if (node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
}
},
applyCss: function (cssText, moniker, target, contextNode) {
var style = this.createScopeStyle(cssText, moniker);
return this.applyStyle(style, target, contextNode);
},
applyStyle: function (style, target, contextNode) {
target = target || document.head;
var after = contextNode && contextNode.nextSibling || target.firstChild;
this.__lastHeadApplyNode = style;
return target.insertBefore(style, after);
},
createScopeStyle: function (cssText, moniker) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
return style;
},
__lastHeadApplyNode: null,
applyStylePlaceHolder: function (moniker) {
var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
var scope = document.head;
scope.insertBefore(placeHolder, after || scope.firstChild);
this.__lastHeadApplyNode = placeHolder;
return placeHolder;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this.cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
if (!e.hasAttribute('preserve-content')) {
cssText += this.cssFromElement(e);
}
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
styleIncludesToTemplate: function (targetTemplate) {
var styles = targetTemplate.content.querySelectorAll('style[include]');
for (var i = 0, s; i < styles.length; i++) {
s = styles[i];
s.parentNode.insertBefore(this._includesToFragment(s.getAttribute('include')), s);
}
},
_includesToFragment: function (styleIncludes) {
var includeArray = styleIncludes.trim().split(' ');
var frag = document.createDocumentFragment();
for (var i = 0; i < includeArray.length; i++) {
var t = Polymer.DomModule.import(includeArray[i], 'template');
if (t) {
this._addStylesToFragment(frag, t.content);
}
}
return frag;
},
_addStylesToFragment: function (frag, source) {
var s$ = source.querySelectorAll('style');
for (var i = 0, s; i < s$.length; i++) {
s = s$[i];
var include = s.getAttribute('include');
if (include) {
frag.appendChild(this._includesToFragment(include));
}
if (s.textContent) {
frag.appendChild(s.cloneNode(true));
}
}
},
isTargetedBuild: function (buildType) {
return settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';
},
cssBuildTypeForModule: function (module) {
var dm = Polymer.DomModule.import(module);
if (dm) {
return this.getCssBuildType(dm);
}
},
getCssBuildType: function (element) {
return element.getAttribute('css-build');
},
_findMatchingParen: function (text, start) {
var level = 0;
for (var i = start, l = text.length; i < l; i++) {
switch (text[i]) {
case '(':
level++;
break;
case ')':
if (--level === 0) {
return i;
}
break;
}
}
return -1;
},
processVariableAndFallback: function (str, callback) {
var start = str.indexOf('var(');
if (start === -1) {
return callback(str, '', '', '');
}
var end = this._findMatchingParen(str, start + 3);
var inner = str.substring(start + 4, end);
var prefix = str.substring(0, start);
var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
var comma = inner.indexOf(',');
if (comma === -1) {
return callback(prefix, inner.trim(), '', suffix);
}
var value = inner.substring(0, comma).trim();
var fallback = inner.substring(comma + 1).trim();
return callback(prefix, value, fallback, suffix);
},
rx: {
VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();Polymer.StyleTransformer = function () {
var styleUtil = Polymer.StyleUtil;
var settings = Polymer.Settings;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
var cssBuildType = element.__cssBuild;
var passthrough = settings.useNativeShadow || cssBuildType === 'shady';
var cb;
if (passthrough) {
var self = this;
cb = function (rule) {
rule.selector = self._slottedToContent(rule.selector);
rule.selector = rule.selector.replace(ROOT, ':host > *');
if (callback) {
callback(rule);
}
};
}
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
},
_transformRuleCss: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
if (!styleUtil.isKeyframesSelector(rule)) {
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
}
return p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.trim();
selector = this._slottedToContent(selector);
selector = selector.replace(ROOT, ':host > *');
selector = selector.replace(CONTENT_START, HOST + ' $1');
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = this._transformHostSelector(selector, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
_transformHostSelector: function (selector, hostScope) {
var m = selector.match(HOST_PAREN);
var paren = m && m[2].trim() || '';
if (paren) {
if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
if (typeSelector === hostScope) {
return paren;
} else {
return SELECTOR_NO_MATCH;
}
} else {
return selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
}
} else {
return selector.replace(HOST, hostScope);
}
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!settings.useNativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
rule.selector = rule.selector.replace(ROOT, 'html');
var parts = rule.selector.split(COMPLEX_SELECTOR_SEP);
parts = parts.filter(function (part) {
return !part.match(HOST_OR_HOST_GT_STAR);
});
rule.selector = parts.join(COMPLEX_SELECTOR_SEP);
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
_slottedToContent: function (cssText) {
return cssText.replace(SLOTTED_PAREN, CONTENT + '> $1');
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /::content|::shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
var CONTENT_START = new RegExp('^(' + CONTENT + ')');
var SELECTOR_NO_MATCH = 'should_not_match';
var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/;
return api;
}();Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachRule(rules, function (rule) {
self._mapRuleOntoParent(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRuleOntoParent: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || [];
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();Polymer.ApplyShim = function () {
'use strict';
var styleUtil = Polymer.StyleUtil;
var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
var MIXIN_VAR_SEP = '_-_';
var mixinMap = {};
function mapSet(name, props) {
name = name.trim();
mixinMap[name] = {
properties: props,
dependants: {}
};
}
function mapGet(name) {
name = name.trim();
return mixinMap[name];
}
function replaceInitialOrInherit(property, value) {
var match = INITIAL_INHERIT.exec(value);
if (match) {
if (match[1]) {
value = ApplyShim._getInitialValueForProperty(property);
} else {
value = 'apply-shim-inherit';
}
}
return value;
}
function cssTextToMap(text) {
var props = text.split(';');
var property, value;
var out = {};
for (var i = 0, p, sp; i < props.length; i++) {
p = props[i];
if (p) {
sp = p.split(':');
if (sp.length > 1) {
property = sp[0].trim();
value = replaceInitialOrInherit(property, sp.slice(1).join(':'));
out[property] = value;
}
}
}
return out;
}
function invalidateMixinEntry(mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
var currentElementName = currentProto && currentProto.is;
for (var elementName in mixinEntry.dependants) {
if (elementName !== currentElementName) {
mixinEntry.dependants[elementName].__applyShimInvalid = true;
}
}
}
function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
if (valueProperty) {
styleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {
if (value && mapGet(value)) {
valueMixin = '@apply ' + value + ';';
}
});
}
if (!valueMixin) {
return matchText;
}
var mixinAsProperties = consumeCssProperties(valueMixin);
var prefix = matchText.slice(0, matchText.indexOf('--'));
var mixinValues = cssTextToMap(mixinAsProperties);
var combinedProps = mixinValues;
var mixinEntry = mapGet(propertyName);
var oldProps = mixinEntry && mixinEntry.properties;
if (oldProps) {
combinedProps = Object.create(oldProps);
combinedProps = Polymer.Base.mixin(combinedProps, mixinValues);
} else {
mapSet(propertyName, combinedProps);
}
var out = [];
var p, v;
var needToInvalidate = false;
for (p in combinedProps) {
v = mixinValues[p];
if (v === undefined) {
v = 'initial';
}
if (oldProps && !(p in oldProps)) {
needToInvalidate = true;
}
out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);
}
if (needToInvalidate) {
invalidateMixinEntry(mixinEntry);
}
if (mixinEntry) {
mixinEntry.properties = combinedProps;
}
if (valueProperty) {
prefix = matchText + ';' + prefix;
}
return prefix + out.join('; ') + ';';
}
function fixVars(matchText, varA, varB) {
return 'var(' + varA + ',' + 'var(' + varB + '))';
}
function atApplyToCssProperties(mixinName, fallbacks) {
mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
var vars = [];
var mixinEntry = mapGet(mixinName);
if (!mixinEntry) {
mapSet(mixinName, {});
mixinEntry = mapGet(mixinName);
}
if (mixinEntry) {
var currentProto = ApplyShim.__currentElementProto;
if (currentProto) {
mixinEntry.dependants[currentProto.is] = currentProto;
}
var p, parts, f;
for (p in mixinEntry.properties) {
f = fallbacks && fallbacks[p];
parts = [
p,
': var(',
mixinName,
MIXIN_VAR_SEP,
p
];
if (f) {
parts.push(',', f);
}
parts.push(')');
vars.push(parts.join(''));
}
}
return vars.join('; ');
}
function consumeCssProperties(text) {
var m;
while (m = MIXIN_MATCH.exec(text)) {
var matchText = m[0];
var mixinName = m[1];
var idx = m.index;
var applyPos = idx + matchText.indexOf('@apply');
var afterApplyPos = idx + matchText.length;
var textBeforeApply = text.slice(0, applyPos);
var textAfterApply = text.slice(afterApplyPos);
var defaults = cssTextToMap(textBeforeApply);
var replacement = atApplyToCssProperties(mixinName, defaults);
text = [
textBeforeApply,
replacement,
textAfterApply
].join('');
MIXIN_MATCH.lastIndex = idx + replacement.length;
}
return text;
}
var ApplyShim = {
_measureElement: null,
_map: mixinMap,
_separator: MIXIN_VAR_SEP,
transform: function (styles, elementProto) {
this.__currentElementProto = elementProto;
styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
styleUtil.forRulesInStyles(styles, this._boundFindApplications);
if (elementProto) {
elementProto.__applyShimInvalid = false;
}
this.__currentElementProto = null;
},
_findDefinitions: function (rule) {
var cssText = rule.parsedCssText;
cssText = cssText.replace(BAD_VAR, fixVars);
cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
rule.cssText = cssText;
if (rule.selector === ':root') {
rule.selector = ':host > *';
}
},
_findApplications: function (rule) {
rule.cssText = consumeCssProperties(rule.cssText);
},
transformRule: function (rule) {
this._findDefinitions(rule);
this._findApplications(rule);
},
_getInitialValueForProperty: function (property) {
if (!this._measureElement) {
this._measureElement = document.createElement('meta');
this._measureElement.style.all = 'initial';
document.head.appendChild(this._measureElement);
}
return window.getComputedStyle(this._measureElement).getPropertyValue(property);
}
};
ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
return ApplyShim;
}();(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
var applyShim = Polymer.ApplyShim;
var settings = Polymer.Settings;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle && this.__cssBuild !== 'shady') {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow;
}
if (!nativeShadow) {
this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
}
this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);
},
_prepShimStyles: function () {
if (this._template) {
var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
if (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {
if (settings.preserveStyleIncludes) {
styleUtil.styleIncludesToTemplate(this._template);
}
return;
}
this._styles = this._styles || this._collectStyles();
if (settings.useNativeCSSProperties && !this.__cssBuild) {
applyShim.transform(this._styles, this);
}
var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
this._prepStyleProperties();
if (!this._needsStyleProperties() && cssText) {
styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);
}
} else {
this._styles = [];
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
var p = this._template && this._template.parentNode;
if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
cssText += styleUtil.cssFromElement(this._template);
}
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
var className = node.getAttribute('class');
node.setAttribute('class', self._scopeElementClass(node, className));
var n$ = node.querySelectorAll('*');
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
className = n.getAttribute('class');
n.setAttribute('class', self._scopeElementClass(n, className));
}
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
if (m.addedNodes) {
for (var j = 0; j < m.addedNodes.length; j++) {
scopify(m.addedNodes[j]);
}
}
}
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());Polymer.StyleProperties = function () {
'use strict';
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var IS_IE = navigator.userAgent.match('Trident');
var settings = Polymer.Settings;
return {
decorateStyles: function (styles, scope) {
var self = this, props = {}, keyframes = [], ruleIndex = 0;
var scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
styleUtil.forRulesInStyles(styles, function (rule, style) {
self.decorateRule(rule);
rule.index = ruleIndex++;
self.whenHostOrRootRule(scope, rule, style, function (info) {
if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
scope.__notStyleScopeCacheable = true;
}
if (info.isHost) {
var hostContextOrFunction = info.selector.split(' ').some(function (s) {
return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;
});
scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;
}
});
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
}, function onKeyframesRule(rule) {
keyframes.push(rule);
});
styles._keyframes = keyframes;
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var value;
var any;
while (m = rx.exec(cssText)) {
value = (m[2] || m[3]).trim();
if (value !== 'inherit') {
properties[m[1].trim()] = value;
}
any = true;
}
return any;
}
},
collectCssText: function (rule) {
return this.collectConsumingCssText(rule.parsedCssText);
},
collectConsumingCssText: function (cssText) {
return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
var name = m[1];
if (m[2] !== ':') {
props[name] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (prefix, value, fallback, suffix) {
var propertyValue = self.valueForProperty(props[value], props);
if (!propertyValue || propertyValue === 'initial') {
propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
} else if (propertyValue === 'apply-shim-inherit') {
propertyValue = 'inherit';
}
return prefix + (propertyValue || '') + suffix;
};
property = styleUtil.processVariableAndFallback(property, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
this.rx.MIXIN_MATCH.lastIndex = 0;
m = this.rx.MIXIN_MATCH.exec(p);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var colon = p.indexOf(':');
if (colon !== -1) {
var pp = p.substring(colon);
pp = pp.trim();
pp = this.valueForProperty(pp, props) || pp;
p = p.substring(0, colon) + pp;
}
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
applyKeyframeTransforms: function (rule, keyframeTransforms) {
var input = rule.cssText;
var output = rule.cssText;
if (rule.hasAnimations == null) {
rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
}
if (rule.hasAnimations) {
var transform;
if (rule.keyframeNamesToTransform == null) {
rule.keyframeNamesToTransform = [];
for (var keyframe in keyframeTransforms) {
transform = keyframeTransforms[keyframe];
output = transform(input);
if (input !== output) {
input = output;
rule.keyframeNamesToTransform.push(keyframe);
}
}
} else {
for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
input = transform(input);
}
output = input;
}
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [];
styleUtil.forActiveRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
if (element && rule.propertyInfo.properties && selectorToMatch) {
if (matchesSelector.call(element, selectorToMatch)) {
self.collectProperties(rule, props);
addToBitMask(rule.index, o);
}
}
});
return {
properties: props,
key: o
};
},
_rootSelector: /:root|:host\s*>\s*\*/,
_checkRoot: function (hostScope, selector) {
return Boolean(selector.match(this._rootSelector)) || hostScope === 'html' && selector.indexOf('html') > -1;
},
whenHostOrRootRule: function (scope, rule, style, callback) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (!rule.propertyInfo.properties) {
return;
}
var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';
var parsedSelector = rule.parsedSelector;
var isRoot = this._checkRoot(hostScope, parsedSelector);
var isHost = !isRoot && parsedSelector.indexOf(':host') === 0;
var cssBuild = scope.__cssBuild || style.__cssBuild;
if (cssBuild === 'shady') {
isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') > -1;
isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
}
if (!isRoot && !isHost) {
return;
}
var selectorToMatch = hostScope;
if (isHost) {
if (settings.useNativeShadow && !rule.transformedSelector) {
rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
}
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
if (isRoot && hostScope === 'html') {
selectorToMatch = rule.transformedSelector || rule.parsedSelector;
}
callback({
selector: selectorToMatch,
isHost: isHost,
isRoot: isRoot
});
},
hostAndRootPropertiesForScope: function (scope) {
var hostProps = {}, rootProps = {}, self = this;
styleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {
self.whenHostOrRootRule(scope, rule, style, function (info) {
var element = scope._element || scope;
if (matchesSelector.call(element, info.selector)) {
if (info.isHost) {
self.collectProperties(rule, hostProps);
} else {
self.collectProperties(rule, rootProps);
}
}
});
});
return {
rootProps: rootProps,
hostProps: hostProps
};
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
self.applyKeyframeTransforms(rule, keyframeTransforms);
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_elementKeyframeTransforms: function (element, scopeSelector) {
var keyframesRules = element._styles._keyframes;
var keyframeTransforms = {};
if (!settings.useNativeShadow && keyframesRules) {
for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
this._scopeKeyframes(keyframesRule, scopeSelector);
keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);
}
}
return keyframeTransforms;
},
_keyframesRuleTransformer: function (keyframesRule) {
return function (cssText) {
return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
};
},
_scopeKeyframes: function (rule, scopeId) {
rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');
rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;
rule.transformedSelector = rule.transformedSelector || rule.selector;
rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.setAttribute('class', v);
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !settings.useNativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (settings.useNativeShadow) {
if (element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);
}
} else {
if (!style) {
if (cssText) {
style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);
}
} else if (!style.parentNode) {
if (IS_IE && cssText.indexOf('@media') > -1) {
style.textContent = cssText;
}
styleUtil.applyStyle(style, null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
updateNativeStyleProperties: function (element, properties) {
var oldPropertyNames = element.__customStyleProperties;
if (oldPropertyNames) {
for (var i = 0; i < oldPropertyNames.length; i++) {
element.style.removeProperty(oldPropertyNames[i]);
}
}
var propertyNames = [];
for (var p in properties) {
if (properties[p] !== null) {
element.style.setProperty(p, properties[p]);
propertyNames.push(p);
}
}
element.__customStyleProperties = propertyNames;
},
rx: styleUtil.rx,
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var StyleCache = Polymer.StyleCache;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
_element: Polymer.DomApi.wrap(document.documentElement),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles, this);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
hasStyleProperties: function () {
return Boolean(this._properties);
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
if (nativeVariables) {
styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);
}
}
};
return api;
}();(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
var nativeVariables = Polymer.Settings.useNativeCSSProperties;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
if (!nativeVariables) {
this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;
}
},
customStyle: null,
getComputedStyleValue: function (property) {
if (!nativeVariables && !this._styleProperties) {
this._computeStyleProperties();
}
return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);
},
_setupStyleProperties: function () {
this.customStyle = {};
this._styleCache = null;
this._styleProperties = null;
this._scopeSelector = null;
this._ownStyleProperties = null;
this._customStyle = null;
},
_needsStyleProperties: function () {
return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_validateApplyShim: function () {
if (this.__applyShimInvalid) {
Polymer.ApplyShim.transform(this._styles, this.__proto__);
var cssText = styleTransformer.elementStyles(this);
if (nativeShadow) {
var templateStyle = this._template.content.querySelector('style');
if (templateStyle) {
templateStyle.textContent = cssText;
}
} else {
var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
if (shadyStyle) {
shadyStyle.textContent = cssText;
}
}
}
},
_beforeAttached: function () {
if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
this.__stylePropertiesInvalid = false;
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
var scopeCacheable = !this.__notStyleScopeCacheable;
if (scopeCacheable) {
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
}
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
if (scopeCacheable) {
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
}
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
this.mixin(props, hostAndRootProps.hostProps);
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, hostAndRootProps.rootProps);
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (nativeVariables) {
propertyUtils.updateNativeStyleProperties(this, this.customStyle);
} else {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
} else {
this.__stylePropertiesInvalid = true;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
if (this.factoryImpl) {
this._prepConstructor();
}
this._prepStyles();
},
_finishRegisterFeatures: function () {
this._prepTemplate();
this._prepShimStyles();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepPropertyInfo();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._setupGestures();
this._setupConfigure(this.__data__);
this._setupStyleProperties();
this._setupDebouncers();
this._setupShady();
this._registerHost();
if (this._template) {
this._validateApplyShim();
this._poolContent();
this._beginHosting();
this._stampTemplate();
this._endHosting();
this._marshalAnnotationReferences();
}
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalHostAttributes();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
if (b.listeners) {
this._listenListeners(b.listeners);
}
}
});(function () {
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
var applyShim = Polymer.ApplyShim;
var debounce = Polymer.Debounce;
var settings = Polymer.Settings;
var updateDebouncer;
Polymer({
is: 'custom-style',
extends: 'style',
_template: null,
properties: { include: String },
ready: function () {
this.__appliedElement = this.__appliedElement || this;
this.__cssBuild = styleUtil.getCssBuildType(this);
if (this.__appliedElement !== this) {
this.__appliedElement.__cssBuild = this.__cssBuild;
}
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement;
if (!settings.useNativeCSSProperties) {
this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
styleDefaults.addStyle(e);
}
if (e.textContent || this.include) {
this._apply(true);
} else {
var self = this;
var observer = new MutationObserver(function () {
observer.disconnect();
self._apply(true);
});
observer.observe(e, { childList: true });
}
}
}
},
_updateStyles: function () {
Polymer.updateStyles();
},
_apply: function (initialApply) {
var e = this.__appliedElement;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (!e.textContent) {
return;
}
var buildType = this.__cssBuild;
var targetedBuild = styleUtil.isTargetedBuild(buildType);
if (settings.useNativeCSSProperties && targetedBuild) {
return;
}
var styleRules = styleUtil.rulesForStyle(e);
if (!targetedBuild) {
styleUtil.forEachRule(styleRules, function (rule) {
styleTransformer.documentRule(rule);
});
if (settings.useNativeCSSProperties && !buildType) {
applyShim.transform([e]);
}
}
if (settings.useNativeCSSProperties) {
e.textContent = styleUtil.toCssText(styleRules);
} else {
var self = this;
var fn = function fn() {
self._flushCustomProperties();
};
if (initialApply) {
Polymer.RenderStatus.whenReady(fn);
} else {
fn();
}
}
},
_flushCustomProperties: function () {
if (this.__needsUpdateStyles) {
this.__needsUpdateStyles = false;
updateDebouncer = debounce(updateDebouncer, this._updateStyles);
} else {
this._applyCustomProperties();
}
},
_applyCustomProperties: function () {
var element = this.__appliedElement;
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
if (!rules) {
return;
}
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepPropertyInfo();
archetype._prepBindings();
archetype._notifyPathUp = this._notifyPathUpImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
archetype.__setPropertyOrig = this.__setProperty;
archetype.__setProperty = this.__setPropertyImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
__setPropertyImpl: function (property, value, fromAbove, node) {
if (node && node.__hideTemplateChildren__ && property == 'textContent') {
property = '__polymerTextContent__';
}
this.__setPropertyOrig(property, value, fromAbove, node);
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function () {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = function () {
rootDataHost._prepElement();
};
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop),
fn: Polymer.Bind._functionEffect
},
{
kind: 'notify',
fn: Polymer.Bind._notifyEffect,
effect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }
}
];
proto._propertyEffects = proto._propertyEffects || {};
proto._propertyEffects[parentProp] = effects;
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
var self = this;
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = function (source, value) {
self._forwardParentProp(source, value);
};
}
this._extendTemplate(template, proto);
template._pathEffector = function (path, value, fromAbove) {
return self._pathEffectorImpl(path, value, fromAbove);
};
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
var n$ = Object.getOwnPropertyNames(proto);
if (proto._propertySetter) {
template._propertySetter = proto._propertySetter;
}
for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
var val = template[n];
if (val && n == '_propertyEffects') {
var pe = Polymer.Base.mixin({}, val);
template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects);
} else {
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
}
}
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathUpImpl: function (path, value) {
var dataHost = this.dataHost;
var root = Polymer.Path.root(path);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
var model = Polymer.Path.root(subPath);
if (model in this._parentProps) {
this._forwardParentPath(subPath, value);
}
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._registerHost(host);
this._beginHosting();
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._endHosting();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
return value;
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
if (model[prop] === undefined) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};Polymer({
is: 'dom-template',
extends: 'template',
_template: null,
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return '#' + key;
},
removeKey: function (key) {
if (key = this._parseKey(key)) {
this._removeFromMap(this.store[key]);
delete this.store[key];
}
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
var key;
if (item && typeof item == 'object') {
key = this.omap.get(item);
} else {
key = this.pmap[item];
}
if (key != undefined) {
return '#' + key;
}
},
getKeys: function () {
return Object.keys(this.store).map(function (key) {
return '#' + key;
});
},
_parseKey: function (key) {
if (key && key[0] == '#') {
return key.slice(1);
}
},
setItem: function (key, item) {
if (key = this._parseKey(key)) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
}
},
getItem: function (key) {
if (key = this._parseKey(key)) {
return this.store[key];
}
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
s.addedKeys = [];
for (var j = 0; j < s.removed.length; j++) {
key = this.getKey(s.removed[j]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.addedCount; j++) {
var item = this.userArray[s.index + j];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}
var removed = [];
var added = [];
for (key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};Polymer({
is: 'dom-repeat',
extends: 'template',
_template: null,
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number,
renderedItemCount: {
type: Number,
notify: !Polymer.Settings.suppressTemplateNotifications,
readOnly: true
},
initialCount: {
type: Number,
observer: '_initializeChunking'
},
targetFramerate: {
type: Number,
value: 20
},
notifyDomChange: { type: Boolean },
_targetFrameTime: {
type: Number,
computed: '_computeFrameTime(targetFramerate)'
}
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
this._pool = [];
this._limit = Infinity;
var self = this;
this._boundRenderChunk = function () {
self._renderChunk();
};
},
detached: function () {
this.__isDetached = true;
for (var i = 0; i < this._instances.length; i++) {
this._detachInstance(i);
}
},
attached: function () {
if (this.__isDetached) {
this.__isDetached = false;
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
var parent = Polymer.dom(parentNode);
for (var i = 0; i < this._instances.length; i++) {
this._attachInstance(i, parent, refNode);
}
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function (sort) {
var dataHost = this._getRootDataHost();
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function (filter) {
var dataHost = this._getRootDataHost();
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_computeFrameTime: function (rate) {
return Math.ceil(1000 / rate);
},
_initializeChunking: function () {
if (this.initialCount) {
this._limit = this.initialCount;
this._chunkCount = this.initialCount;
this._lastChunkTime = performance.now();
}
},
_tryRenderChunk: function () {
if (this.items && this._limit < this.items.length) {
this.debounce('renderChunk', this._requestRenderChunk);
}
},
_requestRenderChunk: function () {
requestAnimationFrame(this._boundRenderChunk);
},
_renderChunk: function () {
var currChunkTime = performance.now();
var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
this._limit += this._chunkCount;
this._lastChunkTime = currChunkTime;
this._debounceTemplate(this._render);
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._initializeChunking();
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else if (this._keySplices.length) {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
} else {
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder && i < this._limit) {
inst = this._insertInstance(i, inst.__key__);
} else if (!inst.isPlaceholder && i >= this._limit) {
inst = this._downgradeInstance(i, inst.__key__);
}
keyToIdx[inst.__key__] = i;
if (!inst.isPlaceholder) {
inst.__setProperty(this.indexAs, i, true);
}
}
this._pool.length = 0;
this._setRenderedItemCount(this._instances.length);
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._tryRenderChunk();
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
var self = this;
if (this._filterFn) {
keys = keys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
if (this._sortFn) {
keys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
}
for (i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__key__ = key;
if (!inst.isPlaceholder && i < this._limit) {
inst.__setProperty(this.as, c.getItem(key), true);
}
} else if (i < this._limit) {
this._insertInstance(i, key);
} else {
this._insertPlaceholder(i, key);
}
}
for (var j = this._instances.length - 1; j >= i; j--) {
this._detachAndRemoveInstance(j);
}
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var keyMap = {};
var key;
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
key = s.removed[j];
keyMap[key] = keyMap[key] ? null : -1;
}
for (j = 0; j < s.added.length; j++) {
key = s.added[j];
keyMap[key] = keyMap[key] ? null : 1;
}
}
var removedIdxs = [];
var addedKeys = [];
for (key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
this._detachAndRemoveInstance(idx);
}
}
}
var self = this;
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return self._filterFn(c.getItem(a));
});
}
addedKeys.sort(function (a, b) {
return self._sortFn(c.getItem(a), c.getItem(b));
});
var start = 0;
for (i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i]);
}
}
},
_insertRowUserSort: function (start, key) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = this._sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._insertPlaceholder(idx, key);
return idx;
},
_applySplicesArrayOrder: function (splices) {
for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0; j < s.removed.length; j++) {
this._detachAndRemoveInstance(s.index);
}
for (j = 0; j < s.addedKeys.length; j++) {
this._insertPlaceholder(s.index + j, s.addedKeys[j]);
}
}
},
_detachInstance: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
return inst;
}
},
_attachInstance: function (idx, parent, refNode) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
parent.insertBefore(inst.root, refNode);
}
},
_detachAndRemoveInstance: function (idx) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
this._instances.splice(idx, 1);
},
_insertPlaceholder: function (idx, key) {
this._instances.splice(idx, 0, {
isPlaceholder: true,
__key__: key
});
},
_stampInstance: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
return this.stamp(model);
},
_insertInstance: function (idx, key) {
var inst = this._pool.pop();
if (inst) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._stampInstance(idx, key);
}
var beforeRow = this._instances[idx + 1];
var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
if (beforeNode == this) {
beforeNode = parentNode;
}
parentNode = Polymer.dom(parentNode).parentNode;
}
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
this._instances[idx] = inst;
return inst;
},
_downgradeInstance: function (idx, key) {
var inst = this._detachInstance(idx);
if (inst) {
this._pool.push(inst);
}
inst = {
isPlaceholder: true,
__key__: key
};
this._instances[idx] = inst;
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
if (!this._instances[i].isPlaceholder)
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst.__setProperty(prop, value, true);
}
}
},
_forwardParentPath: function (path, value) {
var i$ = this._instances;
for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
if (!inst.isPlaceholder) {
inst._notifyPath(path, value, true);
}
}
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst && !inst.isPlaceholder) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst._notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});Polymer({
is: 'array-selector',
_template: null,
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});Polymer({
is: 'dom-if',
extends: 'template',
_template: null,
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
},
notifyDomChange: { type: Boolean }
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
var parentNode = this.parentNode;
if (parentNode && parentNode.localName == this.is) {
parentNode = Polymer.dom(parentNode).parentNode;
}
if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
this._teardownInstance();
}
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
this._lastIf = this.if;
}
},
_ensureInstance: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode && parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
if (parentNode) {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
Polymer.dom(parentNode).insertBefore(root, refNode);
} else {
var c$ = this._instance._children;
if (c$ && c$.length) {
var lastChild = Polymer.dom(refNode).previousSibling;
if (lastChild !== c$[c$.length - 1]) {
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
Polymer.dom(parentNode).insertBefore(n, refNode);
}
}
}
}
}
},
_teardownInstance: function () {
if (this._instance) {
var c$ = this._instance._children;
if (c$ && c$.length) {
var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
parent.removeChild(n);
}
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance.__setProperty(prop, value, true);
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance._notifyPath(path, value, true);
}
}
});Polymer({
is: 'dom-bind',
properties: { notifyDomChange: { type: Boolean } },
extends: 'template',
_template: null,
created: function () {
var self = this;
Polymer.RenderStatus.whenReady(function () {
if (document.readyState == 'loading') {
document.addEventListener('DOMContentLoaded', function () {
self._markImportsReady();
});
} else {
self._markImportsReady();
}
});
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var refNode;
var parentNode = Polymer.dom(this).parentNode;
if (parentNode.localName == this.is) {
refNode = parentNode;
parentNode = Polymer.dom(parentNode).parentNode;
} else {
refNode = this;
}
Polymer.dom(parentNode).insertBefore(this.root, refNode);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_configureInstanceProperties: function () {
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
var setupConfigure = this._setupConfigure;
this._setupConfigure = function () {
setupConfigure.call(this, config);
};
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
this._prepPropertyInfo();
Polymer.Base._initFeatures.call(this);
this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);
}
this._insertChildren();
if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
this.fire('dom-change');
}
}
});

'use strict';

if (!Polymer.Settings.useNativeShadow) {
  tr.showPanic('Polymer error', 'base only works in shadow mode');
}


'use strict';

/**
 * @fileoverview Provides the Settings object.
 */
tr.exportTo('tr.b', function() {
  /**
   * Settings is a simple wrapper around local storage, to make it easier
   * to test classes that have settings.
   *
   * May be called as new tr.b.Settings() or simply tr.b.Settings()
   * @constructor
   */
  function Settings() {
    return Settings;
  }

  if (tr.b.unittest && tr.b.unittest.TestRunner) {
    tr.b.unittest.TestRunner.addEventListener(
        'tr-unittest-will-run',
        function() {
          if (tr.isHeadless) {
            Settings.setAlternativeStorageInstance(new HeadlessStorage());
          } else {
            Settings.setAlternativeStorageInstance(global.sessionStorage);
            global.sessionStorage.clear();
          }
        });
  }

  function SessionSettings() {
    return SessionSettings;
  }

  function AddStaticStorageFunctionsToClass_(inputClass, storage) {
    inputClass.storage_ = storage;

    /**
     * Get the setting with the given name.
     *
     * @param {string} key The name of the setting.
     * @param {string=} opt_default The default value to return if not set.
     * @param {string=} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    inputClass.get = function(key, opt_default, opt_namespace) {
      key = inputClass.namespace_(key, opt_namespace);
      const rawVal = inputClass.storage_.getItem(key);
      if (rawVal === null || rawVal === undefined) {
        return opt_default;
      }

      // Old settings versions used to stringify objects instead of putting them
      // into JSON. If those are encountered, parse will fail. In that case,
      // "upgrade" the setting to the default value.
      try {
        return JSON.parse(rawVal).value;
      } catch (e) {
        inputClass.storage_.removeItem(key);
        return opt_default;
      }
    };

    /**
     * Set the setting with the given name to the given value.
     *
     * @param {string} key The name of the setting.
     * @param {string} value The value of the setting.
     * @param {string=} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    inputClass.set = function(key, value, opt_namespace) {
      if (value === undefined) {
        throw new Error('Settings.set: value must not be undefined');
      }
      const v = JSON.stringify({value});
      inputClass.storage_.setItem(
          inputClass.namespace_(key, opt_namespace), v);
    };

    /**
     * Return a list of all the keys, or all the keys in the given namespace
     * if one is provided.
     *
     * @param {string=} opt_namespace If set, only return settings which
     * begin with this prefix.
     */
    inputClass.keys = function(opt_namespace) {
      const result = [];
      opt_namespace = opt_namespace || '';
      for (let i = 0; i < inputClass.storage_.length; i++) {
        const key = inputClass.storage_.key(i);
        if (inputClass.isnamespaced_(key, opt_namespace)) {
          result.push(inputClass.unnamespace_(key, opt_namespace));
        }
      }
      return result;
    };

    inputClass.isnamespaced_ = function(key, opt_namespace) {
      return key.indexOf(inputClass.normalize_(opt_namespace)) === 0;
    };

    inputClass.namespace_ = function(key, opt_namespace) {
      return inputClass.normalize_(opt_namespace) + key;
    };

    inputClass.unnamespace_ = function(key, opt_namespace) {
      return key.replace(inputClass.normalize_(opt_namespace), '');
    };

    /**
     * All settings are prefixed with a global namespace to avoid collisions.
     * inputClass may also be namespaced with an additional prefix passed into
     * the get, set, and keys methods in order to group related settings.
     * This method makes sure the two namespaces are always set properly.
     */
    inputClass.normalize_ = function(opt_namespace) {
      return inputClass.NAMESPACE + (opt_namespace ? opt_namespace + '.' : '');
    };

    inputClass.setAlternativeStorageInstance = function(instance) {
      inputClass.storage_ = instance;
    };

    inputClass.getAlternativeStorageInstance = function() {
      if (!tr.isHeadless && inputClass.storage_ === localStorage) {
        return undefined;
      }
      return inputClass.storage_;
    };

    inputClass.NAMESPACE = 'trace-viewer';
  }

  function HeadlessStorage() {
    this.length = 0;
    this.hasItem_ = {};
    this.items_ = {};
    this.itemsAsArray_ = undefined;
  }
  HeadlessStorage.prototype = {
    key(index) {
      return this.itemsAsArray[index];
    },

    get itemsAsArray() {
      if (this.itemsAsArray_ !== undefined) {
        return this.itemsAsArray_;
      }
      const itemsAsArray = [];
      for (const k in this.items_) {
        itemsAsArray.push(k);
      }
      this.itemsAsArray_ = itemsAsArray;
      return this.itemsAsArray_;
    },

    getItem(key) {
      if (!this.hasItem_[key]) {
        return null;
      }
      return this.items_[key];
    },

    removeItem(key) {
      if (!this.hasItem_[key]) {
        return;
      }
      const value = this.items_[key];
      delete this.hasItem_[key];
      delete this.items_[key];
      this.length--;
      this.itemsAsArray_ = undefined;
      return value;
    },

    setItem(key, value) {
      if (this.hasItem_[key]) {
        this.items_[key] = value;
        return;
      }
      this.items_[key] = value;
      this.hasItem_[key] = true;
      this.length++;
      this.itemsAsArray_ = undefined;
      return value;
    }
  };

  if (tr.isHeadless) {
    AddStaticStorageFunctionsToClass_(Settings, new HeadlessStorage());
    AddStaticStorageFunctionsToClass_(SessionSettings, new HeadlessStorage());
  } else {
    AddStaticStorageFunctionsToClass_(Settings, localStorage);
    AddStaticStorageFunctionsToClass_(SessionSettings, sessionStorage);
  }

  return {
    Settings,
    SessionSettings,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const URL_REGEX = /^(https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b|file:\/\/)([-a-zA-Z0-9@:%_\+.~#?&//=]*)$/;  // eslint-disable-line max-len

  function deepCopy(value) {
    if (!(value instanceof Object)) {
      if (value === undefined || value === null) return value;
      if (typeof value === 'string') return value.substring();
      if (typeof value === 'boolean') return value;
      if (typeof value === 'number') return value;
      throw new Error('Unrecognized: ' + typeof value);
    }

    const object = value;
    if (object instanceof Array) {
      const res = new Array(object.length);
      for (let i = 0; i < object.length; i++) {
        res[i] = deepCopy(object[i]);
      }
      return res;
    }

    if (object.__proto__ !== Object.prototype) {
      throw new Error('Can only clone simple types');
    }
    const res = {};
    for (const key in object) {
      res[key] = deepCopy(object[key]);
    }
    return res;
  }

  function normalizeException(e) {
    if (e === undefined || e === null) {
      return {
        typeName: 'UndefinedError',
        message: 'Unknown: null or undefined exception',
        stack: 'Unknown'
      };
    }

    if (typeof(e) === 'string') {
      return {
        typeName: 'StringError',
        message: e,
        stack: [e]
      };
    }

    let typeName;
    if (e.name) {
      typeName = e.name;
    } else if (e.constructor) {
      if (e.constructor.name) {
        typeName = e.constructor.name;
      } else {
        typeName = 'AnonymousError';
      }
    } else {
      typeName = 'ErrorWithNoConstructor';
    }

    const msg = e.message ? e.message : 'Unknown';
    return {
      typeName,
      message: msg,
      stack: e.stack ? e.stack : [msg]
    };
  }

  function stackTraceAsString() {
    return new Error().stack + '';
  }
  function stackTrace() {
    let stack = stackTraceAsString();
    stack = stack.split('\n');
    return stack.slice(2);
  }

  function getUsingPath(path, fromDict) {
    const parts = path.split('.');
    let cur = fromDict;

    for (let part; parts.length && (part = parts.shift());) {
      if (!parts.length) {
        return cur[part];
      } else if (part in cur) {
        cur = cur[part];
      } else {
        return undefined;
      }
    }
    return undefined;
  }

  /**
   * Format date as a string "YYYY-MM-DD HH:mm:ss". The timezone is implicitly
   * UTC. This format is based on the ISO format, but without milliseconds and
   * the 'T' is replaced with a space for legibility.
   *
   * @param {!Date} date
   * @return {string}
   */
  function formatDate(date) {
    return date.toISOString().replace('T', ' ').slice(0, 19);
  }

  /**
   * Infinity and NaN are left out of JSON for security reasons that do not
   * apply to our use cases. This helper function allows serializing them
   * independently of null.
   *
   * @param {!number} n
   * @return {!(number|string)}
   */
  function numberToJson(n) {
    if (isNaN(n)) return 'NaN';
    if (n === Infinity) return 'Infinity';
    if (n === -Infinity) return '-Infinity';
    return n;
  }

  /**
   * Infinity and NaN are left out of JSON for security reasons that do not
   * apply to our use cases. This helper function allows deserializing them
   * independently of null.
   *
   * @param {!(number|string)} n
   * @return {!number}
   */
  function numberFromJson(n) {
    if (n === 'NaN' || n === null) return NaN;
    if (n === 'Infinity') return Infinity;
    if (n === '-Infinity') return -Infinity;
    return n;
  }

  /**
   * @param {Array.<T>} ary
   * @returns {Array.<Object.<T, number>>} The run length encoding of the array
   * as an array of {value, count} objects.
   * @template T
   */
  function runLengthEncoding(ary) {
    const encodedArray = [];
    for (const element of ary) {
      if (encodedArray.length === 0 ||
          encodedArray[encodedArray.length - 1].value !== element) {
        encodedArray.push({
          value: element,
          count: 1,
        });
      } else {
        encodedArray[encodedArray.length - 1].count += 1;
      }
    }
    return encodedArray;
  }

  /**
   * @param {string} s
   * @return {boolean}
   */
  function isUrl(s) {
    return typeof(s) === 'string' && s.match(URL_REGEX) !== null;
  }

  /**
   * Returns the only element in the iterable. If the iterable is empty or has
   * more than one element, an error is thrown.
   */
  function getOnlyElement(iterable) {
    const iterator = iterable[Symbol.iterator]();

    const firstIteration = iterator.next();
    if (firstIteration.done) {
      throw new Error('getOnlyElement was passed an empty iterable.');
    }

    const secondIteration = iterator.next();
    if (!secondIteration.done) {
      throw new Error(
          'getOnlyElement was passed an iterable with multiple elements.');
    }

    return firstIteration.value;
  }

  /**
   * Returns the first element in the iterable. If the iterable is empty, an
   * error is thrown.
   */
  function getFirstElement(iterable) {
    const iterator = iterable[Symbol.iterator]();
    const result = iterator.next();
    if (result.done) {
      throw new Error('getFirstElement was passed an empty iterable.');
    }

    return result.value;
  }

  function compareArrays(x, y, elementCmp) {
    const minLength = Math.min(x.length, y.length);
    let i;
    for (i = 0; i < minLength; i++) {
      const tmp = elementCmp(x[i], y[i]);
      if (tmp) return tmp;
    }
    if (x.length === y.length) return 0;

    if (x[i] === undefined) return -1;

    return 1;
  }

  /**
   * Returns a new Map with items grouped by the return value of the
   * specified function being called on each item.
   * @param {!Array.<!*>} ary The array being iterated through
   * @param {!function(!*):!*} callback The mapping function between the array
   * value and the map key.
   * @param {*=} opt_this
   */
  function groupIntoMap(ary, callback, opt_this, opt_arrayConstructor) {
    const arrayConstructor = opt_arrayConstructor || Array;
    const results = new Map();
    for (const element of ary) {
      const key = callback.call(opt_this, element);
      let items = results.get(key);
      if (items === undefined) {
        items = new arrayConstructor();
        results.set(key, items);
      }
      items.push(element);
    }
    return results;
  }

  function inPlaceFilter(array, predicate, opt_this) {
    opt_this = opt_this || this;
    let nextPosition = 0;
    for (let i = 0; i < array.length; i++) {
      if (!predicate.call(opt_this, array[i], i)) continue;
      if (nextPosition < i) {
        array[nextPosition] = array[i];  // Move elements only if necessary.
      }
      nextPosition++;
    }

    if (nextPosition < array.length) {
      array.length = nextPosition;  // Truncate the array only if necessary.
    }
  }

  /**
   * Convert an array of dictionaries to a dictionary of arrays.
   *
   * The keys of the resulting dictionary are a union of the keys of all
   * dictionaries in the provided array. Each array in the resulting dictionary
   * has the same length as the provided array and contains the values of its
   * key in the dictionaries in the provided array. Example:
   *
   *   INPUT:
   *
   *     [
   *       {a: 6, b: 5      },
   *       undefined,
   *       {a: 4, b: 3, c: 2},
   *       {      b: 1, c: 0}
   *     ]
   *
   *   OUTPUT:
   *
   *     {
   *       a: [6,         undefined, 4, undefined],
   *       b: [5,         undefined, 3, 1        ],
   *       c: [undefined, undefined, 2, 0        ]
   *     }
   *
   * @param {!Array} array Array of items to be inverted. If opt_dictGetter
   *     is not provided, all elements of the array must be either undefined,
   *     or dictionaries.
   * @param {?(function(*): (!Object|undefined))=} opt_dictGetter Optional
   *     function mapping defined elements of array to dictionaries.
   * @param {*=} opt_this Optional 'this' context for opt_dictGetter.
   */
  function invertArrayOfDicts(array, opt_dictGetter, opt_this) {
    opt_this = opt_this || this;
    const result = {};
    for (let i = 0; i < array.length; i++) {
      const item = array[i];
      if (item === undefined) continue;
      const dict = opt_dictGetter ? opt_dictGetter.call(opt_this, item) : item;
      if (dict === undefined) continue;
      for (const key in dict) {
        let valueList = result[key];
        if (valueList === undefined) {
          result[key] = valueList = new Array(array.length);
        }
        valueList[i] = dict[key];
      }
    }
    return result;
  }

  function setsEqual(a, b) {
    if (!(a instanceof Set) || !(b instanceof Set)) return false;
    if (a.size !== b.size) return false;
    // Avoid Array.from() here -- it creates garbage.
    for (const x of a) {
      if (!b.has(x)) return false;
    }
    return true;
  }

  /**
   * Finds the first index in the array whose value is >= loVal.
   *
   * The key for the search is defined by the mapFn. This array must
   * be prearranged such that ary.map(mapFn) would also be sorted in
   * ascending order.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} loVal Value for which to search.
   * @return {Number} Offset o into ary where all ary[i] for i <= o
   *     are < loVal, or ary.length if loVal is greater than all elements in
   *     the array.
   */
  function findLowIndexInSortedArray(ary, mapFn, loVal) {
    if (ary.length === 0) return 1;

    let low = 0;
    let high = ary.length - 1;
    let i;
    let comparison;
    let hitPos = -1;
    while (low <= high) {
      i = Math.floor((low + high) / 2);
      comparison = mapFn(ary[i]) - loVal;
      if (comparison < 0) {
        low = i + 1; continue;
      } else if (comparison > 0) {
        high = i - 1; continue;
      } else {
        hitPos = i;
        high = i - 1;
      }
    }
    // return where we hit, or failing that the low pos
    return hitPos !== -1 ? hitPos : low;
  }

  // From devtools/front_end/platform/utilities.js upperBound
  function findHighIndexInSortedArray(ary, mapFn, loVal, hiVal) {
    let lo = loVal || 0;
    let hi = hiVal !== undefined ? hiVal : ary.length;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (mapFn(ary[mid]) >= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return hi;
  }

  /**
   * Finds an index in an array of intervals that either intersects
   * the provided loVal, or if no intersection is found, -1 or ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapWidthFn the width. Intersection is lower-inclusive, e.g. [lo,lo+w).
   *
   * The array of intervals formed by this mapping must be non-overlapping and
   * sorted in ascending order by loVal.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   *     interval represented by an  element in the array.
   * @param {number} loVal The low value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     loVal, -1 if none found and loVal is below than all the intervals,
   *     ary.length if loVal is greater than all the intervals.
   */
  function findIndexInSortedIntervals(ary, mapLoFn, mapWidthFn, loVal) {
    const first = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (first === 0) {
      if (loVal >= mapLoFn(ary[0]) &&
          loVal < mapLoFn(ary[0]) + mapWidthFn(ary[0], 0)) {
        return 0;
      }
      return -1;
    }

    if (first < ary.length) {
      if (loVal >= mapLoFn(ary[first]) &&
          loVal < mapLoFn(ary[first]) + mapWidthFn(ary[first], first)) {
        return first;
      }
      if (loVal >= mapLoFn(ary[first - 1]) &&
          loVal < mapLoFn(ary[first - 1]) +
          mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      }
      return ary.length;
    }

    if (first === ary.length) {
      if (loVal >= mapLoFn(ary[first - 1]) &&
          loVal < mapLoFn(ary[first - 1]) +
          mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      }
      return ary.length;
    }

    return ary.length;
  }

  /**
   * Finds an index in an array of sorted closed intervals that either
   * intersects the provided val, or if no intersection is found, -1 or
   *  ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapHiFn the high. Intersection is closed, e.g. [lo,hi], unlike with
   * findIndexInSortedIntervals, which is right-open.
   *
   * The array of intervals formed by this mapping must be non-overlapping, and
   * sorted in ascending order by val.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an  element in the array.
   * @param {number} val The value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     val, -1 if none found and val is below than all the intervals,
   *     ary.length if val is greater than all the intervals.
   */
  function findIndexInSortedClosedIntervals(ary, mapLoFn, mapHiFn, val) {
    const i = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (i === 0) {
      if (val >= mapLoFn(ary[0], 0) &&
          val <= mapHiFn(ary[0], 0)) {
        return 0;
      }
      return -1;
    }

    if (i < ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) &&
          val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      }
      if (val >= mapLoFn(ary[i], i) &&
          val <= mapHiFn(ary[i], i)) {
        return i;
      }
      return ary.length;
    }

    if (i === ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) &&
          val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      }
      return ary.length;
    }

    return ary.length;
  }

  /**
   * Calls cb for all intervals in the implicit array of intervals
   * defnied by ary, mapLoFn and mapHiFn that intersect the range
   * [loVal,hiVal)
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   * nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   * interval represented by an element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   * interval represented by an element in the array.
   * @param {number} loVal The low value for the search, inclusive.
   * @param {number} hiVal The high value for the search, non inclusive.
   * @param {function():*} cb The function to run for intersecting intervals.
   */
  function iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal,
      hiVal, cb) {
    if (ary.length === 0) return;

    if (loVal > hiVal) return;

    let i = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (i === -1) {
      return;
    }
    if (i > 0) {
      const hi = mapLoFn(ary[i - 1]) + mapWidthFn(ary[i - 1], i - 1);
      if (hi >= loVal) {
        cb(ary[i - 1], i - 1);
      }
    }
    if (i === ary.length) {
      return;
    }

    for (let n = ary.length; i < n; i++) {
      const lo = mapLoFn(ary[i]);
      if (lo >= hiVal) break;
      cb(ary[i], i);
    }
  }

  /**
   * Finds the element in the array whose value is closest to |val|.
   *
   * The same restrictions on sortedness as for findLowIndexInSortedArray apply.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} val Value for which to search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an element's value.
   * @return {object} Object in the array whose value is closest to |val|, or
   *     null if no object is within range.
   */
  function findClosestElementInSortedArray(ary, mapFn, val, maxDiff) {
    if (ary.length === 0) return null;

    let aftIdx = findLowIndexInSortedArray(ary, mapFn, val);
    const befIdx = aftIdx > 0 ? aftIdx - 1 : 0;

    if (aftIdx === ary.length) aftIdx -= 1;

    const befDiff = Math.abs(val - mapFn(ary[befIdx]));
    const aftDiff = Math.abs(val - mapFn(ary[aftIdx]));

    if (befDiff > maxDiff && aftDiff > maxDiff) return null;

    const idx = befDiff < aftDiff ? befIdx : aftIdx;
    return ary[idx];
  }

  /**
   * Finds the closest interval in the implicit array of intervals
   * defined by ary, mapLoFn and mapHiFn.
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapHiFn.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an element in the array.
   * @param {number} val The value for the search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an interval's low or high value.
   * @return {interval} Interval in the array whose high or low value is closest
   *     to |val|, or null if no interval is within range.
   */
  function findClosestIntervalInSortedIntervals(ary, mapLoFn, mapHiFn, val,
      maxDiff) {
    if (ary.length === 0) return null;

    let idx = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (idx > 0) idx -= 1;

    const hiInt = ary[idx];
    let loInt = hiInt;

    if (val > mapHiFn(hiInt) && idx + 1 < ary.length) {
      loInt = ary[idx + 1];
    }

    const loDiff = Math.abs(val - mapLoFn(loInt));
    const hiDiff = Math.abs(val - mapHiFn(hiInt));

    if (loDiff > maxDiff && hiDiff > maxDiff) return null;

    if (loDiff < hiDiff) return loInt;

    return hiInt;
  }

  return {
    compareArrays,
    deepCopy,
    findClosestElementInSortedArray,
    findClosestIntervalInSortedIntervals,
    findHighIndexInSortedArray,
    findIndexInSortedClosedIntervals,
    findIndexInSortedIntervals,
    findLowIndexInSortedArray,
    formatDate,
    getFirstElement,
    getOnlyElement,
    getUsingPath,
    groupIntoMap,
    inPlaceFilter,
    invertArrayOfDicts,
    isUrl,
    iterateOverIntersectingIntervals,
    normalizeException,
    numberFromJson,
    numberToJson,
    runLengthEncoding,
    setsEqual,
    stackTrace,
    stackTraceAsString,
  };
});


'use strict';

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */
tr.exportTo('tr.b', function() {
  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   */
  function EventTarget() {
  }
  EventTarget.decorate = function(target) {
    for (const k in EventTarget.prototype) {
      if (k === 'decorate') continue;
      const v = EventTarget.prototype[k];
      if (typeof v !== 'function') continue;
      target[k] = v;
    }
  };

  EventTarget.prototype = {

    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event. This is called when the event is dispatched.
     */
    addEventListener(type, handler) {
      if (!this.listeners_) {
        this.listeners_ = Object.create(null);
      }
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        const handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0) {
          handlers.push(handler);
        }
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event.
     */
    removeEventListener(type, handler) {
      if (!this.listeners_) return;
      if (type in this.listeners_) {
        const handlers = this.listeners_[type];
        const index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length === 1) {
            delete this.listeners_[type];
          } else {
            handlers.splice(index, 1);
          }
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!cr.event.Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent(event) {
      if (!this.listeners_) return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      event.__defineGetter__('target', () => this);
      const realPreventDefault = event.preventDefault;
      event.preventDefault = function() {
        realPreventDefault.call(this);
        this.rawReturnValue = false;
      };

      const type = event.type;
      let prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        const handlers = this.listeners_[type].concat();
        for (let i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent) {
            prevented |= handler.handleEvent.call(handler, event) === false;
          } else {
            prevented |= handler.call(this, event) === false;
          }
        }
      }

      return !prevented && event.rawReturnValue;
    },

    async dispatchAsync(event) {
      if (!this.listeners_) return true;

      const listeners = this.listeners_[event.type];
      if (listeners === undefined) return;

      // Clone to prevent removal during dispatch
      await Promise.all(listeners.slice().map(listener => {
        if (listener.handleEvent) {
          return listener.handleEvent.call(listener, event);
        }
        return listener.call(this, event);
      }));
    },

    hasEventListener(type) {
      return (this.listeners_ !== undefined &&
              this.listeners_[type] !== undefined);
    }
  };

  return {
    EventTarget,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function RegisteredTypeInfo(constructor, metadata) {
    this.constructor = constructor;
    this.metadata = metadata;
  }

  const BASIC_REGISTRY_MODE = 'BASIC_REGISTRY_MODE';
  const TYPE_BASED_REGISTRY_MODE = 'TYPE_BASED_REGISTRY_MODE';
  const ALL_MODES = {BASIC_REGISTRY_MODE: true, TYPE_BASED_REGISTRY_MODE: true};

  function ExtensionRegistryOptions(mode) {
    if (mode === undefined) {
      throw new Error('Mode is required');
    }
    if (!ALL_MODES[mode]) {
      throw new Error('Not a mode.');
    }

    this.mode_ = mode;
    this.defaultMetadata_ = {};
    this.defaultConstructor_ = undefined;
    this.defaultTypeInfo_ = undefined;
    this.frozen_ = false;
  }
  ExtensionRegistryOptions.prototype = {
    freeze() {
      if (this.frozen_) {
        throw new Error('Frozen');
      }
      this.frozen_ = true;
    },

    get mode() {
      return this.mode_;
    },

    get defaultMetadata() {
      return this.defaultMetadata_;
    },

    set defaultMetadata(defaultMetadata) {
      if (this.frozen_) {
        throw new Error('Frozen');
      }
      this.defaultMetadata_ = defaultMetadata;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultConstructor() {
      return this.defaultConstructor_;
    },

    set defaultConstructor(defaultConstructor) {
      if (this.frozen_) {
        throw new Error('Frozen');
      }
      this.defaultConstructor_ = defaultConstructor;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultTypeInfo() {
      if (this.defaultTypeInfo_ === undefined && this.defaultConstructor_) {
        this.defaultTypeInfo_ = new RegisteredTypeInfo(
            this.defaultConstructor,
            this.defaultMetadata);
      }
      return this.defaultTypeInfo_;
    },

    validateConstructor(constructor) {
      if (!this.mandatoryBaseClass) return;
      let curProto = constructor.prototype.__proto__;
      let ok = false;
      while (curProto) {
        if (curProto === this.mandatoryBaseClass.prototype) {
          ok = true;
          break;
        }
        curProto = curProto.__proto__;
      }
      if (!ok) {
        throw new Error(constructor + 'must be subclass of ' + registry);
      }
    }
  };

  return {
    BASIC_REGISTRY_MODE,
    TYPE_BASED_REGISTRY_MODE,

    ExtensionRegistryOptions,
    RegisteredTypeInfo,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  let Event;
  if (tr.isHeadless) {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function HeadlessEvent(type, opt_bubbles, opt_preventable) {
      this.type = type;
      this.bubbles = (opt_bubbles !== undefined ?
          !!opt_bubbles : false);
      this.cancelable = (opt_preventable !== undefined ?
          !!opt_preventable : false);

      this.defaultPrevented = false;
      this.cancelBubble = false;
    }

    HeadlessEvent.prototype = {
      preventDefault() {
        this.defaultPrevented = true;
      },

      stopPropagation() {
        this.cancelBubble = true;
      }
    };
    Event = HeadlessEvent;
  } else {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function TrEvent(type, opt_bubbles, opt_preventable) {
      const e = tr.doc.createEvent('Event');
      e.initEvent(type, !!opt_bubbles, !!opt_preventable);
      e.__proto__ = global.Event.prototype;
      return e;
    }

    TrEvent.prototype = {
      __proto__: global.Event.prototype
    };
    Event = TrEvent;
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented.
   * @param {!Object=} opt_fields
   *
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable,
      opt_fields) {
    const e = new tr.b.Event(type, opt_bubbles, opt_cancelable);
    Object.assign(e, opt_fields);
    return target.dispatchEvent(e);
  }

  async function dispatchSimpleEventAsync(target, type, opt_fields) {
    const e = new tr.b.Event(type, false, false);
    Object.assign(e, opt_fields);
    return await target.dispatchAsync(e);
  }

  return {
    Event,
    dispatchSimpleEvent,
    dispatchSimpleEventAsync,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  const ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

  function decorateBasicExtensionRegistry(registry, extensionRegistryOptions) {
    const savedStateStack = [];
    registry.registeredTypeInfos_ = [];

    registry.register = function(constructor,
        opt_metadata) {
      if (registry.findIndexOfRegisteredConstructor(
          constructor) !== undefined) {
        throw new Error('Handler already registered for ' + constructor);
      }

      extensionRegistryOptions.validateConstructor(constructor);

      const metadata = {};
      for (const k in extensionRegistryOptions.defaultMetadata) {
        metadata[k] = extensionRegistryOptions.defaultMetadata[k];
      }
      if (opt_metadata) {
        for (const k in opt_metadata) {
          metadata[k] = opt_metadata[k];
        }
      }

      const typeInfo = new RegisteredTypeInfo(
          constructor,
          metadata);

      let e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      registry.registeredTypeInfos_.push(typeInfo);

      e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function() {
      savedStateStack.push(registry.registeredTypeInfos_);
      registry.registeredTypeInfos_ = [];

      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };
    registry.popCleanStateAfterTest = function() {
      registry.registeredTypeInfos_ = savedStateStack[0];
      savedStateStack.splice(0, 1);

      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.findIndexOfRegisteredConstructor = function(constructor) {
      for (let i = 0; i < registry.registeredTypeInfos_.length; i++) {
        if (registry.registeredTypeInfos_[i].constructor === constructor) {
          return i;
        }
      }
      return undefined;
    };

    registry.unregister = function(constructor) {
      const foundIndex = registry.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex === undefined) {
        throw new Error(constructor + ' not registered');
      }
      registry.registeredTypeInfos_.splice(foundIndex, 1);

      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getAllRegisteredTypeInfos = function() {
      return registry.registeredTypeInfos_;
    };

    registry.findTypeInfo = function(constructor) {
      const foundIndex = this.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex !== undefined) {
        return this.registeredTypeInfos_[foundIndex];
      }
      return undefined;
    };

    registry.findTypeInfoMatching = function(predicate, opt_this) {
      opt_this = opt_this ? opt_this : undefined;
      for (let i = 0; i < registry.registeredTypeInfos_.length; ++i) {
        const typeInfo = registry.registeredTypeInfos_[i];
        if (predicate.call(opt_this, typeInfo)) {
          return typeInfo;
        }
      }
      return extensionRegistryOptions.defaultTypeInfo;
    };

    registry.findTypeInfoWithName = function(name) {
      if (typeof(name) !== 'string') {
        throw new Error('Name is not a string.');
      }
      const typeInfo = registry.findTypeInfoMatching(function(ti) {
        return ti.constructor.name === name;
      });
      if (typeInfo) return typeInfo;
      return undefined;
    };
  }

  return {
    _decorateBasicExtensionRegistry: decorateBasicExtensionRegistry
  };
});


'use strict';

/**
 * @fileoverview Helper code for working with tracing categories.
 *
 */
tr.exportTo('tr.b', function() {
  // Cached values for getCategoryParts.
  const categoryPartsFor = {};

  /**
   * Categories are stored in comma-separated form, e.g: 'a,b' meaning
   * that the event is part of the a and b category.
   *
   * This function returns the category split by string, caching the
   * array for performance.
   *
   * Do not mutate the returned array!!!!
   */
  function getCategoryParts(category) {
    let parts = categoryPartsFor[category];
    if (parts !== undefined) return parts;
    parts = category.split(',');
    categoryPartsFor[category] = parts;
    return parts;
  }

  return {
    getCategoryParts,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const getCategoryParts = tr.b.getCategoryParts;

  const RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  const ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;


  function decorateTypeBasedExtensionRegistry(registry,
      extensionRegistryOptions) {
    const savedStateStack = [];

    registry.registeredTypeInfos_ = [];

    registry.categoryPartToTypeInfoMap_ = new Map();
    registry.typeNameToTypeInfoMap_ = new Map();

    registry.register = function(constructor,
        metadata) {
      extensionRegistryOptions.validateConstructor(constructor);

      const typeInfo = new RegisteredTypeInfo(
          constructor,
          metadata || extensionRegistryOptions.defaultMetadata);

      typeInfo.typeNames = [];
      typeInfo.categoryParts = [];
      if (metadata && metadata.typeName) {
        typeInfo.typeNames.push(metadata.typeName);
      }
      if (metadata && metadata.typeNames) {
        typeInfo.typeNames.push.apply(
            typeInfo.typeNames, metadata.typeNames);
      }
      if (metadata && metadata.categoryParts) {
        typeInfo.categoryParts.push.apply(
            typeInfo.categoryParts, metadata.categoryParts);
      }

      if (typeInfo.typeNames.length === 0 &&
          typeInfo.categoryParts.length === 0) {
        throw new Error('typeName or typeNames must be provided');
      }

      // Sanity checks...
      typeInfo.typeNames.forEach(function(typeName) {
        if (registry.typeNameToTypeInfoMap_.has(typeName)) {
          throw new Error('typeName ' + typeName + ' already registered');
        }
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        if (registry.categoryPartToTypeInfoMap_.has(categoryPart)) {
          throw new Error('categoryPart ' + categoryPart +
                          ' already registered');
        }
      });

      let e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      // Actual registration.
      typeInfo.typeNames.forEach(function(typeName) {
        registry.typeNameToTypeInfoMap_.set(typeName, typeInfo);
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        registry.categoryPartToTypeInfoMap_.set(categoryPart, typeInfo);
      });
      registry.registeredTypeInfos_.push(typeInfo);

      e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function() {
      savedStateStack.push({
        registeredTypeInfos: registry.registeredTypeInfos_,
        typeNameToTypeInfoMap: registry.typeNameToTypeInfoMap_,
        categoryPartToTypeInfoMap: registry.categoryPartToTypeInfoMap_
      });
      registry.registeredTypeInfos_ = [];
      registry.typeNameToTypeInfoMap_ = new Map();
      registry.categoryPartToTypeInfoMap_ = new Map();
      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.popCleanStateAfterTest = function() {
      const state = savedStateStack[0];
      savedStateStack.splice(0, 1);

      registry.registeredTypeInfos_ = state.registeredTypeInfos;
      registry.typeNameToTypeInfoMap_ = state.typeNameToTypeInfoMap;
      registry.categoryPartToTypeInfoMap_ = state.categoryPartToTypeInfoMap;
      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.unregister = function(constructor) {
      let typeInfoIndex = -1;
      for (let i = 0; i < registry.registeredTypeInfos_.length; i++) {
        if (registry.registeredTypeInfos_[i].constructor === constructor) {
          typeInfoIndex = i;
          break;
        }
      }
      if (typeInfoIndex === -1) {
        throw new Error(constructor + ' not registered');
      }

      const typeInfo = registry.registeredTypeInfos_[typeInfoIndex];
      registry.registeredTypeInfos_.splice(typeInfoIndex, 1);
      typeInfo.typeNames.forEach(function(typeName) {
        registry.typeNameToTypeInfoMap_.delete(typeName);
      });
      typeInfo.categoryParts.forEach(function(categoryPart) {
        registry.categoryPartToTypeInfoMap_.delete(categoryPart);
      });
      const e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getTypeInfo = function(category, typeName) {
      if (category) {
        const categoryParts = getCategoryParts(category);
        for (let i = 0; i < categoryParts.length; i++) {
          const categoryPart = categoryParts[i];
          const typeInfo = registry.categoryPartToTypeInfoMap_.get(
              categoryPart);
          if (typeInfo !== undefined) return typeInfo;
        }
      }
      const typeInfo = registry.typeNameToTypeInfoMap_.get(typeName);
      if (typeInfo !== undefined) return typeInfo;

      return extensionRegistryOptions.defaultTypeInfo;
    };

    // TODO(nduca): Remove or rename.
    registry.getConstructor = function(category, typeName) {
      const typeInfo = registry.getTypeInfo(category, typeName);
      if (typeInfo) return typeInfo.constructor;
      return undefined;
    };
  }

  return {
    _decorateTypeBasedExtensionRegistry: decorateTypeBasedExtensionRegistry
  };
});


'use strict';

/**
 * @fileoverview Helper code for defining extension registries, which can be
 * used to make a part of trace-viewer extensible.
 *
 * This file provides two basic types of extension registries:
 * - Generic: register a type with metadata, query for those types based on
 *            a predicate
 *
 * - TypeName-based: register a type that handles some combination
 *                   of tracing categories or typeNames, then query
 *                   for it based on a category, typeName or both.
 *
 * When you register subtypes, you pass the constructor for the
 * subtype, and any metadata you want associated with the subtype. Use metadata
 * instead of stuffing fields onto the constructor. E.g.:
 *     registry.register(MySubclass, {titleWhenShownInTabStrip: 'MySub'})
 *
 * Some registries want a default object that is returned when a more precise
 * subtype has not been registered. To provide one, set the defaultConstructor
 * option on the registry options.
 *
 * TODO: Extension registry used to make reference to mandatoryBaseType but it
 * was never enforced. We may want to add it back in the future in order to
 * enforce the types that can be put into a given registry.
 */
tr.exportTo('tr.b', function() {
  function decorateExtensionRegistry(registry, registryOptions) {
    if (registry.register) {
      throw new Error('Already has registry');
    }

    registryOptions.freeze();
    if (registryOptions.mode === tr.b.BASIC_REGISTRY_MODE) {
      tr.b._decorateBasicExtensionRegistry(registry, registryOptions);
    } else if (registryOptions.mode === tr.b.TYPE_BASED_REGISTRY_MODE) {
      tr.b._decorateTypeBasedExtensionRegistry(registry, registryOptions);
    } else {
      throw new Error('Unrecognized mode');
    }

    // Make it an event target.
    if (registry.addEventListener === undefined) {
      tr.b.EventTarget.decorate(registry);
    }
  }

  return {
    decorateExtensionRegistry,
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function ScriptingObject() {
  }

  ScriptingObject.prototype = {
    onModelChanged(model) {
    }
  };

  return {
    ScriptingObject,
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function ScriptingController(brushingStateController) {
    this.brushingStateController_ = brushingStateController;
    this.scriptObjectNames_ = [];
    this.scriptObjectValues_ = [];
    this.brushingStateController.addEventListener(
        'model-changed', this.onModelChanged_.bind(this));

    // Register all scripting objects.
    const typeInfos = ScriptingObjectRegistry.getAllRegisteredTypeInfos();
    typeInfos.forEach(function(typeInfo) {
      this.addScriptObject(typeInfo.metadata.name, typeInfo.constructor);
      // Also make the object available to the DevTools inspector.
      global[typeInfo.metadata.name] = typeInfo.constructor;
    }, this);
  }

  function ScriptingObjectRegistry() {
  }
  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(ScriptingObjectRegistry, options);

  ScriptingController.prototype = {
    get brushingStateController() {
      return this.brushingStateController_;
    },

    onModelChanged_() {
      this.scriptObjectValues_.forEach(function(v) {
        if (v.onModelChanged) {
          v.onModelChanged(this.brushingStateController.model);
        }
      }, this);
    },

    addScriptObject(name, value) {
      this.scriptObjectNames_.push(name);
      this.scriptObjectValues_.push(value);
    },

    executeCommand(command) {
      const f = new Function(
          this.scriptObjectNames_, 'return eval(' + command + ')');
      return f.apply(null, this.scriptObjectValues_);
    }
  };

  return {
    ScriptingController,
    ScriptingObjectRegistry,
  };
});

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.1
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define(n);else{var r=n();for(var a in r)("object"==typeof exports?exports:t)[a]=r[a]}}(this,function(){return function(t){function n(a){if(r[a])return r[a].exports;var e=r[a]={exports:{},id:a,loaded:!1};return t[a].call(e.exports,e,e.exports,n),e.loaded=!0,e.exports}var r={};return n.m=t,n.c=r,n.p="",n(0)}([function(t,n,r){n.glMatrix=r(1),n.mat2=r(2),n.mat2d=r(3),n.mat3=r(4),n.mat4=r(5),n.quat=r(6),n.vec2=r(9),n.vec3=r(7),n.vec4=r(8)},function(t,n,r){var a={};a.EPSILON=1e-6,a.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,a.RANDOM=Math.random,a.setMatrixArrayType=function(t){GLMAT_ARRAY_TYPE=t};var e=Math.PI/180;a.toRadian=function(t){return t*e},t.exports=a},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},e.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1];t[1]=n[2],t[2]=r}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*u-e*a;return o?(o=1/o,t[0]=u*o,t[1]=-a*o,t[2]=-e*o,t[3]=r*o,t):null},e.adjoint=function(t,n){var r=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=r,t},e.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1],f=r[2],s=r[3];return t[0]=a*i+u*c,t[1]=e*i+o*c,t[2]=a*f+u*s,t[3]=e*f+o*s,t},e.mul=e.multiply,e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+u*i,t[1]=e*c+o*i,t[2]=a*-i+u*c,t[3]=e*-i+o*c,t},e.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1];return t[0]=a*i,t[1]=e*i,t[2]=u*c,t[3]=o*c,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},e.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},e.LDU=function(t,n,r,a){return t[2]=a[2]/a[0],r[0]=a[0],r[1]=a[1],r[3]=a[3]-t[2]*r[1],[t,n,r]},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(6);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=r*u-a*e;return c?(c=1/c,t[0]=u*c,t[1]=-a*c,t[2]=-e*c,t[3]=r*c,t[4]=(e*i-u*o)*c,t[5]=(a*o-r*i)*c,t):null},e.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1],h=r[2],M=r[3],l=r[4],v=r[5];return t[0]=a*f+u*s,t[1]=e*f+o*s,t[2]=a*h+u*M,t[3]=e*h+o*M,t[4]=a*l+u*v+i,t[5]=e*l+o*v+c,t},e.mul=e.multiply,e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=Math.sin(r),s=Math.cos(r);return t[0]=a*s+u*f,t[1]=e*s+o*f,t[2]=a*-f+u*s,t[3]=e*-f+o*s,t[4]=i,t[5]=c,t},e.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1];return t[0]=a*f,t[1]=e*f,t[2]=u*s,t[3]=o*s,t[4]=i,t[5]=c,t},e.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=r[0],s=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=a*f+u*s+i,t[5]=e*f+o*s+c,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t[4]=0,t[5]=0,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},e.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromMat4=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},e.clone=function(t){var n=new a.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[5];t[1]=n[3],t[2]=n[6],t[3]=r,t[5]=n[7],t[6]=a,t[7]=e}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=s*o-i*f,M=-s*u+i*c,l=f*u-o*c,v=r*h+a*M+e*l;return v?(v=1/v,t[0]=h*v,t[1]=(-s*a+e*f)*v,t[2]=(i*a-e*o)*v,t[3]=M*v,t[4]=(s*r-e*c)*v,t[5]=(-i*r+e*u)*v,t[6]=l*v,t[7]=(-f*r+a*c)*v,t[8]=(o*r-a*u)*v,t):null},e.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8];return t[0]=o*s-i*f,t[1]=e*f-a*s,t[2]=a*i-e*o,t[3]=i*c-u*s,t[4]=r*s-e*c,t[5]=e*u-r*i,t[6]=u*f-o*c,t[7]=a*c-r*f,t[8]=r*o-a*u,t},e.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],c=t[7],f=t[8];return n*(f*u-o*c)+r*(-f*e+o*i)+a*(c*e-u*i)},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=r[0],l=r[1],v=r[2],m=r[3],p=r[4],d=r[5],A=r[6],R=r[7],w=r[8];return t[0]=M*a+l*o+v*f,t[1]=M*e+l*i+v*s,t[2]=M*u+l*c+v*h,t[3]=m*a+p*o+d*f,t[4]=m*e+p*i+d*s,t[5]=m*u+p*c+d*h,t[6]=A*a+R*o+w*f,t[7]=A*e+R*i+w*s,t[8]=A*u+R*c+w*h,t},e.mul=e.multiply,e.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=r[0],l=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=c,t[6]=M*a+l*o+f,t[7]=M*e+l*i+s,t[8]=M*u+l*c+h,t},e.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=Math.sin(r),l=Math.cos(r);return t[0]=l*a+M*o,t[1]=l*e+M*i,t[2]=l*u+M*c,t[3]=l*o-M*a,t[4]=l*i-M*e,t[5]=l*c-M*u,t[6]=f,t[7]=s,t[8]=h,t},e.scale=function(t,n,r){var a=r[0],e=r[1];return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=e*n[3],t[4]=e*n[4],t[5]=e*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},e.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=-r,t[4]=a,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},e.fromMat2d=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},e.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,c=e+e,f=r*o,s=a*o,h=a*i,M=e*o,l=e*i,v=e*c,m=u*o,p=u*i,d=u*c;return t[0]=1-h-v,t[3]=s-d,t[6]=M+p,t[1]=s+d,t[4]=1-f-v,t[7]=l-m,t[2]=M-p,t[5]=l+m,t[8]=1-f-h,t},e.normalFromMat4=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15],A=r*i-a*o,R=r*c-e*o,w=r*f-u*o,q=a*c-e*i,Y=a*f-u*i,g=e*f-u*c,y=s*m-h*v,x=s*p-M*v,P=s*d-l*v,E=h*p-M*m,T=h*d-l*m,b=M*d-l*p,D=A*b-R*T+w*E+q*P-Y*x+g*y;return D?(D=1/D,t[0]=(i*b-c*T+f*E)*D,t[1]=(c*P-o*b-f*x)*D,t[2]=(o*T-i*P+f*y)*D,t[3]=(e*T-a*b-u*E)*D,t[4]=(r*b-e*P+u*x)*D,t[5]=(a*P-r*T-u*y)*D,t[6]=(m*g-p*Y+d*q)*D,t[7]=(p*w-v*g-d*R)*D,t[8]=(v*Y-m*w+d*A)*D,t):null},e.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.clone=function(t){var n=new a.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},e.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[3],u=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=r,t[6]=n[9],t[7]=n[13],t[8]=a,t[9]=u,t[11]=n[14],t[12]=e,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},e.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15],A=r*i-a*o,R=r*c-e*o,w=r*f-u*o,q=a*c-e*i,Y=a*f-u*i,g=e*f-u*c,y=s*m-h*v,x=s*p-M*v,P=s*d-l*v,E=h*p-M*m,T=h*d-l*m,b=M*d-l*p,D=A*b-R*T+w*E+q*P-Y*x+g*y;return D?(D=1/D,t[0]=(i*b-c*T+f*E)*D,t[1]=(e*T-a*b-u*E)*D,t[2]=(m*g-p*Y+d*q)*D,t[3]=(M*Y-h*g-l*q)*D,t[4]=(c*P-o*b-f*x)*D,t[5]=(r*b-e*P+u*x)*D,t[6]=(p*w-v*g-d*R)*D,t[7]=(s*g-M*w+l*R)*D,t[8]=(o*T-i*P+f*y)*D,t[9]=(a*P-r*T-u*y)*D,t[10]=(v*Y-m*w+d*A)*D,t[11]=(h*w-s*Y-l*A)*D,t[12]=(i*x-o*E-c*y)*D,t[13]=(r*E-a*x+e*y)*D,t[14]=(m*R-v*q-p*A)*D,t[15]=(s*q-h*R+M*A)*D,t):null},e.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],c=n[6],f=n[7],s=n[8],h=n[9],M=n[10],l=n[11],v=n[12],m=n[13],p=n[14],d=n[15];return t[0]=i*(M*d-l*p)-h*(c*d-f*p)+m*(c*l-f*M),t[1]=-(a*(M*d-l*p)-h*(e*d-u*p)+m*(e*l-u*M)),t[2]=a*(c*d-f*p)-i*(e*d-u*p)+m*(e*f-u*c),t[3]=-(a*(c*l-f*M)-i*(e*l-u*M)+h*(e*f-u*c)),t[4]=-(o*(M*d-l*p)-s*(c*d-f*p)+v*(c*l-f*M)),t[5]=r*(M*d-l*p)-s*(e*d-u*p)+v*(e*l-u*M),t[6]=-(r*(c*d-f*p)-o*(e*d-u*p)+v*(e*f-u*c)),t[7]=r*(c*l-f*M)-o*(e*l-u*M)+s*(e*f-u*c),t[8]=o*(h*d-l*m)-s*(i*d-f*m)+v*(i*l-f*h),t[9]=-(r*(h*d-l*m)-s*(a*d-u*m)+v*(a*l-u*h)),t[10]=r*(i*d-f*m)-o*(a*d-u*m)+v*(a*f-u*i),t[11]=-(r*(i*l-f*h)-o*(a*l-u*h)+s*(a*f-u*i)),t[12]=-(o*(h*p-M*m)-s*(i*p-c*m)+v*(i*M-c*h)),t[13]=r*(h*p-M*m)-s*(a*p-e*m)+v*(a*M-e*h),t[14]=-(r*(i*p-c*m)-o*(a*p-e*m)+v*(a*c-e*i)),t[15]=r*(i*M-c*h)-o*(a*M-e*h)+s*(a*c-e*i),t},e.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],c=t[7],f=t[8],s=t[9],h=t[10],M=t[11],l=t[12],v=t[13],m=t[14],p=t[15],d=n*o-r*u,A=n*i-a*u,R=n*c-e*u,w=r*i-a*o,q=r*c-e*o,Y=a*c-e*i,g=f*v-s*l,y=f*m-h*l,x=f*p-M*l,P=s*m-h*v,E=s*p-M*v,T=h*p-M*m;return d*T-A*E+R*P+w*x-q*y+Y*g},e.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=n[9],l=n[10],v=n[11],m=n[12],p=n[13],d=n[14],A=n[15],R=r[0],w=r[1],q=r[2],Y=r[3];return t[0]=R*a+w*i+q*h+Y*m,t[1]=R*e+w*c+q*M+Y*p,t[2]=R*u+w*f+q*l+Y*d,t[3]=R*o+w*s+q*v+Y*A,R=r[4],w=r[5],q=r[6],Y=r[7],t[4]=R*a+w*i+q*h+Y*m,t[5]=R*e+w*c+q*M+Y*p,t[6]=R*u+w*f+q*l+Y*d,t[7]=R*o+w*s+q*v+Y*A,R=r[8],w=r[9],q=r[10],Y=r[11],t[8]=R*a+w*i+q*h+Y*m,t[9]=R*e+w*c+q*M+Y*p,t[10]=R*u+w*f+q*l+Y*d,t[11]=R*o+w*s+q*v+Y*A,R=r[12],w=r[13],q=r[14],Y=r[15],t[12]=R*a+w*i+q*h+Y*m,t[13]=R*e+w*c+q*M+Y*p,t[14]=R*u+w*f+q*l+Y*d,t[15]=R*o+w*s+q*v+Y*A,t},e.mul=e.multiply,e.translate=function(t,n,r){var a,e,u,o,i,c,f,s,h,M,l,v,m=r[0],p=r[1],d=r[2];return n===t?(t[12]=n[0]*m+n[4]*p+n[8]*d+n[12],t[13]=n[1]*m+n[5]*p+n[9]*d+n[13],t[14]=n[2]*m+n[6]*p+n[10]*d+n[14],t[15]=n[3]*m+n[7]*p+n[11]*d+n[15]):(a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],c=n[5],f=n[6],s=n[7],h=n[8],M=n[9],l=n[10],v=n[11],t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=c,t[6]=f,t[7]=s,t[8]=h,t[9]=M,t[10]=l,t[11]=v,t[12]=a*m+i*p+h*d+n[12],t[13]=e*m+c*p+M*d+n[13],t[14]=u*m+f*p+l*d+n[14],t[15]=o*m+s*p+v*d+n[15]),t},e.scale=function(t,n,r){var a=r[0],e=r[1],u=r[2];return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*u,t[9]=n[9]*u,t[10]=n[10]*u,t[11]=n[11]*u,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},e.rotate=function(t,n,r,e){var u,o,i,c,f,s,h,M,l,v,m,p,d,A,R,w,q,Y,g,y,x,P,E,T,b=e[0],D=e[1],L=e[2],_=Math.sqrt(b*b+D*D+L*L);return Math.abs(_)<a.EPSILON?null:(_=1/_,b*=_,D*=_,L*=_,u=Math.sin(r),o=Math.cos(r),i=1-o,c=n[0],f=n[1],s=n[2],h=n[3],M=n[4],l=n[5],v=n[6],m=n[7],p=n[8],d=n[9],A=n[10],R=n[11],w=b*b*i+o,q=D*b*i+L*u,Y=L*b*i-D*u,g=b*D*i-L*u,y=D*D*i+o,x=L*D*i+b*u,P=b*L*i+D*u,E=D*L*i-b*u,T=L*L*i+o,t[0]=c*w+M*q+p*Y,t[1]=f*w+l*q+d*Y,t[2]=s*w+v*q+A*Y,t[3]=h*w+m*q+R*Y,t[4]=c*g+M*y+p*x,t[5]=f*g+l*y+d*x,t[6]=s*g+v*y+A*x,t[7]=h*g+m*y+R*x,t[8]=c*P+M*E+p*T,t[9]=f*P+l*E+d*T,t[10]=s*P+v*E+A*T,t[11]=h*P+m*E+R*T,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t)},e.rotateX=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[4],o=n[5],i=n[6],c=n[7],f=n[8],s=n[9],h=n[10],M=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=u*e+f*a,t[5]=o*e+s*a,t[6]=i*e+h*a,t[7]=c*e+M*a,t[8]=f*e-u*a,t[9]=s*e-o*a,t[10]=h*e-i*a,t[11]=M*e-c*a,t},e.rotateY=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],c=n[3],f=n[8],s=n[9],h=n[10],M=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*e-f*a,t[1]=o*e-s*a,t[2]=i*e-h*a,t[3]=c*e-M*a,t[8]=u*a+f*e,t[9]=o*a+s*e,t[10]=i*a+h*e,t[11]=c*a+M*e,t},e.rotateZ=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],c=n[3],f=n[4],s=n[5],h=n[6],M=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=u*e+f*a,t[1]=o*e+s*a,t[2]=i*e+h*a,t[3]=c*e+M*a,t[4]=f*e-u*a,t[5]=s*e-o*a,t[6]=h*e-i*a,t[7]=M*e-c*a,t},e.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},e.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromRotation=function(t,n,r){var e,u,o,i=r[0],c=r[1],f=r[2],s=Math.sqrt(i*i+c*c+f*f);return Math.abs(s)<a.EPSILON?null:(s=1/s,i*=s,c*=s,f*=s,e=Math.sin(n),u=Math.cos(n),o=1-u,t[0]=i*i*o+u,t[1]=c*i*o+f*e,t[2]=f*i*o-c*e,t[3]=0,t[4]=i*c*o-f*e,t[5]=c*c*o+u,t[6]=f*c*o+i*e,t[7]=0,t[8]=i*f*o+c*e,t[9]=c*f*o-i*e,t[10]=f*f*o+u,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},e.fromXRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromYRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromZRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.fromRotationTranslation=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=a+a,c=e+e,f=u+u,s=a*i,h=a*c,M=a*f,l=e*c,v=e*f,m=u*f,p=o*i,d=o*c,A=o*f;return t[0]=1-(l+m),t[1]=h+A,t[2]=M-d,t[3]=0,t[4]=h-A,t[5]=1-(s+m),t[6]=v+p,t[7]=0,t[8]=M+d,t[9]=v-p,t[10]=1-(s+l),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},e.fromRotationTranslationScale=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3],c=e+e,f=u+u,s=o+o,h=e*c,M=e*f,l=e*s,v=u*f,m=u*s,p=o*s,d=i*c,A=i*f,R=i*s,w=a[0],q=a[1],Y=a[2];return t[0]=(1-(v+p))*w,t[1]=(M+R)*w,t[2]=(l-A)*w,t[3]=0,t[4]=(M-R)*q,t[5]=(1-(h+p))*q,t[6]=(m+d)*q,t[7]=0,t[8]=(l+A)*Y,t[9]=(m-d)*Y,t[10]=(1-(h+v))*Y,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},e.fromRotationTranslationScaleOrigin=function(t,n,r,a,e){var u=n[0],o=n[1],i=n[2],c=n[3],f=u+u,s=o+o,h=i+i,M=u*f,l=u*s,v=u*h,m=o*s,p=o*h,d=i*h,A=c*f,R=c*s,w=c*h,q=a[0],Y=a[1],g=a[2],y=e[0],x=e[1],P=e[2];return t[0]=(1-(m+d))*q,t[1]=(l+w)*q,t[2]=(v-R)*q,t[3]=0,t[4]=(l-w)*Y,t[5]=(1-(M+d))*Y,t[6]=(p+A)*Y,t[7]=0,t[8]=(v+R)*g,t[9]=(p-A)*g,t[10]=(1-(M+m))*g,t[11]=0,t[12]=r[0]+y-(t[0]*y+t[4]*x+t[8]*P),t[13]=r[1]+x-(t[1]*y+t[5]*x+t[9]*P),t[14]=r[2]+P-(t[2]*y+t[6]*x+t[10]*P),t[15]=1,t},e.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,c=e+e,f=r*o,s=a*o,h=a*i,M=e*o,l=e*i,v=e*c,m=u*o,p=u*i,d=u*c;return t[0]=1-h-v,t[1]=s+d,t[2]=M-p,t[3]=0,t[4]=s-d,t[5]=1-f-v,t[6]=l+m,t[7]=0,t[8]=M+p,t[9]=l-m,t[10]=1-f-h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},e.frustum=function(t,n,r,a,e,u,o){var i=1/(r-n),c=1/(e-a),f=1/(u-o);return t[0]=2*u*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*c,t[6]=0,t[7]=0,t[8]=(r+n)*i,t[9]=(e+a)*c,t[10]=(o+u)*f,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*u*2*f,t[15]=0,t},e.perspective=function(t,n,r,a,e){var u=1/Math.tan(n/2),o=1/(a-e);return t[0]=u/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(e+a)*o,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*e*a*o,t[15]=0,t},e.perspectiveFromFieldOfView=function(t,n,r,a){var e=Math.tan(n.upDegrees*Math.PI/180),u=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),c=2/(o+i),f=2/(e+u);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=f,t[6]=0,t[7]=0,t[8]=-((o-i)*c*.5),t[9]=(e-u)*f*.5,t[10]=a/(r-a),t[11]=-1,t[12]=0,t[13]=0,t[14]=a*r/(r-a),t[15]=0,t},e.ortho=function(t,n,r,a,e,u,o){var i=1/(n-r),c=1/(a-e),f=1/(u-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*f,t[11]=0,t[12]=(n+r)*i,t[13]=(e+a)*c,t[14]=(o+u)*f,t[15]=1,t},e.lookAt=function(t,n,r,u){var o,i,c,f,s,h,M,l,v,m,p=n[0],d=n[1],A=n[2],R=u[0],w=u[1],q=u[2],Y=r[0],g=r[1],y=r[2];return Math.abs(p-Y)<a.EPSILON&&Math.abs(d-g)<a.EPSILON&&Math.abs(A-y)<a.EPSILON?e.identity(t):(M=p-Y,l=d-g,v=A-y,m=1/Math.sqrt(M*M+l*l+v*v),M*=m,l*=m,v*=m,o=w*v-q*l,i=q*M-R*v,c=R*l-w*M,m=Math.sqrt(o*o+i*i+c*c),m?(m=1/m,o*=m,i*=m,c*=m):(o=0,i=0,c=0),f=l*c-v*i,s=v*o-M*c,h=M*i-l*o,m=Math.sqrt(f*f+s*s+h*h),m?(m=1/m,f*=m,s*=m,h*=m):(f=0,s=0,h=0),t[0]=o,t[1]=f,t[2]=M,t[3]=0,t[4]=i,t[5]=s,t[6]=l,t[7]=0,t[8]=c,t[9]=h,t[10]=v,t[11]=0,t[12]=-(o*p+i*d+c*A),t[13]=-(f*p+s*d+h*A),t[14]=-(M*p+l*d+v*A),t[15]=1,t)},e.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},e.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},t.exports=e},function(t,n,r){var a=r(1),e=r(4),u=r(7),o=r(8),i={};i.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},i.rotationTo=function(){var t=u.create(),n=u.fromValues(1,0,0),r=u.fromValues(0,1,0);return function(a,e,o){var c=u.dot(e,o);return-.999999>c?(u.cross(t,n,e),u.length(t)<1e-6&&u.cross(t,r,e),u.normalize(t,t),i.setAxisAngle(a,t,Math.PI),a):c>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(u.cross(t,e,o),a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1+c,i.normalize(a,a))}}(),i.setAxes=function(){var t=e.create();return function(n,r,a,e){return t[0]=a[0],t[3]=a[1],t[6]=a[2],t[1]=e[0],t[4]=e[1],t[7]=e[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],i.normalize(n,i.fromMat3(n,t))}}(),i.clone=o.clone,i.fromValues=o.fromValues,i.copy=o.copy,i.set=o.set,i.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},i.setAxisAngle=function(t,n,r){r=.5*r;var a=Math.sin(r);return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=Math.cos(r),t},i.add=o.add,i.multiply=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],c=r[1],f=r[2],s=r[3];return t[0]=a*s+o*i+e*f-u*c,t[1]=e*s+o*c+u*i-a*f,t[2]=u*s+o*f+a*c-e*i,t[3]=o*s-a*i-e*c-u*f,t},i.mul=i.multiply,i.scale=o.scale,i.rotateX=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+o*i,t[1]=e*c+u*i,t[2]=u*c-e*i,t[3]=o*c-a*i,t},i.rotateY=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c-u*i,t[1]=e*c+o*i,t[2]=u*c+a*i,t[3]=o*c-e*i,t},i.rotateZ=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),c=Math.cos(r);return t[0]=a*c+e*i,t[1]=e*c-a*i,t[2]=u*c+o*i,t[3]=o*c-u*i,t},i.calculateW=function(t,n){var r=n[0],a=n[1],e=n[2];return t[0]=r,t[1]=a,t[2]=e,t[3]=Math.sqrt(Math.abs(1-r*r-a*a-e*e)),t},i.dot=o.dot,i.lerp=o.lerp,i.slerp=function(t,n,r,a){var e,u,o,i,c,f=n[0],s=n[1],h=n[2],M=n[3],l=r[0],v=r[1],m=r[2],p=r[3];return u=f*l+s*v+h*m+M*p,0>u&&(u=-u,l=-l,v=-v,m=-m,p=-p),1-u>1e-6?(e=Math.acos(u),o=Math.sin(e),i=Math.sin((1-a)*e)/o,c=Math.sin(a*e)/o):(i=1-a,c=a),t[0]=i*f+c*l,t[1]=i*s+c*v,t[2]=i*h+c*m,t[3]=i*M+c*p,t},i.sqlerp=function(){var t=i.create(),n=i.create();return function(r,a,e,u,o,c){return i.slerp(t,a,o,c),i.slerp(n,e,u,c),i.slerp(r,t,n,2*c*(1-c)),r}}(),i.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u,i=o?1/o:0;return t[0]=-r*i,t[1]=-a*i,t[2]=-e*i,t[3]=u*i,t},i.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},i.length=o.length,i.len=i.length,i.squaredLength=o.squaredLength,i.sqrLen=i.squaredLength,i.normalize=o.normalize,i.fromMat3=function(t,n){var r,a=n[0]+n[4]+n[8];if(a>0)r=Math.sqrt(a+1),t[3]=.5*r,r=.5/r,t[0]=(n[5]-n[7])*r,t[1]=(n[6]-n[2])*r,t[2]=(n[1]-n[3])*r;else{var e=0;n[4]>n[0]&&(e=1),n[8]>n[3*e+e]&&(e=2);var u=(e+1)%3,o=(e+2)%3;r=Math.sqrt(n[3*e+e]-n[3*u+u]-n[3*o+o]+1),t[e]=.5*r,r=.5/r,t[3]=(n[3*u+o]-n[3*o+u])*r,t[u]=(n[3*u+e]+n[3*e+u])*r,t[o]=(n[3*o+e]+n[3*e+o])*r}return t},i.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},t.exports=i},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(3);return t[0]=0,t[1]=0,t[2]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},e.fromValues=function(t,n,r){var e=new a.ARRAY_TYPE(3);return e[0]=t,e[1]=n,e[2]=r,e},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},e.set=function(t,n,r,a){return t[0]=n,t[1]=r,t[2]=a,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return Math.sqrt(r*r+a*a+e*e)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return r*r+a*a+e*e},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1],a=t[2];return Math.sqrt(n*n+r*r+a*a)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1],a=t[2];return n*n+r*r+a*a},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=r*r+a*a+e*e;return u>0&&(u=1/Math.sqrt(u),t[0]=n[0]*u,t[1]=n[1]*u,t[2]=n[2]*u),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]},e.cross=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2];return t[0]=e*c-u*i,t[1]=u*o-a*c,t[2]=a*i-e*o,t},e.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t},e.hermite=function(t,n,r,a,e,u){var o=u*u,i=o*(2*u-3)+1,c=o*(u-2)+u,f=o*(u-1),s=o*(3-2*u);return t[0]=n[0]*i+r[0]*c+a[0]*f+e[0]*s,t[1]=n[1]*i+r[1]*c+a[1]*f+e[1]*s,t[2]=n[2]*i+r[2]*c+a[2]*f+e[2]*s,t},e.bezier=function(t,n,r,a,e,u){var o=1-u,i=o*o,c=u*u,f=i*o,s=3*u*i,h=3*c*o,M=c*u;return t[0]=n[0]*f+r[0]*s+a[0]*h+e[0]*M,t[1]=n[1]*f+r[1]*s+a[1]*h+e[1]*M,t[2]=n[2]*f+r[2]*s+a[2]*h+e[2]*M,t},e.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI,e=2*a.RANDOM()-1,u=Math.sqrt(1-e*e)*n;return t[0]=Math.cos(r)*u,t[1]=Math.sin(r)*u,t[2]=e*n,t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[3]*a+r[7]*e+r[11]*u+r[15];return o=o||1,t[0]=(r[0]*a+r[4]*e+r[8]*u+r[12])/o,t[1]=(r[1]*a+r[5]*e+r[9]*u+r[13])/o,t[2]=(r[2]*a+r[6]*e+r[10]*u+r[14])/o,t},e.transformMat3=function(t,n,r){var a=n[0],e=n[1],u=n[2];return t[0]=a*r[0]+e*r[3]+u*r[6],t[1]=a*r[1]+e*r[4]+u*r[7],t[2]=a*r[2]+e*r[5]+u*r[8],t},e.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2],f=r[3],s=f*a+i*u-c*e,h=f*e+c*a-o*u,M=f*u+o*e-i*a,l=-o*a-i*e-c*u;return t[0]=s*f+l*-o+h*-c-M*-i,t[1]=h*f+l*-i+M*-o-s*-c,t[2]=M*f+l*-c+s*-i-h*-o,t},e.rotateX=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0],u[1]=e[1]*Math.cos(a)-e[2]*Math.sin(a),u[2]=e[1]*Math.sin(a)+e[2]*Math.cos(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.rotateY=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[2]*Math.sin(a)+e[0]*Math.cos(a),u[1]=e[1],u[2]=e[2]*Math.cos(a)-e[0]*Math.sin(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.rotateZ=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0]*Math.cos(a)-e[1]*Math.sin(a),u[1]=e[0]*Math.sin(a)+e[1]*Math.cos(a),u[2]=e[2],t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=3),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2];return n}}(),e.angle=function(t,n){var r=e.fromValues(t[0],t[1],t[2]),a=e.fromValues(n[0],n[1],n[2]);e.normalize(r,r),e.normalize(a,a);var u=e.dot(r,a);return u>1?0:Math.acos(u)},e.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},e.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},e.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t[3]=n[3]*r[3],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t[3]=n[3]/r[3],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t[3]=Math.min(n[3],r[3]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t[3]=Math.max(n[3],r[3]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return Math.sqrt(r*r+a*a+e*e+u*u)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return r*r+a*a+e*e+u*u},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1],a=t[2],e=t[3];return Math.sqrt(n*n+r*r+a*a+e*e)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1],a=t[2],e=t[3];return n*n+r*r+a*a+e*e},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u;return o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=a*o,t[2]=e*o,t[3]=u*o),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]},e.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t[3]=i+a*(r[3]-i),t},e.random=function(t,n){return n=n||1,t[0]=a.RANDOM(),t[1]=a.RANDOM(),t[2]=a.RANDOM(),t[3]=a.RANDOM(),e.normalize(t,t),e.scale(t,t,n),t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3];return t[0]=r[0]*a+r[4]*e+r[8]*u+r[12]*o,t[1]=r[1]*a+r[5]*e+r[9]*u+r[13]*o,t[2]=r[2]*a+r[6]*e+r[10]*u+r[14]*o,t[3]=r[3]*a+r[7]*e+r[11]*u+r[15]*o,t},e.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],c=r[2],f=r[3],s=f*a+i*u-c*e,h=f*e+c*a-o*u,M=f*u+o*e-i*a,l=-o*a-i*e-c*u;return t[0]=s*f+l*-o+h*-c-M*-i,t[1]=h*f+l*-i+M*-o-s*-c,t[2]=M*f+l*-c+s*-i-h*-o,t[3]=n[3],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=4),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}(),e.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},t.exports=e},function(t,n,r){var a=r(1),e={};e.create=function(){var t=new a.ARRAY_TYPE(2);return t[0]=0,t[1]=0,t},e.clone=function(t){var n=new a.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n},e.fromValues=function(t,n){var r=new a.ARRAY_TYPE(2);return r[0]=t,r[1]=n,r},e.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t},e.set=function(t,n,r){return t[0]=n,t[1]=r,t},e.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t},e.subtract=function(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t},e.sub=e.subtract,e.multiply=function(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t},e.mul=e.multiply,e.divide=function(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t},e.div=e.divide,e.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t},e.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t},e.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t},e.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t},e.distance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1];return Math.sqrt(r*r+a*a)},e.dist=e.distance,e.squaredDistance=function(t,n){var r=n[0]-t[0],a=n[1]-t[1];return r*r+a*a},e.sqrDist=e.squaredDistance,e.length=function(t){var n=t[0],r=t[1];return Math.sqrt(n*n+r*r)},e.len=e.length,e.squaredLength=function(t){var n=t[0],r=t[1];return n*n+r*r},e.sqrLen=e.squaredLength,e.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t},e.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},e.normalize=function(t,n){var r=n[0],a=n[1],e=r*r+a*a;return e>0&&(e=1/Math.sqrt(e),t[0]=n[0]*e,t[1]=n[1]*e),t},e.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]},e.cross=function(t,n,r){var a=n[0]*r[1]-n[1]*r[0];return t[0]=t[1]=0,t[2]=a,t},e.lerp=function(t,n,r,a){var e=n[0],u=n[1];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t},e.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI;return t[0]=Math.cos(r)*n,t[1]=Math.sin(r)*n,t},e.transformMat2=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e,t[1]=r[1]*a+r[3]*e,t},e.transformMat2d=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e+r[4],t[1]=r[1]*a+r[3]*e+r[5],t},e.transformMat3=function(t,n,r){
var a=n[0],e=n[1];return t[0]=r[0]*a+r[3]*e+r[6],t[1]=r[1]*a+r[4]*e+r[7],t},e.transformMat4=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[4]*e+r[12],t[1]=r[1]*a+r[5]*e+r[13],t},e.forEach=function(){var t=e.create();return function(n,r,a,e,u,o){var i,c;for(r||(r=2),a||(a=0),c=e?Math.min(e*r+a,n.length):n.length,i=a;c>i;i+=r)t[0]=n[i],t[1]=n[i+1],u(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}(),e.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},t.exports=e}])});

'use strict';

// In node, the script-src for gl-matrix-min above brings in glmatrix into
// a module, instead of into the global scope. Whereas, Tracing code
// assumes that glMatrix is in the global scope. So, in Node only, we
// require() it in, and then take all its exports and shove them into the
// global scope by hand.
(function(global) {
  if (tr.isNode) {
    const glMatrixAbsPath = HTMLImportsLoader.hrefToAbsolutePath(
        '/gl-matrix-min.js');
    const glMatrixModule = require(glMatrixAbsPath);
    for (const exportName in glMatrixModule) {
      global[exportName] = glMatrixModule[exportName];
    }
  }
})(this);


'use strict';

tr.exportTo('tr.b.math', function() {
  const PREFERRED_NUMBER_SERIES_MULTIPLIERS = [1, 2, 5, 10];

  /* Returns true when x and y are within delta of each other. */
  function approximately(x, y, delta) {
    if (delta === undefined) delta = 1e-9;
    return Math.abs(x - y) < delta;
  }

  function clamp(x, lo, hi) {
    return Math.min(Math.max(x, lo), hi);
  }

  function lerp(percentage, lo, hi) {
    const range = hi - lo;
    return lo + percentage * range;
  }

  function normalize(value, lo, hi) {
    return (value - lo) / (hi - lo);
  }

  function deg2rad(deg) {
    return (Math.PI * deg) / 180.0;
  }

  /* The Gauss error function gives the probability that a measurement (which is
   * under the influence of normally distributed errors with standard deviation
   * sigma = 1) is less than x from the mean value of the standard normal
   * distribution.
   * https://www.desmos.com/calculator/t1v4bdpske
   *
   * @param {number} x A tolerance for error.
   * @return {number} The probability that a measurement is less than |x| from
   * the mean value of the standard normal distribution.
   */
  function erf(x) {
    // save the sign of x
    // erf(-x) = -erf(x);
    const sign = (x >= 0) ? 1 : -1;
    x = Math.abs(x);

    // constants
    const a1 = 0.254829592;
    const a2 = -0.284496736;
    const a3 = 1.421413741;
    const a4 = -1.453152027;
    const a5 = 1.061405429;
    const p = 0.3275911;

    // Abramowitz and Stegun formula 7.1.26
    // maximum error: 1.5e-7
    const t = 1.0 / (1.0 + p * x);
    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t *
      Math.exp(-x * x);
    return sign * y;
  }

  const tmpVec2 = vec2.create();
  const tmpVec2b = vec2.create();
  const tmpVec4 = vec4.create();
  const tmpMat2d = mat2d.create();

  vec2.createFromArray = function(arr) {
    if (arr.length !== 2) throw new Error('Should be length 2');
    const v = vec2.create();
    vec2.set(v, arr[0], arr[1]);
    return v;
  };

  vec2.createXY = function(x, y) {
    const v = vec2.create();
    vec2.set(v, x, y);
    return v;
  };

  vec2.toString = function(a) {
    return '[' + a[0] + ', ' + a[1] + ']';
  };

  vec2.addTwoScaledUnitVectors = function(out, u1, scale1, u2, scale2) {
    // out = u1 * scale1 + u2 * scale2
    vec2.scale(tmpVec2, u1, scale1);
    vec2.scale(tmpVec2b, u2, scale2);
    vec2.add(out, tmpVec2, tmpVec2b);
  };

  vec2.interpolatePiecewiseFunction = function(points, x) {
    if (x < points[0][0]) return points[0][1];
    for (let i = 1; i < points.length; ++i) {
      if (x < points[i][0]) {
        const percent = normalize(x, points[i - 1][0], points[i][0]);
        return lerp(percent, points[i - 1][1], points[i][1]);
      }
    }
    return points[points.length - 1][1];
  };

  vec3.createXYZ = function(x, y, z) {
    const v = vec3.create();
    vec3.set(v, x, y, z);
    return v;
  };

  vec3.toString = function(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  };

  mat2d.translateXY = function(out, x, y) {
    vec2.set(tmpVec2, x, y);
    mat2d.translate(out, out, tmpVec2);
  };

  mat2d.scaleXY = function(out, x, y) {
    vec2.set(tmpVec2, x, y);
    mat2d.scale(out, out, tmpVec2);
  };

  vec4.unitize = function(out, a) {
    out[0] = a[0] / a[3];
    out[1] = a[1] / a[3];
    out[2] = a[2] / a[3];
    out[3] = 1;
    return out;
  };

  vec2.copyFromVec4 = function(out, a) {
    vec4.unitize(tmpVec4, a);
    vec2.copy(out, tmpVec4);
  };

  /**
   * @param {number} x
   * @param {number=} opt_base Defaults to 10
   * @return {number}
   */
  function logOrLog10(x, base) {
    if (base === 10) return Math.log10(x);
    return Math.log(x) / Math.log(base);
  }

  /**
   * @param {number} x
   * @param {number=} opt_base Defaults to 10
   * @return {number}
   */
  function lesserPower(x, opt_base) {
    const base = opt_base || 10;
    return Math.pow(base, Math.floor(logOrLog10(x, base)));
  }

  /**
   * @param {number} x
   * @param {number=} opt_base Defaults to 10
   * @return {number}
   */
  function greaterPower(x, opt_base) {
    const base = opt_base || 10;
    return Math.pow(base, Math.ceil(logOrLog10(x, base)));
  }

  function lesserWholeNumber(x) {
    if (x === 0) return 0;
    const pow10 = (x < 0) ? -lesserPower(-x) : lesserPower(x);
    return pow10 * Math.floor(x / pow10);
  }

  function greaterWholeNumber(x) {
    if (x === 0) return 0;
    const pow10 = (x < 0) ? -lesserPower(-x) : lesserPower(x);
    return pow10 * Math.ceil(x / pow10);
  }

  /**
   *  Uses the 1-2-5 series to find the closest prefered number to min
   *  whose absolute value is at least the absolute value of |min|.
   *  https://en.wikipedia.org/wiki/Preferred_number
   */
  function preferredNumberLargerThanMin(min) {
    const absMin = Math.abs(min);
    // The conservative guess is the largest power of 10 less than
    // or equal to |absMin|.
    const conservativeGuess = tr.b.math.lesserPower(absMin);
    let minPreferedNumber = undefined;
    for (const multiplier of PREFERRED_NUMBER_SERIES_MULTIPLIERS) {
      const tightenedGuess = conservativeGuess * multiplier;
      if (tightenedGuess >= absMin) {
        minPreferedNumber = tightenedGuess;
        break;
      }
    }
    if (minPreferedNumber === undefined) {
      throw new Error('Could not compute preferred number for ' + min);
    }
    if (min < 0) minPreferedNumber *= -1;
    return minPreferedNumber;
  }

  return {
    approximately,
    clamp,
    lerp,
    normalize,
    deg2rad,
    erf,
    lesserPower,
    greaterPower,
    lesserWholeNumber,
    greaterWholeNumber,
    preferredNumberLargerThanMin,
  };
});


'use strict';

/**
 * @fileoverview Quick range computations.
 */
tr.exportTo('tr.b.math', function() {
  function Range() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  }

  Range.prototype = {
    __proto__: Object.prototype,

    clone() {
      if (this.isEmpty) return new Range();
      return Range.fromExplicitRange(this.min_, this.max_);
    },

    reset() {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addRange(range) {
      if (range.isEmpty) return;
      this.addValue(range.min);
      this.addValue(range.max);
    },

    addValue(value) {
      if (this.isEmpty_) {
        this.max_ = value;
        this.min_ = value;
        this.isEmpty_ = false;
        return;
      }
      this.max_ = Math.max(this.max_, value);
      this.min_ = Math.min(this.min_, value);
    },

    set min(min) {
      this.isEmpty_ = false;
      this.min_ = min;
    },

    get min() {
      if (this.isEmpty_) return undefined;
      return this.min_;
    },

    get max() {
      if (this.isEmpty_) return undefined;
      return this.max_;
    },

    set max(max) {
      this.isEmpty_ = false;
      this.max_ = max;
    },

    get range() {
      if (this.isEmpty_) return undefined;
      return this.max_ - this.min_;
    },

    get center() {
      return (this.min_ + this.max_) * 0.5;
    },

    get duration() {
      if (this.isEmpty_) return 0;
      return this.max_ - this.min_;
    },

    /**
     * Get a new Range spanning the powers (of opt_base || 10) that enclose
     * |this| Range.
     * If |this| is empty, returns a new empty Range.
     *
     * @param {number=} opt_base Defaults to 10.
     * @return {!Range}
     */
    enclosingPowers(opt_base) {
      if (this.isEmpty) return new Range();
      return Range.fromExplicitRange(
          tr.b.math.lesserPower(this.min_, opt_base),
          tr.b.math.greaterPower(this.max_, opt_base));
    },

    normalize(x) {
      return tr.b.math.normalize(x, this.min, this.max);
    },

    lerp(x) {
      return tr.b.math.lerp(x, this.min, this.max);
    },

    clamp(x) {
      return tr.b.math.clamp(x, this.min, this.max);
    },

    equals(that) {
      if (this.isEmpty && that.isEmpty) return true;
      if (this.isEmpty !== that.isEmpty) return false;
      return (tr.b.math.approximately(this.min, that.min) &&
          tr.b.math.approximately(this.max, that.max));
    },

    containsExplicitRangeInclusive(min, max) {
      if (this.isEmpty) return false;
      return this.min_ <= min && max <= this.max_;
    },

    containsExplicitRangeExclusive(min, max) {
      if (this.isEmpty) return false;
      return this.min_ < min && max < this.max_;
    },

    intersectsExplicitRangeInclusive(min, max) {
      if (this.isEmpty) return false;
      return this.min_ <= max && min <= this.max_;
    },

    intersectsExplicitRangeExclusive(min, max) {
      if (this.isEmpty) return false;
      return this.min_ < max && min < this.max_;
    },

    containsRangeInclusive(range) {
      if (range.isEmpty) return false;
      return this.containsExplicitRangeInclusive(range.min_, range.max_);
    },

    containsRangeExclusive(range) {
      if (range.isEmpty) return false;
      return this.containsExplicitRangeExclusive(range.min_, range.max_);
    },

    intersectsRangeInclusive(range) {
      if (range.isEmpty) return false;
      return this.intersectsExplicitRangeInclusive(range.min_, range.max_);
    },

    intersectsRangeExclusive(range) {
      if (range.isEmpty) return false;
      return this.intersectsExplicitRangeExclusive(range.min_, range.max_);
    },

    findExplicitIntersectionDuration(min, max) {
      min = Math.max(this.min, min);
      max = Math.min(this.max, max);
      if (max < min) return 0;
      return max - min;
    },

    findIntersection(range) {
      if (this.isEmpty || range.isEmpty) return new Range();

      const min = Math.max(this.min, range.min);
      const max = Math.min(this.max, range.max);

      if (max < min) return new Range();

      return Range.fromExplicitRange(min, max);
    },

    toJSON() {
      if (this.isEmpty_) return {isEmpty: true};
      return {
        isEmpty: false,
        max: this.max,
        min: this.min
      };
    },

    /**
     * Returns a slice of the input array that intersects with this range
     * inclusively.
     * If the range does not have a min, it is treated as unbounded from below.
     * Similarly, if max is undefined, the range is unbounded from above.
     *
     * @param {Array} array The array of elements to be filtered.
     * @param {Funcation=} opt_keyFunc A function that extracts a numeric value,
     *        to be used in comparisons, from an element of the array. If not
     *        specified, array elements themselves will be used.
     * @param {Object=} opt_this An optional this argument to be passed to
     *        opt_keyFunc.
     */
    filterArray(array, opt_keyFunc, opt_this) {
      if (this.isEmpty_) return [];
      // Binary search. |test| is a function that should return true when we
      // need to explore the left branch and false to explore the right branch.
      function binSearch(test) {
        let i0 = 0;
        let i1 = array.length;
        while (i0 < i1) {
          const i = Math.trunc((i0 + i1) / 2);
          if (test(i)) {
            i1 = i;  // Explore the left branch.
          } else {
            i0 = i + 1;  // Explore the right branch.
          }
        }
        return i1;
      }

      const keyFunc = opt_keyFunc || (x => x);
      function getValue(index) {
        return keyFunc.call(opt_this, array[index]);
      }

      const first = binSearch(function(i) {
        return this.min_ === undefined || this.min_ <= getValue(i);
      }.bind(this));
      const last = binSearch(function(i) {
        return this.max_ !== undefined && this.max_ < getValue(i);
      }.bind(this));
      return array.slice(first, last);
    }
  };

  Range.fromDict = function(d) {
    if (d.isEmpty === true) return new Range();
    if (d.isEmpty === false) {
      const range = new Range();
      range.min = d.min;
      range.max = d.max;
      return range;
    }
    throw new Error('Not a range');
  };

  Range.fromExplicitRange = function(min, max) {
    const range = new Range();
    range.min = min;
    range.max = max;
    return range;
  };

  Range.compareByMinTimes = function(a, b) {
    if (!a.isEmpty && !b.isEmpty) return a.min_ - b.min_;

    if (a.isEmpty && !b.isEmpty) return -1;

    if (!a.isEmpty && b.isEmpty) return 1;

    return 0;
  };

  /**
  * Subtracts the intersection of |rangeA| and |rangeB| from |rangeA| and
  * returns the remaining ranges as return. |rangeA| and |rangeB| are
  * not changed during the subtraction.
  *
  * rangeA:       |==========|
  * rangeB:          |===|
  * result:       |==|   |===|
  *
  * @param {tr.b.math.Range} rangeA
  * @param {tr.b.math.Range} rangeB
  * @return {Array.<tr.b.math.Range>} An array of ranges which is the result of
  * the subtraction.
  */
  Range.findDifference = function(rangeA, rangeB) {
    if (!rangeA || rangeA.duration < 0 || !rangeB || rangeB.duration < 0) {
      throw new Error(`Couldn't subtract ranges`);
    }
    const resultRanges = [];

    if (rangeA.isEmpty) return resultRanges;
    if (rangeB.isEmpty) return [rangeA.clone()];

    const intersection = rangeA.findIntersection(rangeB);
    if (intersection.isEmpty) {
      return [rangeA.clone()];
    }
    if (rangeA.duration === 0 && rangeB.duration === 0) {
      if (intersection.empty) return [rangeA.clone()];
      else if (intersection.duration === 0) return resultRanges;
      throw new Error(`Two points' intersection can only be a point or empty`);
    }

    //  rangeA:       |==========|
    //  rangeB:          |===|
    //  result:       |==|   |===|
    const leftRange = tr.b.math.Range.fromExplicitRange(
        rangeA.min, intersection.min);
    if (leftRange.duration > 0) {
      resultRanges.push(leftRange);
    }
    const rightRange = tr.b.math.Range.fromExplicitRange(
        intersection.max, rangeA.max);
    if (rightRange.duration > 0) {
      resultRanges.push(rightRange);
    }
    return resultRanges;
  };

  Range.PERCENT_RANGE = Range.fromExplicitRange(0, 1);
  Object.freeze(Range.PERCENT_RANGE);

  return {
    Range,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  function MetricRegistry() {}

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  tr.b.decorateExtensionRegistry(MetricRegistry, options);

  function camelCaseToHackerString(camelCase) {
    let hackerString = '';
    for (const c of camelCase) {
      const lowered = c.toLocaleLowerCase();
      if (lowered === c) {
        hackerString += c;
      } else {
        hackerString += '_' + lowered;
      }
    }
    return hackerString;
  }

  function getCallStack() {
    try {
      throw new Error();
    } catch (error) {
      return error.stack;
    }
  }

  function getPathsFromStack(stack) {
    return stack.split('\n').map(line => {
      line = line.replace(/^ */, '').split(':');
      if (line.length < 4) return '';
      return line[line.length - 3].split('/');
    }).filter(x => x);
  }

  MetricRegistry.checkFilename = function(metricName, opt_metricPathForTest) {
    if (metricName === 'runtimeStatsTotalMetric' ||
        metricName === 'v8AndMemoryMetrics') {
      // TODO(crbug.com/688342) Remove the runtimeStatsTotalMetric exception.
      // TODO(3275) Remove the v8AndMemoryMetrics exception.
      // https://github.com/catapult-project/catapult/issues/3275
      return;
    }

    const expectedFilename = camelCaseToHackerString(metricName) + '.html';
    const stack = getCallStack();

    let metricPath = opt_metricPathForTest;
    if (metricPath === undefined) {
      const paths = getPathsFromStack(stack);
      const METRIC_STACK_INDEX = 5;

      // This filename is in paths[0]. If this file is not vulcanized, then the
      // metric's filename is in paths[METRIC_STACK_INDEX]. If this file is
      // vulcanized, then they are the same, and paths[METRIC_STACK_INDEX] is
      // not the metric's filename.
      if (paths.length <= METRIC_STACK_INDEX ||
          paths[METRIC_STACK_INDEX].join('/') === paths[0].join('/')) {
        return;
      }

      metricPath = paths[METRIC_STACK_INDEX].slice(
          paths[METRIC_STACK_INDEX].length - 2);
    }

    if (!metricPath[1].endsWith('_test.html') &&
        metricPath[1] !== expectedFilename &&
        metricPath.join('_') !== expectedFilename) {
      throw new Error(
          'Expected ' + metricName + ' to be in a file named ' +
          expectedFilename + '; actual: ' + metricPath.join('/') +
          '; stack: ' + stack.replace(/\n/g, '\n  '));
    }
  };

  MetricRegistry.addEventListener('will-register', function(e) {
    const metric = e.typeInfo.constructor;
    if (!(metric instanceof Function)) {
      throw new Error('Metrics must be functions.');
    }

    if (!metric.name.endsWith('Metric') &&
        !metric.name.endsWith('Metrics')) {
      throw new Error('Metric names must end with "Metric" or "Metrics".');
    }

    if (metric.length < 2) {
      throw new Error('Metrics take a HistogramSet and a Model and ' +
                      'optionally an options dictionary.');
    }

    MetricRegistry.checkFilename(metric.name);
  });

  return {
    MetricRegistry,
  };
});


'use strict';

tr.exportTo('tr.b.math', function() {
  /**
   * An object of this class computes basic statistics online in O(1).
   * Usage:
   * 1. Create an instance.
   * 2. Add numbers using the |add| method.
   * 3. Query statistics.
   * 4. Repeat from step 2.
   */
  class RunningStatistics {
    constructor() {
      this.mean_ = 0;
      this.count_ = 0;
      this.max_ = -Infinity;
      this.min_ = Infinity;
      this.sum_ = 0;
      this.variance_ = 0;

      // Mean of logarithms of absolute values of samples, or undefined if any
      // samples were <= 0.
      this.meanlogs_ = 0;
    }

    get count() {
      return this.count_;
    }

    get geometricMean() {
      if (this.meanlogs_ === undefined) return 0;
      return Math.exp(this.meanlogs_);
    }

    get mean() {
      if (this.count_ === 0) return undefined;
      return this.mean_;
    }

    get max() {
      return this.max_;
    }

    get min() {
      return this.min_;
    }

    get sum() {
      return this.sum_;
    }

    get variance() {
      if (this.count_ === 0) return undefined;
      if (this.count_ === 1) return 0;
      return this.variance_ / (this.count_ - 1);
    }

    get stddev() {
      if (this.count_ === 0) return undefined;
      return Math.sqrt(this.variance);
    }

    add(x) {
      this.count_++;
      this.max_ = Math.max(this.max_, x);
      this.min_ = Math.min(this.min_, x);
      this.sum_ += x;

      // The geometric mean is computed using the arithmetic mean of logarithms.
      if (x <= 0) {
        this.meanlogs_ = undefined;
      } else if (this.meanlogs_ !== undefined) {
        this.meanlogs_ += (Math.log(Math.abs(x)) - this.meanlogs_) / this.count;
      }

      // The following uses Welford's algorithm for computing running mean
      // and variance. See http://www.johndcook.com/blog/standard_deviation.
      if (this.count_ === 1) {
        this.mean_ = x;
        this.variance_ = 0;
      } else {
        const oldMean = this.mean_;
        const oldVariance = this.variance_;
        // Using the 2nd formula for updating the mean yields better precision
        // but it doesn't work for the case oldMean is Infinity. Hence we handle
        // that case separately.
        if (oldMean === Infinity || oldMean === -Infinity) {
          this.mean_ = this.sum_ / this.count_;
        } else {
          this.mean_ = oldMean + (x - oldMean) / this.count_;
        }
        this.variance_ = oldVariance + (x - oldMean) * (x - this.mean_);
      }
    }

    merge(other) {
      const result = new RunningStatistics();
      result.count_ = this.count_ + other.count_;
      result.sum_ = this.sum_ + other.sum_;
      result.min_ = Math.min(this.min_, other.min_);
      result.max_ = Math.max(this.max_, other.max_);
      if (result.count === 0) {
        result.mean_ = 0;
        result.variance_ = 0;
        result.meanlogs_ = 0;
      } else {
        // Combine the mean and the variance using the formulas from
        // https://goo.gl/ddcAep.
        result.mean_ = result.sum / result.count;
        const deltaMean = (this.mean || 0) - (other.mean || 0);
        result.variance_ = this.variance_ + other.variance_ +
          (this.count * other.count * deltaMean * deltaMean / result.count);

        // Merge the arithmetic means of logarithms of absolute values of
        // samples, weighted by counts.
        if (this.meanlogs_ === undefined || other.meanlogs_ === undefined) {
          result.meanlogs_ = undefined;
        } else {
          result.meanlogs_ = (this.count * this.meanlogs_ +
              other.count * other.meanlogs_) / result.count;
        }
      }
      return result;
    }

    asDict() {
      if (!this.count) {
        return [];
      }
      // It's more efficient to serialize these fields in an array. If you
      // add any other fields, you should re-evaluate whether it would be more
      // efficient to serialize as a dict.
      return [
        this.count_,
        this.max_,
        this.meanlogs_,
        this.mean_,
        this.min_,
        this.sum_,
        this.variance_,
      ];
    }

    static fromDict(dict) {
      const result = new RunningStatistics();
      if (dict.length !== 7) {
        return result;
      }
      [
        result.count_,
        result.max_,
        result.meanlogs_,
        result.mean_,
        result.min_,
        result.sum_,
        result.variance_,
      ] = dict;
      return result;
    }
  }

  return {
    RunningStatistics,
  };
});

'use strict';

(function(exports) {

    var rank = {
        /*
         * Standart ranking
         *
         * The MIT License, Copyright (c) 2014 Ben Magyar
         */
        standard: function(array, key) {
            // sort the array
            array = array.sort(function(a, b) {
                var x = a[key];
                var y = b[key];
                return ((x < y) ? -1 : ((x > y) ? 1 : 0));
            });
            // assign a naive ranking
            for (var i = 1; i < array.length + 1; i++) {
                array[i - 1]['rank'] = i;
            }
            return array;
        },
        /*
         * Fractional ranking
         *
         * The MIT License, Copyright (c) 2014 Ben Magyar
         */
        fractional: function(array, key) {
            array = this.standard(array, key);
            // now apply fractional
            var pos = 0;
            while (pos < array.length) {
                var sum = 0;
                var i = 0;
                for (i = 0; array[pos + i + 1] && (array[pos + i][key] === array[pos + i + 1][key]); i++) {
                    sum += array[pos + i]['rank'];
                }
                sum += array[pos + i]['rank'];
                var endPos = pos + i + 1;
                for (pos; pos < endPos; pos++) {
                    array[pos]['rank'] = sum / (i + 1);
                }
                pos = endPos;
            }
            return array;
        },
        rank: function(x, y) {
            var nx = x.length,
                ny = y.length,
                combined = [],
                ranked;
            while (nx--) {
                combined.push({
                    set: 'x',
                    val: x[nx]
                });
            }
            while (ny--) {
                combined.push({
                    set: 'y',
                    val: y[ny]
                });
            }
            ranked = this.fractional(combined, 'val');
            return ranked
        }
    };

    /*
    * Error function
    *
    * The MIT License, Copyright (c) 2013 jStat
    */
    var erf = function erf(x) {
        var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
            4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
            1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
            6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12, 8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17
        ];
        var j = cof.length - 1;
        var isneg = false;
        var d = 0;
        var dd = 0;
        var t, ty, tmp, res;

        if (x < 0) {
            x = -x;
            isneg = true;
        }

        t = 2 / (2 + x);
        ty = 4 * t - 2;

        for (; j > 0; j--) {
            tmp = d;
            d = ty * d - dd + cof[j];
            dd = tmp;
        }

        res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
        return isneg ? res - 1 : 1 - res;
    };

    /*
    * Normal distribution CDF
    *
    * The MIT License, Copyright (c) 2013 jStat
    */
    var dnorm = function(x, mean, std) {
        return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * std * std)));
    }

    var statistic = function(x, y) {
        var ranked = rank.rank(x, y),
            nr = ranked.length,
            nx = x.length,
            ny = y.length,
            ranksums = {
                x: 0,
                y: 0
            },
            i = 0, t = 0, nt = 1, tcf, ux, uy;

        while (i < nr) {
            if (i > 0) {
                if (ranked[i].val == ranked[i-1].val) {
                    nt++;
                } else {
                    if (nt > 1) {
                        t += Math.pow(nt, 3) - nt
                        nt = 1;
                    }
                }
            }
            ranksums[ranked[i].set] += ranked[i].rank
            i++;
        }
        tcf = 1 - (t / (Math.pow(nr, 3) - nr))
        ux = nx*ny + (nx*(nx+1)/2) - ranksums.x;
        uy = nx*ny - ux;

        return {
            tcf: tcf,
            ux: ux,
            uy: uy,
            big: Math.max(ux, uy),
            small: Math.min(ux, uy)
        }
    }

    exports.test = function(x, y, alt, corr) {
        // set default value for alternative
        alt = typeof alt !== 'undefined' ? alt : 'two-sided';
        // set default value for continuity
        corr = typeof corr !== 'undefined' ? corr : true;
        var nx = x.length, // x's size
            ny = y.length, // y's size
            f = 1,
            u, mu, std, z, p;

        // test statistic
        u = statistic(x, y);

        // mean compute and correct if given
        if (corr) {
            mu = (nx * ny / 2) + 0.5;
        } else {
            mu = nx * ny / 2;
        }

        // compute standard deviation using tie correction factor
        std = Math.sqrt(u.tcf * nx * ny * (nx + ny + 1) / 12);

        // compute z according to given alternative
        if (alt == 'less') {
            z = (u.ux - mu) / std;
        } else if (alt == 'greater') {
            z = (u.uy - mu) / std;
        } else if (alt == 'two-sided') {
            z = Math.abs((u.big - mu) / std);
        } else {
            console.log('Unknown alternative argument');
        }

        // factor to correct two sided p-value
        if (alt == 'two-sided') {
            f = 2;
        }

        // compute p-value using CDF of standard normal
        p = dnorm(-z, 0, 1) * f;

        return {U: u.small, p: p};
    }

})(typeof exports === 'undefined' ? this['mannwhitneyu'] = {} : exports);

'use strict';

// In node, the script-src for mannwhitneyu above brings in mannwhitneyui
// into a module, instead of into the global scope. Whereas this file
// assumes that mannwhitneyu is in the global scope. So, in Node only, we
// require() it in, and then take all its exports and shove them into the
// global scope by hand.
(function(global) {
  if (tr.isNode) {
    const mwuAbsPath = HTMLImportsLoader.hrefToAbsolutePath(
        '/mannwhitneyu.js');
    const mwuModule = require(mwuAbsPath);
    for (const exportName in mwuModule) {
      global[exportName] = mwuModule[exportName];
    }
  }
})(this);


'use strict';

// TODO(charliea): Remove:
/* eslint-disable catapult-camelcase */

tr.exportTo('tr.b.math', function() {
  const Statistics = {};

  /* Returns the quotient, or zero if the denominator is zero.*/
  Statistics.divideIfPossibleOrZero = function(numerator, denominator) {
    if (denominator === 0) return 0;
    return numerator / denominator;
  };

  Statistics.sum = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    let ret = 0;
    let i = 0;
    for (const elt of ary) {
      ret += func.call(opt_this, elt, i++);
    }
    return ret;
  };

  Statistics.mean = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    let sum = 0;
    let i = 0;

    for (const elt of ary) {
      sum += func.call(opt_this, elt, i++);
    }

    if (i === 0) return undefined;

    return sum / i;
  };

  Statistics.geometricMean = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    let i = 0;
    let logsum = 0;

    // The geometric mean is expressed as the arithmetic mean of logarithms
    // in order to prevent overflow.
    for (const elt of ary) {
      const x = func.call(opt_this, elt, i++);
      if (x <= 0) return 0;
      logsum += Math.log(Math.abs(x));
    }

    if (i === 0) return 1;

    return Math.exp(logsum / i);
  };

  // Returns undefined if the sum of the weights is zero.
  Statistics.weightedMean = function(
      ary, weightCallback, opt_valueCallback, opt_this) {
    const valueCallback = opt_valueCallback || (x => x);
    let numerator = 0;
    let denominator = 0;
    let i = -1;

    for (const elt of ary) {
      i++;
      const value = valueCallback.call(opt_this, elt, i);
      if (value === undefined) continue;
      const weight = weightCallback.call(opt_this, elt, i, value);
      numerator += weight * value;
      denominator += weight;
    }

    if (denominator === 0) return undefined;

    return numerator / denominator;
  };

  Statistics.variance = function(ary, opt_func, opt_this) {
    if (ary.length === 0) return undefined;
    if (ary.length === 1) return 0;
    const func = opt_func || (x => x);
    const mean = Statistics.mean(ary, func, opt_this);
    const sumOfSquaredDistances = Statistics.sum(
        ary,
        function(d, i) {
          const v = func.call(this, d, i) - mean;
          return v * v;
        },
        opt_this);
    return sumOfSquaredDistances / (ary.length - 1);
  };

  Statistics.stddev = function(ary, opt_func, opt_this) {
    if (ary.length === 0) return undefined;
    return Math.sqrt(
        Statistics.variance(ary, opt_func, opt_this));
  };

  Statistics.max = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    let ret = -Infinity;
    let i = 0;
    for (const elt of ary) {
      ret = Math.max(ret, func.call(opt_this, elt, i++));
    }
    return ret;
  };

  Statistics.min = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    let ret = Infinity;
    let i = 0;
    for (const elt of ary) {
      ret = Math.min(ret, func.call(opt_this, elt, i++));
    }
    return ret;
  };

  Statistics.range = function(ary, opt_func, opt_this) {
    const func = opt_func || (x => x);
    const ret = new tr.b.math.Range();
    let i = 0;
    for (const elt of ary) {
      ret.addValue(func.call(opt_this, elt, i++));
    }
    return ret;
  };

  Statistics.percentile = function(ary, percent, opt_func, opt_this) {
    if (!(percent >= 0 && percent <= 1)) {
      throw new Error('percent must be [0,1]');
    }

    const func = opt_func || (x => x);
    const tmp = new Array(ary.length);
    let i = 0;
    for (const elt of ary) {
      tmp[i] = func.call(opt_this, elt, i++);
    }
    tmp.sort((a, b) => a - b);
    const idx = Math.floor((ary.length - 1) * percent);
    return tmp[idx];
  };

  /**
   * Sorts the samples, and map them linearly to the range [0,1].
   *
   * They're mapped such that for the N samples, the first sample is 0.5/N and
   * the last sample is (N-0.5)/N.
   *
   * Background: The discrepancy of the sample set i/(N-1); i=0, ..., N-1 is
   * 2/N, twice the discrepancy of the sample set (i+1/2)/N; i=0, ..., N-1. In
   * our case we don't want to distinguish between these two cases, as our
   * original domain is not bounded (it is for Monte Carlo integration, where
   * discrepancy was first used).
   **/
  Statistics.normalizeSamples = function(samples) {
    if (samples.length === 0) {
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    // Create a copy to make sure that we don't mutate original |samples| input.
    samples = samples.slice().sort(
        function(a, b) {
          return a - b;
        }
    );
    const low = Math.min.apply(null, samples);
    const high = Math.max.apply(null, samples);
    const newLow = 0.5 / samples.length;
    const newHigh = (samples.length - 0.5) / samples.length;
    if (high - low === 0.0) {
      // Samples is an array of 0.5 in this case.
      samples = Array.apply(null, new Array(samples.length)).map(
          function() { return 0.5;});
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    const scale = (newHigh - newLow) / (high - low);
    for (let i = 0; i < samples.length; i++) {
      samples[i] = (samples[i] - low) * scale + newLow;
    }
    return {
      normalized_samples: samples,
      scale
    };
  };

  /**
   * Computes the discrepancy of a set of 1D samples from the interval [0,1].
   *
   * The samples must be sorted. We define the discrepancy of an empty set
   * of samples to be zero.
   *
   * http://en.wikipedia.org/wiki/Low-discrepancy_sequence
   * http://mathworld.wolfram.com/Discrepancy.html
   */
  Statistics.discrepancy = function(samples, opt_locationCount) {
    if (samples.length === 0) return 0.0;

    let maxLocalDiscrepancy = 0;
    const invSampleCount = 1.0 / samples.length;
    const locations = [];
    // For each location, stores the number of samples less than that location.
    const countLess = [];
    // For each location, stores the number of samples less than or equal to
    // that location.
    const countLessEqual = [];

    if (opt_locationCount !== undefined) {
      // Generate list of equally spaced locations.
      let sampleIndex = 0;
      for (let i = 0; i < opt_locationCount; i++) {
        const location = i / (opt_locationCount - 1);
        locations.push(location);
        while (sampleIndex < samples.length &&
          samples[sampleIndex] < location) {
          sampleIndex += 1;
        }
        countLess.push(sampleIndex);
        while (sampleIndex < samples.length &&
            samples[sampleIndex] <= location) {
          sampleIndex += 1;
        }
        countLessEqual.push(sampleIndex);
      }
    } else {
      // Populate locations with sample positions. Append 0 and 1 if necessary.
      if (samples[0] > 0.0) {
        locations.push(0.0);
        countLess.push(0);
        countLessEqual.push(0);
      }
      for (let i = 0; i < samples.length; i++) {
        locations.push(samples[i]);
        countLess.push(i);
        countLessEqual.push(i + 1);
      }
      if (samples[-1] < 1.0) {
        locations.push(1.0);
        countLess.push(samples.length);
        countLessEqual.push(samples.length);
      }
    }

    // Compute discrepancy as max(overshoot, -undershoot), where
    // overshoot = max(countClosed(i, j)/N - length(i, j)) for all i < j,
    // undershoot = min(countOpen(i, j)/N - length(i, j)) for all i < j,
    // N = len(samples),
    // countClosed(i, j) is the number of points between i and j
    // including ends,
    // countOpen(i, j) is the number of points between i and j excluding ends,
    // length(i, j) is locations[i] - locations[j].

    // The following algorithm is modification of Kadane's algorithm,
    // see https://en.wikipedia.org/wiki/Maximum_subarray_problem.

    // The maximum of (countClosed(k, i-1)/N - length(k, i-1)) for any k < i-1.
    let maxDiff = 0;
    // The minimum of (countOpen(k, i-1)/N - length(k, i-1)) for any k < i-1.
    let minDiff = 0;
    for (let i = 1; i < locations.length; i++) {
      const length = locations[i] - locations[i - 1];
      const countClosed = countLessEqual[i] - countLess[i - 1];
      const countOpen = countLess[i] - countLessEqual[i - 1];
      // Number of points that are added if we extend a closed range that
      // ends at location (i-1).
      const countClosedIncrement =
          countLessEqual[i] - countLessEqual[i - 1];
      // Number of points that are added if we extend an open range that
      // ends at location (i-1).
      const countOpenIncrement = countLess[i] - countLess[i - 1];

      // Either extend the previous optimal range or start a new one.
      maxDiff = Math.max(
          countClosedIncrement * invSampleCount - length + maxDiff,
          countClosed * invSampleCount - length);
      minDiff = Math.min(
          countOpenIncrement * invSampleCount - length + minDiff,
          countOpen * invSampleCount - length);

      maxLocalDiscrepancy = Math.max(
          maxDiff, -minDiff, maxLocalDiscrepancy);
    }
    return maxLocalDiscrepancy;
  };

  /**
   * A discrepancy based metric for measuring timestamp jank.
   *
   * timestampsDiscrepancy quantifies the largest area of jank observed in a
   * series of timestamps.  Note that this is different from metrics based on
   * the max_time_interval. For example, the time stamp series A = [0,1,2,3,5,6]
   *  and B = [0,1,2,3,5,7] have the same max_time_interval = 2, but
   * Discrepancy(B) > Discrepancy(A).
   *
   * Two variants of discrepancy can be computed:
   *
   * Relative discrepancy is following the original definition of
   * discrepancy. It characterized the largest area of jank, relative to the
   * duration of the entire time stamp series.  We normalize the raw results,
   * because the best case discrepancy for a set of N samples is 1/N (for
   * equally spaced samples), and we want our metric to report 0.0 in that
   * case.
   *
   * Absolute discrepancy also characterizes the largest area of jank, but its
   * value wouldn't change (except for imprecisions due to a low
   * |interval_multiplier|) if additional 'good' intervals were added to an
   * exisiting list of time stamps.  Its range is [0,inf] and the unit is
   * milliseconds.
   *
   * The time stamp series C = [0,2,3,4] and D = [0,2,3,4,5] have the same
   * absolute discrepancy, but D has lower relative discrepancy than C.
   *
   * |timestamps| may be a list of lists S = [S_1, S_2, ..., S_N], where each
   * S_i is a time stamp series. In that case, the discrepancy D(S) is:
   * D(S) = max(D(S_1), D(S_2), ..., D(S_N))
   **/
  Statistics.timestampsDiscrepancy = function(timestamps, opt_absolute,
      opt_locationCount) {
    if (timestamps.length === 0) return 0.0;

    if (opt_absolute === undefined) opt_absolute = true;

    if (Array.isArray(timestamps[0])) {
      const rangeDiscrepancies = timestamps.map(function(r) {
        return Statistics.timestampsDiscrepancy(r);
      });
      return Math.max.apply(null, rangeDiscrepancies);
    }

    const s = Statistics.normalizeSamples(timestamps);
    const samples = s.normalized_samples;
    const sampleScale = s.scale;
    let discrepancy = Statistics.discrepancy(samples, opt_locationCount);
    const invSampleCount = 1.0 / samples.length;
    if (opt_absolute === true) {
      // Compute absolute discrepancy
      discrepancy /= sampleScale;
    } else {
      // Compute relative discrepancy
      discrepancy = tr.b.math.clamp(
          (discrepancy - invSampleCount) / (1.0 - invSampleCount), 0.0, 1.0);
    }
    return discrepancy;
  };

  /**
   * A discrepancy based metric for measuring duration jank.
   *
   * DurationsDiscrepancy computes a jank metric which measures how irregular a
   * given sequence of intervals is. In order to minimize jank, each duration
   * should be equally long. This is similar to how timestamp jank works,
   * and we therefore reuse the timestamp discrepancy function above to compute
   * a similar duration discrepancy number.
   *
   * Because timestamp discrepancy is defined in terms of timestamps, we first
   * convert the list of durations to monotonically increasing timestamps.
   *
   * Args:
   *  durations: List of interval lengths in milliseconds.
   *  absolute: See TimestampsDiscrepancy.
   *  opt_locationCount: See TimestampsDiscrepancy.
   **/
  Statistics.durationsDiscrepancy = function(
      durations, opt_absolute, opt_locationCount) {
    if (durations.length === 0) return 0.0;

    const timestamps = durations.reduce(function(prev, curr, index, array) {
      prev.push(prev[prev.length - 1] + curr);
      return prev;
    }, [0]);
    return Statistics.timestampsDiscrepancy(
        timestamps, opt_absolute, opt_locationCount);
  };

  /**
   * Modifies |samples| in-place to reduce its length down to |count|.
   *
   * @param {!Array} samples
   * @param {number} count
   * @return {!Array}
   */
  Statistics.uniformlySampleArray = function(samples, count) {
    if (samples.length <= count) {
      return samples;
    }
    while (samples.length > count) {
      const i = parseInt(Math.random() * samples.length);
      samples.splice(i, 1);
    }
    return samples;
  };

  /**
   * A mechanism to uniformly sample elements from an arbitrary long stream.
   *
   * Call this method every time a new element is obtained from the stream,
   * passing always the same |samples| array and the |numSamples| you desire.
   * Also pass in the current |streamLength|, which is the same as the index of
   * |newElement| within that stream.
   *
   * The |samples| array will possibly be updated, replacing one of its element
   * with |newElements|. The length of |samples| will not be more than
   * |numSamples|.
   *
   * This method guarantees that after |streamLength| elements have been
   * processed each one has equal probability of being in |samples|. The order
   * of samples is not preserved though.
   *
   * Args:
   *  samples: Array of elements that have already been selected. Start with [].
   *  streamLength: The current length of the stream, up to |newElement|.
   *  newElement: The element that was just extracted from the stream.
   *  numSamples: The total number of samples desired.
   **/
  Statistics.uniformlySampleStream = function(samples, streamLength, newElement,
      numSamples) {
    if (streamLength <= numSamples) {
      if (samples.length >= streamLength) {
        samples[streamLength - 1] = newElement;
      } else {
        samples.push(newElement);
      }
      return;
    }

    const probToKeep = numSamples / streamLength;
    if (Math.random() > probToKeep) return;  // New sample was rejected.

    // Keeping it, replace an alement randomly.
    const index = Math.floor(Math.random() * numSamples);
    samples[index] = newElement;
  };

  /**
   * A mechanism to merge two arrays of uniformly sampled elements in a way that
   * ensures elements in the final array are still sampled uniformly.
   *
   * This works similarly to sampleStreamUniform. The |samplesA| array will be
   * updated, some of its elements replaced by elements from |samplesB| in a
   * way that ensure that elements will be sampled uniformly.
   *
   * Args:
   *  samplesA: Array of uniformly sampled elements, will be updated.
   *  streamLengthA: The length of the stream from which |samplesA| was sampled.
   *  samplesB: Other array of uniformly sampled elements, will NOT be updated.
   *  streamLengthB: The length of the stream from which |samplesB| was sampled.
   *  numSamples: The total number of samples desired, both in |samplesA| and
   *      |samplesB|.
   **/
  Statistics.mergeSampledStreams = function(
      samplesA, streamLengthA,
      samplesB, streamLengthB, numSamples) {
    if (streamLengthB < numSamples) {
      // samplesB has not reached max capacity so every sample of stream B were
      // chosen with certainty. Add them one by one into samplesA.
      const nbElements = Math.min(streamLengthB, samplesB.length);
      for (let i = 0; i < nbElements; ++i) {
        Statistics.uniformlySampleStream(samplesA, streamLengthA + i + 1,
            samplesB[i], numSamples);
      }
      return;
    }
    if (streamLengthA < numSamples) {
      // samplesA has not reached max capacity so every sample of stream A were
      // chosen with certainty. Add them one by one into samplesB.
      const nbElements = Math.min(streamLengthA, samplesA.length);
      const tempSamples = samplesB.slice();
      for (let i = 0; i < nbElements; ++i) {
        Statistics.uniformlySampleStream(tempSamples, streamLengthB + i + 1,
            samplesA[i], numSamples);
      }
      // Copy that back into the first vector.
      for (let i = 0; i < tempSamples.length; ++i) {
        samplesA[i] = tempSamples[i];
      }
      return;
    }

    // Both sample arrays are at max capacity, use the power of maths!
    // Elements in samplesA have been selected with probability
    // numSamples / streamLengthA. Same for samplesB. For each index of the
    // array we keep samplesA[i] with probability
    //   P = streamLengthA / (streamLengthA + streamLengthB)
    // and replace it with samplesB[i] with probability 1-P.
    // The total probability of keeping it is therefore
    //   numSamples / streamLengthA *
    //                      streamLengthA / (streamLengthA + streamLengthB)
    //   = numSamples / (streamLengthA + streamLengthB)
    // A similar computation shows we have the same probability of keeping any
    // element in samplesB. Magic!
    const nbElements = Math.min(numSamples, samplesB.length);
    const probOfSwapping = streamLengthB / (streamLengthA + streamLengthB);
    for (let i = 0; i < nbElements; ++i) {
      if (Math.random() < probOfSwapping) {
        samplesA[i] = samplesB[i];
      }
    }
  };

  /* Continuous distributions are defined by probability density functions.
   *
   * Random variables are referred to by capital letters: X, Y, Z.
   * Particular values from these distributions are referred to by lowercase
   * letters like |x|.
   * The probability that |X| ever exactly equals |x| is P(X==x) = 0.
   *
   * For a discrete probability distribution, see tr.v.Histogram.
   */
  function Distribution() {
  }

  Distribution.prototype = {
    /* The probability density of the random variable at value |x| is the
     * relative likelihood for this random variable to take on the given value
     * |x|.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} probability density at x.
     */
    computeDensity(x) {
      throw Error('Not implemented');
    },

    /* A percentile is the probability that a sample from the distribution is
     * less than the given value |x|. This function is monotonically increasing.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} P(X<x).
     */
    computePercentile(x) {
      throw Error('Not implemented');
    },

    /* A complementary percentile is the probability that a sample from the
     * distribution is greater than the given value |x|. This function is
     * monotonically decreasing.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} P(X>x).
     */
    computeComplementaryPercentile(x) {
      return 1 - this.computePercentile(x);
    },

    /* Compute the mean of the probability distribution.
     *
     * @return {number} mean.
     */
    get mean() {
      throw Error('Not implemented');
    },

    /* The mode of a distribution is the most likely value.
     * The maximum of the computeDensity() function is at this mode.
     * @return {number} mode.
     */
    get mode() {
      throw Error('Not implemented');
    },

    /* The median is the center value of the distribution.
     * computePercentile(median) = computeComplementaryPercentile(median) = 0.5
     *
     * @return {number} median.
     */
    get median() {
      throw Error('Not implemented');
    },

    /* The standard deviation is a measure of how dispersed or spread out the
     * distribution is (this statistic has the same units as the values).
     *
     * @return {number} standard deviation.
     */
    get standardDeviation() {
      throw Error('Not implemented');
    },

    /* An alternative measure of how spread out the distribution is,
     * the variance is the square of the standard deviation.
     * @return {number} variance.
     */
    get variance() {
      throw Error('Not implemented');
    }
  };

  Statistics.UniformDistribution = function(opt_range) {
    if (!opt_range) opt_range = tr.b.math.Range.fromExplicitRange(0, 1);
    this.range = opt_range;
  };

  Statistics.UniformDistribution.prototype = {
    __proto__: Distribution.prototype,

    computeDensity(x) {
      return 1 / this.range.range;
    },

    computePercentile(x) {
      return tr.b.math.normalize(x, this.range.min, this.range.max);
    },

    get mean() {
      return this.range.center;
    },

    get mode() {
      return undefined;
    },

    get median() {
      return this.mean;
    },

    get standardDeviation() {
      return Math.sqrt(this.variance);
    },

    get variance() {
      return Math.pow(this.range.range, 2) / 12;
    }
  };

  /* The Normal or Gaussian distribution, or bell curve, is common in complex
   * processes such as are found in many of the natural sciences.  If Z is the
   * standard normal distribution with mean = 0 and variance = 1, then the
   * general normal distribution is Y = mean + Z*sqrt(variance).
   * https://www.desmos.com/calculator/tqtbjm4s3z
   */
  Statistics.NormalDistribution = function(opt_mean, opt_variance) {
    this.mean_ = opt_mean || 0;
    this.variance_ = opt_variance || 1;
    this.standardDeviation_ = Math.sqrt(this.variance_);
  };

  Statistics.NormalDistribution.prototype = {
    __proto__: Distribution.prototype,

    computeDensity(x) {
      const scale = (1.0 / (this.standardDeviation * Math.sqrt(2.0 * Math.PI)));
      const exponent = -Math.pow(x - this.mean, 2) / (2.0 * this.variance);
      return scale * Math.exp(exponent);
    },

    computePercentile(x) {
      const standardizedX = ((x - this.mean) /
                           Math.sqrt(2.0 * this.variance));
      return (1.0 + tr.b.math.erf(standardizedX)) / 2.0;
    },

    get mean() {
      return this.mean_;
    },

    get median() {
      return this.mean;
    },

    get mode() {
      return this.mean;
    },

    get standardDeviation() {
      return this.standardDeviation_;
    },

    get variance() {
      return this.variance_;
    }
  };

  /* The log-normal distribution is a continuous probability distribution of a
   * random variable whose logarithm is normally distributed.
   * If Y is the general normal distribution, then X = exp(Y) is the general
   * log-normal distribution.
   * X will have different parameters from Y,
   * so the mean of Y is called the "location" of X,
   * and the standard deviation of Y is called the "shape" of X.
   * The standard lognormal distribution exp(Z) has location = 0 and shape = 1.
   * https://www.desmos.com/calculator/tqtbjm4s3z
   */
  Statistics.LogNormalDistribution = function(opt_location, opt_shape) {
    this.normalDistribution_ = new Statistics.NormalDistribution(
        opt_location, Math.pow(opt_shape || 1, 2));
  };

  Statistics.LogNormalDistribution.prototype = {
    __proto__: Statistics.NormalDistribution.prototype,

    computeDensity(x) {
      return this.normalDistribution_.computeDensity(Math.log(x)) / x;
    },

    computePercentile(x) {
      return this.normalDistribution_.computePercentile(Math.log(x));
    },

    get mean() {
      return Math.exp(this.normalDistribution_.mean +
          (this.normalDistribution_.variance / 2));
    },

    get variance() {
      const nm = this.normalDistribution_.mean;
      const nv = this.normalDistribution_.variance;
      return (Math.exp(2 * (nm + nv)) -
              Math.exp(2 * nm + nv));
    },

    get standardDeviation() {
      return Math.sqrt(this.variance);
    },

    get median() {
      return Math.exp(this.normalDistribution_.mean);
    },

    get mode() {
      return Math.exp(this.normalDistribution_.mean -
                      this.normalDistribution_.variance);
    }
  };

  /**
   * Instead of describing a LogNormalDistribution in terms of its "location"
   * and "shape", it can also be described in terms of its median
   * and the point at which its complementary cumulative distribution
   * function bends between the linear-ish region in the middle and the
   * exponential-ish region. When the distribution is used to compute
   * percentiles for log-normal random processes such as latency, as the latency
   * improves, it hits a point of diminishing returns, when it becomes
   * relatively difficult to improve the score further. This point of
   * diminishing returns is the first x-intercept of the third derivative of the
   * CDF, which is the second derivative of the PDF.
   *
   * https://www.desmos.com/calculator/cg5rnftabn
   *
   * @param {number} median The median of the distribution.
   * @param {number} diminishingReturns The point of diminishing returns.
   * @return {LogNormalDistribution}
   */
  Statistics.LogNormalDistribution.fromMedianAndDiminishingReturns =
    function(median, diminishingReturns) {
      diminishingReturns = Math.log(diminishingReturns / median);
      const shape = Math.sqrt(1 - 3 * diminishingReturns -
          Math.sqrt(Math.pow(diminishingReturns - 3, 2) - 8)) / 2;
      const location = Math.log(median);
      return new Statistics.LogNormalDistribution(location, shape);
    };

  // p-values less than this indicate statistical significance.
  Statistics.DEFAULT_ALPHA = 0.01;

  // If a statistical significant difference has not been established with
  // this many observations per sample, we'll assume none exists.
  Statistics.MAX_SUGGESTED_SAMPLE_SIZE = 20;

  /** @enum */
  Statistics.Significance = {
    SIGNIFICANT: 'REJECT',
    INSIGNIFICANT: 'FAIL_TO_REJECT',
    NEED_MORE_DATA: 'NEED_MORE_DATA',
    DONT_CARE: 'DONT_CARE',
  };


  /**
   * @typedef {Object} HypothesisTestResult
   * @property {number} p
   * @property {number} U
   * @property {!tr.b.math.Statistics.Significance} significance
   */

  /**
   * @param {!Array.<number>} a
   * @param {!Array.<number>} b
   * @param {number=} opt_alpha
   * @param {number=} opt_reqSampleSize
   * @return {!HypothesisTestResult}
   */
  Statistics.mwu = function(a, b, opt_alpha, opt_reqSampleSize) {
    const result = mannwhitneyu.test(a, b);
    const alpha = opt_alpha || Statistics.DEFAULT_ALPHA;
    if (result.p < alpha) {
      result.significance = Statistics.Significance.SIGNIFICANT;
    } else if (opt_reqSampleSize && (a.length < opt_reqSampleSize ||
          b.length < opt_reqSampleSize)) {
      result.significance = Statistics.Significance.NEED_MORE_DATA;
    } else {
      result.significance = Statistics.Significance.INSIGNIFICANT;
    }
    return result;
  };

  return {
    Statistics,
  };
});


'use strict';

const GREEK_SMALL_LETTER_MU = String.fromCharCode(956);

tr.exportTo('tr.b', function() {
  const SECONDS_IN_A_MINUTE = 60;
  const SECONDS_IN_AN_HOUR = SECONDS_IN_A_MINUTE * 60;
  const SECONDS_IN_A_DAY = SECONDS_IN_AN_HOUR * 24;
  const SECONDS_IN_A_WEEK = SECONDS_IN_A_DAY * 7;
  const SECONDS_IN_A_YEAR = SECONDS_IN_A_DAY * 365.2422;
  const SECONDS_IN_A_MONTH = SECONDS_IN_A_YEAR / 12;

  const UnitPrefixScale = {};
  const UnitScale = {};

  function defineUnitPrefixScale(name, prefixes) {
    if (UnitPrefixScale[name] !== undefined) {
      throw new Error('Unit prefix scale \'' + name + '\' already exists');
    }
    if (prefixes.AUTO !== undefined) {
      throw new Error('The \'AUTO\' unit prefix is not supported for unit' +
          'prefix scales and cannot be added to scale \'' + name + '\'');
    }

    UnitPrefixScale[name] = prefixes;
  }

  UnitScale.defineUnitScale = function(name, unitScale) {
    if (UnitScale[name] !== undefined) {
      throw new Error('Unit scale \'' + name + '\' already exists');
    }
    if (unitScale.AUTO !== undefined) {
      throw new Error('\'AUTO\' unit scale will be added automatically ' +
          'for unit scale \'' + name + '\'');
    }

    // The 'AUTO' unit scale is used in auto formatting Units. In units using
    // the 'BINARY' UnitScale the absolute formatted value closest to the
    // [1, 1024) interval as possible is used. So 1023 and 1024 bytes are
    // displayed as "1,023.0 B" and "1.0 KiB", respectively.
    unitScale.AUTO = Object.values(unitScale);
    unitScale.AUTO.sort((a, b) => a.value - b.value);

    if (name) UnitScale[name] = unitScale;
    return unitScale;
  };

  UnitScale.defineUnitScaleFromPrefixScale = function(
      baseSymbol, baseName, prefixScale, opt_scaleName) {
    if (baseSymbol === undefined) {
      throw new Error('Cannot create UnitScale with undefined baseSymbol.');
    }
    if (!baseName) {
      throw new Error('Cannot create UnitScale without a baseName.');
    }
    if (!prefixScale) {
      throw new Error('Cannot create UnitScale without a prefix scale.');
    }
    const unitScale = {};
    for (const curPrefix of Object.keys(prefixScale)) {
      const curScale = prefixScale[curPrefix];
      if (curScale.symbol === undefined || !curScale.value) {
        throw new Error(
            `Cannot convert PrefixScale with malformed prefix ${curScale}.`);
      }
      const name = curPrefix === 'NONE' ? baseName : `${curPrefix}_${baseName}`;
      unitScale[name] = {
        value: curScale.value,
        symbol: curScale.symbol + baseSymbol,
        baseSymbol
      };
    }
    return UnitScale.defineUnitScale(opt_scaleName, unitScale);
  };

 /**
  * Converts |value| from |fromScale| (e.g. kilo) to |toScale| (e.g. mega).
  *
  * Returns undefined if |value| is undefined.
  * |fromScale| and |toScale| need not come from the same UnitScale or
  * UnitPrefixScale. But if they are both UnitScales they must have matching
  * or undefined baseSymbol's.
  *
  * @param {(undefined|number)} value
  * @param {!object} fromScale
  * @param {!object} toScale
  * @return {(undefined|number)}
  */
  function convertUnit(value, fromScale, toScale) {
    if (value === undefined) return undefined;
    const fromScaleBase = fromScale.baseSymbol;
    const toScaleBase = toScale.baseSymbol;
    if (fromScaleBase !== undefined && toScaleBase !== undefined &&
        fromScaleBase !== toScaleBase) {
      throw new Error(
          'Cannot convert between units with different base symbols.');
    }
    return value * (fromScale.value / toScale.value);
  }

  // See https://en.wikipedia.org/wiki/Binary_prefix.
  defineUnitPrefixScale('BINARY', {
    NONE: { value: Math.pow(1024, 0), symbol: '' },
    KIBI: { value: Math.pow(1024, 1), symbol: 'Ki' },
    MEBI: { value: Math.pow(1024, 2), symbol: 'Mi' },
    GIBI: { value: Math.pow(1024, 3), symbol: 'Gi' },
    TEBI: { value: Math.pow(1024, 4), symbol: 'Ti' }
  });

  // See https://en.wikipedia.org/wiki/Metric_prefix.
  defineUnitPrefixScale('METRIC', {
    NANO: { value: 1e-9, symbol: 'n' },
    MICRO: { value: 1e-6, symbol: GREEK_SMALL_LETTER_MU },
    MILLI: { value: 1e-3, symbol: 'm' },
    NONE: { value: 1, symbol: ''},
    KILO: { value: 1e3, symbol: 'k'},
    MEGA: { value: 1e6, symbol: 'M'},
    GIGA: { value: 1e9, symbol: 'G'}
  });

  UnitScale.defineUnitScale('TIME', {
    NANO_SEC: { value: 1e-9, symbol: 'ns', baseSymbol: 's'},
    MICRO_SEC: { value: 1e-6, symbol: GREEK_SMALL_LETTER_MU + 's',
      baseSymbol: 's'},
    MILLI_SEC: { value: 1e-3, symbol: 'ms', baseSymbol: 's'},
    SEC: { value: 1, symbol: 's', baseSymbol: 's'},
    MINUTE: { value: SECONDS_IN_A_MINUTE, symbol: 'min', baseSymbol: 's'},
    HOUR: { value: SECONDS_IN_AN_HOUR, symbol: 'hr', baseSymbol: 's'},
    DAY: { value: SECONDS_IN_A_DAY, symbol: 'days', baseSymbol: 's'},
    WEEK: { value: SECONDS_IN_A_WEEK, symbol: 'weeks', baseSymbol: 's'},
    MONTH: { value: SECONDS_IN_A_MONTH, symbol: 'months', baseSymbol: 's'},
    YEAR: { value: SECONDS_IN_A_YEAR, symbol: 'years', baseSymbol: 's'}
  });

  UnitScale.defineUnitScaleFromPrefixScale(
      'B', 'BYTE', UnitPrefixScale.BINARY, 'MEMORY');

  return {
    UnitPrefixScale,
    UnitScale,
    convertUnit,
  };
});


'use strict';

/**
 * @fileoverview Time currentDisplayUnit
 */
tr.exportTo('tr.b', function() {
  const msDisplayMode = {
    scale: 1e-3,
    suffix: 'ms',
    // Compares a < b with adjustments to precision errors.
    roundedLess(a, b) {
      return Math.round(a * 1000) < Math.round(b * 1000);
    },
    formatSpec: {
      unitScale: [tr.b.UnitScale.TIME.MILLI_SEC],
      minimumFractionDigits: 3,
    }
  };

  const nsDisplayMode = {
    scale: 1e-9,
    suffix: 'ns',
    // Compares a < b with adjustments to precision errors.
    roundedLess(a, b) {
      return Math.round(a * 1000000) < Math.round(b * 1000000);
    },
    formatSpec: {
      unitScale: [tr.b.UnitScale.TIME.NANO_SEC],
      maximumFractionDigits: 0
    }
  };

  const TimeDisplayModes = {
    ns: nsDisplayMode,
    ms: msDisplayMode
  };

  return {
    TimeDisplayModes,
  };
});



'use strict';

tr.exportTo('tr.ui.b', function() {
  function iterateElementDeeplyImpl(element, cb, thisArg, includeElement) {
    if (includeElement && cb.call(thisArg, element)) return true;

    if (element.root &&
        element.root !== element &&
        iterateElementDeeplyImpl(element.root, cb, thisArg, false)) {
      // Some elements, most notably Polymer template dom-repeat='...'
      // elements, are their own shadow root. Make sure that we avoid infinite
      // recursion by avoiding these elements.
      return true;
    }
    const children = Polymer.dom(element).children;
    for (let i = 0; i < children.length; i++) {
      if (iterateElementDeeplyImpl(children[i], cb, thisArg, true)) {
        return true;
      }
    }

    return false;
  }

  function iterateElementDeeply(element, cb, thisArg) {
    iterateElementDeeplyImpl(element, cb, thisArg, false);
  }

  function findDeepElementMatchingPredicate(element, predicate) {
    let foundElement = undefined;
    function matches(element) {
      const match = predicate(element);
      if (!match) {
        return false;
      }
      foundElement = element;
      return true;
    }
    iterateElementDeeply(element, matches);
    return foundElement;
  }

  function findDeepElementsMatchingPredicate(element, predicate) {
    const foundElements = [];
    function matches(element) {
      const match = predicate(element);
      if (match) {
        foundElements.push(element);
      }
      return false;
    }
    iterateElementDeeply(element, matches);
    return foundElements;
  }

  function findDeepElementMatching(element, selector) {
    return findDeepElementMatchingPredicate(element, function(element) {
      return element.matches(selector);
    });
  }
  function findDeepElementsMatching(element, selector) {
    return findDeepElementsMatchingPredicate(element, function(element) {
      return element.matches(selector);
    });
  }
  function findDeepElementWithTextContent(element, re) {
    return findDeepElementMatchingPredicate(element, function(element) {
      if (element.children.length !== 0) return false;
      return re.test(Polymer.dom(element).textContent);
    });
  }

  return {
    findDeepElementMatching,
    findDeepElementsMatching,
    findDeepElementMatchingPredicate,
    findDeepElementsMatchingPredicate,
    findDeepElementWithTextContent,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const TimeDisplayModes = tr.b.TimeDisplayModes;

  const PLUS_MINUS_SIGN = String.fromCharCode(177);

  const CACHED_FORMATTERS = {};
  function getNumberFormatter(minSpec, maxSpec, minCtx, maxCtx) {
    const key = minSpec + '-' + maxSpec + '-' + minCtx + '-' + maxCtx;
    let formatter = CACHED_FORMATTERS[key];
    if (formatter === undefined) {
      let minimumFractionDigits = minCtx !== undefined ? minCtx : minSpec;
      let maximumFractionDigits = maxCtx !== undefined ? maxCtx : maxSpec;

      // If the context overrides only one of the two |*FractionDigits|
      // properties and the other one is provided by the unit, we might need to
      // shift the other property so that
      // |minimumFractionDigits| <= |maximumFractionDigits|.
      if (minimumFractionDigits > maximumFractionDigits) {
        if (minCtx !== undefined && maxCtx === undefined) {
          // Only minimumFractionDigits was overriden by context.
          maximumFractionDigits = minimumFractionDigits;
        } else if (minCtx === undefined && maxCtx !== undefined) {
          // Only maximumFractionDigits was overriden by context.
          minimumFractionDigits = maximumFractionDigits;
        }
      }

      formatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits,
        maximumFractionDigits,
      });

      CACHED_FORMATTERS[key] = formatter;
    }
    return formatter;
  }

  function max(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    return a.scale > b.scale ? a : b;
  }

  /** @enum */
  const ImprovementDirection = {
    DONT_CARE: 0,
    BIGGER_IS_BETTER: 1,
    SMALLER_IS_BETTER: 2
  };

  /** @constructor */
  function Unit(unitName, jsonName, scaleBaseUnit, isDelta,
      improvementDirection, formatSpec) {
    this.unitName = unitName;
    this.jsonName = jsonName;
    this.scaleBaseUnit = scaleBaseUnit;
    this.isDelta = isDelta;
    this.improvementDirection = improvementDirection;
    this.formatSpec_ = formatSpec;

    // Example: powerInWattsDelta_biggerIsBetter -> powerInWatts.
    this.baseUnit = undefined;

    // Example: energyInJoules_smallerIsBetter ->
    // energyInJoulesDelta_smallerIsBetter.
    this.correspondingDeltaUnit = undefined;
  }

  Unit.prototype = {
    asJSON() {
      return this.jsonName;
    },

    getUnitScale_(opt_context) {
      let formatSpec = this.formatSpec_;
      let formatSpecWasFunction = false;
      if (typeof formatSpec === 'function') {
        formatSpecWasFunction = true;
        formatSpec = formatSpec();
      }
      const context = opt_context || {};

      let scale = undefined;
      if (context.unitScale) {
        scale = context.unitScale;
      } else if (context.unitPrefix) {
        // TODO(aiolos): Switch all calls to format to use UnitScales instead
        // of UnitPrefixScales. UnitPrefixeScales use in Unit is deprecated.
        const symbol = formatSpec.baseSymbol ?
            formatSpec.baseSymbol : this.scaleBaseUnit.baseSymbol;
        scale = tr.b.UnitScale.defineUnitScaleFromPrefixScale(
            symbol, symbol, [context.unitPrefix]).AUTO;
      } else {
        scale = formatSpec.unitScale;
        if (!scale) {
          // Unit has no conversion value(s). Ex: Watts, count.
          scale = [{
            value: 1,
            symbol: formatSpec.baseSymbol || '',
            baseSymbol: formatSpec.baseSymbol || ''
          }];
          if (!formatSpecWasFunction) formatSpec.unitScale = scale;
        }
      }
      if (!(scale instanceof Array)) {
        throw new Error('Unit has a malformed unit scale.');
      }
      return scale;
    },

    get unitString() {
      const scale = this.getUnitScale_();
      if (!scale) {
        throw new Error(
            'A UnitScale could not be found for Unit ' + this.unitName);
      }
      return scale[0].symbol;
    },

    /**
     * Returns a human readable string representation of the value passed.
     *
     * Example: .00023 formatted using the timeInMsAutoFormat Unit would return
     *   '230 ns' since the base unit scale is ms.
     *
     * @param {number} value - The value to be formatted.
     * @param {Object} [opt_context] - Optional formatting parameters.
     * @param {!tr.b.UnitScale=} [opt_context.unitScale] - A UnitScale to use
     *   while formatting the value instead of this Unit's UnitScale.
     * @param {!tr.b.UnitPrefix=} [opt_context.unitPrefix] - A UnitPrefix that
     *   the value should be formatted into.
     * @param {number} [opt_context.deltaValue] - Format the value based on
     *   this delta between it and another number instead of the actual value.
     */
    format(value, opt_context) {
      let signString = '';
      if (value < 0) {
        signString = '-';
        value = -value;  // Treat positive and negative values symmetrically.
      } else if (this.isDelta) {
        signString = value === 0 ? PLUS_MINUS_SIGN : '+';
      }

      const context = opt_context || {};
      const scale = this.getUnitScale_(context);
      let deltaValue = context.deltaValue === undefined ? value :
          context.deltaValue;
      deltaValue = Math.abs(deltaValue) * this.scaleBaseUnit.value;
      let i = 0;
      while (i < scale.length - 1 &&
             deltaValue / scale[i + 1].value >= 1) {
        i++;
      }
      const selectedSubUnit = scale[i];

      let formatSpec = this.formatSpec_;
      if (typeof formatSpec === 'function') formatSpec = formatSpec();
      let unitString = '';
      if (selectedSubUnit.symbol) {
        if (!formatSpec.avoidSpacePrecedingUnit) unitString = ' ';
        unitString += selectedSubUnit.symbol;
      }

      value = tr.b.convertUnit(value, this.scaleBaseUnit, selectedSubUnit);
      const numberString = getNumberFormatter(
          formatSpec.minimumFractionDigits,
          formatSpec.maximumFractionDigits,
          context.minimumFractionDigits,
          context.maximumFractionDigits).format(value);

      return signString + numberString + unitString;
    }
  };

  Unit.reset = function() {
    Unit.currentTimeDisplayMode = TimeDisplayModes.ms;
  };

  Unit.timestampFromUs = function(us) {
    return tr.b.convertUnit(us, tr.b.UnitPrefixScale.METRIC.MICRO,
        tr.b.UnitPrefixScale.METRIC.MILLI);
  };

  Object.defineProperty(Unit, 'currentTimeDisplayMode', {
    get() {
      return Unit.currentTimeDisplayMode_;
    },
    // Use tr-v-ui-preferred-display-unit element instead of directly setting.
    set(value) {
      if (Unit.currentTimeDisplayMode_ === value) return;

      Unit.currentTimeDisplayMode_ = value;
      Unit.dispatchEvent(new tr.b.Event('display-mode-changed'));
    }
  });

  Unit.didPreferredTimeDisplayUnitChange = function() {
    let largest = undefined;
    // TODO(aiolos): base should not depend on ui. Move the functionality of
    //     searching for preferred-display-unit out of Unit.
    // https://github.com/catapult-project/catapult/issues/3092
    const els = tr.ui.b.findDeepElementsMatching(document.body,
        'tr-v-ui-preferred-display-unit');
    els.forEach(function(el) {
      largest = max(largest, el.preferredTimeDisplayMode);
    });

    Unit.currentTimeDisplayMode = largest === undefined ?
        TimeDisplayModes.ms : largest;
  };

  Unit.byName = {};
  Unit.byJSONName = {};

  Unit.fromJSON = function(object) {
    const u = Unit.byJSONName[object];
    if (u) {
      return u;
    }
    throw new Error(`Unrecognized unit "${object}"`);
  };

  /**
   * Define all combinations of a unit with isDelta and improvementDirection
   * flags. For example, the following code:
   *
   *   Unit.define({
   *     baseUnitName: 'powerInWatts'
   *     baseJsonName: 'W'
   *     formatSpec: {
   *       // Specification of how the unit should be formatted (unit symbol,
   *       // unit prefix, fraction digits, etc), or a function returning such
   *       // a specification.
   *     }
   *   });
   *
   * generates the following six units (JSON names shown in parentheses):
   *
   *   Unit.byName.powerInWatts (W)
   *   Unit.byName.powerInWatts_smallerIsBetter (W_smallerIsBetter)
   *   Unit.byName.powerInWatts_biggerIsBetter (W_biggerIsBetter)
   *   Unit.byName.powerInWattsDelta (WDelta)
   *   Unit.byName.powerInWattsDelta_smallerIsBetter (WDelta_smallerIsBetter)
   *   Unit.byName.powerInWattsDelta_biggerIsBetter (WDelta_biggerIsBetter)
   *
   * with the appropriate flags and formatting code (including +/- prefixes
   * for deltas).
   */
  Unit.define = function(params) {
    const definedUnits = [];

    for (const improvementDirection of Object.values(ImprovementDirection)) {
      const regularUnit =
          Unit.defineUnitVariant_(params, false, improvementDirection);
      const deltaUnit =
          Unit.defineUnitVariant_(params, true, improvementDirection);

      regularUnit.correspondingDeltaUnit = deltaUnit;
      deltaUnit.correspondingDeltaUnit = deltaUnit;
      definedUnits.push(regularUnit, deltaUnit);
    }

    const baseUnit = Unit.byName[params.baseUnitName];
    definedUnits.forEach(u => u.baseUnit = baseUnit);
  };

  Unit.nameSuffixForImprovementDirection = function(improvementDirection) {
    switch (improvementDirection) {
      case ImprovementDirection.DONT_CARE:
        return '';
      case ImprovementDirection.BIGGER_IS_BETTER:
        return '_biggerIsBetter';
      case ImprovementDirection.SMALLER_IS_BETTER:
        return '_smallerIsBetter';
      default:
        throw new Error(
            'Unknown improvement direction: ' + improvementDirection);
    }
  };

  Unit.defineUnitVariant_ = function(params, isDelta, improvementDirection) {
    let nameSuffix = isDelta ? 'Delta' : '';
    nameSuffix += Unit.nameSuffixForImprovementDirection(improvementDirection);

    const unitName = params.baseUnitName + nameSuffix;
    const jsonName = params.baseJsonName + nameSuffix;
    if (Unit.byName[unitName] !== undefined) {
      throw new Error('Unit \'' + unitName + '\' already exists');
    }
    if (Unit.byJSONName[jsonName] !== undefined) {
      throw new Error('JSON unit \'' + jsonName + '\' alread exists');
    }

    let scaleBaseUnit = params.scaleBaseUnit;
    if (!scaleBaseUnit) {
      let formatSpec = params.formatSpec;
      if (typeof formatSpec === 'function') formatSpec = formatSpec();
      const baseSymbol = formatSpec.unitScale ?
          formatSpec.unitScale[0].baseSymbol : (formatSpec.baseSymbol || '');
      scaleBaseUnit = { value: 1, symbol: baseSymbol, baseSymbol };
    }
    const unit = new Unit(unitName, jsonName, scaleBaseUnit,
        isDelta, improvementDirection, params.formatSpec);
    Unit.byName[unitName] = unit;
    Unit.byJSONName[jsonName] = unit;

    return unit;
  };

  tr.b.EventTarget.decorate(Unit);
  Unit.reset();

  // Known display units follow.
  //////////////////////////////////////////////////////////////////////////////

  Unit.define({
    baseUnitName: 'timeInMsAutoFormat',
    baseJsonName: 'msBestFitFormat',
    scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
    formatSpec: {
      unitScale: tr.b.UnitScale.TIME.AUTO,
      minimumFractionDigits: 0,
      maximumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'timeDurationInMs',
    baseJsonName: 'ms',
    scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
    formatSpec() {
      return Unit.currentTimeDisplayMode_.formatSpec;
    }
  });

  Unit.define({
    baseUnitName: 'timeStampInMs',
    baseJsonName: 'tsMs',
    scaleBaseUnit: tr.b.UnitScale.TIME.MILLI_SEC,
    formatSpec() {
      return Unit.currentTimeDisplayMode_.formatSpec;
    }
  });

  Unit.define({
    baseUnitName: 'normalizedPercentage',
    baseJsonName: 'n%',
    formatSpec: {
      unitScale: [{value: 0.01, symbol: '%'}],
      avoidSpacePrecedingUnit: true,
      minimumFractionDigits: 3,
      maximumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'sizeInBytes',
    baseJsonName: 'sizeInBytes',
    formatSpec: {
      unitScale: tr.b.UnitScale.MEMORY.AUTO,
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }
  });

  Unit.define({
    baseUnitName: 'energyInJoules',
    baseJsonName: 'J',
    formatSpec: {
      baseSymbol: 'J',
      minimumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'powerInWatts',
    baseJsonName: 'W',
    formatSpec: {
      baseSymbol: 'W',
      minimumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'unitlessNumber',
    baseJsonName: 'unitless',
    formatSpec: {
      minimumFractionDigits: 3,
      maximumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'count',
    baseJsonName: 'count',
    formatSpec: {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }
  });

  Unit.define({
    baseUnitName: 'sigma',
    baseJsonName: 'sigma',
    formatSpec: {
      baseSymbol: String.fromCharCode(963),
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }
  });

  return {
    ImprovementDirection,
    Unit,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  class Scalar {
    constructor(unit, value) {
      if (!(unit instanceof tr.b.Unit)) {
        throw new Error('Expected Unit');
      }

      if (!(typeof(value) === 'number')) {
        throw new Error('Expected value to be number');
      }

      this.unit = unit;
      this.value = value;
    }

    asDict() {
      return {
        unit: this.unit.asJSON(),
        value: tr.b.numberToJson(this.value),
      };
    }

    toString() {
      return this.unit.format(this.value);
    }

    static fromDict(d) {
      return new Scalar(tr.b.Unit.fromJSON(d.unit),
          tr.b.numberFromJson(d.value));
    }
  }

  return {
    Scalar,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class Diagnostic {
    constructor() {
      this.guid_ = undefined;
    }

    /**
     * Returns a new Diagnostic that is like this one but distinct.
     * This is useful when merging Diagnostics.
     * @return {!tr.v.d.Diagnostic}
     */
    clone() {
      return new this.constructor();
    }

    /**
     * Return true if |this| can be merged with |otherDiagnostic|.
     *
     * @param {!tr.v.d.Diagnostic} otherDiagnostic
     * @return {!boolean}
     */
    canAddDiagnostic(otherDiagnostic) {
      return false;
    }

    /**
     * If subclasses override canAddDiagnostic() then they must also override
     * this method to modify |this| to include information from
     * |otherDiagnostic|.
     *
     * @param {!tr.v.d.Diagnostic} otherDiagnostic
     */
    addDiagnostic(otherDiagnostic) {
      throw new Error('Abstract virtual method: subclasses must override ' +
          'this method if they override canAddDiagnostic');
    }

    get guid() {
      if (this.guid_ === undefined) {
        this.guid_ = tr.b.GUID.allocateUUID4();
      }

      return this.guid_;
    }

    set guid(guid) {
      if (this.guid_ !== undefined) {
        throw new Error('Cannot reset guid');
      }

      this.guid_ = guid;
    }

    /**
     * If this Diagnostic is shared between multiple Histograms, then return its
     * |guid|. Otherwise, serialize this Diagnostic to a dictionary.
     *
     * @return {string|!Object}
     */
    asDictOrReference() {
      if (this.guid_ !== undefined) {
        return this.guid_;
      }
      return this.asDict();
    }

    /**
     * Serialize all of the information in this Diagnostic to a dictionary,
     * regardless of whether it is shared between multiple Histograms.
     *
     * @return {!Object}
     */
    asDict() {
      const result = {type: this.constructor.name};
      if (this.guid_ !== undefined) {
        result.guid = this.guid_;
      }
      this.asDictInto_(result);
      return result;
    }

    asDictInto_(d) {
      throw new Error('Abstract virtual method: subclasses must override ' +
          'this method if they override canAddDiagnostic');
    }

    static fromDict(d) {
      const typeInfo = Diagnostic.findTypeInfoWithName(d.type);
      if (!typeInfo) {
        throw new Error('Unrecognized diagnostic type: ' + d.type);
      }

      const diagnostic = typeInfo.constructor.fromDict(d);
      if (d.guid !== undefined) diagnostic.guid = d.guid;
      return diagnostic;
    }
  }

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Diagnostic;
  tr.b.decorateExtensionRegistry(Diagnostic, options);

  Diagnostic.addEventListener('will-register', function(e) {
    const constructor = e.typeInfo.constructor;
    if (!(constructor.fromDict instanceof Function) ||
        (constructor.fromDict === Diagnostic.fromDict) ||
        (constructor.fromDict.length !== 1)) {
      throw new Error('Diagnostics must define fromDict(d)');
    }
  });

  return {
    Diagnostic,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class Breakdown extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.values_ = new Map();
      this.colorScheme = undefined;
    }

    clone() {
      const clone = new Breakdown();
      clone.colorScheme = this.colorScheme;
      clone.addDiagnostic(this);
      return clone;
    }

    canAddDiagnostic(otherDiagnostic) {
      return ((otherDiagnostic instanceof Breakdown) &&
              (otherDiagnostic.colorScheme === this.colorScheme));
    }

    addDiagnostic(otherDiagnostic) {
      for (const [name, value] of otherDiagnostic) {
        this.set(name, this.get(name) + value);
      }
      return this;
    }

    /**
     * Add a Value by an explicit name to this map.
     *
     * @param {string} name
     * @param {number} value
     */
    set(name, value) {
      if (typeof name !== 'string' ||
          typeof value !== 'number') {
        throw new Error('Breakdown maps from strings to numbers');
      }
      this.values_.set(name, value);
    }

    /**
     * @param {string} name
     * @return {number}
     */
    get(name) {
      return this.values_.get(name) || 0;
    }

    * [Symbol.iterator]() {
      for (const pair of this.values_) {
        yield pair;
      }
    }

    asDictInto_(d) {
      d.values = {};
      for (const [name, value] of this) {
        d.values[name] = tr.b.numberToJson(value);
      }
      if (this.colorScheme) {
        d.colorScheme = this.colorScheme;
      }
    }

    static fromDict(d) {
      const breakdown = new Breakdown();
      for (const [name, value] of Object.entries(d.values)) {
        breakdown.set(name, tr.b.numberFromJson(value));
      }
      if (d.colorScheme) {
        breakdown.colorScheme = d.colorScheme;
      }
      return breakdown;
    }
  }

  tr.v.d.Diagnostic.register(Breakdown, {
    elementName: 'tr-v-ui-breakdown-span'
  });

  return {
    Breakdown,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class CollectedRelatedEventSet extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.eventSetsByCanonicalUrl_ = new Map();
    }

    asDictInto_(d) {
      d.events = {};
      for (const [canonicalUrl, eventSet] of this) {
        d.events[canonicalUrl] = [];
        for (const event of eventSet) {
          d.events[canonicalUrl].push({
            stableId: event.stableId,
            title: event.title,
            start: event.start,
            duration: event.duration
          });
        }
      }
    }

    static fromDict(d) {
      const result = new CollectedRelatedEventSet();
      for (const [canonicalUrl, events] of Object.entries(d.events)) {
        result.eventSetsByCanonicalUrl_.set(canonicalUrl, events.map(
            e => new tr.v.d.EventRef(e)));
      }
      return result;
    }

    get size() {
      return this.eventSetsByCanonicalUrl_.size;
    }

    get(canonicalUrl) {
      return this.eventSetsByCanonicalUrl_.get(canonicalUrl);
    }

    * [Symbol.iterator]() {
      for (const [canonicalUrl, eventSet] of this.eventSetsByCanonicalUrl_) {
        yield [canonicalUrl, eventSet];
      }
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof tr.v.d.RelatedEventSet ||
        otherDiagnostic instanceof tr.v.d.CollectedRelatedEventSet;
    }

    addEventSetForCanonicalUrl(canonicalUrl, events) {
      let myEventSet = this.eventSetsByCanonicalUrl_.get(canonicalUrl);
      if (myEventSet === undefined) {
        myEventSet = new Set();
        this.eventSetsByCanonicalUrl_.set(canonicalUrl, myEventSet);
      }
      for (const event of events) {
        myEventSet.add(event);
      }
    }

    addDiagnostic(otherDiagnostic) {
      if (otherDiagnostic instanceof tr.v.d.CollectedRelatedEventSet) {
        // Merge Maps of Sets.
        for (const [canonicalUrl, otherEventSet] of otherDiagnostic) {
          this.addEventSetForCanonicalUrl(canonicalUrl, otherEventSet);
        }
        return;
      }

      if (!otherDiagnostic.canonicalUrl) return;
      this.addEventSetForCanonicalUrl(
          otherDiagnostic.canonicalUrl, otherDiagnostic);
    }
  }

  tr.v.d.Diagnostic.register(CollectedRelatedEventSet, {
    elementName: 'tr-v-ui-collected-related-event-set-span'
  });

  return {
    CollectedRelatedEventSet,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * This class represents a mergeable range of Date objects.
   * This range can contain 1 or 2 Dates.
   */
  class DateRange extends tr.v.d.Diagnostic {
    /**
     * @param {number} ms
     */
    constructor(ms) {
      super();
      this.range_ = new tr.b.math.Range();
      this.range_.addValue(ms);
    }

    get minDate() {
      return new Date(this.range_.min);
    }

    get maxDate() {
      return new Date(this.range_.max);
    }

    get durationMs() {
      return this.range_.duration;
    }

    clone() {
      const clone = new tr.v.d.DateRange(this.range_.min);
      clone.addDiagnostic(this);
      return clone;
    }

    equals(other) {
      if (!(other instanceof DateRange)) return false;
      return this.range_.equals(other.range_);
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof DateRange;
    }

    addDiagnostic(other) {
      this.range_.addRange(other.range_);
    }

    toString() {
      const minDate = tr.b.formatDate(this.minDate);
      if (this.durationMs === 0) return minDate;
      const maxDate = tr.b.formatDate(this.maxDate);
      return `${minDate} - ${maxDate}`;
    }

    asDictInto_(d) {
      d.min = this.range_.min;
      if (this.durationMs === 0) return;
      d.max = this.range_.max;
    }

    static fromDict(d) {
      const dateRange = new DateRange(d.min);
      if (d.max !== undefined) dateRange.range_.addValue(d.max);
      return dateRange;
    }
  }

  tr.v.d.Diagnostic.register(DateRange, {
    elementName: 'tr-v-ui-date-range-span'
  });

  return {
    DateRange,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * This is a placeholder to allow many DiagnosticMaps to contain references to
   * the same Diagnostic.
   */
  class DiagnosticRef {
    /**
     * @param {string} guid
     */
    constructor(guid) {
      this.guid = guid;
    }

    asDict() {
      return this.guid;
    }

    asDictOrReference() {
      return this.asDict();
    }
  }

  return {
    DiagnosticRef,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * Stringify Arrays or dictionaries. Sorts dictionaries keys. Non-recursive.
   *
   * @param {!Object} obj
   * @return {string}
   */
  function stableStringify(obj) {
    let replacer;
    if (!(obj instanceof Array)) replacer = Object.keys(obj).sort();
    return JSON.stringify(obj, replacer);
  }

  /**
   * @typedef {(null|number|string|boolean|Array.<!PlainOldData>|!Object)}
   * PlainOldData
   */

  class GenericSet extends tr.v.d.Diagnostic {
    /**
     * @param {!Iterable.<!PlainOldData>} values
     */
    constructor(values) {
      super();
      this.values_ = new Set(values);
    }

    get size() {
      return this.values_.size;
    }

    get length() {
      return this.values_.size;
    }

    * [Symbol.iterator]() {
      for (const value of this.values_) {
        yield value;
      }
    }

    has(value) {
      if (typeof value !== 'object') return this.values_.has(value);
      const json = JSON.stringify(value);
      for (const x of this) {
        if (typeof x !== 'object') continue;
        if (json === JSON.stringify(x)) return true;
      }
      return false;
    }

    equals(other) {
      if (!(other instanceof GenericSet)) return false;
      if (this.size !== other.size) return false;
      for (const value of this) {
        if (!other.has(value)) return false;
      }
      return true;
    }

    asDictInto_(d) {
      d.values = Array.from(this);
    }

    static fromDict(d) {
      return new GenericSet(d.values);
    }

    clone() {
      return new GenericSet(this.values_);
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof GenericSet;
    }

    addDiagnostic(otherDiagnostic) {
      const jsons = new Set();
      for (const value of this) {
        if (typeof value !== 'object') continue;
        jsons.add(stableStringify(value));
      }

      for (const value of otherDiagnostic) {
        if (typeof value === 'object' && jsons.has(stableStringify(value))) {
          continue;
        }
        this.values_.add(value);
      }
    }
  }

  tr.v.d.Diagnostic.register(GenericSet, {
    elementName: 'tr-v-ui-generic-set-span'
  });

  return {
    GenericSet,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /*
   * Histograms are merged using trees of maps produced by
   * HistogramSet.groupHistogramsRecursively().
   * GroupingPath diagnostics record the path through that tree so that
   * RelatedHistogram{Set,Map}.mergeRelationships() can relate merged source
   * Histograms that pertain to specific stories for example to merged related
   * Histograms that also pertain to those specific stories.
   */
  class GroupingPath extends tr.v.d.Diagnostic {
    /**
     * @param {!Array.<string>} groupingPath
     */
    constructor(groupingPath) {
      super();
      this.groupingPath_ = groupingPath;
    }

    clone() {
      return new GroupingPath(Array.from(this.groupingPath_));
    }

    addToHistogram(hist) {
      hist.diagnostics.set(tr.v.d.RESERVED_NAMES.GROUPING_PATH, this);
    }

    static getFromHistogram(hist) {
      return hist.diagnostics.get(tr.v.d.RESERVED_NAMES.GROUPING_PATH);
    }

    equals(other) {
      return 0 === tr.b.compareArrays(
          this.groupingPath_, other.groupingPath_,
          (x, y) => x.localeCompare(y));
    }

    asDictInto_(d) {
      d.groupingPath = this.groupingPath_;
    }

    static fromDict(d) {
      return new GroupingPath(d.groupingPath);
    }
  }

  tr.v.d.Diagnostic.register(GroupingPath);

  return {
    GroupingPath,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  let nextGUID = 1;

  const UUID4_PATTERN = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

  const GUID = {
    /* Allocate an integer GUID.
     *
     * These GUIDs are not unique between loads, but are fast to generate, and
     * consume very little memory.
     *
     * @return {number} globally unique id.
     */
    allocateSimple() {
      return nextGUID++;
    },

    /* Return the last GUID allocated without allocating a new one.
     *
     * @return {number} last guid.
     */
    getLastSimpleGuid() {
      return nextGUID - 1;
    },

    /* Generate a random string UUID.
     *
     * Version 4 random UUIDs are practically guaranteed to be unique between
     * loads, so they can be serialized and compared with results from other
     * loads. These are slower to generate and consume more memory than simple
     * GUIDs.
     *
     * Background on using Math.random() for allocating identifiers:
     * https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.n5b6vgrsh
     * https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html
     *
     * @return {string} universally unique id.
     */
    allocateUUID4() {
      return UUID4_PATTERN.replace(/[xy]/g, function(c) {
        let r = parseInt(Math.random() * 16);
        if (c === 'y') r = (r & 3) + 8;
        return r.toString(16);
      });
    }
  };

  return {
    GUID,
  };
});


'use strict';

/**
 * @fileoverview Provides the EventRegistry class.
 */
tr.exportTo('tr.model', function() {
  // Create the type registry.
  function EventRegistry() {
  }

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(EventRegistry, options);

  // Enforce all options objects have the right fields.
  EventRegistry.addEventListener('will-register', function(e) {
    const metadata = e.typeInfo.metadata;
    if (metadata.name === undefined) {
      throw new Error('Registered events must provide name metadata');
    }
    if (metadata.pluralName === undefined) {
      throw new Error('Registered events must provide pluralName metadata');
    }

    // Add a subtype registry to every event so that all events can be
    // extended
    if (metadata.subTypes === undefined) {
      metadata.subTypes = {};
      const options = new tr.b.ExtensionRegistryOptions(
          tr.b.TYPE_BASED_REGISTRY_MODE);
      options.mandatoryBaseClass = e.typeInfo.constructor;
      options.defaultConstructor = e.typeInfo.constructor;
      tr.b.decorateExtensionRegistry(metadata.subTypes, options);
    } else {
      if (!metadata.subTypes.register) {
        throw new Error('metadata.subTypes must be an extension registry.');
      }
    }

    e.typeInfo.constructor.subTypes = metadata.subTypes;
  });

  // Helper: lookup Events indexed by type name.
  let eventsByTypeName = undefined;
  EventRegistry.getEventTypeInfoByTypeName = function(typeName) {
    if (eventsByTypeName === undefined) {
      eventsByTypeName = {};
      EventRegistry.getAllRegisteredTypeInfos().forEach(function(typeInfo) {
        eventsByTypeName[typeInfo.metadata.name] = typeInfo;
      });
    }
    return eventsByTypeName[typeName];
  };

  // Ensure eventsByTypeName stays current.
  EventRegistry.addEventListener('registry-changed', function() {
    eventsByTypeName = undefined;
  });

  function convertCamelCaseToTitleCase(name) {
    let result = name.replace(/[A-Z]/g, ' $&');
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  EventRegistry.getUserFriendlySingularName = function(typeName) {
    const typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    const str = typeInfo.metadata.name;
    return convertCamelCaseToTitleCase(str);
  };

  EventRegistry.getUserFriendlyPluralName = function(typeName) {
    const typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    const str = typeInfo.metadata.pluralName;
    return convertCamelCaseToTitleCase(str);
  };

  return {
    EventRegistry,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const EventRegistry = tr.model.EventRegistry;

  const RequestSelectionChangeEvent = tr.b.Event.bind(
      undefined, 'requestSelectionChange', true, false);

  /**
   * Represents a event set within a  and its associated set of tracks.
   * @constructor
   */
  function EventSet(opt_events) {
    this.bounds_ = new tr.b.math.Range();
    this.events_ = new Set();
    this.guid_ = tr.b.GUID.allocateSimple();

    if (opt_events) {
      if (opt_events instanceof Array) {
        for (const event of opt_events) {
          this.push(event);
        }
      } else if (opt_events instanceof EventSet) {
        this.addEventSet(opt_events);
      } else {
        this.push(opt_events);
      }
    }
  }

  EventSet.prototype = {
    __proto__: Object.prototype,

    get bounds() {
      return this.bounds_;
    },

    get duration() {
      if (this.bounds_.isEmpty) return 0;
      return this.bounds_.max - this.bounds_.min;
    },

    get length() {
      return this.events_.size;
    },

    get guid() {
      return this.guid_;
    },

    * [Symbol.iterator]() {
      for (const event of this.events_) {
        yield event;
      }
    },

    clear() {
      this.bounds_ = new tr.b.math.Range();
      this.events_.clear();
    },

    /**
     * Pushes each argument onto the EventSet. Returns the number of
     * arguments pushed.
     */
    push(...events) {
      let numPushed;
      for (const event of events) {
        if (event.guid === undefined) {
          throw new Error('Event must have a GUID');
        }

        if (!this.events_.has(event)) {
          this.events_.add(event);
          // Some uses of eventSet (e.g. in tests) have Events as objects that
          // don't have addBoundsToRange as a function. Thus we need to handle
          // this case.
          if (event.addBoundsToRange) {
            if (this.bounds_ !== undefined) {
              event.addBoundsToRange(this.bounds_);
            }
          }
        }
        numPushed++;
      }
      return numPushed;
    },

    contains(event) {
      if (this.events_.has(event)) return event;
      return undefined;
    },

    addEventSet(eventSet) {
      for (const event of eventSet) {
        this.push(event);
      }
    },

    intersectionIsEmpty(otherEventSet) {
      return !this.some(event => otherEventSet.contains(event));
    },

    equals(that) {
      if (this.length !== that.length) return false;
      return this.every(event => that.contains(event));
    },

    sortEvents(compare) {
      // Convert to array, then sort, then convert back
      const ary = this.toArray();
      ary.sort(compare);

      this.clear();
      for (const event of ary) {
        this.push(event);
      }
    },

    getEventsOrganizedByBaseType(opt_pruneEmpty) {
      const allTypeInfos = EventRegistry.getAllRegisteredTypeInfos();

      const events = this.getEventsOrganizedByCallback(function(event) {
        let maxEventIndex = -1;
        let maxEventTypeInfo = undefined;

        allTypeInfos.forEach(function(eventTypeInfo, eventIndex) {
          if (!(event instanceof eventTypeInfo.constructor)) return;

          if (eventIndex > maxEventIndex) {
            maxEventIndex = eventIndex;
            maxEventTypeInfo = eventTypeInfo;
          }
        });

        if (maxEventIndex === -1) {
          throw new Error(`Unrecognized event type: ${event.constructor.name}`);
        }

        return maxEventTypeInfo.metadata.name;
      });

      if (!opt_pruneEmpty) {
        allTypeInfos.forEach(function(eventTypeInfo) {
          if (events[eventTypeInfo.metadata.name] === undefined) {
            events[eventTypeInfo.metadata.name] = new EventSet();
          }
        });
      }

      return events;
    },

    getEventsOrganizedByTitle() {
      return this.getEventsOrganizedByCallback(function(event) {
        if (event.title === undefined) {
          throw new Error('An event didn\'t have a title!');
        }
        return event.title;
      });
    },

    /**
     * @param {!function(!tr.model.Event):string} cb
     * @param {*=} opt_this
     * @return {!Object}  TODO(#3432) Return Map.
     */
    getEventsOrganizedByCallback(cb, opt_this) {
      const groupedEvents = tr.b.groupIntoMap(this, cb, opt_this || this);
      const groupedEventsDict = {};
      for (const [k, events] of groupedEvents) {
        groupedEventsDict[k] = new EventSet(events);
      }
      return groupedEventsDict;
    },

    enumEventsOfType(type, func) {
      for (const event of this) {
        if (event instanceof type) {
          func(event);
        }
      }
    },

    get userFriendlyName() {
      if (this.length === 0) {
        throw new Error('Empty event set');
      }

      const eventsByBaseType = this.getEventsOrganizedByBaseType(true);
      const eventTypeName = Object.keys(eventsByBaseType)[0];

      if (this.length === 1) {
        const tmp = EventRegistry.getUserFriendlySingularName(eventTypeName);
        return tr.b.getOnlyElement(this.events_).userFriendlyName;
      }

      const numEventTypes = Object.keys(eventsByBaseType).length;
      if (numEventTypes !== 1) {
        return this.length + ' events of various types';
      }

      const tmp = EventRegistry.getUserFriendlyPluralName(eventTypeName);
      return this.length + ' ' + tmp;
    },

    filter(fn, opt_this) {
      const res = new EventSet();
      for (const event of this) {
        if (fn.call(opt_this, event)) {
          res.push(event);
        }
      }

      return res;
    },

    toArray() {
      const ary = [];
      for (const event of this) {
        ary.push(event);
      }
      return ary;
    },

    forEach(fn, opt_this) {
      for (const event of this) {
        fn.call(opt_this, event);
      }
    },

    map(fn, opt_this) {
      const res = [];
      for (const event of this) {
        res.push(fn.call(opt_this, event));
      }
      return res;
    },

    every(fn, opt_this) {
      for (const event of this) {
        if (!fn.call(opt_this, event)) {
          return false;
        }
      }
      return true;
    },

    some(fn, opt_this) {
      for (const event of this) {
        if (fn.call(opt_this, event)) {
          return true;
        }
      }
      return false;
    },

    asDict() {
      const stableIds = [];
      for (const event of this) {
        stableIds.push(event.stableId);
      }
      return {'events': stableIds};
    },

    asSet() {
      return this.events_;
    }
  };

  EventSet.IMMUTABLE_EMPTY_SET = (function() {
    const s = new EventSet();
    s.push = function() {
      throw new Error('Cannot push to an immutable event set');
    };
    s.addEventSet = function() {
      throw new Error('Cannot add to an immutable event set');
    };
    Object.freeze(s);
    return s;
  })();

  return {
    EventSet,
    RequestSelectionChangeEvent,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * This is a placeholder in case the referenced Event isn't available in
   * memory to point to directly.
   */
  class EventRef {
    /**
     * @param {!Object} event
     * @param {string} event.stableId
     * @param {string} event.title
     * @param {number} event.start
     * @param {number} event.duration
     */
    constructor(event) {
      this.stableId = event.stableId;
      this.title = event.title;
      this.start = event.start;
      this.duration = event.duration;
      this.end = this.start + this.duration;

      // tr.v.d.RelatedEventSet identifies events using stableId, but
      // tr.model.EventSet uses guid.
      this.guid = tr.b.GUID.allocateSimple();
    }
  }

  return {
    EventRef,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * @typedef {!(tr.v.d.EventRef|tr.model.Event)} EventLike
   */

  /**
   * A RelatedEventSet diagnostic contains references to Events
   */
  class RelatedEventSet extends tr.v.d.Diagnostic {
    /**
     * @param {!(tr.model.EventSet|Array.<EventLike>|EventLike)=} opt_events
     */
    constructor(opt_events) {
      super();
      this.eventsByStableId_ = new Map();
      // TODO(#2431) Plumb canonicalUrl from event.model.
      this.canonicalUrl_ = undefined;

      if (opt_events) {
        if (opt_events instanceof tr.model.EventSet ||
            opt_events instanceof Array) {
          for (const event of opt_events) {
            this.add(event);
          }
        } else {
          this.add(opt_events);
        }
      }
    }

    clone() {
      const clone = new tr.v.d.CollectedRelatedEventSet();
      clone.addDiagnostic(this);
      return clone;
    }

    /**
     * @param {!(tr.v.d.EventRef|tr.model.Event)} event
     */
    add(event) {
      this.eventsByStableId_.set(event.stableId, event);
    }

    /**
     * @param {!(tr.v.d.EventRef|tr.model.Event)} event
     * @return {boolean}
     */
    has(event) {
      return this.eventsByStableId_.has(event.stableId);
    }

    get length() {
      return this.eventsByStableId_.size;
    }

    * [Symbol.iterator]() {
      for (const event of this.eventsByStableId_.values()) {
        yield event;
      }
    }

    get canonicalUrl() {
      return this.canonicalUrl_;
    }

    /**
     * Resolve all EventRefs into Events by finding their stableIds in |model|.
     * If a stableId cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a stableId cannot be found and |opt_required| is false, then the
     * EventRef will remain an EventRef.
     *
     * @param {!tr.model.Model} model
     * @param {boolean=} opt_required
     */
    resolve(model, opt_required) {
      for (const [stableId, value] of this.eventsByStableId_) {
        if (!(value instanceof tr.v.d.EventRef)) continue;

        const event = model.getEventByStableId(stableId);
        if (event instanceof tr.model.Event) {
          this.eventsByStableId_.set(stableId, event);
        } else if (opt_required) {
          throw new Error('Unable to find Event ' + stableId);
        }
      }
    }

    asDictInto_(d) {
      d.events = [];
      for (const event of this) {
        d.events.push({
          stableId: event.stableId,
          title: event.title,
          start: event.start,
          duration: event.duration
        });
      }
    }

    static fromDict(d) {
      return new RelatedEventSet(d.events.map(
          event => new tr.v.d.EventRef(event)));
    }
  }

  tr.v.d.Diagnostic.register(RelatedEventSet, {
    elementName: 'tr-v-ui-related-event-set-span'
  });

  return {
    RelatedEventSet,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /** @constructor */
  function HistogramRef(guid) {
    this.guid = guid;
  }

  return {
    HistogramRef
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class RelatedHistogramMap extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.histogramsByName_ = new Map();
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof RelatedHistogramMap;
    }

    addDiagnostic(otherDiagnostic) {
      // Related Histograms might not exist yet.
    }

    mergeRelationships(otherDiagnostic, parentHist, otherParentHist) {
      /*
        Modify |this| to contain Histograms that should be related to
        |parentHist|.

        |otherParentHist| was merged to |parentHist|.
        |otherDiagnostic| contains Histograms that are related to
        |otherParentHist|.

        Since mergeRelationships() is called after all Histograms are merged,
        then the MERGED_TO diagnostics of the Histograms in |otherDiagnostic|
        contain Histograms that should be related to |parentHist| via |this|
        RelatedHistogramMap.

        otherParentHist -----------------------------> parentHist
        |               merged to RelatedHistogramMap   |
        |                                               |
        | otherDiagnostic                               | this
        | RelatedHistogramMap                           | RelatedHistogramMap
        v                                               v
        otherRelatedHist -----------------------------> relatedHist
                         merged to RelatedHistogramMap

        However, |otherRelatedHist| may have been merged to Histograms using
        different grouping keys, so if |relatedHist|'s merge path is different
        from |parentHist|'s merge path, then |relatedHist| should not be related
        to |parentHist|.
       */

      const parentGroupingPath = tr.v.d.GroupingPath.getFromHistogram(
          parentHist);

      for (const [name, otherRelatedHist] of otherDiagnostic) {
        const mergedTo = otherRelatedHist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.MERGED_TO);
        if (mergedTo === undefined) continue;

        for (const relatedHist of mergedTo.histogramsByName_.values()) {
          const relatedGroupingPath = tr.v.d.GroupingPath.getFromHistogram(
              relatedHist);
          if (relatedGroupingPath === undefined) continue;
          if (!parentGroupingPath.equals(relatedGroupingPath)) continue;

          this.set(name, relatedHist);
        }
      }
    }

    /**
     * Lookup a Histogram by name. Returns undefined if |name| is not found.
     *
     * @param {string} name
     * @return {!tr.v.d.HistogramRef|!tr.v.Histogram|undefined}
     */
    get(name) {
      return this.histogramsByName_.get(name);
    }

    /**
     * Add a Histogram by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.HistogramRef|tr.v.Histogram)} hist
     */
    set(name, hist) {
      if (!(hist instanceof tr.v.Histogram) &&
          !(hist instanceof tr.v.d.HistogramRef)) {
        throw new Error('Must be instanceof Histogram or HistogramRef: ' +
            hist);
      }

      this.histogramsByName_.set(name, hist);
    }

    /**
     * Add a Histogram implicitly by its own name to this map.
     *
     * @param {!(tr.v.d.HistogramRef|tr.v.Histogram)} hist
     */
    add(hist) {
      this.set(hist.name, hist);
    }

    get length() {
      return this.histogramsByName_.size;
    }

    * [Symbol.iterator]() {
      for (const pair of this.histogramsByName_) {
        yield pair;
      }
    }

    /**
     * Resolve all HistogramRefs into Histograms by looking up their guids in
     * |histograms|.
     * If a Histogram cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a Histogram cannot be found and |opt_required| is false, then the
     * HistogramRef will remain a HistogramRef.
     *
     * @param {!tr.v.HistogramSet} histograms
     * @param {boolean=} opt_required
     */
    resolve(histograms, opt_required) {
      for (const [name, value] of this) {
        if (!(value instanceof tr.v.d.HistogramRef)) continue;

        const guid = value.guid;
        const hist = histograms.lookupHistogram(guid);
        if (hist instanceof tr.v.Histogram) {
          this.histogramsByName_.set(name, hist);
        } else if (opt_required) {
          throw new Error('Unable to find Histogram ' + guid);
        }
      }
    }

    asDictInto_(d) {
      d.values = {};
      for (const [name, hist] of this) {
        d.values[name] = hist.guid;
      }
    }

    static fromDict(d) {
      const map = new RelatedHistogramMap();
      for (const [name, guid] of Object.entries(d.values)) {
        map.set(name, new tr.v.d.HistogramRef(guid));
      }
      return map;
    }
  }

  tr.v.d.Diagnostic.register(RelatedHistogramMap, {
    elementName: 'tr-v-ui-related-histogram-map-span'
  });

  return {
    RelatedHistogramMap,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  const COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER =
    'ChromeUserFriendlyCategory';

  /**
   * RelatedHistogramBreakdown encapsulates an additive relationship between
   * Histograms: the Histogram that contains this RelatedHistogramBreakdown
   * diagnostic is composed of the Histograms referenced by this
   * RelatedHistogramBreakdown diagnostic. RelatedHistogramBreakdown is a
   * "breakdown" of its containing Histogram into its contained Histograms. This
   * additive relationship can apply to groups of other things besides Events,
   * such as memory allocations. RelatedHistogramBreakdowns over groups of
   * Events is expected to be the most common way of building
   * RelatedHistogramBreakdowns, though it is not the only way. See
   * buildFromEvents() for an example of how to build a
   * RelatedHistogramBreakdown from an EventSet and a grouping function.
   */
  class RelatedHistogramBreakdown extends tr.v.d.RelatedHistogramMap {
    constructor() {
      super();
      this.colorScheme = undefined;
    }

    clone() {
      const clone = new RelatedHistogramBreakdown();
      clone.colorScheme = this.colorScheme;
      // RelatedHistogramMap.addDiagnostic() is no-op.
      return clone;
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof RelatedHistogramBreakdown &&
        otherDiagnostic.colorScheme === this.colorScheme;
    }

    /**
     * Add a Histogram by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.HistogramRef|tr.v.Histogram)} hist
     */
    set(name, hist) {
      if (!(hist instanceof tr.v.d.HistogramRef)) {
        if (!(hist instanceof tr.v.Histogram)) {
          throw new Error(
              'RelatedHistogramBreakdown can only contain Histograms');
        }

        if ((this.length > 0) &&
            (hist.unit !==
             tr.b.getFirstElement(this)[1].unit)) {
          throw new Error('Units mismatch', tr.b.getFirstElement(this)[1].unit,
              hist.unit);
        }
      }

      tr.v.d.RelatedHistogramMap.prototype.set.call(this, name, hist);
    }

    asDictInto_(d) {
      tr.v.d.RelatedHistogramMap.prototype.asDictInto_.call(this, d);
      if (this.colorScheme) d.colorScheme = this.colorScheme;
    }

    static fromDict(d) {
      const diagnostic = new RelatedHistogramBreakdown();
      for (const [name, guid] of Object.entries(d.values)) {
        diagnostic.set(name, new tr.v.d.HistogramRef(guid));
      }
      if (d.colorScheme) diagnostic.colorScheme = d.colorScheme;
      return diagnostic;
    }

    /**
    * Build a RelatedHistogramBreakdown and its Histograms from |events|.  Group
    * events using |categoryForEvent|. Add the Histograms to |histograms|.
    * Histograms' names are prefixed with |namePrefix|. Histograms are built
    * with |opt_binBoundaries|. The numeric sample for each Event is derived
    * from |opt_sampleForEvent|, which defaults to event.cpuSelfTime. The caller
    * must add the result RelatedHistogramBreakdown to their Histogram's
    * diagnostics.
    *
    * @param {!tr.v.HistogramSet} histograms
    * @param {string} namePrefix
    * @param {!tr.model.EventSet} events
    * @param {!function(!tr.model.Event):string} categoryForEvent
    * @param {!tr.b.Unit} unit
    * @param {!function(!tr.model.Event):number=} opt_sampleForEvent
    * @param {!tr.v.HistogramBinBoundaries=} opt_binBoundaries
    * @param {*=} opt_this
    * @return {!RelatedHistogramBreakdown}
    */
    static buildFromEvents(histograms, namePrefix, events, categoryForEvent,
        unit, opt_sampleForEvent, opt_binBoundaries, opt_this) {
      const sampleForEvent = opt_sampleForEvent ||
        ((event) => event.cpuSelfTime);

      const diagnostic = new RelatedHistogramBreakdown();
      for (const event of events) {
        const sample = sampleForEvent.call(opt_this, event);
        if (sample === undefined) continue;

        const eventCategory = categoryForEvent.call(opt_this, event);
        let hist = diagnostic.get(eventCategory);
        if (hist === undefined) {
          hist = new tr.v.Histogram(
              namePrefix + eventCategory, unit, opt_binBoundaries);
          histograms.addHistogram(hist);
          diagnostic.set(eventCategory, hist);
        }

        hist.addSample(sample,
            {relatedEvents: new tr.v.d.RelatedEventSet([event])});
      }
      return diagnostic;
    }
  }

  tr.v.d.Diagnostic.register(RelatedHistogramBreakdown, {
    elementName: 'tr-v-ui-breakdown-span'
  });

  return {
    COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER,
    RelatedHistogramBreakdown,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class Scalar extends tr.v.d.Diagnostic {
    /**
     * @param {!tr.b.Scalar} value
     */
    constructor(value) {
      super();
      if (!(value instanceof tr.b.Scalar)) {
        throw new Error('expected Scalar');
      }
      this.value = value;
    }

    clone() {
      return new Scalar(this.value);
    }

    asDictInto_(d) {
      d.value = this.value.asDict();
    }

    static fromDict(d) {
      return new Scalar(tr.b.Scalar.fromDict(d.value));
    }
  }

  tr.v.d.Diagnostic.register(Scalar, {
    elementName: 'tr-v-ui-scalar-diagnostic-span'
  });

  return {
    Scalar,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class TagMap extends tr.v.d.Diagnostic {
    constructor(opt_info) {
      super();
      this.tagsToStoryNames_ = new Map();

      if (opt_info) {
        for (const [tag, storyDisplayNames] of Object.entries(
            opt_info.tagsToStoryNames || {})) {
          this.tagsToStoryNames.set(tag, new Set(storyDisplayNames));
        }
      }
    }

    clone() {
      const clone = new TagMap();
      clone.addDiagnostic(this);
      return clone;
    }

    addToHistogram(hist) {
      hist.diagnostics.set(tr.v.d.RESERVED_NAMES.TAG_MAP, this);
    }

    equals(other) {
      if (!(other instanceof TagMap)) return false;

      const keys1 = new Set(this.tagsToStoryNames.keys());
      const keys2 = new Set(other.tagsToStoryNames.keys());
      if (!tr.b.setsEqual(keys1, keys2)) {
        return false;
      }

      for (const key of keys1) {
        if (!tr.b.setsEqual(
            this.tagsToStoryNames.get(key),
            other.tagsToStoryNames.get(key))) {
          return false;
        }
      }

      return true;
    }

    canAddDiagnostic(otherDiagnostic) {
      return otherDiagnostic instanceof TagMap;
    }

    addDiagnostic(otherDiagnostic) {
      for (const [name, storyDisplayNames] of
          otherDiagnostic.tagsToStoryNames) {
        if (!this.tagsToStoryNames.has(name)) {
          this.tagsToStoryNames.set(name, new Set());
        }
        for (const t of storyDisplayNames) {
          this.tagsToStoryNames.get(name).add(t);
        }
      }

      return this;
    }

    asDictInto_(d) {
      d.tagsToStoryNames = {};
      for (const [name, value] of this.tagsToStoryNames) {
        d.tagsToStoryNames[name] = Array.from(value);
      }
    }

    /**
     * @returns {Map.<string, Set.<string>>} A map of tag names to sets of story
     * display names.
     */
    get tagsToStoryNames() {
      return this.tagsToStoryNames_;
    }

    static fromDict(d) {
      const info = new TagMap();

      for (const [name, values] of
          Object.entries(d.tagsToStoryNames || {})) {
        info.tagsToStoryNames.set(name, new Set(values));
      }

      return info;
    }
  }

  tr.v.d.Diagnostic.register(TagMap, {
    elementName: 'tr-v-ui-tag-map-span'
  });

  return {
    TagMap,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class UnmergeableDiagnosticSet extends tr.v.d.Diagnostic {
    /**
     * @param {!Array.<!tr.v.d.Diagnostic>} diagnostics
     */
    constructor(diagnostics) {
      super();
      this._diagnostics = diagnostics;
    }

    clone() {
      const clone = new tr.v.d.UnmergeableDiagnosticSet();
      clone.addDiagnostic(this);
      return clone;
    }

    canAddDiagnostic(otherDiagnostic) {
      return true;
    }

    /**
     * If |otherDiagnostic| is an UnmergeableDiagnosticSet, then add clones of
     * its diagnostics to |this|. Otherwise, try to add |otherDiagnostic| to one
     * of the diagnostics already in this set. If that fails, add a clone of
     * |otherDiagnostic| to this set.
     *
     * @param {!tr.v.d.Diagnostic} otherDiagnostic
     * @return {!tr.v.d.UnmergeableDiagnostic} this
     */
    addDiagnostic(otherDiagnostic) {
      if (otherDiagnostic instanceof UnmergeableDiagnosticSet) {
        for (const subOtherDiagnostic of otherDiagnostic) {
          const clone = subOtherDiagnostic.clone();
          this.addDiagnostic(clone);
        }
        return;
      }

      for (let i = 0; i < this._diagnostics.length; ++i) {
        if (this._diagnostics[i].canAddDiagnostic(otherDiagnostic)) {
          this._diagnostics[i].addDiagnostic(otherDiagnostic);
          return;
        }
      }

      const clone = otherDiagnostic.clone();
      this._diagnostics.push(clone);
    }

    mergeRelationships(otherDiagnostic, parentHist, otherParentHist) {
      if (otherDiagnostic instanceof UnmergeableDiagnosticSet) {
        for (const subDiagnostic of otherDiagnostic) {
          this.mergeRelationships(subDiagnostic, parentHist, otherParentHist);
        }
        return;
      }
      for (const subDiagnostic of this) {
        if (!(subDiagnostic instanceof tr.v.d.RelatedHistogramMap) &&
            !(subDiagnostic instanceof tr.v.d.RelatedHistogramBreakdown)) {
          continue;
        }
        subDiagnostic.mergeRelationships(
            otherDiagnostic, parentHist, otherParentHist);
      }
    }

    get length() {
      return this._diagnostics.length;
    }

    * [Symbol.iterator]() {
      for (const diagnostic of this._diagnostics) yield diagnostic;
    }

    asDictInto_(d) {
      d.diagnostics = this._diagnostics.map(d => d.asDictOrReference());
    }

    static fromDict(d) {
      return new UnmergeableDiagnosticSet(d.diagnostics.map(
          d => ((typeof d === 'string') ?
            new tr.v.d.DiagnosticRef(d) : tr.v.d.Diagnostic.fromDict(d))));
    }
  }

  tr.v.d.Diagnostic.register(UnmergeableDiagnosticSet, {
    elementName: 'tr-v-ui-unmergeable-diagnostic-set-span'
  });

  return {
    UnmergeableDiagnosticSet,
  };
});


'use strict';
tr.exportTo('tr.v.d', function() {
  // Diagnostics that are produced outside of metrics (e.g. by telemetry) use
  // reserved names.
  const RESERVED_INFOS = {
    ANGLE_REVISIONS: {name: 'angleRevisions', type: tr.v.d.GenericSet},
    ARCHITECTURES: {name: 'architectures', type: tr.v.d.GenericSet},
    BENCHMARKS: {name: 'benchmarks', type: tr.v.d.GenericSet},
    BENCHMARK_START: {name: 'benchmarkStart', type: tr.v.d.DateRange},
    BOTS: {name: 'bots', type: tr.v.d.GenericSet},
    BUG_COMPONENTS: {name: 'bugComponents', type: tr.v.d.GenericSet},
    BUILDS: {name: 'builds', type: tr.v.d.GenericSet},
    CATAPULT_REVISIONS: {name: 'catapultRevisions', type: tr.v.d.GenericSet},
    CHROMIUM_COMMIT_POSITIONS: {
      name: 'chromiumCommitPositions', type: tr.v.d.GenericSet},
    CHROMIUM_REVISIONS: {name: 'chromiumRevisions', type: tr.v.d.GenericSet},
    GPUS: {name: 'gpus', type: tr.v.d.GenericSet},
    GROUPING_PATH: {name: 'groupingPath', type: tr.v.d.GroupingPath},
    LABELS: {name: 'labels', type: tr.v.d.GenericSet},
    LOG_URLS: {name: 'logUrls', type: tr.v.d.GenericSet},
    MASTERS: {name: 'masters', type: tr.v.d.GenericSet},
    MEMORY_AMOUNTS: {name: 'memoryAmounts', type: tr.v.d.GenericSet},
    MERGED_FROM: {name: 'mergedFrom', type: tr.v.d.RelatedHistogramMap},
    MERGED_TO: {name: 'mergedTo', type: tr.v.d.RelatedHistogramMap},
    OS_NAMES: {name: 'osNames', type: tr.v.d.GenericSet},
    OS_VERSIONS: {name: 'osVersions', type: tr.v.d.GenericSet},
    OWNERS: {name: 'owners', type: tr.v.d.GenericSet},
    PRODUCT_VERSIONS: {name: 'productVersions', type: tr.v.d.GenericSet},
    RELATED_NAMES: {name: 'relatedNames', type: tr.v.d.GenericSet},
    SKIA_REVISIONS: {name: 'skiaRevisions', type: tr.v.d.GenericSet},
    STORIES: {name: 'stories', type: tr.v.d.GenericSet},
    STORYSET_REPEATS: {name: 'storysetRepeats', type: tr.v.d.GenericSet},
    STORY_TAGS: {name: 'storyTags', type: tr.v.d.GenericSet},
    TAG_MAP: {name: 'tagmap', type: tr.v.d.TagMap},
    TRACE_START: {name: 'traceStart', type: tr.v.d.DateRange},
    TRACE_URLS: {name: 'traceUrls', type: tr.v.d.GenericSet},
    V8_COMMIT_POSITIONS: {name: 'v8CommitPositions', type: tr.v.d.DateRange},
    V8_REVISIONS: {name: 'v8Revisions', type: tr.v.d.GenericSet},
    WEBRTC_REVISIONS: {name: 'webrtcRevisions', type: tr.v.d.GenericSet},
  };

  const RESERVED_NAMES = {};

  const RESERVED_NAMES_TO_TYPES = new Map();

  for (const [codename, info] of Object.entries(RESERVED_INFOS)) {
    RESERVED_NAMES[codename] = info.name;
    if (RESERVED_NAMES_TO_TYPES.has(info.name)) {
      throw new Error(`Duplicate reserved name "${info.name}"`);
    }
    RESERVED_NAMES_TO_TYPES.set(info.name, info.type);
  }

  const RESERVED_NAMES_SET = new Set(Object.values(RESERVED_NAMES));

  return {
    RESERVED_INFOS,
    RESERVED_NAMES,
    RESERVED_NAMES_SET,
    RESERVED_NAMES_TO_TYPES,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  class DiagnosticMap extends Map {
    /**
     * @param {boolean=} opt_allowReservedNames defaults to true
     */
    constructor(opt_allowReservedNames) {
      super();
      if (opt_allowReservedNames === undefined) {
        opt_allowReservedNames = true;
      }
      this.allowReservedNames_ = opt_allowReservedNames;
    }

    /**
     * Add a new Diagnostic to this map.
     *
     * @param {string} name
     * @param {!tr.v.d.Diagnostic} diagnostic
     */
    set(name, diagnostic) {
      if (typeof(name) !== 'string') {
        throw new Error(`name must be string, not ${name}`);
      }

      if (!(diagnostic instanceof tr.v.d.Diagnostic) &&
          !(diagnostic instanceof tr.v.d.DiagnosticRef)) {
        throw new Error(`Must be instanceof Diagnostic: ${diagnostic}`);
      }

      // TODO(#3507): Reserved names should never be UnmergeableDiagnosticSet.
      if (!this.allowReservedNames_ &&
          tr.v.d.RESERVED_NAMES_SET.has(name) &&
          !(diagnostic instanceof tr.v.d.UnmergeableDiagnosticSet) &&
          !(diagnostic instanceof tr.v.d.DiagnosticRef)) {
        const type = tr.v.d.RESERVED_NAMES_TO_TYPES.get(name);
        if (type && !(diagnostic instanceof type)) {
          throw new Error(
              `Diagnostics named "${name}" must be ${type.name}, ` +
              `not ${diagnostic.constructor.name}`);
        }
      }

      Map.prototype.set.call(this, name, diagnostic);
    }

    delete(name) {
      if (name === undefined) throw new Error('missing name');
      Map.prototype.delete.call(this, name);
    }

    /**
     * Add Diagnostics from a dictionary of dictionaries.
     *
     * @param {Object} dict
     */
    addDicts(dict) {
      for (const [name, diagnosticDict] of Object.entries(dict)) {
        if (typeof diagnosticDict === 'string') {
          this.set(name, new tr.v.d.DiagnosticRef(diagnosticDict));
        } else {
          this.set(name, tr.v.d.Diagnostic.fromDict(diagnosticDict));
        }
      }
    }

    resolveSharedDiagnostics(histograms, opt_required) {
      for (const [name, value] of this) {
        if (!(value instanceof tr.v.d.DiagnosticRef)) {
          continue;
        }

        const guid = value.guid;
        const diagnostic = histograms.lookupDiagnostic(guid);
        if (diagnostic instanceof tr.v.d.Diagnostic) {
          this.set(name, diagnostic);
        } else if (opt_required) {
          throw new Error('Unable to find shared Diagnostic ' + guid);
        }
      }
    }

    asDict() {
      const dict = {};
      for (const [name, diagnostic] of this) {
        dict[name] = diagnostic.asDictOrReference();
      }
      return dict;
    }

    static fromDict(d) {
      const diagnostics = new DiagnosticMap();
      diagnostics.addDicts(d);
      return diagnostics;
    }

    static fromObject(obj) {
      const diagnostics = new DiagnosticMap();
      for (const [name, diagnostic] of Object.entries(obj)) {
        diagnostics.set(name, diagnostic);
      }
      return diagnostics;
    }

    addDiagnostics(other) {
      for (const [name, otherDiagnostic] of other) {
        if (name === tr.v.d.RESERVED_NAMES.MERGED_FROM ||
            name === tr.v.d.RESERVED_NAMES.MERGED_TO ||
            name === tr.v.d.RESERVED_NAMES.GROUPING_PATH) {
          continue;
        }

        const myDiagnostic = this.get(name);

        if (myDiagnostic !== undefined &&
            myDiagnostic.canAddDiagnostic(otherDiagnostic)) {
          myDiagnostic.addDiagnostic(otherDiagnostic);
          continue;
        }

        // We need to avoid storing references to |otherDiagnostic| in both
        // |this| and |other| because future merge()s may add yet other
        // Diagnostics to |this|, and they shouldn't accidentally modify
        // anything in |other|.
        // Now, either |this| doesn't already have a Diagnostic named |name|
        // (myDiagnostic is undefined), or
        // |this| already has a Diagnostic named |name| that can't be merged
        // with |otherDiagnostic|.
        // Either way, we need to clone |otherDiagnostic|.
        // However, clones produced via fromDict/toDict cannot necessarily be
        // merged with yet other Diagnostics, either because of semantics (as in
        // the case of TelemtryInfo and the like) or because guids must not be
        // shared by distinct Diagnostics. Therefore, Diagnostics support
        // another way of cloning that is specifically targeted at supporting
        // merging: clone().

        const clone = otherDiagnostic.clone();

        if (myDiagnostic === undefined) {
          this.set(name, clone);
          continue;
        }

        // Now, |myDiagnostic| exists and it is unmergeable with |clone|, which
        // is safe to store in |this|.
        this.set(name, new tr.v.d.UnmergeableDiagnosticSet(
              [myDiagnostic, clone]));
      }
    }

    /**
     * RelatedHistogram diagnostics cannot be merged when Histograms are merged
     * because the related Histograms might not exist yet.
     * This method assumes that all related Histograms exist and that duplicate
     * Diagnostics have been deduplicated.
     *
     * @param {!tr.v.Histogram} parentHist
     */
    mergeRelationships(parentHist) {
      for (const [name, diagnostic] of this) {
        if (!(diagnostic instanceof tr.v.d.RelatedHistogramMap) &&
            !(diagnostic instanceof tr.v.d.RelatedHistogramBreakdown) &&
            !(diagnostic instanceof tr.v.d.UnmergeableDiagnosticSet)) {
          continue;
        }

        for (const [unusedName, otherHist] of
            this.get(tr.v.d.RESERVED_NAMES.MERGED_FROM)) {
          const otherDiagnostic = otherHist.diagnostics.get(name);
          if (!(otherDiagnostic instanceof tr.v.d.RelatedHistogramMap) &&
              !(otherDiagnostic instanceof tr.v.d.RelatedHistogramBreakdown) &&
              !(otherDiagnostic instanceof tr.v.d.UnmergeableDiagnosticSet)) {
            continue;
          }
          diagnostic.mergeRelationships(otherDiagnostic, parentHist, otherHist);
        }
      }
    }
  }

  return {
    DiagnosticMap,
  };
});


'use strict';

tr.exportTo('tr.v', function() {
  const MAX_DIAGNOSTIC_MAPS = 16;

  const DEFAULT_SAMPLE_VALUES_PER_BIN = 10;

  const DEFAULT_REBINNED_COUNT = 40;

  const DEFAULT_BOUNDARIES_FOR_UNIT = new Map();

  const DELTA = String.fromCharCode(916);
  const Z_SCORE_NAME = 'z-score';
  const P_VALUE_NAME = 'p-value';
  const U_STATISTIC_NAME = 'U';

  /**
   * Converts the given percent to a string in the format specified above.
   * @param {number} percent The percent must be between 0.0 and 1.0.
   * @param {boolean=} opt_force3 Whether to force the result to be 3 chars long
   * @return {string}
   */
  function percentToString(percent, opt_force3) {
    if (percent < 0 || percent > 1) {
      throw new Error('percent must be in [0,1]');
    }
    if (percent === 0) return '000';
    if (percent === 1) return '100';
    let str = percent.toString();
    if (str[1] !== '.') {
      throw new Error('Unexpected percent');
    }
    // Pad short strings with zeros.
    str = str + '0'.repeat(Math.max(4 - str.length, 0));

    if (str.length > 4) {
      if (opt_force3) {
        str = str.slice(0, 4);
      } else {
        str = str.slice(0, 4) + '_' + str.slice(4);
      }
    }
    return '0' + str.slice(2);
  }

  /**
   * Converts the given string to a percent between 0 and 1.
   * @param {string}
   * @return {number}
   */
  function percentFromString(s) {
    return parseFloat(s[0] + '.' + s.substr(1).replace(/_/g, ''));
  }

  class HistogramBin {
    /**
     * @param {!tr.b.math.Range} range
     */
    constructor(range) {
      this.range = range;
      this.count = 0;
      this.diagnosticMaps = [];
    }

    /**
     * @param {*} value
     */
    addSample(value) {
      this.count += 1;
    }

    /**
     * @param {!tr.v.d.DiagnosticMap} diagnostics
     */
    addDiagnosticMap(diagnostics) {
      tr.b.math.Statistics.uniformlySampleStream(
          this.diagnosticMaps, this.count, diagnostics, MAX_DIAGNOSTIC_MAPS);
    }

    addBin(other) {
      if (!this.range.equals(other.range)) {
        throw new Error('Merging incompatible Histogram bins.');
      }
      tr.b.math.Statistics.mergeSampledStreams(this.diagnosticMaps, this.count,
          other.diagnosticMaps, other.count, MAX_DIAGNOSTIC_MAPS);
      this.count += other.count;
    }

    fromDict(dict) {
      this.count = dict[0];
      if (dict.length > 1) {
        for (const map of dict[1]) {
          this.diagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));
        }
      }
    }

    asDict() {
      if (!this.diagnosticMaps.length) {
        return [this.count];
      }
      // It's more efficient to serialize these 2 fields in an array. If you
      // add any other fields, you should re-evaluate whether it would be more
      // efficient to serialize as a dict.
      return [this.count, this.diagnosticMaps.map(d => d.asDict())];
    }
  }

  const DEFAULT_SUMMARY_OPTIONS = new Map([
    ['avg', true],
    ['count', true],
    ['geometricMean', false],
    ['max', true],
    ['min', true],
    ['nans', false],
    ['std', true],
    ['sum', true],
    // Don't include 'percentile' or 'iprs' here. Their default values are [],
    // which is mutable. Callers may push to it, so there must be a different
    // Array instance for each Histogram instance.
  ]);

  /**
   * This is basically a histogram, but so much more.
   * Histogram is serializable using asDict/fromDict.
   * Histogram computes several statistics of its contents.
   * Histograms can be merged.
   * getDifferenceSignificance() test whether one Histogram is statistically
   * significantly different from another Histogram.
   * Histogram stores a random sample of the exact number values added to it.
   * Histogram stores a random sample of optional per-sample DiagnosticMaps.
   * Histogram is visualized by <tr-v-ui-histogram-span>, which supports
   * selecting bins, and visualizing the DiagnosticMaps of selected bins.
   *
   * @param {!tr.b.Unit} unit
   * @param {!tr.v.HistogramBinBoundaries=} opt_binBoundaries
   */
  class Histogram {
    constructor(name, unit, opt_binBoundaries) {
      let binBoundaries = opt_binBoundaries;
      if (!binBoundaries) {
        const baseUnit = unit.baseUnit ? unit.baseUnit : unit;
        binBoundaries = DEFAULT_BOUNDARIES_FOR_UNIT.get(baseUnit.unitName);
      }

      // If this Histogram is being deserialized, then its guid will be set by
      // fromDict().
      // If this Histogram is being computed by a metric, then its guid will be
      // allocated the first time the guid is gotten by asDict().
      this.guid_ = undefined;

      // Serialize binBoundaries here instead of holding a reference to it in
      // case it is modified.
      this.binBoundariesDict_ = binBoundaries.asDict();

      this.allBins = binBoundaries.bins.slice();
      this.description = '';
      const allowReservedNames = false;
      this.diagnostics_ = new tr.v.d.DiagnosticMap(allowReservedNames);
      this.maxNumSampleValues_ = this.defaultMaxNumSampleValues_;
      this.name_ = name;
      this.nanDiagnosticMaps = [];
      this.numNans = 0;
      this.running_ = undefined;
      this.sampleValues_ = [];
      this.shortName = undefined;
      this.summaryOptions = new Map(DEFAULT_SUMMARY_OPTIONS);
      this.summaryOptions.set('percentile', []);
      this.summaryOptions.set('iprs', []);
      this.unit = unit;
    }

    /**
     * Create a Histogram, configure it, and add samples to it.
     *
     * |samples| can be either
     *  0. a number, or
     *  1. a dictionary {value: number, diagnostics: dictionary}, or
     *  2. an array of
     *     2a. number, or
     *     2b. dictionaries {value, diagnostics}.
     *
     * @param {string} name
     * @param {!tr.b.Unit} unit
     * @param {number|!Object|!Array.<(number|!Object)>} samples
     * @param {!Object=} opt_options
     * @param {!tr.v.HistogramBinBoundaries} opt_options.binBoundaries
     * @param {!Object|!Map} opt_options.summaryOptions
     * @param {!Object|!Map} opt_options.diagnostics
     * @param {string} opt_options.description
     * @param {string} opt_options.shortName
     * @return {!tr.v.Histogram}
     */
    static create(name, unit, samples, opt_options) {
      const options = opt_options || {};
      const hist = new Histogram(name, unit, options.binBoundaries);

      if (options.description) hist.description = options.description;
      if (options.shortName) hist.shortName = options.shortName;

      if (options.summaryOptions) {
        let summaryOptions = options.summaryOptions;
        if (!(summaryOptions instanceof Map)) {
          summaryOptions = Object.entries(summaryOptions);
        }
        for (const [name, value] of summaryOptions) {
          hist.summaryOptions.set(name, value);
        }
      }

      if (options.diagnostics !== undefined) {
        let diagnostics = options.diagnostics;
        if (!(diagnostics instanceof Map)) {
          diagnostics = Object.entries(diagnostics);
        }
        for (const [name, diagnostic] of diagnostics) {
          hist.diagnostics.set(name, diagnostic);
        }
      }

      if (!(samples instanceof Array)) samples = [samples];

      for (const sample of samples) {
        if (typeof sample === 'object') {
          hist.addSample(sample.value, sample.diagnostics);
        } else {
          hist.addSample(sample);
        }
      }

      return hist;
    }

    get diagnostics() {
      return this.diagnostics_;
    }

    get running() {
      return this.running_;
    }

    get maxNumSampleValues() {
      return this.maxNumSampleValues_;
    }

    set maxNumSampleValues(n) {
      this.maxNumSampleValues_ = n;
      tr.b.math.Statistics.uniformlySampleArray(
          this.sampleValues_, this.maxNumSampleValues_);
    }

    get name() {
      return this.name_;
    }

    get guid() {
      if (this.guid_ === undefined) {
        this.guid_ = tr.b.GUID.allocateUUID4();
      }

      return this.guid_;
    }

    set guid(guid) {
      if (this.guid_ !== undefined) {
        throw new Error('Cannot reset guid');
      }

      this.guid_ = guid;
    }

    static fromDict(dict) {
      const hist = new Histogram(dict.name, tr.b.Unit.fromJSON(dict.unit),
          HistogramBinBoundaries.fromDict(dict.binBoundaries));
      hist.guid = dict.guid;
      if (dict.shortName) {
        hist.shortName = dict.shortName;
      }
      if (dict.description) {
        hist.description = dict.description;
      }
      if (dict.diagnostics) {
        hist.diagnostics.addDicts(dict.diagnostics);
      }
      if (dict.allBins) {
        if (dict.allBins.length !== undefined) {
          for (let i = 0; i < dict.allBins.length; ++i) {
            // Copy HistogramBin on write, share the rest with the other
            // Histograms that use the same HistogramBinBoundaries.
            hist.allBins[i] = new HistogramBin(hist.allBins[i].range);
            hist.allBins[i].fromDict(dict.allBins[i]);
          }
        } else {
          for (const [i, binDict] of Object.entries(dict.allBins)) {
            hist.allBins[i] = new HistogramBin(hist.allBins[i].range);
            hist.allBins[i].fromDict(binDict);
          }
        }
      }
      if (dict.running) {
        hist.running_ = tr.b.math.RunningStatistics.fromDict(dict.running);
      }
      if (dict.summaryOptions) {
        if (dict.summaryOptions.iprs) {
          // Range.fromDict() requires isEmpty, which is unnecessarily verbose
          // for this use case.
          dict.summaryOptions.iprs = dict.summaryOptions.iprs.map(
              r => tr.b.math.Range.fromExplicitRange(r[0], r[1]));
        }
        hist.customizeSummaryOptions(dict.summaryOptions);
      }
      if (dict.maxNumSampleValues !== undefined) {
        hist.maxNumSampleValues = dict.maxNumSampleValues;
      }
      if (dict.sampleValues) {
        hist.sampleValues_ = dict.sampleValues;
      }
      if (dict.numNans) {
        hist.numNans = dict.numNans;
      }
      if (dict.nanDiagnostics) {
        for (const map of dict.nanDiagnostics) {
          hist.nanDiagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));
        }
      }
      return hist;
    }

    get numValues() {
      return this.running_ ? this.running_.count : 0;
    }

    get average() {
      return this.running_ ? this.running_.mean : undefined;
    }

    get standardDeviation() {
      return this.running_ ? this.running_.stddev : undefined;
    }

    get geometricMean() {
      return this.running_ ? this.running_.geometricMean : 0;
    }

    get sum() {
      return this.running_ ? this.running_.sum : 0;
    }

    get min() {
      return this.running_ ? this.running_.min : Infinity;
    }

    get max() {
      return this.running_ ? this.running_.max : -Infinity;
    }

    /**
     * Requires that units agree.
     * Returns DONT_CARE if that is the units' improvementDirection.
     * Returns SIGNIFICANT if the Mann-Whitney U test returns a
     * p-value less than opt_alpha or DEFAULT_ALPHA. Returns INSIGNIFICANT if
     * the p-value is greater than alpha.
     *
     * @param {!tr.v.Histogram} other
     * @param {number=} opt_alpha
     * @return {!tr.b.math.Statistics.Significance}
     */
    getDifferenceSignificance(other, opt_alpha) {
      if (this.unit !== other.unit) {
        throw new Error('Cannot compare Histograms with different units');
      }

      if (this.unit.improvementDirection ===
          tr.b.ImprovementDirection.DONT_CARE) {
        return tr.b.math.Statistics.Significance.DONT_CARE;
      }

      if (!(other instanceof Histogram)) {
        throw new Error('Unable to compute a p-value');
      }

      const testResult = tr.b.math.Statistics.mwu(
          this.sampleValues, other.sampleValues, opt_alpha);
      return testResult.significance;
    }

    /*
     * Compute an approximation of percentile based on the counts in the bins.
     * If the real percentile lies within |this.range| then the result of
     * the function will deviate from the real percentile by at most
     * the maximum width of the bin(s) within which the point(s)
     * from which the real percentile would be calculated lie.
     * If the real percentile is outside |this.range| then the function
     * returns the closest range limit: |this.range.min| or |this.range.max|.
     *
     * @param {number} percent The percent must be between 0.0 and 1.0.
     */
    getApproximatePercentile(percent) {
      if (percent < 0 || percent > 1) {
        throw new Error('percent must be in [0,1]');
      }
      if (this.numValues === 0) return undefined;
      if (this.allBins.length === 1) {
        // Copy sampleValues, don't sort them in place, in order to preserve
        // insertion order.
        const sortedSampleValues = this.sampleValues.slice().sort(
            (x, y) => x - y);
        return sortedSampleValues[Math.floor((sortedSampleValues.length - 1) *
            percent)];
      }
      let valuesToSkip = Math.floor((this.numValues - 1) * percent);
      for (const bin of this.allBins) {
        valuesToSkip -= bin.count;
        if (valuesToSkip >= 0) continue;
        if (bin.range.min === -Number.MAX_VALUE) {
          return bin.range.max;
        }
        if (bin.range.max === Number.MAX_VALUE) {
          return bin.range.min;
        }
        return bin.range.center;
      }
      return this.allBins[this.allBins.length - 1].range.min;
    }

    getBinIndexForValue(value) {
      // Don't use subtraction to avoid arithmetic overflow.
      const i = tr.b.findHighIndexInSortedArray(
          this.allBins, b => ((value < b.range.max) ? -1 : 1));
      if (0 <= i && i < this.allBins.length) return i;
      return this.allBins.length - 1;
    }

    getBinForValue(value) {
      return this.allBins[this.getBinIndexForValue(value)];
    }

    /**
     * @param {number|*} value
     * @param {(!Object|!tr.v.d.DiagnosticMap)=} opt_diagnostics
     */
    addSample(value, opt_diagnostics) {
      if (opt_diagnostics &&
          !(opt_diagnostics instanceof tr.v.d.DiagnosticMap)) {
        opt_diagnostics = tr.v.d.DiagnosticMap.fromObject(opt_diagnostics);
      }

      if (typeof(value) !== 'number' || isNaN(value)) {
        this.numNans++;
        if (opt_diagnostics) {
          tr.b.math.Statistics.uniformlySampleStream(this.nanDiagnosticMaps,
              this.numNans, opt_diagnostics, MAX_DIAGNOSTIC_MAPS);
        }
      } else {
        if (this.running_ === undefined) {
          this.running_ = new tr.b.math.RunningStatistics();
        }
        this.running_.add(value);

        const binIndex = this.getBinIndexForValue(value);
        let bin = this.allBins[binIndex];
        if (bin.count === 0) {
          // Copy HistogramBin on write, share the rest with the other
          // Histograms that use the same HistogramBinBoundaries.
          bin = new HistogramBin(bin.range);
          this.allBins[binIndex] = bin;
        }
        bin.addSample(value);
        if (opt_diagnostics) {
          bin.addDiagnosticMap(opt_diagnostics);
        }
      }

      tr.b.math.Statistics.uniformlySampleStream(this.sampleValues_,
          this.numValues + this.numNans, value, this.maxNumSampleValues);
    }

    sampleValuesInto(samples) {
      for (const sampleValue of this.sampleValues) {
        samples.push(sampleValue);
      }
    }

    /**
     * Return true if this Histogram can be added to |other|.
     *
     * @param {!tr.v.Histogram} other
     * @return {boolean}
     */
    canAddHistogram(other) {
      if (this.unit !== other.unit) {
        return false;
      }
      if (this.binBoundariesDict_ === other.binBoundariesDict_) {
        return true;
      }
      // |binBoundariesDict_| may be equal even if they are not the same object.
      if (this.binBoundariesDict_.length !== other.binBoundariesDict_.length) {
        return false;
      }
      for (let i = 0; i < this.binBoundariesDict_.length; ++i) {
        const slice = this.binBoundariesDict_[i];
        const otherSlice = other.binBoundariesDict_[i];
        if (slice instanceof Array) {
          if (!(otherSlice instanceof Array)) {
            return false;
          }
          if (slice[0] !== otherSlice[0] ||
              !tr.b.math.approximately(slice[1], otherSlice[1]) ||
              slice[2] !== otherSlice[2]) {
            return false;
          }
        } else {
          if (otherSlice instanceof Array) {
            return false;
          }
          if (!tr.b.math.approximately(slice, otherSlice)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * Add |other| to this Histogram in-place if they can be added.
     *
     * @param {!tr.v.Histogram} other
     */
    addHistogram(other) {
      if (!this.canAddHistogram(other)) {
        throw new Error('Merging incompatible Histograms');
      }

      tr.b.math.Statistics.mergeSampledStreams(this.nanDiagnosticMaps,
          this.numNans, other.nanDiagnosticMaps, other.numNans,
          MAX_DIAGNOSTIC_MAPS);
      tr.b.math.Statistics.mergeSampledStreams(
          this.sampleValues, this.numValues + this.numNans,
          other.sampleValues, other.numValues + other.numNans,
          (this.maxNumSampleValues + other.maxNumSampleValues) / 2);
      this.numNans += other.numNans;

      if (other.running_ !== undefined) {
        if (this.running_ === undefined) {
          this.running_ = new tr.b.math.RunningStatistics();
        }
        this.running_ = this.running_.merge(other.running_);
      }

      for (let i = 0; i < this.allBins.length; ++i) {
        let bin = this.allBins[i];
        if (bin.count === 0) {
          bin = new HistogramBin(bin.range);
          this.allBins[i] = bin;
        }
        bin.addBin(other.allBins[i]);
      }

      let mergedFrom = this.diagnostics.get(tr.v.d.RESERVED_NAMES.MERGED_FROM);
      if (!mergedFrom) {
        mergedFrom = new tr.v.d.RelatedHistogramMap();
        this.diagnostics.set(tr.v.d.RESERVED_NAMES.MERGED_FROM, mergedFrom);
      }
      mergedFrom.set(mergedFrom.length, other);

      let mergedTo = other.diagnostics.get(tr.v.d.RESERVED_NAMES.MERGED_TO);
      if (!mergedTo) {
        mergedTo = new tr.v.d.RelatedHistogramMap();
        other.diagnostics.set(tr.v.d.RESERVED_NAMES.MERGED_TO, mergedTo);
      }
      mergedTo.set(mergedTo.length, this);

      this.diagnostics.addDiagnostics(other.diagnostics);

      for (const [stat, option] of other.summaryOptions) {
        if (stat === 'percentile') {
          const percentiles = this.summaryOptions.get(stat);
          for (const percent of option) {
            if (!percentiles.includes(percent)) percentiles.push(percent);
          }
        } else if (stat === 'iprs') {
          const thisIprs = this.summaryOptions.get(stat);
          for (const ipr of option) {
            let found = false;
            for (const thisIpr of thisIprs) {
              found = ipr.equals(thisIpr);
              if (found) break;
            }
            if (!found) thisIprs.push(ipr);
          }
        } else if (option && !this.summaryOptions.get(stat)) {
          this.summaryOptions.set(stat, true);
        }
      }
    }

    /**
     * Controls which statistics are exported to dashboard for this Histogram.
     * The options not included in the |summaryOptions| will not change.
     *
     * @param {!Object} summaryOptions
     * @param {boolean=} summaryOptions.avg
     * @param {boolean=} summaryOptions.count
     * @param {boolean=} summaryOptions.geometricMean
     * @param {boolean=} summaryOptions.max
     * @param {boolean=} summaryOptions.min
     * @param {boolean=} summaryOptions.nans
     * @param {boolean=} summaryOptions.std
     * @param {boolean=} summaryOptions.sum
     * @param {!Array.<number>=} summaryOptions.percentile Numbers in (0,1)
     * @param {!Array.<!tr.b.Range>=} summaryOptions.iprs Ranges of numbers in
     *     (0,1).
     */
    customizeSummaryOptions(summaryOptions) {
      for (const [key, value] of Object.entries(summaryOptions)) {
        this.summaryOptions.set(key, value);
      }
    }

    /**
     * @param {string} statName
     * @param {!tr.v.Histogram=} opt_referenceHistogram
     * @param {!HypothesisTestResult=} opt_mwu
     * @return {!tr.b.Scalar}
     * @throws {Error} When statName is not recognized, such as delta statistics
     *     when !this.canCompare(opt_referenceHistograms).
     */
    getStatisticScalar(statName, opt_referenceHistogram, opt_mwu) {
      if (statName === 'avg') {
        if (typeof(this.average) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, this.average);
      }
      if (statName === 'std') {
        if (typeof(this.standardDeviation) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, this.standardDeviation);
      }
      if (statName === 'geometricMean') {
        if (typeof(this.geometricMean) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, this.geometricMean);
      }
      if (statName === 'min' || statName === 'max' || statName === 'sum') {
        if (this.running_ === undefined) {
          this.running_ = new tr.b.math.RunningStatistics();
        }
        if (typeof(this.running_[statName]) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, this.running_[statName]);
      }
      if (statName === 'nans') {
        return new tr.b.Scalar(
            tr.b.Unit.byName.count_smallerIsBetter, this.numNans);
      }
      if (statName === 'count') {
        return new tr.b.Scalar(
            tr.b.Unit.byName.count_smallerIsBetter, this.numValues);
      }
      if (statName.substr(0, 4) === 'pct_') {
        const percent = percentFromString(statName.substr(4));
        if (this.numValues === 0) return undefined;
        const percentile = this.getApproximatePercentile(percent);
        if (typeof(percentile) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, percentile);
      }
      if (statName.substr(0, 4) === 'ipr_') {
        let lower = percentFromString(statName.substr(4, 3));
        let upper = percentFromString(statName.substr(8));
        if (lower >= upper) {
          throw new Error('Invalid inter-percentile range: ' + statName);
        }
        lower = this.getApproximatePercentile(lower);
        upper = this.getApproximatePercentile(upper);
        const ipr = upper - lower;
        if (typeof(ipr) !== 'number') return undefined;
        return new tr.b.Scalar(this.unit, ipr);
      }

      if (!this.canCompare(opt_referenceHistogram)) {
        throw new Error(
            'Cannot compute ' + statName +
            ' when histograms are not comparable');
      }

      const suffix = tr.b.Unit.nameSuffixForImprovementDirection(
          this.unit.improvementDirection);

      const deltaIndex = statName.indexOf(DELTA);
      if (deltaIndex >= 0) {
        const baseStatName = statName.substr(deltaIndex + 1);
        const thisStat = this.getStatisticScalar(baseStatName);
        const otherStat = opt_referenceHistogram.getStatisticScalar(
            baseStatName);
        const deltaValue = thisStat.value - otherStat.value;

        if (statName[0] === '%') {
          return new tr.b.Scalar(
              tr.b.Unit.byName['normalizedPercentageDelta' + suffix],
              deltaValue / otherStat.value);
        }
        return new tr.b.Scalar(
            thisStat.unit.correspondingDeltaUnit, deltaValue);
      }

      if (statName === Z_SCORE_NAME) {
        return new tr.b.Scalar(
            tr.b.Unit.byName['sigmaDelta' + suffix],
            (this.average - opt_referenceHistogram.average) /
            opt_referenceHistogram.standardDeviation);
      }

      const mwu = opt_mwu || tr.b.math.Statistics.mwu(
          this.sampleValues, opt_referenceHistogram.sampleValues);
      if (statName === P_VALUE_NAME) {
        return new tr.b.Scalar(tr.b.Unit.byName.unitlessNumber, mwu.p);
      }
      if (statName === U_STATISTIC_NAME) {
        return new tr.b.Scalar(tr.b.Unit.byName.unitlessNumber, mwu.U);
      }

      throw new Error('Unrecognized statistic name: ' + statName);
    }

    /**
     * @return {!Array.<string>} names of enabled summary statistics
     */
    get statisticsNames() {
      const statisticsNames = new Set();
      for (const [statName, option] of this.summaryOptions) {
        if (statName === 'percentile') {
          for (const pctile of option) {
            statisticsNames.add('pct_' + tr.v.percentToString(pctile));
          }
        } else if (statName === 'iprs') {
          for (const range of option) {
            statisticsNames.add(
                'ipr_' + tr.v.percentToString(range.min, true) +
                '_' + tr.v.percentToString(range.max, true));
          }
        } else if (option) {
          statisticsNames.add(statName);
        }
      }
      return statisticsNames;
    }

    /**
     * Returns true if delta statistics can be computed between |this| and
     * |other|.
     *
     * @param {!tr.v.Histogram=} other
     * @return {boolean}
     */
    canCompare(other) {
      return other instanceof Histogram &&
          this.unit === other.unit &&
          this.numValues > 0 &&
          other.numValues > 0;
    }

    /**
     * Returns |statName| if it can be computed, or the related non-delta
     * statistic if |statName| is a delta statistic and
     * !this.canCompare(opt_referenceHist).
     *
     * @param {string} statName
     * @param {!tr.v.Histogram=} opt_referenceHist
     * @return {string}
     */
    getAvailableStatisticName(statName, opt_referenceHist) {
      if (this.canCompare(opt_referenceHist)) return statName;
      if (statName === Z_SCORE_NAME ||
          statName === P_VALUE_NAME ||
          statName === U_STATISTIC_NAME) {
        return 'avg';
      }
      const deltaIndex = statName.indexOf(DELTA);
      if (deltaIndex < 0) return statName;
      return statName.substr(deltaIndex + 1);
    }

    /**
     * Returns names of delta statistics versions of given non-delta statistics
     * names.
     *
     * @param {!Array.<string>} statNames
     * @return {!Array.<string>}
     */
    static getDeltaStatisticsNames(statNames) {
      const deltaNames = [];
      for (const statName of statNames) {
        deltaNames.push(`${DELTA}${statName}`);
        deltaNames.push(`%${DELTA}${statName}`);
      }
      return deltaNames.concat([Z_SCORE_NAME, P_VALUE_NAME, U_STATISTIC_NAME]);
    }

    /**
     * Returns a Map {statisticName: Scalar}.
     *
     * Each enabled summary option produces the corresponding value:
     * min, max, count, sum, avg, or std.
     * Each percentile 0.x produces pct_0x0.
     * Each percentile 0.xx produces pct_0xx.
     * Each percentile 0.xxy produces pct_0xx_y.
     * Percentile 1.0 produces pct_100.
     *
     * @return {!Map.<string, Scalar>}
     */
    get statisticsScalars() {
      const results = new Map();
      for (const statName of this.statisticsNames) {
        const scalar = this.getStatisticScalar(statName);
        if (scalar === undefined) continue;
        results.set(statName, scalar);
      }
      return results;
    }

    get sampleValues() {
      return this.sampleValues_;
    }

    /**
     * Create a new Histogram instance that is just like |this| except for its
     * guid. This is useful when merging Histograms.
     * @return {!tr.v.Histogram}
     */
    clone() {
      const binBoundaries = HistogramBinBoundaries.fromDict(
          this.binBoundariesDict_);
      const hist = new Histogram(this.name, this.unit, binBoundaries);
      for (const [stat, option] of this.summaryOptions) {
        // Copy arrays, but not ipr Ranges.
        if (stat === 'percentile' || stat === 'iprs') {
          hist.summaryOptions.set(stat, Array.from(option));
        } else {
          hist.summaryOptions.set(stat, option);
        }
      }
      hist.addHistogram(this);
      return hist;
    }

    /**
     * Produce a Histogram with |this| Histogram's name, unit, description,
     * statistics, summaryOptions, sampleValues, and diagnostics, but with
     * |newBoundaries|.
     * guid and sample diagnostics are not copied. In-bound Relationship
     * diagnostics are broken.
     *
     * @param {!tr.v.HistogramBinBoundaries} newBoundaries
     * @return {!tr.v.Histogram}
     */
    rebin(newBoundaries) {
      const rebinned = new tr.v.Histogram(this.name, this.unit, newBoundaries);
      rebinned.description = this.description;
      for (const sample of this.sampleValues) {
        rebinned.addSample(sample);
      }
      rebinned.running_ = this.running_;
      for (const [name, diagnostic] of this.diagnostics) {
        rebinned.diagnostics.set(name, diagnostic);
      }
      for (const [stat, option] of this.summaryOptions) {
        // Copy the array of percentiles.
        if (stat === 'percentile') {
          rebinned.summaryOptions.set(stat, Array.from(option));
        } else {
          rebinned.summaryOptions.set(stat, option);
        }
      }
      return rebinned;
    }

    asDict() {
      const dict = {};
      dict.name = this.name;
      dict.unit = this.unit.asJSON();
      dict.guid = this.guid;
      if (this.binBoundariesDict_ !== undefined) {
        dict.binBoundaries = this.binBoundariesDict_;
      }
      if (this.shortName) {
        dict.shortName = this.shortName;
      }
      if (this.description) {
        dict.description = this.description;
      }
      if (this.diagnostics.size) {
        dict.diagnostics = this.diagnostics.asDict();
      }
      if (this.maxNumSampleValues !== this.defaultMaxNumSampleValues_) {
        dict.maxNumSampleValues = this.maxNumSampleValues;
      }
      if (this.numNans) {
        dict.numNans = this.numNans;
      }
      if (this.nanDiagnosticMaps.length) {
        dict.nanDiagnostics = this.nanDiagnosticMaps.map(
            dm => dm.asDict());
      }

      if (this.numValues) {
        dict.sampleValues = this.sampleValues.slice();
        dict.running = this.running_.asDict();
        dict.allBins = this.allBinsAsDict_();
      }

      const summaryOptions = {};
      let anyOverriddenSummaryOptions = false;
      for (const [name, value] of this.summaryOptions) {
        let option;
        if (name === 'percentile') {
          if (value.length === 0) continue;
          option = Array.from(value);
        } else if (name === 'iprs') {
          // Use a more compact JSON format than Range supports.
          if (value.length === 0) continue;
          option = value.map(r => [r.min, r.max]);
        } else if (value === DEFAULT_SUMMARY_OPTIONS.get(name)) {
          continue;
        } else {
          option = value;
        }
        summaryOptions[name] = option;
        anyOverriddenSummaryOptions = true;
      }
      if (anyOverriddenSummaryOptions) {
        dict.summaryOptions = summaryOptions;
      }

      return dict;
    }

    allBinsAsDict_() {
      // dict.allBins may be either an array or a dict, whichever is more
      // efficient.
      // The overhead of the array form is significant when the histogram is
      // sparse, and the overhead of the dict form is significant when the
      // histogram is dense.
      // The dict form is more efficient when more than half of allBins are
      // empty. The array form is more efficient when fewer than half of
      // allBins are empty.

      const numBins = this.allBins.length;

      // If allBins are empty, then don't serialize anything for them.
      let emptyBins = 0;

      for (let i = 0; i < numBins; ++i) {
        if (this.allBins[i].count === 0) {
          ++emptyBins;
        }
      }

      if (emptyBins === numBins) {
        return undefined;
      }

      if (emptyBins > (numBins / 2)) {
        const allBinsDict = {};
        for (let i = 0; i < numBins; ++i) {
          const bin = this.allBins[i];
          if (bin.count > 0) {
            allBinsDict[i] = bin.asDict();
          }
        }
        return allBinsDict;
      }

      const allBinsArray = [];
      for (let i = 0; i < numBins; ++i) {
        allBinsArray.push(this.allBins[i].asDict());
      }
      return allBinsArray;
    }

    get defaultMaxNumSampleValues_() {
      // Single-bin histograms might be rebin()ned, so they should retain enough
      // samples that the rebinned histogram looks close enough.
      return DEFAULT_SAMPLE_VALUES_PER_BIN * Math.max(
          this.allBins.length, DEFAULT_REBINNED_COUNT);
    }
  }

  // Some metrics only want to report average. This dictionary is provided to
  // facilitate disabling all other statistics.
  Histogram.AVERAGE_ONLY_SUMMARY_OPTIONS = {
    count: false,
    max: false,
    min: false,
    std: false,
    sum: false,
  };

  const HISTOGRAM_BIN_BOUNDARIES_CACHE = new Map();

  /*
   * Reusable builder for tr.v.Histogram objects.
   *
   * The bins of the Histogram are specified by adding the desired boundaries
   * between bins. Initially, the builder has only a single boundary:
   *
   *           range.min=range.max
   *                    |
   *                    |
   *   -MAX_VALUE <-----|-----------> +MAX_VALUE
   *       :  resulting : resulting       :
   *       :  underflow :  overflow       :
   *       :     bin    :    bin          :
   *
   * If the single boundary is set to either -Number.MAX_VALUE or
   * +Number.MAX_VALUE, then the builder will construct only a single bin:
   *
   *             range.min=range.max
   *                      |
   *                      |
   *   -MAX_VALUE <-> +MAX_VALUE
   *       :   resulting  :
   *       :      bin     :
   *
   * More boundaries can be added (in increasing order) using addBinBoundary,
   * addLinearBins and addExponentialBins:
   *
   *                range.min                           range.max
   *                     |         |         |     |         |
   *                     |         |         |     |         |
   *   -MAX_VALUE <------|---------|---------|-----|---------|------> +MAX_VALUE
   *       :  resulting  : result. : result. :     : result. : resulting  :
   *       :  underflow  : central : central : ... : central :  overflow  :
   *       :     bin     :  bin 0  :  bin 1  :     : bin N-1 :    bin     :
   *
   * An important feature of the builder is that it's reusable, i.e. it can be
   * used to build multiple Histograms with the same bin structure.
   */
  class HistogramBinBoundaries {
    /**
     * Create a linearly scaled tr.v.HistogramBinBoundaries with |numBins| bins
     * ranging from |min| to |max|.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} numBins
     * @return {tr.v.HistogramBinBoundaries}
     */
    static createLinear(min, max, numBins) {
      return new HistogramBinBoundaries(min).addLinearBins(max, numBins);
    }

    /**
     * Create an exponentially scaled tr.v.HistogramBinBoundaries with |numBins|
     * bins ranging from |min| to |max|.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} numBins
     * @return {tr.v.HistogramBinBoundaries}
     */
    static createExponential(min, max, numBins) {
      return new HistogramBinBoundaries(min).addExponentialBins(max, numBins);
    }

    /**
     * @param {Array.<number>} binBoundaries
     */
    static createWithBoundaries(binBoundaries) {
      const builder = new HistogramBinBoundaries(binBoundaries[0]);
      for (const boundary of binBoundaries.slice(1)) {
        builder.addBinBoundary(boundary);
      }
      return builder;
    }

    /**
     * |minBinBoundary| will be the boundary between the underflow bin and the
     * first central bin if other bin boundaries are added.
     * If no other bin boundaries are added, then |minBinBoundary| will be the
     * boundary between the underflow bin and the overflow bin.
     * If no other bin boundaries are added and |minBinBoundary| is either
     * -Number.MAX_VALUE or +Number.MAX_VALUE, then only a single binRange will
     * be built.
     *
     * @param {number} minBinBoundary The minimum boundary between bins.
     */
    constructor(minBinBoundary) {
      this.builder_ = [minBinBoundary];
      this.range_ = new tr.b.math.Range();
      this.range_.addValue(minBinBoundary);
      this.binRanges_ = undefined;
      this.bins_ = undefined;
    }

    get range() {
      return this.range_;
    }

    asDict() {
      if (this.builder_.length === 1 && this.builder_[0] === Number.MAX_VALUE) {
        return undefined;
      }

      // Don't copy builder_ here so that Histogram.canAddHistogram() can test
      // for object identity.
      return this.builder_;
    }

    pushBuilderSlice_(slice) {
      this.builder_.push(slice);
      // Copy builder_ when it's modified so that Histogram.canAddHistogram()
      // can test for object identity.
      this.builder_ = this.builder_.slice();
    }

    static fromDict(dict) {
      if (dict === undefined) {
        return HistogramBinBoundaries.SINGULAR;
      }

      // When loading a results2.html with many Histograms with the same bin
      // boundaries, caching the HistogramBinBoundaries not only speeds up
      // loading, but also prevents a bug where buildBinRanges_ is occasionally
      // non-deterministic, which causes similar Histograms to be unmergeable.
      const cacheKey = JSON.stringify(dict);
      if (HISTOGRAM_BIN_BOUNDARIES_CACHE.has(cacheKey)) {
        return HISTOGRAM_BIN_BOUNDARIES_CACHE.get(cacheKey);
      }

      const binBoundaries = new HistogramBinBoundaries(dict[0]);
      for (const slice of dict.slice(1)) {
        if (!(slice instanceof Array)) {
          binBoundaries.addBinBoundary(slice);
          continue;
        }
        switch (slice[0]) {
          case HistogramBinBoundaries.SLICE_TYPE.LINEAR:
            binBoundaries.addLinearBins(slice[1], slice[2]);
            break;

          case HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:
            binBoundaries.addExponentialBins(slice[1], slice[2]);
            break;

          default:
            throw new Error('Unrecognized HistogramBinBoundaries slice type');
        }
      }
      HISTOGRAM_BIN_BOUNDARIES_CACHE.set(cacheKey, binBoundaries);
      return binBoundaries;
    }

    get bins() {
      if (this.bins_ === undefined) {
        this.buildBins_();
      }
      return this.bins_;
    }

    buildBins_() {
      this.bins_ = this.binRanges.map(r => new HistogramBin(r));
      // It would be nice to Object.freeze() the bins in order to catch bugs
      // when we forget to copy a bin before writing to it, but that would slow
      // down buildBins_ by 55%: https://jsperf.com/new-vs-new-freeze/1
    }

    /**
     * @return {!Array.<!tr.b.math.Range>}
     */
    get binRanges() {
      if (this.binRanges_ === undefined) {
        this.buildBinRanges_();
      }
      return this.binRanges_;
    }

    buildBinRanges_() {
      if (typeof this.builder_[0] !== 'number') {
        throw new Error('Invalid start of builder_');
      }
      this.binRanges_ = [];
      let prevBoundary = this.builder_[0];

      if (prevBoundary > -Number.MAX_VALUE) {
        // underflow bin
        this.binRanges_.push(tr.b.math.Range.fromExplicitRange(
            -Number.MAX_VALUE, prevBoundary));
      }

      for (const slice of this.builder_.slice(1)) {
        if (!(slice instanceof Array)) {
          this.binRanges_.push(
              tr.b.math.Range.fromExplicitRange(prevBoundary, slice));
          prevBoundary = slice;
          continue;
        }
        const nextMaxBinBoundary = slice[1];
        const binCount = slice[2];
        const sliceMinBinBoundary = prevBoundary;

        switch (slice[0]) {
          case HistogramBinBoundaries.SLICE_TYPE.LINEAR:
            {
              const binWidth = (nextMaxBinBoundary - prevBoundary) / binCount;
              for (let i = 1; i < binCount; i++) {
                const boundary = sliceMinBinBoundary + i * binWidth;
                this.binRanges_.push(tr.b.math.Range.fromExplicitRange(
                    prevBoundary, boundary));
                prevBoundary = boundary;
              }
              break;
            }

          case HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:
            {
              const binExponentWidth =
                  Math.log(nextMaxBinBoundary / prevBoundary) / binCount;
              for (let i = 1; i < binCount; i++) {
                const boundary = sliceMinBinBoundary * Math.exp(
                    i * binExponentWidth);
                this.binRanges_.push(tr.b.math.Range.fromExplicitRange(
                    prevBoundary, boundary));
                prevBoundary = boundary;
              }
              break;
            }

          default:
            throw new Error('Unrecognized HistogramBinBoundaries slice type');
        }
        this.binRanges_.push(tr.b.math.Range.fromExplicitRange(
            prevBoundary, nextMaxBinBoundary));
        prevBoundary = nextMaxBinBoundary;
      }
      if (prevBoundary < Number.MAX_VALUE) {
        // overflow bin
        this.binRanges_.push(tr.b.math.Range.fromExplicitRange(
            prevBoundary, Number.MAX_VALUE));
      }
    }

    /**
     * Add a bin boundary |nextMaxBinBoundary| to the builder.
     *
     * This operation effectively corresponds to appending a new central bin
     * with the range [this.range.max, nextMaxBinBoundary].
     *
     * @param {number} nextMaxBinBoundary The added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     */
    addBinBoundary(nextMaxBinBoundary) {
      if (nextMaxBinBoundary <= this.range.max) {
        throw new Error('The added max bin boundary must be larger than ' +
            'the current max boundary');
      }

      // If binRanges_ had been built, then clear them.
      this.binRanges_ = undefined;
      this.bins_ = undefined;

      this.pushBuilderSlice_(nextMaxBinBoundary);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }

    /**
     * Add |binCount| linearly scaled bin boundaries up to |nextMaxBinBoundary|
     * to the builder.
     *
     * This operation corresponds to appending |binCount| central bins of
     * constant range width
     * W = ((|nextMaxBinBoundary| - |this.range.max|) / |binCount|)
     * with the following ranges:
     *
     *   [|this.maxMinBoundary|, |this.maxMinBoundary| + W]
     *   [|this.maxMinBoundary| + W, |this.maxMinBoundary| + 2W]
     *   [|this.maxMinBoundary| + 2W, |this.maxMinBoundary| + 3W]
     *   ...
     *   [|this.maxMinBoundary| + (|binCount| - 2) * W,
     *    |this.maxMinBoundary| + (|binCount| - 2) * W]
     *   [|this.maxMinBoundary| + (|binCount| - 1) * W,
     *    |nextMaxBinBoundary|]
     *
     * @param {number} nextBinBoundary The last added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     * @param {number} binCount Number of bins to be added (must be positive).
     */
    addLinearBins(nextMaxBinBoundary, binCount) {
      if (binCount <= 0) {
        throw new Error('Bin count must be positive');
      }

      if (nextMaxBinBoundary <= this.range.max) {
        throw new Error('The new max bin boundary must be greater than ' +
            'the previous max bin boundary');
      }

      // If binRanges_ had been built, then clear them.
      this.binRanges_ = undefined;
      this.bins_ = undefined;

      this.pushBuilderSlice_([
        HistogramBinBoundaries.SLICE_TYPE.LINEAR,
        nextMaxBinBoundary, binCount]);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }

    /**
     * Add |binCount| exponentially scaled bin boundaries up to
     * |nextMaxBinBoundary| to the builder.
     *
     * This operation corresponds to appending |binCount| central bins with
     * a constant difference between the logarithms of their range min and max
     * D = ((ln(|nextMaxBinBoundary|) - ln(|this.range.max|)) / |binCount|)
     * with the following ranges:
     *
     *   [|this.maxMinBoundary|, |this.maxMinBoundary| * exp(D)]
     *   [|this.maxMinBoundary| * exp(D), |this.maxMinBoundary| * exp(2D)]
     *   [|this.maxMinBoundary| * exp(2D), |this.maxMinBoundary| * exp(3D)]
     *   ...
     *   [|this.maxMinBoundary| * exp((|binCount| - 2) * D),
     *    |this.maxMinBoundary| * exp((|binCount| - 2) * D)]
     *   [|this.maxMinBoundary| * exp((|binCount| - 1) * D),
     *    |nextMaxBinBoundary|]
     *
     * This method requires that the current max bin boundary is positive.
     *
     * @param {number} nextBinBoundary The last added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     * @param {number} binCount Number of bins to be added (must be positive).
     */
    addExponentialBins(nextMaxBinBoundary, binCount) {
      if (binCount <= 0) {
        throw new Error('Bin count must be positive');
      }
      if (this.range.max <= 0) {
        throw new Error('Current max bin boundary must be positive');
      }
      if (this.range.max >= nextMaxBinBoundary) {
        throw new Error('The last added max boundary must be greater than ' +
            'the current max boundary boundary');
      }

      // If binRanges_ had been built, then clear them.
      this.binRanges_ = undefined;
      this.bins_ = undefined;

      this.pushBuilderSlice_([
        HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL,
        nextMaxBinBoundary, binCount]);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }
  }

  HistogramBinBoundaries.SLICE_TYPE = {
    LINEAR: 0,
    EXPONENTIAL: 1,
  };

  // This special HistogramBinBoundaries instance produces a singe binRange,
  // allowing Histograms to have a single bin.
  // This is the only way for Histograms to have fewer than 2 bins, since
  // HistogramBinBoundaries.buildBinRanges_() ensures that there is always a bin
  // whose min is -Number.MAX_VALUE, and a bin whose max is Number.MAX_VALUE.
  // SINGULAR is the only HistogramBinBoundaries in which those bins are one and
  // the same.
  HistogramBinBoundaries.SINGULAR = new HistogramBinBoundaries(
      Number.MAX_VALUE);

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.timeDurationInMs.unitName,
      HistogramBinBoundaries.createExponential(1e-3, 1e6, 1e2));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.timeStampInMs.unitName,
      HistogramBinBoundaries.createLinear(0, 1e10, 1e3));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.normalizedPercentage.unitName,
      HistogramBinBoundaries.createLinear(0, 1.0, 20));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.sizeInBytes.unitName,
      HistogramBinBoundaries.createExponential(1, 1e12, 1e2));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.energyInJoules.unitName,
      HistogramBinBoundaries.createExponential(1e-3, 1e3, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.powerInWatts.unitName,
      HistogramBinBoundaries.createExponential(1e-3, 1, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.unitlessNumber.unitName,
      HistogramBinBoundaries.createExponential(1e-3, 1e3, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.count.unitName,
      HistogramBinBoundaries.createExponential(1, 1e3, 20));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(
      tr.b.Unit.byName.sigma.unitName,
      HistogramBinBoundaries.createLinear(-5, 5, 50));

  return {
    DEFAULT_REBINNED_COUNT,
    DELTA,
    Histogram,
    HistogramBinBoundaries,
    P_VALUE_NAME,
    U_STATISTIC_NAME,
    Z_SCORE_NAME,
    percentFromString,
    percentToString,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const MAX_INPUT_EVENT_TO_STARTUP_DELAY_IN_MS = 2000;
  // Post-startup activity draw delay.
  const MIN_DRAW_DELAY_IN_MS = 80;
  const MAX_DRAW_DELAY_IN_MS = 2000;

  function findProcess(processName, model) {
    for (const pid in model.processes) {
      const process = model.processes[pid];
      if (process.name === processName) {
        return process;
      }
    }
    return undefined;
  }

  function findThreads(process, threadPrefix) {
    if (process === undefined) return undefined;
    const threads = [];
    for (const tid in process.threads) {
      const thread = process.threads[tid];
      if (thread.name.startsWith(threadPrefix)) {
        threads.push(thread);
      }
    }
    return threads;
  }

  function findUIThread(process) {
    if (process === undefined) return undefined;
    const threads = findThreads(process, 'UI Thread');
    if (threads !== undefined && threads.length === 1) {
      return threads[0];
    }
    return process.threads[process.pid];
  }

  // Returns slices with actual app's process startup, excluding other delays.
  function findLaunchSlices(model) {
    const launches = [];
    const binders = findThreads(findProcess('system_server', model), 'Binder');
    for (const binderId in binders) {
      const binder = binders[binderId];
      for (const sliceId in binder.asyncSliceGroup.slices) {
        const slice = binder.asyncSliceGroup.slices[sliceId];
        if (slice.title.startsWith('launching:')) {
          launches.push(slice);
        }
      }
    }
    return launches;
  }

  // Try to find draw event when activity just shown.
  function findDrawSlice(appName, startNotBefore, model) {
    let drawSlice = undefined;
    const thread = findUIThread(findProcess(appName, model));
    if (thread === undefined) return undefined;

    for (const sliceId in thread.sliceGroup.slices) {
      const slice = thread.sliceGroup.slices[sliceId];
      if (slice.start < startNotBefore + MIN_DRAW_DELAY_IN_MS ||
          slice.start > startNotBefore + MAX_DRAW_DELAY_IN_MS) continue;
      if (slice.title !== 'draw') continue;
      // TODO(kraynov): Add reportFullyDrawn() support.
      if (drawSlice === undefined || slice.start < drawSlice.start) {
        drawSlice = slice;
      }
    }
    return drawSlice;
  }

  // Try to find input event before a process starts.
  function findInputEventSlice(endNotAfter, model) {
    const endNotBefore = endNotAfter - MAX_INPUT_EVENT_TO_STARTUP_DELAY_IN_MS;
    let inputSlice = undefined;
    const systemUi = findUIThread(findProcess('com.android.systemui', model));
    if (systemUi === undefined) return undefined;

    for (const sliceId in systemUi.asyncSliceGroup.slices) {
      const slice = systemUi.asyncSliceGroup.slices[sliceId];
      if (slice.end > endNotAfter || slice.end < endNotBefore) continue;
      if (slice.title !== 'deliverInputEvent') continue;
      if (inputSlice === undefined || slice.end > inputSlice.end) {
        inputSlice = slice;
      }
    }
    return inputSlice;
  }

  function computeStartupTimeInMs(appName, launchSlice, model) {
    let startupStart = launchSlice.start;
    let startupEnd = launchSlice.end;
    const drawSlice = findDrawSlice(appName, launchSlice.end, model);
    if (drawSlice !== undefined) {
      startupEnd = drawSlice.end;
    }
    const inputSlice = findInputEventSlice(launchSlice.start, model);
    if (inputSlice !== undefined) {
      startupStart = inputSlice.start;
    }
    return startupEnd - startupStart;
  }

  // App startup time metric.
  function measureStartup(histograms, model) {
    const launches = findLaunchSlices(model);
    for (const sliceId in launches) {
      const launchSlice = launches[sliceId];
      const appName = launchSlice.title.split(': ')[1];
      const startupMs = computeStartupTimeInMs(appName, launchSlice, model);
      histograms.createHistogram(`android:systrace:startup:${appName}`,
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, startupMs);
    }
  }

  // Metric which measures time spent by process threads in each thread state.
  // The value of metric is a time percentage relative to the length of selected
  // range of interest.
  function measureThreadStates(histograms, model, rangeOfInterest) {
    for (const pid in model.processes) {
      const process = model.processes[pid];
      if (process.name === undefined) continue;

      let hasSlices = false;
      let timeRunning = 0;
      let timeRunnable = 0;
      let timeSleeping = 0;
      let timeUninterruptible = 0;
      let timeBlockIO = 0;
      let timeUnknown = 0;

      for (const tid in process.threads) {
        const thread = process.threads[tid];
        if (thread.timeSlices === undefined) continue;

        for (const sliceId in thread.timeSlices) {
          const slice = thread.timeSlices[sliceId];
          const sliceRange =
              tr.b.math.Range.fromExplicitRange(slice.start, slice.end);
          const intersection = rangeOfInterest.findIntersection(sliceRange);
          const duration = intersection.duration;
          if (duration === 0) continue;
          hasSlices = true;

          if (slice.title === 'Running') {
            timeRunning += duration;
          } else if (slice.title === 'Runnable') {
            timeRunnable += duration;
          } else if (slice.title === 'Sleeping') {
            timeSleeping += duration;
          } else if (slice.title.startsWith('Uninterruptible')) {
            timeUninterruptible += duration;
            if (slice.title.includes('Block I/O')) timeBlockIO += duration;
          } else {
            timeUnknown += duration;
          }
        }
      }

      if (hasSlices) {
        // For sake of simplicity we don't count wall time for each
        // thread/process and just calculate relative values against selected
        // range of interest.
        const wall = rangeOfInterest.max - rangeOfInterest.min;
        histograms.createHistogram(
            `android:systrace:threadtime:${process.name}:running`,
            tr.b.Unit.byName.normalizedPercentage, timeRunning / wall);
        histograms.createHistogram(
            `android:systrace:threadtime:${process.name}:runnable`,
            tr.b.Unit.byName.normalizedPercentage, timeRunnable / wall);
        histograms.createHistogram(
            `android:systrace:threadtime:${process.name}:sleeping`,
            tr.b.Unit.byName.normalizedPercentage, timeSleeping / wall);
        histograms.createHistogram(
            `android:systrace:threadtime:${process.name}:blockio`,
            tr.b.Unit.byName.normalizedPercentage, timeBlockIO / wall);
        histograms.createHistogram(
            `android:systrace:threadtime:${process.name}:uninterruptible`,
            tr.b.Unit.byName.normalizedPercentage, timeUninterruptible / wall);

        // In case of changing names in systrace and importer.
        if (timeUnknown > 0) {
          histograms.createHistogram(
              `android:systrace:threadtime:${process.name}:unknown`,
              tr.b.Unit.byName.normalizedPercentage, timeUnknown / wall);
        }
      }
    }
  }

  function androidSystraceMetric(histograms, model, options) {
    let rangeOfInterest = model.bounds;
    if (options !== undefined && options.rangeOfInterest !== undefined) {
      rangeOfInterest = options.rangeOfInterest;
    }

    measureStartup(histograms, model);
    measureThreadStates(histograms, model, rangeOfInterest);
  }

  tr.metrics.MetricRegistry.register(androidSystraceMetric, {
    supportsRangeOfInterest: true
  });

  return {
    androidSystraceMetric,
  };
});


'use strict';

tr.exportTo('tr.b.math', function() {
  const PERCENTILE_PRECISION = 1e-7;
  /**
   * A function that consists of linear pieces.
   * See https://en.wikipedia.org/wiki/Piecewise_linear_function.
   * @constructor
   */
  function PiecewiseLinearFunction() {
    this.pieces = [];
  }

  PiecewiseLinearFunction.prototype = {
    /**
     * Push a linear piece defined by linear interpolation between.
     * (x1, y1) and (x2, y2).
     * Pieces must be pushed in the order of increasing x coordinate.
     */
    push(x1, y1, x2, y2) {
      if (x1 >= x2) {
        throw new Error('Invalid segment');
      }
      if (this.pieces.length > 0 &&
          this.pieces[this.pieces.length - 1].x2 > x1) {
        throw new Error('Potentially overlapping segments');
      }
      if (x1 < x2) {
        this.pieces.push(new Piece(x1, y1, x2, y2));
      }
    },

    /**
     *  Returns the size of the set A such that for all x in A: f(x) < y.
     */
    partBelow(y) {
      return this.pieces.reduce((acc, p) => (acc + p.partBelow(y)), 0);
    },

    get min() {
      return this.pieces.reduce((acc, p) => Math.min(acc, p.min), Infinity);
    },

    get max() {
      return this.pieces.reduce((acc, p) => Math.max(acc, p.max), -Infinity);
    },

    get average() {
      let weightedSum = 0;
      let totalWeight = 0;
      this.pieces.forEach(function(piece) {
        weightedSum += piece.width * piece.average;
        totalWeight += piece.width;
      });
      if (totalWeight === 0) return 0;
      return weightedSum / totalWeight;
    },

    /**
    * Returns the minimum possible value y such that the percentage of x points
    * that have f(x) <= y is approximately equal to the given |percent|.
    */
    percentile(percent) {
      if (!(percent >= 0 && percent <= 1)) {
        throw new Error('percent must be [0,1]');
      }
      let lower = this.min;
      let upper = this.max;
      const total = this.partBelow(upper);
      if (total === 0) return 0;
      while (upper - lower > PERCENTILE_PRECISION) {
        const middle = (lower + upper) / 2;
        const below = this.partBelow(middle);
        if (below / total < percent) {
          lower = middle;
        } else {
          upper = middle;
        }
      }
      return (lower + upper) / 2;
    }
  };

  /**
  * A linear segment from (x1, y1) to (x2, y2).
  * @constructor
  */
  function Piece(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  Piece.prototype = {
    /**
    * The total length of all x points such that f(x) < y.
    * More formally:
    * max(x2 - x1) such that for all x in [x1 .. x2]: f(x) < y.
    */
    partBelow(y) {
      const width = this.width;
      if (width === 0) return 0;
      const minY = this.min;
      const maxY = this.max;
      if (y >= maxY) return width;
      if (y < minY) return 0;
      return (y - minY) / (maxY - minY) * width;
    },

    get min() {
      return Math.min(this.y1, this.y2);
    },

    get max() {
      return Math.max(this.y1, this.y2);
    },

    get average() {
      return (this.y1 + this.y2) / 2;
    },

    get width() {
      return this.x2 - this.x1;
    }
  };

  return {
    PiecewiseLinearFunction,
  };
});


'use strict';

/**
 * @fileoverview Provides event merging functionality for grouping/analysis.
 */
tr.exportTo('tr.b.math', function() {
  function convertEventsToRanges(events) {
    return events.map(function(event) {
      return tr.b.math.Range.fromExplicitRange(event.start, event.end);
    });
  }

  function mergeRanges(inRanges, mergeThreshold, mergeFunction) {
    const remainingEvents = inRanges.slice();
    remainingEvents.sort(function(x, y) {
      return x.min - y.min;
    });

    if (remainingEvents.length <= 1) {
      const merged = [];
      if (remainingEvents.length === 1) {
        merged.push(mergeFunction(remainingEvents));
      }
      return merged;
    }

    const mergedEvents = [];

    let currentMergeBuffer = [];
    let rightEdge;
    function beginMerging() {
      currentMergeBuffer.push(remainingEvents[0]);
      remainingEvents.splice(0, 1);
      rightEdge = currentMergeBuffer[0].max;
    }

    function flushCurrentMergeBuffer() {
      if (currentMergeBuffer.length === 0) return;

      mergedEvents.push(mergeFunction(currentMergeBuffer));
      currentMergeBuffer = [];

      // Refill merge buffer if needed.
      if (remainingEvents.length !== 0) beginMerging();
    }

    beginMerging();

    while (remainingEvents.length) {
      const currentEvent = remainingEvents[0];

      const distanceFromRightEdge = currentEvent.min - rightEdge;
      if (distanceFromRightEdge < mergeThreshold) {
        rightEdge = Math.max(rightEdge, currentEvent.max);
        remainingEvents.splice(0, 1);
        currentMergeBuffer.push(currentEvent);
        continue;
      }

      // Too big a gap.
      flushCurrentMergeBuffer();
    }
    flushCurrentMergeBuffer();

    return mergedEvents;
  }

  // Pass in |opt_totalRange| in order to find empty ranges before the first of
  // |inRanges| and after the last of |inRanges|.
  function findEmptyRangesBetweenRanges(inRanges, opt_totalRange) {
    if (opt_totalRange && opt_totalRange.isEmpty) opt_totalRange = undefined;

    const emptyRanges = [];
    if (!inRanges.length) {
      if (opt_totalRange) emptyRanges.push(opt_totalRange);
      return emptyRanges;
    }

    inRanges = inRanges.slice();
    inRanges.sort(function(x, y) {
      return x.min - y.min;
    });
    if (opt_totalRange &&
        (opt_totalRange.min < inRanges[0].min)) {
      emptyRanges.push(tr.b.math.Range.fromExplicitRange(
          opt_totalRange.min, inRanges[0].min));
    }

    inRanges.forEach(function(range, index) {
      for (let otherIndex = 0; otherIndex < inRanges.length; ++otherIndex) {
        if (index === otherIndex) continue;
        const other = inRanges[otherIndex];

        if (other.min > range.max) {
          // |inRanges| is sorted, so |other| is the first range after |range|,
          // and there is an empty range between them.
          emptyRanges.push(tr.b.math.Range.fromExplicitRange(
              range.max, other.min));
          return;
        }
        // Otherwise, |other| starts before |range| ends, so |other| might
        // possibly contain the end of |range|.

        if (other.max > range.max) {
          // |other| does contain the end of |range|, so no empty range starts
          // at the end of this |range|.
          return;
        }
      }
      if (opt_totalRange && (range.max < opt_totalRange.max)) {
        emptyRanges.push(tr.b.math.Range.fromExplicitRange(
            range.max, opt_totalRange.max));
      }
    });
    return emptyRanges;
  }

  return {
    convertEventsToRanges,
    findEmptyRangesBetweenRanges,
    mergeRanges,
  };
});


'use strict';

tr.exportTo('tr.metrics.v8.utils', function() {
  // The title of the idle task event.
  const IDLE_TASK_EVENT = 'SingleThreadIdleTaskRunner::RunTask';

  // V8 execution event.
  const V8_EXECUTE = 'V8.Execute';

  // GC events start with this prefix.
  const GC_EVENT_PREFIX = 'V8.GC';

  // Special handling is required for full GCs inside low memory notification.
  const FULL_GC_EVENT = 'V8.GCCompactor';

  const LOW_MEMORY_EVENT = 'V8.GCLowMemoryNotification';

  const MAJOR_GC_EVENT = 'MajorGC';
  const MINOR_GC_EVENT = 'MinorGC';

  // Maps the top-level GC events in timeline to telemetry friendly names.
  const TOP_GC_EVENTS = {
    'V8.GCCompactor': 'v8-gc-full-mark-compactor',
    'V8.GCFinalizeMC': 'v8-gc-latency-mark-compactor',
    'V8.GCFinalizeMCReduceMemory': 'v8-gc-memory-mark-compactor',
    'V8.GCIncrementalMarking': 'v8-gc-incremental-step',
    'V8.GCIncrementalMarkingFinalize': 'v8-gc-incremental-finalize',
    'V8.GCIncrementalMarkingStart': 'v8-gc-incremental-start',
    'V8.GCPhantomHandleProcessingCallback': 'v8-gc-phantom-handle-callback',
    'V8.GCScavenger': 'v8-gc-scavenger'
  };

  const LOW_MEMORY_MARK_COMPACTOR = 'v8-gc-low-memory-mark-compactor';

  /**
   * Finds the first parent of the |event| for which the |predicate| holds.
   */
  function findParent(event, predicate) {
    let parent = event.parentSlice;
    while (parent) {
      if (predicate(parent)) {
        return parent;
      }
      parent = parent.parentSlice;
    }
    return null;
  }

  function isIdleTask(event) {
    return event.title === IDLE_TASK_EVENT;
  }

  function isLowMemoryEvent(event) {
    return event.title === LOW_MEMORY_EVENT;
  }

  function isV8Event(event) {
    return event.title.startsWith('V8.');
  }

  function isV8ExecuteEvent(event) {
    return event.title === V8_EXECUTE;
  }

  function isTopV8ExecuteEvent(event) {
    return isV8ExecuteEvent(event) && findParent(isV8ExecuteEvent) === null;
  }

  function isGarbageCollectionEvent(event) {
    // Low memory notification is handled specially because it contains
    // several full mark compact events.
    return event.title && event.title.startsWith(GC_EVENT_PREFIX) &&
           event.title !== LOW_MEMORY_EVENT;
  }

  function isTopGarbageCollectionEvent(event) {
    return event.title in TOP_GC_EVENTS;
  }

  function isForcedGarbageCollectionEvent(event) {
    return findParent(event, isLowMemoryEvent) !== null;
  }

  function isSubGarbageCollectionEvent(event) {
    // To reduce number of results, we return only the first level of GC
    // subevents. Some subevents are nested in MajorGC or MinorGC events, so
    // we have to check for it explicitly.
    return isGarbageCollectionEvent(event) &&
           event.parentSlice &&
           (isTopGarbageCollectionEvent(event.parentSlice) ||
            event.parentSlice.title === MAJOR_GC_EVENT ||
            event.parentSlice.title === MINOR_GC_EVENT);
  }

  function isCompileOptimizeEvent(event) {
    return (event.title === 'V8.OptimizeCode' ||
            event.title === 'V8.RecompileSynchronous' ||
            event.title === 'V8.RecompileConcurrent');
  }

  function isCompileUnoptimizeEvent(event) {
    return (event.title === 'V8.CompileIgnition' ||
            event.title === 'V8.CompileUnoptimizedInnerFunctions' ||
            event.title === 'V8.Compile' ||
            event.title === 'V8.CompileEval' ||
            event.title === 'V8.CompileCode' ||
            event.title === 'V8.CompileScript');
  }

  function isCompileParseEvent(event) {
    return (event.title === 'V8.PreParse' ||
            event.title === 'V8.ParseFunction' ||
            event.title === 'V8.ParseProgram');
  }

  function isCompileEvent(event) {
    return tr.b.getCategoryParts(event.category).includes(
        'disabled-by-default-v8.compile');
  }

  function isFullMarkCompactorEvent(event) {
    return event.title === 'V8.GCCompactor';
  }

  function isIncrementalMarkingEvent(event) {
    return event.title.startsWith('V8.GCIncrementalMarking');
  }

  function isLatencyMarkCompactorEvent(event) {
    return event.title === 'V8.GCFinalizeMC';
  }

  function isMemoryMarkCompactorEvent(event) {
    return event.title === 'V8.GCFinalizeMCReduceMemory';
  }

  function isScavengerEvent(event) {
    return event.title === 'V8.GCScavenger';
  }

  function topGarbageCollectionEventName(event) {
    if (event.title === FULL_GC_EVENT) {
      // Full mark compact events inside a low memory notification
      // are counted as low memory mark compacts.
      if (findParent(event, isLowMemoryEvent)) {
        return LOW_MEMORY_MARK_COMPACTOR;
      }
    }
    return TOP_GC_EVENTS[event.title];
  }

  function subGarbageCollectionEventName(event) {
    const topEvent = findParent(event, isTopGarbageCollectionEvent);
    const prefix = topEvent ? topGarbageCollectionEventName(topEvent) :
      'unknown';
    // Remove redundant prefixes and convert to lower case.
    const name = event.title.replace('V8.GC_MC_', '')
                          .replace('V8.GC_SCAVENGER_', '')
                          .replace('V8.GC_', '')
                          .replace(/_/g, '-').toLowerCase();
    return prefix + '-' + name;
  }

  /**
   * Filters events using the |filterCallback|, then groups events by the user
   * the name computed using the |nameCallback|, and then invokes
   * the |processCallback| with the grouped events.
   * @param {Function} filterCallback Takes an event and returns a boolean.
   * @param {Function} nameCallback Takes event and returns a string.
   * @param {Function} processCallback Takes a name, and an array of events.
   */
  function groupAndProcessEvents(model, filterCallback,
      nameCallback, processCallback) {
    // Map: name -> [events].
    const nameToEvents = {};
    for (const event of model.getDescendantEvents()) {
      if (!filterCallback(event)) continue;
      const name = nameCallback(event);
      nameToEvents[name] = nameToEvents[name] || [];
      nameToEvents[name].push(event);
    }
    for (const [name, events] of Object.entries(nameToEvents)) {
      processCallback(name, events);
    }
  }

  /**
   * Given a list of intervals, returns a new list with all overalapping
   * intervals merged into a single interval.
   */
  function unionOfIntervals(intervals) {
    if (intervals.length === 0) return [];
    return tr.b.math.mergeRanges(
        intervals.map(x => { return { min: x.start, max: x.end }; }), 1e-6,
        function(ranges) {
          return {
            start: ranges.reduce(
                (acc, x) => Math.min(acc, x.min), ranges[0].min),
            end: ranges.reduce((acc, x) => Math.max(acc, x.max), ranges[0].max)
          };
        }
    );
  }

  function hasV8Stats(globalMemoryDump) {
    let v8stats = undefined;
    globalMemoryDump.iterateContainerDumps(function(dump) {
      v8stats = v8stats || dump.getMemoryAllocatorDumpByFullName('v8');
    });
    return !!v8stats;
  }

  function rangeForMemoryDumps(model) {
    const startOfFirstDumpWithV8 =
        model.globalMemoryDumps.filter(hasV8Stats).reduce(
            (start, dump) => Math.min(start, dump.start), Infinity);
    // Empty range.
    if (startOfFirstDumpWithV8 === Infinity) return new tr.b.math.Range();
    return tr.b.math.Range.fromExplicitRange(startOfFirstDumpWithV8, Infinity);
  }

  return {
    findParent,
    groupAndProcessEvents,
    isCompileEvent,
    isCompileOptimizeEvent,
    isCompileUnoptimizeEvent,
    isCompileParseEvent,
    isForcedGarbageCollectionEvent,
    isFullMarkCompactorEvent,
    isGarbageCollectionEvent,
    isIdleTask,
    isIncrementalMarkingEvent,
    isLatencyMarkCompactorEvent,
    isLowMemoryEvent,
    isMemoryMarkCompactorEvent,
    isScavengerEvent,
    isSubGarbageCollectionEvent,
    isTopGarbageCollectionEvent,
    isTopV8ExecuteEvent,
    isV8Event,
    isV8ExecuteEvent,
    rangeForMemoryDumps,
    subGarbageCollectionEventName,
    topGarbageCollectionEventName,
    unionOfIntervals,
  };
});


'use strict';

tr.exportTo('tr.metrics.blink', function() {
  // Maps the Blink GC events in timeline to telemetry friendly names.
  const BLINK_GC_EVENTS = {
    'BlinkGCMarking': 'blink-gc-marking',
    'ThreadState::completeSweep': 'blink-gc-complete-sweep',
    'ThreadState::performIdleLazySweep': 'blink-gc-idle-lazy-sweep'
  };

  function isBlinkGarbageCollectionEvent(event) {
    return event.title in BLINK_GC_EVENTS;
  }

  function blinkGarbageCollectionEventName(event) {
    return BLINK_GC_EVENTS[event.title];
  }

  function blinkGcMetric(histograms, model) {
    addDurationOfTopEvents(histograms, model);
    addTotalDurationOfTopEvents(histograms, model);
    addIdleTimesOfTopEvents(histograms, model);
    addTotalIdleTimesOfTopEvents(histograms, model);
  }

  tr.metrics.MetricRegistry.register(blinkGcMetric);

  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const percentage_biggerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  const CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200)
    .addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90]});
    return n;
  }

  function createNumericForIdleTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator) {
    const histogram = new tr.v.Histogram(name, percentage_biggerIsBetter);
    if (denominator === 0) {
      histogram.addSample(0);
    } else {
      histogram.addSample(numerator / denominator);
    }
    return histogram;
  }

  /**
   * Example output:
   * - blink-gc-marking.
   */
  function addDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isBlinkGarbageCollectionEvent,
        blinkGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - blink-gc-total
   */
  function addTotalDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isBlinkGarbageCollectionEvent,
        event => 'blink-gc-total',
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - blink-gc-marking_idle_deadline_overrun,
   * - blink-gc-marking_outside_idle,
   * - blink-gc-marking_percentage_idle.
   */
  function addIdleTimesOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isBlinkGarbageCollectionEvent,
        blinkGarbageCollectionEventName,
        function(name, events) {
          addIdleTimes(histograms, model, name, events);
        }
    );
  }

  /**
   * Example output:
   * - blink-gc-total_idle_deadline_overrun,
   * - blink-gc-total_outside_idle,
   * - blink-gc-total_percentage_idle.
   */
  function addTotalIdleTimesOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isBlinkGarbageCollectionEvent,
        event => 'blink-gc-total',
        function(name, events) {
          addIdleTimes(histograms, model, name, events);
        }
    );
  }

  function addIdleTimes(histograms, model, name, events) {
    const cpuDuration = createNumericForIdleTime(name + '_cpu');
    const insideIdle = createNumericForIdleTime(name + '_inside_idle');
    const outsideIdle = createNumericForIdleTime(name + '_outside_idle');
    const idleDeadlineOverrun = createNumericForIdleTime(
        name + '_idle_deadline_overrun');
    events.forEach(function(event) {
      const idleTask = tr.metrics.v8.utils.findParent(
          event, tr.metrics.v8.utils.isIdleTask);
      let inside = 0;
      let overrun = 0;
      if (idleTask) {
        const allottedTime = idleTask.args.allotted_time_ms;
        if (event.duration > allottedTime) {
          overrun = event.duration - allottedTime;
          // Don't count time over the deadline as being inside idle time.
          // Since the deadline should be relative to wall clock we
          // compare allotted_time_ms with wall duration instead of thread
          // duration, and then assume the thread duration was inside idle
          // for the same percentage of time.
          inside = event.cpuDuration * allottedTime / event.duration;
        } else {
          inside = event.cpuDuration;
        }
      }
      cpuDuration.addSample(event.cpuDuration);
      insideIdle.addSample(inside);
      outsideIdle.addSample(event.cpuDuration - inside);
      idleDeadlineOverrun.addSample(overrun);
    });
    histograms.addHistogram(idleDeadlineOverrun);
    histograms.addHistogram(outsideIdle);
    const percentage = createPercentage(
        name + '_percentage_idle', insideIdle.sum, cpuDuration.sum);
    histograms.addHistogram(percentage);
  }

  return {
    blinkGcMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  function getCpuSnapshotsFromModel(model) {
    const snapshots = [];
    for (const pid in model.processes) {
      const snapshotInstances =
        model.processes[pid].objects.getAllInstancesNamed('CPUSnapshots');
      if (!snapshotInstances) continue;

      for (const object of snapshotInstances[0].snapshots) {
        snapshots.push(object.args.processes);
      }
    }
    return snapshots;
  }

  function getProcessSumsFromSnapshot(snapshot) {
    const processSums = new Map();
    for (const processData of snapshot) {
      const processName = processData.name;
      if (!(processSums.has(processName))) {
        processSums.set(processName, {sum: 0.0, paths: new Set()});
      }
      processSums.get(processName).sum += parseFloat(processData.pCpu);
      // The process path may be missing on Windows because of AccessDenied
      // error thrown by psutil package used by CPU tracing agent.
      if (processData.path) {
        processSums.get(processName).paths.add(processData.path);
      }
    }
    return processSums;
  }

  function buildNumericsFromSnapshots(snapshots) {
    const processNumerics = new Map();
    for (const snapshot of snapshots) {
      const processSums = getProcessSumsFromSnapshot(snapshot);
      for (const [processName, processData] of processSums.entries()) {
        if (!(processNumerics.has(processName))) {
          processNumerics.set(processName, {
            numeric: new tr.v.Histogram('cpu:percent:' + processName,
             tr.b.Unit.byName.normalizedPercentage_smallerIsBetter),
            paths: new Set()
          });
        }
        processNumerics.get(processName).numeric.addSample(
            processData.sum / 100.0);
        for (const path of processData.paths) {
          processNumerics.get(processName).paths.add(path);
        }
      }
    }
    return processNumerics;
  }

  function cpuProcessMetric(histograms, model) {
    const snapshots = getCpuSnapshotsFromModel(model);
    const processNumerics = buildNumericsFromSnapshots(snapshots);
    for (const [processName, processData] of processNumerics) {
      const numeric = processData.numeric;
      // Treat missing snapshots as zeros. A process is missing from a snapshots
      // when its CPU usage was below minimum threshold when the snapshot was
      // taken.
      const missingSnapshotCount = snapshots.length - numeric.numValues;
      for (let i = 0; i < missingSnapshotCount; i++) {
        numeric.addSample(0);
      }
      numeric.diagnostics.set('paths', new
          tr.v.d.GenericSet([...processData.paths]));
      histograms.addHistogram(numeric);
    }
  }

  tr.metrics.MetricRegistry.register(cpuProcessMetric);

  return {
    cpuProcessMetric,
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.model.helpers', function() {
  const MAIN_FRAMETIME_TYPE = 'main_frametime_type';
  const IMPL_FRAMETIME_TYPE = 'impl_frametime_type';

  const MAIN_RENDERING_STATS =
      'BenchmarkInstrumentation::MainThreadRenderingStats';
  const IMPL_RENDERING_STATS =
      'BenchmarkInstrumentation::ImplThreadRenderingStats';


  function getSlicesIntersectingRange(rangeOfInterest, slices) {
    const slicesInFilterRange = [];
    for (let i = 0; i < slices.length; i++) {
      const slice = slices[i];
      if (rangeOfInterest.intersectsExplicitRangeInclusive(
          slice.start, slice.end)) {
        slicesInFilterRange.push(slice);
      }
    }
    return slicesInFilterRange;
  }


  function ChromeProcessHelper(modelHelper, process) {
    this.modelHelper = modelHelper;
    this.process = process;
    this.telemetryInternalRanges_ = undefined;
  }

  ChromeProcessHelper.prototype = {
    get pid() {
      return this.process.pid;
    },

    isTelemetryInternalEvent(slice) {
      if (this.telemetryInternalRanges_ === undefined) {
        this.findTelemetryInternalRanges_();
      }
      for (const range of this.telemetryInternalRanges_) {
        if (range.containsExplicitRangeInclusive(slice.start, slice.end)) {
          return true;
        }
      }
      return false;
    },

    findTelemetryInternalRanges_() {
      this.telemetryInternalRanges_ = [];
      let start = 0;
      for (const thread of Object.values(this.process.threads)) {
        for (const slice of thread.asyncSliceGroup.getDescendantEvents()) {
          if (/^telemetry\.internal\.[^.]*\.start$/.test(slice.title)) {
            start = slice.start;
          } else if (/^telemetry\.internal\.[^.]*\.end$/.test(slice.title) &&
              start !== undefined) {
            this.telemetryInternalRanges_.push(
                tr.b.math.Range.fromExplicitRange(start, slice.end));
            start = undefined;
          }
        }
      }
    },

    getFrameEventsInRange(frametimeType, range) {
      const titleToGet = (frametimeType === MAIN_FRAMETIME_TYPE ?
        MAIN_RENDERING_STATS : IMPL_RENDERING_STATS);

      const frameEvents = [];
      for (const event of this.process.getDescendantEvents()) {
        if (event.title === titleToGet) {
          if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
            frameEvents.push(event);
          }
        }
      }

      frameEvents.sort(function(a, b) {return a.start - b.start;});
      return frameEvents;
    }
  };

  function getFrametimeDataFromEvents(frameEvents) {
    const frametimeData = [];
    for (let i = 1; i < frameEvents.length; i++) {
      const diff = frameEvents[i].start - frameEvents[i - 1].start;
      frametimeData.push({
        'x': frameEvents[i].start,
        'frametime': diff
      });
    }
    return frametimeData;
  }

  return {
    ChromeProcessHelper,

    MAIN_FRAMETIME_TYPE,
    IMPL_FRAMETIME_TYPE,
    MAIN_RENDERING_STATS,
    IMPL_RENDERING_STATS,

    getSlicesIntersectingRange,
    getFrametimeDataFromEvents,
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.model.helpers', function() {
  function ChromeBrowserHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrBrowserMain');
    if (!process.name) {
      process.name = ChromeBrowserHelper.PROCESS_NAME;
    }
  }

  ChromeBrowserHelper.PROCESS_NAME = 'Browser';

  ChromeBrowserHelper.isBrowserProcess = function(process) {
    return !!process.findAtMostOneThreadNamed('CrBrowserMain');
  };

  ChromeBrowserHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype,

    // TODO(petrcermak): Pass browser name in a metadata event (see
    // crbug.com/605088).
    get browserName() {
      const hasInProcessRendererThread = this.process.findAllThreadsNamed(
          'Chrome_InProcRendererThread').length > 0;
      return hasInProcessRendererThread ? 'webview' : 'chrome';
    },

    get mainThread() {
      return this.mainThread_;
    },

    get rendererHelpers() {
      return this.modelHelper.rendererHelpers;
    },

    getLoadingEventsInRange(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return slice.title.indexOf('WebContentsImpl Loading') === 0 &&
            rangeOfInterest.intersectsExplicitRangeInclusive(
                slice.start, slice.end);
      });
    },

    getCommitProvisionalLoadEventsInRange(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return slice.title === 'RenderFrameImpl::didCommitProvisionalLoad' &&
            rangeOfInterest.intersectsExplicitRangeInclusive(
                slice.start, slice.end);
      });
    },

    get hasLatencyEvents() {
      let hasLatency = false;
      for (const thread of this.modelHelper.model.getAllThreads()) {
        for (const event of thread.getDescendantEvents()) {
          if (!event.isTopLevel) continue;
          if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice)) {
            continue;
          }
          hasLatency = true;
        }
      }
      return hasLatency;
    },

    getLatencyEventsInRange(rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function(slice) {
        return (slice.title.indexOf('InputLatency') === 0) &&
            rangeOfInterest.intersectsExplicitRangeInclusive(
                slice.start, slice.end);
      });
    },

    getAllAsyncSlicesMatching(pred, opt_this) {
      const events = [];
      this.iterAllThreads(function(thread) {
        for (const slice of thread.getDescendantEvents()) {
          if (pred.call(opt_this, slice)) {
            events.push(slice);
          }
        }
      });
      return events;
    },

    iterAllThreads(func, opt_this) {
      for (const thread of Object.values(this.process.threads)) {
        func.call(opt_this, thread);
      }

      for (const rendererHelper of Object.values(this.rendererHelpers)) {
        const rendererProcess = rendererHelper.process;
        for (const thread of Object.values(rendererProcess.threads)) {
          func.call(opt_this, thread);
        }
      }
    }
  };

  return {
    ChromeBrowserHelper,
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing the Chrome GPU Process.
 */
tr.exportTo('tr.model.helpers', function() {
  // TODO(charliea): This method should probably throw if this isn't a Chrome
  // GPU process.
  function ChromeGpuHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    if (!process.name) {
      process.name = ChromeGpuHelper.PROCESS_NAME;
    }
  }

  ChromeGpuHelper.PROCESS_NAME = 'GPU Process';

  ChromeGpuHelper.isGpuProcess = function(process) {
    // In some Android builds the GPU thread is not in a separate process.
    if (process.findAtMostOneThreadNamed('CrBrowserMain') ||
        process.findAtMostOneThreadNamed('CrRendererMain')) {
      return false;
    }

    // On Android, there can sometimes be GPU processes with multiple main
    // threads. We need to recognize those processes as GPU processes.
    return process.findAllThreadsNamed('CrGpuMain').length > 0;
  };

  ChromeGpuHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype
  };

  return {
    ChromeGpuHelper,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function clamp01(value) {
    return Math.max(0, Math.min(1, value));
  }

  function Color(opt_r, opt_g, opt_b, opt_a) {
    this.r = Math.floor(opt_r) || 0;
    this.g = Math.floor(opt_g) || 0;
    this.b = Math.floor(opt_b) || 0;
    this.a = opt_a;
  }

  Color.fromString = function(str) {
    let tmp;
    let values;
    if (str.substr(0, 4) === 'rgb(') {
      tmp = str.substr(4, str.length - 5);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length !== 3) {
        throw new Error('Malformatted rgb-expression');
      }
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]));
    }
    if (str.substr(0, 5) === 'rgba(') {
      tmp = str.substr(5, str.length - 6);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length !== 4) {
        throw new Error('Malformatted rgb-expression');
      }
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]),
          parseFloat(values[3]));
    }
    if (str[0] === '#' && str.length === 7) {
      return new Color(
          parseInt(str.substr(1, 2), 16),
          parseInt(str.substr(3, 2), 16),
          parseInt(str.substr(5, 2), 16));
    }
    throw new Error('Unrecognized string format.');
  };

  Color.lerp = function(a, b, percent) {
    if (a.a !== undefined && b.a !== undefined) {
      return Color.lerpRGBA(a, b, percent);
    }
    return Color.lerpRGB(a, b, percent);
  };

  Color.lerpRGB = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b);
  };

  Color.lerpRGBA = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b,
        ((b.a - a.a) * percent) + a.a);
  };

  Color.fromDict = function(dict) {
    return new Color(dict.r, dict.g, dict.b, dict.a);
  };

  /**
   * Converts an HSL triplet with alpha to an RGB color.
   * |h| Hue value in [0, 1].
   * |s| Saturation value in [0, 1].
   * |l| Lightness in [0, 1].
   * |a| Alpha in [0, 1]
   */
  Color.fromHSLExplicit = function(h, s, l, a) {
    let r;
    let g;
    let b;
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return new Color(Math.floor(r * 255),
                     Math.floor(g * 255),
                     Math.floor(b * 255), a);
  };

  Color.fromHSL = function(hsl) {
    return Color.fromHSLExplicit(hsl.h, hsl.s, hsl.l, hsl.a);
  };

  Color.prototype = {
    clone() {
      const c = new Color();
      c.r = this.r;
      c.g = this.g;
      c.b = this.b;
      c.a = this.a;
      return c;
    },

    blendOver(bgColor) {
      const oneMinusThisAlpha = 1 - this.a;
      const outA = this.a + bgColor.a * oneMinusThisAlpha;
      const bgBlend = (bgColor.a * oneMinusThisAlpha) / bgColor.a;
      return new Color(
          this.r * this.a + bgColor.r * bgBlend,
          this.g * this.a + bgColor.g * bgBlend,
          this.b * this.a + bgColor.b * bgBlend,
          outA);
    },

    brighten(opt_k) {
      const k = opt_k || 0.45;

      return new Color(
          Math.min(255, this.r + Math.floor(this.r * k)),
          Math.min(255, this.g + Math.floor(this.g * k)),
          Math.min(255, this.b + Math.floor(this.b * k)),
          this.a);
    },

    lighten(k, opt_maxL) {
      const maxL = opt_maxL !== undefined ? opt_maxL : 1.0;
      const hsl = this.toHSL();
      hsl.l = Math.min(hsl.l + k, maxL);
      return Color.fromHSL(hsl);
    },

    darken(opt_k) {
      let k;
      if (opt_k !== undefined) {
        k = opt_k;
      } else {
        k = 0.45;
      }

      return new Color(
          Math.min(255, this.r - Math.floor(this.r * k)),
          Math.min(255, this.g - Math.floor(this.g * k)),
          Math.min(255, this.b - Math.floor(this.b * k)),
          this.a);
    },

    desaturate(opt_desaturateFactor) {
      let desaturateFactor;
      if (opt_desaturateFactor !== undefined) {
        desaturateFactor = opt_desaturateFactor;
      } else {
        desaturateFactor = 1;
      }

      const hsl = this.toHSL();
      hsl.s = clamp01(hsl.s * (1 - desaturateFactor));
      return Color.fromHSL(hsl);
    },

    withAlpha(a) {
      return new Color(this.r, this.g, this.b, a);
    },

    toString() {
      if (this.a !== undefined) {
        return 'rgba(' +
            this.r + ',' + this.g + ',' +
            this.b + ',' + this.a + ')';
      }
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    },

    /**
     * Returns a dict {h, s, l, a} with:
     * |h| Hue value in [0, 1].
     * |s| Saturation value in [0, 1].
     * |l| Lightness in [0, 1].
     * |a| Alpha in [0, 1]
     */
    toHSL() {
      const r = this.r / 255;
      const g = this.g / 255;
      const b = this.b / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);

      let h;
      let s;
      const l = (max + min) / 2;
      if (min === max) {
        h = 0;
        s = 0;
      } else {
        const delta = max - min;
        if (l > 0.5) {
          s = delta / (2 - max - min);
        } else {
          s = delta / (max + min);
        }

        if (r === max) {
          h = (g - b) / delta;
          if (g < b) h += 6;
        } else if (g === max) {
          h = 2 + ((b - r) / delta);
        } else {
          h = 4 + ((r - g) / delta);
        }
        h /= 6;
      }

      return {h, s, l, a: this.a};
    },

    toStringWithAlphaOverride(alpha) {
      return 'rgba(' +
          this.r + ',' + this.g + ',' +
          this.b + ',' + alpha + ')';
    }
  };

  return {
    Color,
  };
});


'use strict';
tr.exportTo('tr.b', function() {
  /**
   * Generate pretty colors!
   * http://basecase.org/env/on-rainbows
   * https://mycarta.wordpress.com/2012/10/06/the-rainbow-is-deadlong-live-the-rainbow-part-3/
   *
   * Set brightness = 0 to always generate black.
   * Set brightness = 2 to always generate white.
   * Set brightness = 1 to generate saturated colors.
   *
   * @constructor
   * @param {number=} opt_a alpha opacity in [0,1]
   * @param {number=} opt_brightness in [0,2]
   */
  function SinebowColorGenerator(opt_a, opt_brightness) {
    this.a_ = (opt_a === undefined) ? 1 : opt_a;
    this.brightness_ = (opt_brightness === undefined) ? 1 : opt_brightness;
    this.colorIndex_ = 0;
    this.keyToColor = {};
  }

  SinebowColorGenerator.prototype = {
    colorForKey(key) {
      if (!this.keyToColor[key]) {
        this.keyToColor[key] = this.nextColor();
      }
      return this.keyToColor[key];
    },

    nextColor() {
      const components = SinebowColorGenerator.nthColor(this.colorIndex_++);
      return tr.b.Color.fromString(SinebowColorGenerator.calculateColor(
          components[0], components[1], components[2],
          this.a_, this.brightness_));
    }
  };

  SinebowColorGenerator.PHI = (1 + Math.sqrt(5)) / 2;

  SinebowColorGenerator.sinebow_ = function(h) {
    h += 0.5;
    h = -h;
    let r = Math.sin(Math.PI * h);
    let g = Math.sin(Math.PI * (h + 1 / 3));
    let b = Math.sin(Math.PI * (h + 2 / 3));
    r *= r; g *= g; b *= b;
    // Roughly correct for human perception.
    // https://en.wikipedia.org/wiki/Luma_%28video%29
    // Multiply by 2 to normalize all values to 0.5.
    // (Halfway between black and white.)
    const y = 2 * (0.2989 * r + 0.5870 * g + 0.1140 * b);
    r /= y; g /= y; b /= y;
    return [256 * r, 256 * g, 256 * b];
  };

  SinebowColorGenerator.nthColor = function(n) {
    return SinebowColorGenerator.sinebow_(n * this.PHI);
  };

  SinebowColorGenerator.calculateColor = function(r, g, b, a, brightness) {
    if (brightness <= 1) {
      r *= brightness;
      g *= brightness;
      b *= brightness;
    } else {
      r = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), r, 255);
      g = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), g, 255);
      b = tr.b.math.lerp(tr.b.math.normalize(brightness, 1, 2), b, 255);
    }
    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);
    return 'rgba(' + r + ',' + g + ',' + b + ', ' + a + ')';
  };

  return {
    SinebowColorGenerator,
  };
});


'use strict';

tr.exportTo('tr.e.chrome', function() {
  const SAME_AS_PARENT = 'same-as-parent';

  const TITLES_FOR_USER_FRIENDLY_CATEGORY = {
    composite: [
      'CompositingInputsUpdater::update',
      'ThreadProxy::SetNeedsUpdateLayers',
      'LayerTreeHost::UpdateLayers::CalcDrawProps',
      'UpdateLayerTree'
    ],

    gc: [
      'minorGC',
      'majorGC',
      'MajorGC',
      'MinorGC',
      'V8.GCScavenger',
      'V8.GCIncrementalMarking',
      'V8.GCIdleNotification',
      'V8.GCContext',
      'V8.GCCompactor',
      'V8GCController::traceDOMWrappers'
    ],

    iframe_creation: [
      'WebLocalFrameImpl::createChildframe'
    ],

    imageDecode: [
      'Decode Image',
      'ImageFrameGenerator::decode',
      'ImageFrameGenerator::decodeAndScale'
    ],

    input: [
      'HitTest',
      'ScrollableArea::scrollPositionChanged',
      'EventHandler::handleMouseMoveEvent'
    ],

    layout: [
      'FrameView::invalidateTree',
      'FrameView::layout',
      'FrameView::performLayout',
      'FrameView::performPostLayoutTasks',
      'FrameView::performPreLayoutTasks',
      'Layer::updateLayerPositionsAfterLayout',
      'Layout',
      'LayoutView::hitTest',
      'ResourceLoadPriorityOptimizer::updateAllImageResourcePriorities',
      'WebViewImpl::layout'
    ],

    parseHTML: [
      'ParseHTML',
      'HTMLDocumentParser::didReceiveParsedChunkFromBackgroundParser',
      'HTMLDocumentParser::processParsedChunkFromBackgroundParser',
      'HTMLDocumentParser::processTokenizedChunkFromBackgroundParser',
    ],

    raster: [
      'DisplayListRasterSource::PerformSolidColorAnalysis',
      'Picture::Raster',
      'RasterBufferImpl::Playback',
      'RasterTask',
      'RasterizerTaskImpl::RunOnWorkerThread',
      'SkCanvas::drawImageRect()',
      'SkCanvas::drawPicture()',
      'SkCanvas::drawTextBlob()',
      'TileTaskWorkerPool::PlaybackToMemory'
    ],

    record: [
      'ContentLayerDelegate::paintContents',
      'DeprecatedPaintLayerCompositor::updateIfNeededRecursive',
      'DeprecatedPaintLayerCompositor::updateLayerPositionsAfterLayout',
      'Paint',
      'Picture::Record',
      'PictureLayer::Update',
      'RenderLayer::updateLayerPositionsAfterLayout'
    ],

    style: [
      'CSSParserImpl::parseStyleSheet.parse',
      'CSSParserImpl::parseStyleSheet.tokenize',
      'Document::updateStyle',
      'Document::updateStyleInvalidationIfNeeded',
      'ParseAuthorStyleSheet',
      'RuleSet::addRulesFromSheet',
      'StyleElement::processStyleSheet',
      'StyleEngine::createResolver',
      'StyleSheetContents::parseAuthorStyleSheet',
      'UpdateLayoutTree'
    ],

    script_parse_and_compile: [
      'v8.parseOnBackground',
      'V8.ScriptCompiler'
    ],

    script_execute: [
      'V8.Execute',
      'WindowProxy::initialize'
    ],

    resource_loading: [
      'ResourceFetcher::requestResource',
      'ResourceDispatcher::OnReceivedData',
      'ResourceDispatcher::OnRequestComplete',
      'ResourceDispatcher::OnReceivedResponse',
      'Resource::appendData'
    ],

    // Where do these go?
    renderer_misc: [
      'DecodeFont',
      'ThreadState::completeSweep' // blink_gc
    ],

    // TODO(fmeawad): https://github.com/catapult-project/catapult/issues/2572
    v8_runtime: [
      // Dynamically populated.
    ],

    [SAME_AS_PARENT]: [
      'SyncChannel::Send'
    ]
  };

  const COLOR_FOR_USER_FRIENDLY_CATEGORY = new tr.b.SinebowColorGenerator();
  const USER_FRIENDLY_CATEGORY_FOR_TITLE = new Map();

  for (const category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
    TITLES_FOR_USER_FRIENDLY_CATEGORY[category].forEach(function(title) {
      USER_FRIENDLY_CATEGORY_FOR_TITLE.set(title, category);
    });
  }

  // keys: event.category part
  // values: user friendly category
  const USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY = {
    netlog: 'net',
    overhead: 'overhead',
    startup: 'startup',
    gpu: 'gpu'
  };

  function ChromeUserFriendlyCategoryDriver() {
  }

  ChromeUserFriendlyCategoryDriver.fromEvent = function(event) {
    let userFriendlyCategory =
        USER_FRIENDLY_CATEGORY_FOR_TITLE.get(event.title);
    if (userFriendlyCategory) {
      if (userFriendlyCategory === SAME_AS_PARENT) {
        if (event.parentSlice) {
          return ChromeUserFriendlyCategoryDriver.fromEvent(event.parentSlice);
        }
      } else {
        return userFriendlyCategory;
      }
    }

    const eventCategoryParts = tr.b.getCategoryParts(event.category);
    for (let i = 0; i < eventCategoryParts.length; ++i) {
      const eventCategory = eventCategoryParts[i];
      userFriendlyCategory = USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY[
          eventCategory];
      if (userFriendlyCategory) {
        return userFriendlyCategory;
      }
    }

    return 'other';
  };

  ChromeUserFriendlyCategoryDriver.getColor = function(ufc) {
    return COLOR_FOR_USER_FRIENDLY_CATEGORY.colorForKey(ufc);
  };

  ChromeUserFriendlyCategoryDriver.ALL_TITLES = ['other'];
  for (const category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
    if (category === SAME_AS_PARENT) continue;
    ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
  }
  for (const category of Object.values(
      USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY)) {
    ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
  }
  ChromeUserFriendlyCategoryDriver.ALL_TITLES.sort();

  // Prime the color generator by iterating through all UFCs in alphabetical
  // order.
  for (const category of ChromeUserFriendlyCategoryDriver.ALL_TITLES) {
    ChromeUserFriendlyCategoryDriver.getColor(category);
  }

  return {
    ChromeUserFriendlyCategoryDriver,
  };
});


'use strict';

tr.exportTo('tr.model.helpers', function() {
  const NET_CATEGORIES = new Set(['net', 'netlog',
    'disabled-by-default-netlog', 'disabled-by-default-network']);

  class ChromeThreadHelper {
    constructor(thread) {
      this.thread = thread;
    }

    getNetworkEvents() {
      const networkEvents = [];
      for (const slice of this.thread.asyncSliceGroup.slices) {
        const categories = tr.b.getCategoryParts(slice.category);
        const isNetEvent = category => NET_CATEGORIES.has(category);
        if (categories.filter(isNetEvent).length === 0) continue;
        networkEvents.push(slice);
      }
      return networkEvents;
    }
  }

  return {
    ChromeThreadHelper,
  };
});


'use strict';

tr.exportTo('tr.model.helpers', function() {
  const ChromeThreadHelper = tr.model.helpers.ChromeThreadHelper;

  function ChromeRendererHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrRendererMain') ||
        process.findAtMostOneThreadNamed('Chrome_InProcRendererThread');
    this.compositorThread_ = process.findAtMostOneThreadNamed('Compositor');
    this.rasterWorkerThreads_ = process.findAllThreadsMatching(function(t) {
      if (t.name === undefined) return false;
      if (t.name.indexOf('CompositorTileWorker') === 0) return true;
      if (t.name.indexOf('CompositorRasterWorker') === 0) return true;
      return false;
    });

    if (!process.name) {
      process.name = ChromeRendererHelper.PROCESS_NAME;
    }
  }

  ChromeRendererHelper.PROCESS_NAME = 'Renderer';

  // Returns true if there is either a main thread or a compositor thread.
  ChromeRendererHelper.isRenderProcess = function(process) {
    if (process.findAtMostOneThreadNamed('CrRendererMain')) return true;
    if (process.findAtMostOneThreadNamed('Compositor')) return true;
    return false;
  };

  ChromeRendererHelper.isTracingProcess = function(process) {
    return process.labels !== undefined &&
        process.labels.length === 1 &&
        process.labels[0] === 'chrome://tracing';
  };

  ChromeRendererHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype,

    // May be undefined.
    get mainThread() {
      return this.mainThread_;
    },

    // May be undefined.
    get compositorThread() {
      return this.compositorThread_;
    },

    // May be empty.
    get rasterWorkerThreads() {
      return this.rasterWorkerThreads_;
    },

    get isChromeTracingUI() {
      return ChromeRendererHelper.isTracingProcess(this.process);
    },
  };

  return {
    ChromeRendererHelper,
  };
});


'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tr.exportTo('tr.model.helpers', function() {
  function findChromeBrowserProcesses(model) {
    return model.getAllProcesses(
        tr.model.helpers.ChromeBrowserHelper.isBrowserProcess);
  }

  function findChromeRenderProcesses(model) {
    return model.getAllProcesses(
        tr.model.helpers.ChromeRendererHelper.isRenderProcess);
  }

  function findChromeGpuProcess(model) {
    const gpuProcesses = model.getAllProcesses(
        tr.model.helpers.ChromeGpuHelper.isGpuProcess);
    if (gpuProcesses.length !== 1) return undefined;
    return gpuProcesses[0];
  }

  function ChromeModelHelper(model) {
    this.model_ = model;

    // Find browserHelpers.
    const browserProcesses = findChromeBrowserProcesses(model);
    this.browserHelpers_ = browserProcesses.map(
        p => new tr.model.helpers.ChromeBrowserHelper(this, p));

    // Find gpuHelper.
    const gpuProcess = findChromeGpuProcess(model);
    if (gpuProcess) {
      this.gpuHelper_ = new tr.model.helpers.ChromeGpuHelper(
          this, gpuProcess);
    } else {
      this.gpuHelper_ = undefined;
    }

    // Find rendererHelpers.
    const rendererProcesses_ = findChromeRenderProcesses(model);

    this.rendererHelpers_ = {};
    rendererProcesses_.forEach(function(renderProcess) {
      const rendererHelper = new tr.model.helpers.ChromeRendererHelper(
          this, renderProcess);
      this.rendererHelpers_[rendererHelper.pid] = rendererHelper;
    }, this);

    this.chromeBounds_ = undefined;
  }

  ChromeModelHelper.guid = tr.b.GUID.allocateSimple();

  ChromeModelHelper.supportsModel = function(model) {
    if (findChromeBrowserProcesses(model).length) return true;
    if (findChromeRenderProcesses(model).length) return true;
    return false;
  };

  ChromeModelHelper.prototype = {
    get pid() {
      throw new Error('woah');
    },

    get process() {
      throw new Error('woah');
    },

    get model() {
      return this.model_;
    },

    // TODO: Make all users of ChromeModelHelper support multiple browsers and
    // remove this getter (see #2119).
    get browserProcess() {
      if (this.browserHelper === undefined) return undefined;
      return this.browserHelper.process;
    },

    // TODO: Make all users of ChromeModelHelper support multiple browsers and
    // remove this getter (see #2119).
    get browserHelper() {
      return this.browserHelpers_[0];
    },

    get browserHelpers() {
      return this.browserHelpers_;
    },

    get gpuHelper() {
      return this.gpuHelper_;
    },

    get rendererHelpers() {
      return this.rendererHelpers_;
    },


    // TODO(dproy): Remove this when loading_metric supports all renderers.
    // https://github.com/catapult-project/catapult/issues/2820
    /**
     * Returns the renderer with the largest PID that is not the Chrome tracing
     * UI.
     *
     * This is a very hacky approach to find the "target" renderer in metrics
     * calculation. Often in Telemetry tests we are only interested in
     * calculating metrics for the page opened by the automated testing system,
     * but there's currently no reliable way to find this renderer. One useful
     * heuristic is that the page Telemetry opens is opened after all the other
     * renderers in Chrome were opened, and therefore has the largest PID.
     */
    get rendererWithLargestPid() {
      let largestPid = -1;
      for (const pid in this.rendererHelpers) {
        const rendererHelper = this.rendererHelpers[pid];
        if (rendererHelper.isChromeTracingUI) continue;
        if (pid > largestPid) largestPid = pid;
      }

      if (largestPid === -1) return undefined;

      return this.rendererHelpers[largestPid];
    },

    /**
     * Returns the minimal bounds that includes all Chrome-related slices, or
     * undefined if no such minimal bounds could be established. This relies on
     * the assumption that all Chrome-relevant traces are bounded by the browser
     * process.
     */
    get chromeBounds() {
      if (!this.chromeBounds_) {
        this.chromeBounds_ = new tr.b.math.Range();
        for (const browserHelper of
             Object.values(this.browserHelpers)) {
          this.chromeBounds_.addRange(browserHelper.process.bounds);
        }
      }

      if (this.chromeBounds_.isEmpty) {
        return undefined;
      }

      return this.chromeBounds_;
    }
  };

  return {
    ChromeModelHelper,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  function mediaMetric(histograms, model) {
    let playStart;
    let timeToAudioPlay;
    let timeToVideoPlay;

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (chromeHelper === undefined) return;

    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      // Find the threads we're interested in, and if a needed thread
      // is missing, no need to look further in this process.
      const mainThread = rendererHelper.mainThread;
      if (mainThread === undefined) continue;

      const compositorThread = rendererHelper.compositorThread;
      const audioThread =
        rendererHelper.process.findAtMostOneThreadNamed('AudioOutputDevice');
      if (compositorThread === undefined && audioThread === undefined) continue;

      // Look for the media player DoLoad event on main thread.
      for (const event of mainThread.getDescendantEvents()) {
        if (event.title === 'WebMediaPlayerImpl::DoLoad') {
          // TODO(johnchen@chromium.org): Support multiple audio/video
          // elements per page. Currently, we only support a single
          // audio or video element, so we can store the start time in
          // a simple variable, and exit the loop.
          if (playStart !== undefined) {
            throw new Error(
                'Loading multiple audio/video elements not yet supported');
          }
          playStart = event.start;
          break;
        }
      }
      if (playStart === undefined) continue;

      // Look for video render event.
      if (compositorThread !== undefined) {
        for (const event of compositorThread.getDescendantEvents()) {
          if (event.title === 'VideoRendererImpl::Render') {
            timeToVideoPlay = event.start - playStart;
            break;
          }
        }
      }

      // Look for audio render event.
      if (audioThread !== undefined) {
        for (const event of audioThread.getDescendantEvents()) {
          if (event.title === 'AudioRendererImpl::Render') {
            timeToAudioPlay = event.start - playStart;
            break;
          }
        }
      }
      if (timeToVideoPlay !== undefined) break;
      if (timeToAudioPlay !== undefined) break;
    }

    if (timeToVideoPlay !== undefined) {
      histograms.createHistogram('time_to_video_play',
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, timeToVideoPlay);
    }
    if (timeToAudioPlay !== undefined) {
      histograms.createHistogram('time_to_audio_play',
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, timeToAudioPlay);
    }
  }

  tr.metrics.MetricRegistry.register(mediaMetric);

  return {
    mediaMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  function sampleMetric(histograms, model) {
    const hist = new tr.v.Histogram(
        'foo', tr.b.Unit.byName.sizeInBytes_smallerIsBetter);
    hist.addSample(9);
    hist.addSample(91, {bar: new tr.v.d.GenericSet([{hello: 42}])});

    for (const expectation of model.userModel.expectations) {
      if (expectation instanceof tr.model.um.ResponseExpectation) {
      } else if (expectation instanceof tr.model.um.AnimationExpectation) {
      } else if (expectation instanceof tr.model.um.IdleExpectation) {
      } else if (expectation instanceof tr.model.um.LoadExpectation) {
      }
    }

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);

    for (const [pid, process] of Object.entries(model.processes)) {
    }

    histograms.addHistogram(hist);
  }

  tr.metrics.MetricRegistry.register(sampleMetric);

  return {
    sampleMetric,
  };
});


'use strict';

/**
 * @fileoverview This file contains helper functions to identify
 * FrameLoader::updateForSameDocumentNavigation events on all renderer
 * processes and find their preceding navigation start events.
 *_______________________________________________________________
 * browser:     InputLatency/NavigationControllerImpl::GoToIndex |
 *----------------------------------------
 * renderer:       LatencyInfo.Flow
 *                  WebViewImpl::handleInputEvent
 *                          FrameLoader::updateForSameDocumentNavigation
 *----------------------------------------------------
 * FrameLoader::updateForSameDocumentNavigation is called when SPA
 * in-app navigation occurs.
 * For details about how SPA in-app navigation is defined and
 * how it is found based on FrameLoader::updateForSameDocumentNavigation,
 * read the doc: https://goo.gl/1I3tqd.
 */
tr.exportTo('tr.metrics', function() {
  const HANDLE_INPUT_EVENT_TITLE = 'WebViewImpl::handleInputEvent';

  /**
   * @returns {Map.<tr.model.Slice, tr.model.Slice>} A map of the
   * elements in eventsB which immediately precede events in eventsA.
   * For instance:
   * eventsA:     A1   A2   A3   A4
   * eventsB: B1 B2  B3   B4   B5
   *  output: {A1: B2, A2: B3, A3: B4, A4: B5}
   * or
   * eventsA:     A1   A2   A3   A4
   * eventsB: B1
   *  output: {A1: B1, A2: B1, A3: B1, A4: B1}
   */
  function findPrecedingEvents_(eventsA, eventsB) {
    const events = new Map();
    let eventsBIndex = 0;
    for (const eventA of eventsA) {
      for (; eventsBIndex < eventsB.length; eventsBIndex++) {
        if (eventsB[eventsBIndex].start > eventA.start) break;
      }
      // If statement prevents the situation when eventsB is empty.
      if (eventsBIndex > 0) {
        events.set(eventA, eventsB[eventsBIndex - 1]);
      }
    }
    return events;
  }

  /**
   * @returns {Map.<tr.model.Slice, tr.model.Slice>} A map of
   * the elements in eventsB which immediately follow events
   * in eventsA.
   * For instance:
   * eventsA:  A1   A2   A3   A4
   * eventsB: B1  B2   B3  B4   B5
   *  output: {A1:B2, A2:B3, A3:B4, A4:B5}
   * or
   * eventsA:  A1   A2   A3   A4
   * eventsB:                B1
   *  output: {A1:B1, A2:B1, A3:B1}
   */
  function findFollowingEvents_(eventsA, eventsB) {
    const events = new Map();
    let eventsBIndex = 0;
    for (const eventA of eventsA) {
      for (; eventsBIndex < eventsB.length; eventsBIndex++) {
        if (eventsB[eventsBIndex].start >= eventA.start) break;
      }
      // If statement prevents the situation when eventsB is empty
      // and when it reaches the end of loop.
      if (eventsBIndex >= 0 && eventsBIndex < eventsB.length) {
        events.set(eventA, eventsB[eventsBIndex]);
      }
    }
    return events;
  }

  /**
   * @return {Array.<tr.model.Slice>} An array of events that may
   * be qualified as a SPA navigation start candidate such as
   * WebViewImpl::handleInputEvent and NavigationControllerImpl::GoToIndex.
   */
  function getSpaNavigationStartCandidates_(rendererHelper, browserHelper) {
    const isNavStartEvent = e => {
      if (e.title === HANDLE_INPUT_EVENT_TITLE && e.args.type === 'MouseUp') {
        return true;
      }
      return e.title === 'NavigationControllerImpl::GoToIndex';
    };

    return [
      ...rendererHelper.mainThread.sliceGroup.getDescendantEvents(),
      ...browserHelper.mainThread.sliceGroup.getDescendantEvents()
    ].filter(isNavStartEvent);
  }

  /**
   * @return {Array.<tr.model.Slice>} An array of SPA navigation events.
   * A SPA navigation event indicates the happening of a SPA navigation.
   */
  function getSpaNavigationEvents_(rendererHelper) {
    const isNavEvent = e => e.category === 'blink' &&
        e.title === 'FrameLoader::updateForSameDocumentNavigation';

    return [...rendererHelper.mainThread.sliceGroup.getDescendantEvents()]
        .filter(isNavEvent);
  }

  /**
   * @return {Array.<tr.model.AsyncSlice>} An array of InputLatency events from
   * the browser main thread.
   */
  function getInputLatencyEvents_(browserHelper) {
    const isInputLatencyEvent = e => e.title === 'InputLatency::MouseUp';

    return browserHelper.getAllAsyncSlicesMatching(isInputLatencyEvent);
  }

  /**
   * @return {Map.<number, tr.model.Slice>} A mapping of trace_id value
   * in each InputLatency event to the respective InputLatency event itself.
   */
  function getInputLatencyEventByBindIdMap_(browserHelper) {
    const inputLatencyEventByBindIdMap = new Map();
    for (const event of getInputLatencyEvents_(browserHelper)) {
      inputLatencyEventByBindIdMap.set(event.args.data.trace_id, event);
    }
    return inputLatencyEventByBindIdMap;
  }

  /**
   * @returns {Map.<tr.model.Slice, tr.model.AsyncSlice>} A mapping
   * from a FrameLoader update navigation slice to its respective
   * navigation start event, which can be an InputLatency async
   * slice or a NavigationControllerImpl::GoToIndex slice.
   */
  function getSpaNavigationEventToNavigationStartMap_(
      rendererHelper, browserHelper) {
    const mainThread = rendererHelper.mainThread;
    const spaNavEvents = getSpaNavigationEvents_(rendererHelper);
    const navStartCandidates = getSpaNavigationStartCandidates_(
        rendererHelper, browserHelper).sort(tr.importer.compareEvents);
    const spaNavEventToNavStartCandidateMap =
        findPrecedingEvents_(spaNavEvents, navStartCandidates);

    const inputLatencyEventByBindIdMap =
        getInputLatencyEventByBindIdMap_(browserHelper);
    const spaNavEventToNavStartEventMap = new Map();
    for (const [spaNavEvent, navStartCandidate] of
        spaNavEventToNavStartCandidateMap) {
      if (navStartCandidate.title === HANDLE_INPUT_EVENT_TITLE) {
        const inputLatencySlice = inputLatencyEventByBindIdMap.get(
            Number(navStartCandidate.parentSlice.bindId));
        if (inputLatencySlice) {
          spaNavEventToNavStartEventMap.set(spaNavEvent, inputLatencySlice);
        }
      } else {
        spaNavEventToNavStartEventMap.set(spaNavEvent, navStartCandidate);
      }
    }
    return spaNavEventToNavStartEventMap;
  }

  /**
   * @return {Array.<tr.model.Slice>} An array of first paint events.
   */
  function getFirstPaintEvents_(rendererHelper) {
    const isFirstPaintEvent = e => e.category === 'blink' &&
        e.title === 'PaintLayerCompositor::updateIfNeededRecursive';

    return [...rendererHelper.mainThread.sliceGroup.getDescendantEvents()]
        .filter(isFirstPaintEvent);
  }

  /**
   * @returns {Map.<tr.model.Slice, tr.model.Slice>} A mapping
   * from a FrameLoader update navigation slice to its respective
   * first paint slice.
   */
  function getSpaNavigationEventToFirstPaintEventMap_(rendererHelper) {
    const spaNavEvents = getSpaNavigationEvents_(
        rendererHelper).sort(tr.importer.compareEvents);
    const firstPaintEvents = getFirstPaintEvents_(
        rendererHelper).sort(tr.importer.compareEvents);

    return findFollowingEvents_(spaNavEvents, firstPaintEvents);
  }

  /**
   * @typedef {NavStartCandidates}
   * @property {tr.model.AsyncSlice} inputLatencyAsyncSlice
   * @property {tr.model.Slice} goToIndexSlice
   */

  /**
   * @typedef {SpaNavObject}
   * @property {NavStartCandidates} navStartCandidates
   * @property {tr.model.Slice} firstPaintEvent
   * @property {string} url
   */

  /**
   * @returns {Array.<SpaNavObject>}
   */
  function findSpaNavigationsOnRenderer(rendererHelper, browserHelper) {
    const spaNavEventToNavStartMap =
        getSpaNavigationEventToNavigationStartMap_(
            rendererHelper, browserHelper);
    const spaNavEventToFirstPaintEventMap =
        getSpaNavigationEventToFirstPaintEventMap_(rendererHelper);
    const spaNavigations = [];
    for (const [spaNavEvent, navStartEvent] of
        spaNavEventToNavStartMap) {
      if (spaNavEventToFirstPaintEventMap.has(spaNavEvent)) {
        const firstPaintEvent =
            spaNavEventToFirstPaintEventMap.get(spaNavEvent);
        const isNavStartAsyncSlice =
          navStartEvent instanceof tr.model.AsyncSlice;
        spaNavigations.push({
          navStartCandidates: {
            inputLatencyAsyncSlice:
                isNavStartAsyncSlice ? navStartEvent : undefined,
            goToIndexSlice: isNavStartAsyncSlice ? undefined : navStartEvent
          },
          firstPaintEvent,
          url: spaNavEvent.args.url
        });
      }
    }
    return spaNavigations;
  }

  return {
    findSpaNavigationsOnRenderer,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * Indicates how much of a compound-event is selected [if any].
   *
   * The CompoundEventSelectionState enum is used with events that are
   * directly selectable, but also have associated events, too, that can be
   * selected. In this situation, there are a variety of different
   * selected states other than just "yes, no". This enum encodes those
   * various possible states.
   */
  const CompoundEventSelectionState = {
    // Basic bit states.
    NOT_SELECTED: 0,
    EVENT_SELECTED: 0x1,
    SOME_ASSOCIATED_EVENTS_SELECTED: 0x2,
    ALL_ASSOCIATED_EVENTS_SELECTED: 0x4,

    // Common combinations.
    EVENT_AND_SOME_ASSOCIATED_SELECTED: 0x1 | 0x2,
    EVENT_AND_ALL_ASSOCIATED_SELECTED: 0x1 | 0x4
  };

  return {
    CompoundEventSelectionState,
  };
});


'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
tr.exportTo('tr.b', function() {
  // Basic constants...
  const generalPurposeColors = [
    new tr.b.Color(122, 98, 135),
    new tr.b.Color(150, 83, 105),
    new tr.b.Color(44, 56, 189),
    new tr.b.Color(99, 86, 147),
    new tr.b.Color(104, 129, 107),
    new tr.b.Color(130, 178, 55),
    new tr.b.Color(87, 109, 147),
    new tr.b.Color(111, 145, 88),
    new tr.b.Color(81, 152, 131),
    new tr.b.Color(142, 91, 111),
    new tr.b.Color(81, 163, 70),
    new tr.b.Color(148, 94, 86),
    new tr.b.Color(144, 89, 118),
    new tr.b.Color(83, 150, 97),
    new tr.b.Color(105, 94, 139),
    new tr.b.Color(89, 144, 122),
    new tr.b.Color(105, 119, 128),
    new tr.b.Color(96, 128, 137),
    new tr.b.Color(145, 88, 145),
    new tr.b.Color(88, 145, 144),
    new tr.b.Color(90, 100, 143),
    new tr.b.Color(121, 97, 136),
    new tr.b.Color(111, 160, 73),
    new tr.b.Color(112, 91, 142),
    new tr.b.Color(86, 147, 86),
    new tr.b.Color(63, 100, 170),
    new tr.b.Color(81, 152, 107),
    new tr.b.Color(60, 164, 173),
    new tr.b.Color(143, 72, 161),
    new tr.b.Color(159, 74, 86)];

  const reservedColorsByName = {
    thread_state_uninterruptible: new tr.b.Color(182, 125, 143),
    thread_state_iowait: new tr.b.Color(255, 140, 0),
    thread_state_running: new tr.b.Color(126, 200, 148),
    thread_state_runnable: new tr.b.Color(133, 160, 210),
    thread_state_sleeping: new tr.b.Color(240, 240, 240),
    thread_state_unknown: new tr.b.Color(199, 155, 125),

    background_memory_dump: new tr.b.Color(0, 180, 180),
    light_memory_dump: new tr.b.Color(0, 0, 180),
    detailed_memory_dump: new tr.b.Color(180, 0, 180),

    vsync_highlight_color: new tr.b.Color(0, 0, 255),
    generic_work: new tr.b.Color(125, 125, 125),

    good: new tr.b.Color(0, 125, 0),
    bad: new tr.b.Color(180, 125, 0),
    terrible: new tr.b.Color(180, 0, 0),

    black: new tr.b.Color(0, 0, 0),
    grey: new tr.b.Color(221, 221, 221),
    white: new tr.b.Color(255, 255, 255),
    yellow: new tr.b.Color(255, 255, 0),
    olive: new tr.b.Color(100, 100, 0),

    rail_response: new tr.b.Color(67, 135, 253),
    rail_animation: new tr.b.Color(244, 74, 63),
    rail_idle: new tr.b.Color(238, 142, 0),
    rail_load: new tr.b.Color(13, 168, 97),
    startup: new tr.b.Color(230, 230, 0),

    heap_dump_stack_frame: new tr.b.Color(128, 128, 128),
    heap_dump_object_type: new tr.b.Color(0, 0, 255),
    heap_dump_child_node_arrow: new tr.b.Color(204, 102, 0),

    cq_build_running: new tr.b.Color(255, 255, 119),
    cq_build_passed: new tr.b.Color(153, 238, 102),
    cq_build_failed: new tr.b.Color(238, 136, 136),
    cq_build_abandoned: new tr.b.Color(187, 187, 187),

    cq_build_attempt_runnig: new tr.b.Color(222, 222, 75),
    cq_build_attempt_passed: new tr.b.Color(103, 218, 35),
    cq_build_attempt_failed: new tr.b.Color(197, 81, 81)
  };

  // Some constants we'll need for later lookups.
  const numGeneralPurposeColorIds = generalPurposeColors.length;
  const numReservedColorIds = Object.keys(reservedColorsByName).length;
  const numColorsPerVariant = numGeneralPurposeColorIds + numReservedColorIds;

  function ColorScheme() {
  }

  /*
   * A flat array of tr.b.Color values of the palette, and their variants.
   *
   * This array is made up of a set of base colors, repeated N times to form
   * a set of variants on that base color.
   *
   * Within the base colors, there are "general purpose" colors,
   * which can be used for random color selection, and
   * reserved colors, which are used when specific colors
   * need to be used, e.g. where red is desired.
   *
   * The variants are automatically generated from the base colors. The 0th
   * variant is the default apeparance of the color, and the varaiants are
   * mutations of that color, e.g. several brightening levels and desaturations.
   *
   * For example, a very simple version of this array looks like the following:
   *     0: Generic Color 0
   *     1: Generic Color 1
   *     2: Named Color 'foo'
   *     3: Brightened Generic Color 0
   *     4: Brightened Generic Color 1
   *     5: Brightened Named Color 'foo'
   */
  const paletteBase = [];
  paletteBase.push.apply(paletteBase, generalPurposeColors);
  paletteBase.push.apply(paletteBase, Object.values(reservedColorsByName));
  ColorScheme.colors = [];
  ColorScheme.properties = {};
  ColorScheme.properties = {
    numColorsPerVariant,
  };

  function pushVariant(func) {
    const variantColors = paletteBase.map(func);
    ColorScheme.colors.push.apply(ColorScheme.colors, variantColors);
  }

  // Basic colors.
  pushVariant(function(c) { return c; });

  // Brightened variants.
  ColorScheme.properties.brightenedOffsets = [];
  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.lighten(0.3, 0.8);
  });

  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.lighten(0.48, 0.85);
  });

  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.lighten(0.65, 0.9);
  });


  // Desaturated variants.
  ColorScheme.properties.dimmedOffsets = [];
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.desaturate();
  });
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.desaturate(0.5);
  });
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function(c) {
    return c.desaturate(0.3);
  });

  /**
   * A toString'd representation of ColorScheme.colors.
   */
  ColorScheme.colorsAsStrings = ColorScheme.colors.map(function(c) {
    return c.toString();
  });

  // Build reservedColorNameToIdMap.
  const reservedColorNameToIdMap = (function() {
    const m = new Map();
    let i = generalPurposeColors.length;
    for (const key of Object.keys(reservedColorsByName)) {
      m.set(key, i++);
    }
    return m;
  })();

  /**
   * @param {String} name The color name.
   * @return {Number} The color ID for the given color name.
   */
  ColorScheme.getColorIdForReservedName = function(name) {
    const id = reservedColorNameToIdMap.get(name);
    if (id === undefined) {
      throw new Error('Unrecognized color ' + name);
    }
    return id;
  };

  ColorScheme.getColorForReservedNameAsString = function(reservedName) {
    const id = ColorScheme.getColorIdForReservedName(reservedName);
    return ColorScheme.colorsAsStrings[id];
  };

  /**
   * Computes a simplistic hashcode of the provide name. Used to chose colors
   * for slices.
   * @param {string} name The string to hash.
   */
  ColorScheme.getStringHash = function(name) {
    let hash = 0;
    for (let i = 0; i < name.length; ++i) {
      hash = (hash + 37 * hash + 11 * name.charCodeAt(i)) % 0xFFFFFFFF;
    }
    return hash;
  };

  // Previously computed string color IDs. They are based on a stable hash, so
  // it is safe to save them throughout the program time.
  const stringColorIdCache = new Map();

  /**
   * @return {Number} A color ID that is stably associated to the provided via
   * the getStringHash method. The color ID will be chosen from the general
   * purpose ID space only, e.g. no reserved ID will be used.
   */
  ColorScheme.getColorIdForGeneralPurposeString = function(string) {
    if (stringColorIdCache.get(string) === undefined) {
      const hash = ColorScheme.getStringHash(string);
      stringColorIdCache.set(string, hash % numGeneralPurposeColorIds);
    }
    return stringColorIdCache.get(string);
  };

  /**
   * @return {Number} A color id generated consistently from a |colorId| and
   * number |n|.
   */
  ColorScheme.getAnotherColorId = function(colorId, n) {
    return (colorId + n) % numColorsPerVariant;
  };

  /**
   * @return {Number} A color ID that the |offset| variant of |colorId|.
   */
  ColorScheme.getVariantColorId = function(colorId, offset) {
    return colorId + offset;
  };

  return {
    ColorScheme,
  };
});


'use strict';

/**
 * @fileoverview Provides the SelectionState class.
 */
tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;

  /**
   * Describes the level of visual highlighting to apply to an event when shown.
   *
   * color_scheme.html defines N variations off of a base color palette,
   * one for each selection state, all concatenated into one flat array. To
   * pick the final colorId for a given variations, the SelectionState is
   * multiplied by the number of base colors.
   *
   * Thus, the values here must be kept in sync with color_scheme's palette
   * layout.
   */
  const SelectionState = {
    NONE: 0,

    // Legacy names.
    SELECTED: ColorScheme.properties.brightenedOffsets[0],
    HIGHLIGHTED: ColorScheme.properties.brightenedOffsets[1],
    DIMMED: ColorScheme.properties.dimmedOffsets[0],

    // Modern names.
    BRIGHTENED0: ColorScheme.properties.brightenedOffsets[0],
    BRIGHTENED1: ColorScheme.properties.brightenedOffsets[1],
    BRIGHTENED2: ColorScheme.properties.brightenedOffsets[2],

    DIMMED0: ColorScheme.properties.dimmedOffsets[0],
    DIMMED1: ColorScheme.properties.dimmedOffsets[1],
    DIMMED2: ColorScheme.properties.dimmedOffsets[2]
  };

  const brighteningLevels = [
    SelectionState.NONE,
    SelectionState.BRIGHTENED0,
    SelectionState.BRIGHTENED1,
    SelectionState.BRIGHTENED2
  ];
  SelectionState.getFromBrighteningLevel = function(level) {
    return brighteningLevels[level];
  };

  const dimmingLevels = [
    SelectionState.DIMMED0,
    SelectionState.DIMMED1,
    SelectionState.DIMMED2
  ];
  SelectionState.getFromDimmingLevel = function(level) {
    return dimmingLevels[level];
  };

  return {
    SelectionState,
  };
});


'use strict';

/**
 * @fileoverview Provides the SelectableItem class.
 */
tr.exportTo('tr.model', function() {
  const SelectionState = tr.model.SelectionState;

  /**
   * A SelectableItem is the abstract base class for any non-container data that
   * has an associated model item in the trace model (possibly itself).
   *
   * Subclasses must provide a selectionState property (or getter).
   *
   * @constructor
   */
  function SelectableItem(modelItem) {
    this.modelItem_ = modelItem;
  }

  SelectableItem.prototype = {
    get modelItem() {
      return this.modelItem_;
    },

    get selected() {
      return this.selectionState === SelectionState.SELECTED;
    },

    addToSelection(selection) {
      const modelItem = this.modelItem_;
      if (!modelItem) return;
      selection.push(modelItem);
    },

    addToTrackMap(eventToTrackMap, track) {
      const modelItem = this.modelItem_;
      if (!modelItem) return;
      eventToTrackMap.addEvent(modelItem, track);
    }
  };

  return {
    SelectableItem,
  };
});


'use strict';

/**
 * @fileoverview Provides the Event class.
 */
tr.exportTo('tr.model', function() {
  const SelectableItem = tr.model.SelectableItem;
  const SelectionState = tr.model.SelectionState;
  const IMMUTABLE_EMPTY_SET = tr.model.EventSet.IMMUTABLE_EMPTY_SET;

  /**
   * An Event is the base type for any non-container, selectable piece
   * of data in the trace model.
   *
   * @constructor
   * @extends {SelectableItem}
   */
  function Event() {
    SelectableItem.call(this, this /* modelItem */);
    this.guid_ = tr.b.GUID.allocateSimple();
    this.selectionState = SelectionState.NONE;
    this.info = undefined;
  }

  Event.prototype = {
    __proto__: SelectableItem.prototype,

    get guid() {
      return this.guid_;
    },

    get stableId() {
      return undefined;
    },

    get range() {
      const range = new tr.b.math.Range();
      this.addBoundsToRange(range);
      return range;
    },

    // Empty by default. Lazily initialized on an instance in
    // addAssociatedAlert(). See #1930.
    associatedAlerts: IMMUTABLE_EMPTY_SET,

    addAssociatedAlert(alert) {
      if (this.associatedAlerts === IMMUTABLE_EMPTY_SET) {
        this.associatedAlerts = new tr.model.EventSet();
      }
      this.associatedAlerts.push(alert);
    },

    // Adds the range of timestamps for this event to the specified range.
    // If this is not overridden in subclass, it means that type of event
    // doesn't have timestamps.
    addBoundsToRange(range) {}
  };

  return {
    Event,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * TimedEvent is a base type for any entity in the trace model with a specific
   * start and duration.
   *
   * @constructor
   */
  function TimedEvent(start) {
    tr.model.Event.call(this);
    this.start = start;
    this.duration = 0;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
    // The set of contexts this event belongs to (order is unimportant). This
    // array should never be modified.
    this.contexts = Object.freeze([]);
  }

  TimedEvent.prototype = {
    __proto__: tr.model.Event.prototype,

    get end() {
      return this.start + this.duration;
    },

    addBoundsToRange(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    },

    // TODO(charliea): Can this be implemented in terms of Event.range()?
    // Returns true if 'that' TimedEvent is fully contained within 'this' timed
    // event.
    bounds(that, opt_precisionUnit) {
      if (opt_precisionUnit === undefined) {
        opt_precisionUnit = tr.b.TimeDisplayModes.ms;
      }

      const startsBefore = opt_precisionUnit.roundedLess(
          that.start, this.start);
      const endsAfter = opt_precisionUnit.roundedLess(this.end, that.end);
      return !startsBefore && !endsAfter;
    }
  };

  return {
    TimedEvent,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  const CompoundEventSelectionState = tr.model.CompoundEventSelectionState;

  function UserExpectation(parentModel, initiatorType, start, duration) {
    tr.model.TimedEvent.call(this, start);
    this.associatedEvents = new tr.model.EventSet();
    this.duration = duration;
    this.initiatorType_ = initiatorType;
    this.parentModel = parentModel;
    this.typeInfo_ = undefined;

    // sourceEvents are the ones that caused the UserModelBuilder to create this
    // UserExpectation.
    this.sourceEvents = new tr.model.EventSet();
  }

  // Strings used to name UEs.
  const INITIATOR_TYPE = {
    KEYBOARD: 'Keyboard',
    MOUSE: 'Mouse',
    MOUSE_WHEEL: 'MouseWheel',
    TAP: 'Tap',
    PINCH: 'Pinch',
    FLING: 'Fling',
    TOUCH: 'Touch',
    SCROLL: 'Scroll',
    CSS: 'CSS',
    WEBGL: 'WebGL',
    VIDEO: 'Video'
  };

  UserExpectation.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    computeCompoundEvenSelectionState(selection) {
      let cess = CompoundEventSelectionState.NOT_SELECTED;
      if (selection.contains(this)) {
        cess |= CompoundEventSelectionState.EVENT_SELECTED;
      }

      if (this.associatedEvents.intersectionIsEmpty(selection)) {
        return cess;
      }

      const allContained = this.associatedEvents.every(function(event) {
        return selection.contains(event);
      });

      if (allContained) {
        cess |= CompoundEventSelectionState.ALL_ASSOCIATED_EVENTS_SELECTED;
      } else {
        cess |= CompoundEventSelectionState.SOME_ASSOCIATED_EVENTS_SELECTED;
      }
      return cess;
    },

    // Returns samples which are overlapping with V8.Execute
    get associatedSamples() {
      const samples = new tr.model.EventSet();
      this.associatedEvents.forEach(function(event) {
        if (event instanceof tr.model.ThreadSlice) {
          samples.addEventSet(event.overlappingSamples);
        }
      });
      return samples;
    },

    get userFriendlyName() {
      return this.title + ' User Expectation at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      return ('UserExpectation.' + this.guid);
    },

    get typeInfo() {
      if (!this.typeInfo_) {
        this.typeInfo_ = UserExpectation.subTypes.findTypeInfo(
            this.constructor);
      }

      // If you set Subclass.prototype = {}, then you must explicitly specify
      // constructor in that prototype object!
      // http://javascript.info/tutorial/constructor

      if (!this.typeInfo_) {
        throw new Error('Unregistered UserExpectation');
      }

      return this.typeInfo_;
    },

    get colorId() {
      return this.typeInfo.metadata.colorId;
    },

    get stageTitle() {
      return this.typeInfo.metadata.stageTitle;
    },

    get initiatorType() {
      return this.initiatorType_;
    },

    get title() {
      if (!this.initiatorType) {
        return this.stageTitle;
      }

      return this.initiatorType + ' ' + this.stageTitle;
    },

    /**
     * Returns the sum of the number of CPU ms spent by this UserExpectation.
     */
    get totalCpuMs() {
      let cpuMs = 0;
      this.associatedEvents.forEach(function(event) {
        if (event.cpuSelfTime) {
          cpuMs += event.cpuSelfTime;
        }
      });
      return cpuMs;
    }
  };

  const subTypes = {};
  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(subTypes, options);

  subTypes.addEventListener('will-register', function(e) {
    const metadata = e.typeInfo.metadata;

    if (metadata.stageTitle === undefined) {
      throw new Error('Registered UserExpectations must provide ' +
          'stageTitle');
    }

    if (metadata.colorId === undefined) {
      throw new Error('Registered UserExpectations must provide ' +
          'colorId');
    }
  });

  tr.model.EventRegistry.register(
      UserExpectation,
      {
        name: 'userExpectation',
        pluralName: 'userExpectations',
        subTypes
      });

  return {
    UserExpectation,
    INITIATOR_TYPE,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  // Returns a weight for this score.
  // score should be a number between 0 and 1 inclusive.
  // This function is expected to be passed to tr.b.math.Statistics.weightedMean
  // as its weightCallback.
  function perceptualBlend(ir, index, score) {
    // Lower scores are exponentially more important than higher scores
    // due to the Peak-end rule.
    // Other than that general rule, there is no specific reasoning behind this
    // specific formula -- it is fairly arbitrary.
    return Math.exp(1 - score);
  }

  function filterExpectationsByRange(irs, opt_range) {
    const filteredExpectations = [];
    irs.forEach(function(ir) {
      if (!(ir instanceof tr.model.um.UserExpectation)) return;

      if (!opt_range ||
          opt_range.intersectsExplicitRangeInclusive(ir.start, ir.end)) {
        filteredExpectations.push(ir);
      }
    });
    return filteredExpectations;
  }

  return {
    perceptualBlend,
    filterExpectationsByRange,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  /**
  * @callback getEventAttributeCallback
  * @param {!tr.b.Event} event The event to read an attribute from.
  * @return {number} The value of the attribute.
  */

  /**
  * Generate a breakdown tree from all slices of |mainThread| in
  * |rangeOfInterest|. The callback functions |getEventStart|,
  * |getEventDuration| and |getEventSelfTime| specify how to get start,
  * duration and selftime from a given event.
  *
  * @param  {!tr.model.Thread} mainThread
  * @param  {!tr.b.math.Range} rangeOfInterest
  * @callback {getEventAttributeCallback} getEventStart
  * @callback {getEventAttributeCallback} getEventDuration
  * @callback {getEventAttributeCallback} getEventSelfTime
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly title & values are an object that show the total spent
  * in |rangeOfInterest|, and the list of event labels of the
  * group and their total time in |rangeOfInterest|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateTimeBreakdownTree(mainThread, rangeOfInterest, getEventStart,
      getEventDuration, getEventSelfTime) {
    if (mainThread === null) return;
    const breakdownTree = {};
    for (const title of
        tr.e.chrome.ChromeUserFriendlyCategoryDriver.ALL_TITLES) {
      breakdownTree[title] = {total: 0, events: {}};
    }
    for (const event of mainThread.getDescendantEvents()) {
      const eventStart = getEventStart(event);
      const eventDuration = getEventDuration(event);
      const eventSelfTime = getEventSelfTime(event);
      const eventEnd = eventStart + eventDuration;
      if (!rangeOfInterest.intersectsExplicitRangeExclusive(
          eventStart, eventEnd)) {
        continue;
      }
      if (eventSelfTime === undefined) continue;
      const title =
          tr.e.chrome.ChromeUserFriendlyCategoryDriver.fromEvent(event);
      let timeIntersectionRatio = 0;
      if (eventDuration > 0) {
        timeIntersectionRatio =
            rangeOfInterest.findExplicitIntersectionDuration(
                eventStart, eventEnd) / eventDuration;
      }

      const v8Runtime = event.args['runtime-call-stat'];
      if (v8Runtime !== undefined) {
        const v8RuntimeObject = JSON.parse(v8Runtime);
        for (const runtimeCall in v8RuntimeObject) {
          // When the V8 Runtime Object contains 2 values, the 2nd value
          // always represents the V8 Runtime duration.
          if (v8RuntimeObject[runtimeCall].length === 2) {
            if (breakdownTree.v8_runtime.events[runtimeCall] === undefined) {
              breakdownTree.v8_runtime.events[runtimeCall] = 0;
            }
            const runtimeTime = tr.b.Unit.timestampFromUs(
                v8RuntimeObject[runtimeCall][1] * timeIntersectionRatio);
            breakdownTree.v8_runtime.total += runtimeTime;
            breakdownTree.v8_runtime.events[runtimeCall] += runtimeTime;
          }
        }
      }
      //        [     Slice 1       ]   [      Slice  2   ]   [    Slice 3   ]
      //            [  Slice 4    ]                             [ Slice 5 ]
      //              [ Slice 6 ]                                  |
      //                 |                                         |
      //                 |                                         |
      //                 v                                         v
      //                start                                     end
      //
      // For the case where the |start| or |end| overlapped with some existing
      // slice (see above diagram), we approximate the overlapped self-time
      // by multiplying the ratio of overlapped wall time to the self-time.
      // There should be way to compute the exact number, but in practice,
      // this should rarely happen, and when it does, the overlapped range
      // is relative small so that using approximation here should be good
      // enough.
      const approximatedSelfTimeContribution =
          eventSelfTime * timeIntersectionRatio;
      breakdownTree[title].total += approximatedSelfTimeContribution;
      if (breakdownTree[title].events[event.title] === undefined) {
        breakdownTree[title].events[event.title] = 0;
      }
      breakdownTree[title].events[event.title] +=
          approximatedSelfTimeContribution;
    }
    return breakdownTree;
  }

  /**
   * Adds 'blocked_on_network' and 'idle' to the |breakdownTree| that has been
   * generated by |generateTimeBreakdownTree|. Taking into account the
   * |networkEvents|, this function is able to distinguish between these two
   * types of cpu idle time during the range |rangeOfInterest| not used by
   * events of the main thread |mainThreadEvents|.
   *
   * @param {!Object.<string, Object>} breakdownTree The breakdownTree that has
   * been generated by |generateTimeBreakdownTree|.
   * @param {!tr.b.Event} mainThreadEvents The top level events of the main
   * thread.
   * @param {!tr.b.Event} networkEvents The network events in the renderer.
   * @param {!tr.b.math.Range} rangeOfInterest The range for which
   * |breakdownTree| is calculated.
   */
  function addIdleAndBlockByNetworkBreakdown_(breakdownTree, mainThreadEvents,
      networkEvents, rangeOfInterest) {
    let idleRanges = [rangeOfInterest];
    const mainThreadEventRanges = tr.b.math.convertEventsToRanges(
        mainThreadEvents);
    const networkEventRanges = tr.b.math.convertEventsToRanges(
        networkEvents);
    const eventRanges = mainThreadEventRanges.concat(networkEventRanges);
    eventRanges.sort((a, b) => a.min - b.min);
    for (const eventRange of eventRanges) {
      if (!eventRange || eventRange.isEmpty ||
          eventRange.duration < 0) {
        throw new Error('Range is invalid');
      }
      // Every eventRange does not intersect with any idleRanges prior to the
      // last freeRange, because:
      //
      // freeRange[last-1].max <= eventRange[i-1].min <= eventRange[i].min
      //             (due to subtraction)      (due to sorting)
      //
      // where 'i' is the current index of eventRange.
      const newLastIdleRanges =
          tr.b.math.Range.findDifference(
              idleRanges[idleRanges.length - 1], eventRange);
      idleRanges.pop();
      idleRanges = idleRanges.concat(newLastIdleRanges);
      if (idleRanges.length === 0) break;
    }
    const totalFreeDuration = tr.b.math.Statistics.sum(idleRanges,
        range => range.duration);
    breakdownTree.idle = {total: totalFreeDuration, events: {}};

    let totalBlockedDuration = rangeOfInterest.duration;
    for (const component of Object.values(breakdownTree)) {
      totalBlockedDuration -= component.total;
    }
    breakdownTree.blocked_on_network = {
      total: totalBlockedDuration,
      events: {}
    };
  }


  /**
  * Generate a breakdown that attributes where wall clock time goes in
  * |rangeOfInterest| on the renderer thread.
  *
  * @param {!tr.model.Thread} mainThread
  * @param {!tr.b.math.Range} rangeOfInterest
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly titles & values are an object that shows the total
  * wall clock time spent in |rangeOfInterest|, and the list of event
  * labels of the group and their total wall clock time in |rangeOfInterest|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateWallClockTimeBreakdownTree(
      mainThread, networkEvents, rangeOfInterest) {
    function getEventStart(e) { return e.start; }
    function getEventDuration(e) { return e.duration; }
    function getEventSelfTime(e) { return e.selfTime; }
    const breakdownTree = generateTimeBreakdownTree(
        mainThread, rangeOfInterest, getEventStart, getEventDuration,
        getEventSelfTime);
    const mainThreadEventsInRange = tr.model.helpers.getSlicesIntersectingRange(
        rangeOfInterest, mainThread.sliceGroup.topLevelSlices);
    addIdleAndBlockByNetworkBreakdown_(
        breakdownTree, mainThreadEventsInRange, networkEvents, rangeOfInterest);
    return breakdownTree;
  }

  /**
  * Generate a breakdown that attributes where CPU time goes in
  * |rangeOfInterestCpuTime| on the renderer thread.
  *
  * @param {!tr.model.Thread} mainThread
  * @param {!tr.b.math.Range} rangeOfInterestCpuTime
  * @return {Object.<string, Object>} A time breakdown object whose keys are
  * Chrome userfriendly titles & values are an object that shows the total
  * CPU time spent in |rangeOfInterestCpuTime|, and the list of event labels
  * of the group and their total durations in |rangeOfInterestCpuTime|.
  *
  * Example:
  *   {
  *     layout: {
  *         total: 100,
  *         events: {'FrameView::performPreLayoutTasks': 20,..}},
  *     v8_runtime: {
  *         total: 500,
  *         events: {'String::NewExternalTwoByte': 0.5,..}},
  *     ...
  *   }
  */
  function generateCpuTimeBreakdownTree(mainThread, rangeOfInterestCpuTime) {
    function getEventStart(e) { return e.cpuStart; }
    function getEventDuration(e) { return e.cpuDuration; }
    function getEventSelfTime(e) { return e.cpuSelfTime; }
    return generateTimeBreakdownTree(mainThread, rangeOfInterestCpuTime,
        getEventStart, getEventDuration, getEventSelfTime);
  }

  return {
    generateTimeBreakdownTree,
    generateWallClockTimeBreakdownTree,
    generateCpuTimeBreakdownTree,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const RESPONSIVENESS_THRESHOLD_MS = 50;
  const INTERACTIVE_WINDOW_SIZE_MS = 5 * 1000;
  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const RelatedEventSet = tr.v.d.RelatedEventSet;

  /**
   * @param  {!tr.model.Process} process
   * @param  {!tr.b.math.Range} range
   * @return {Array.<tr.model.Event>} An array of network events of a process
   * and that are intersecting a range.
   */
  function getNetworkEventsInRange(process, range) {
    const networkEvents = [];
    for (const thread of Object.values(process.threads)) {
      const threadHelper = new tr.model.helpers.ChromeThreadHelper(thread);
      const events = threadHelper.getNetworkEvents();
      for (const event of events) {
        if (range.intersectsExplicitRangeInclusive(event.start, event.end)) {
          networkEvents.push(event);
        }
      }
    }
    return networkEvents;
  }

  // TODO(ksakamoto): This should be a method of tr.model.Event or one of its
  // subclasses.
  function hasCategoryAndName(event, category, title) {
    return event.title === title && event.category &&
        tr.b.getCategoryParts(event.category).includes(category);
  }

  /**
   * @param {!Object.<string, Object>} breakdownTree
   * @return {tr.v.d.Breakdown} A breakdown with categories and the total time
   * (ms) spent under each category.
   */
  function createBreakdownDiagnostic(breakdownTree) {
    const breakdownDiagnostic = new tr.v.d.Breakdown();
    breakdownDiagnostic.colorScheme =
        tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;

    for (const label in breakdownTree) {
      breakdownDiagnostic.set(label, breakdownTree[label].total);
    }
    return breakdownDiagnostic;
  }

  /**
   * A utility class for finding navigationStart event for given frame and
   * timestamp.
   * @constructor
   */
  function NavigationStartFinder(rendererHelper) {
    this.navigationStartsForFrameId_ = {};
    for (const ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', 'navigationStart')) {
        continue;
      }
      const frameIdRef = ev.args.frame;
      let list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) {
        this.navigationStartsForFrameId_[frameIdRef] = list = [];
      }
      list.unshift(ev);
    }
  }

  NavigationStartFinder.prototype = {
    findNavigationStartEventForFrameBeforeTimestamp(frameIdRef, ts) {
      const list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) return undefined;
      let eventBeforeTimestamp;
      for (const ev of list) {
        if (ev.start > ts) continue;
        if (eventBeforeTimestamp === undefined) {
          eventBeforeTimestamp = ev;
        }
      }
      if (eventBeforeTimestamp === undefined) return undefined;
      return eventBeforeTimestamp;
    }
  };

  const FIRST_PAINT_BOUNDARIES = tr.v.HistogramBinBoundaries
    .createLinear(0, 1e3, 20)  // 50ms step to 1s
    .addLinearBins(3e3, 20) // 100ms step to 3s
    .addExponentialBins(20e3, 20);

  const SUMMARY_OPTIONS = {
    avg: true,
    count: false,
    max: true,
    min: true,
    std: true,
    sum: false,
  };

  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    const objects = rendererHelper.process.objects;
    const frameLoaderInstances = objects.instancesByTypeName_.FrameLoader;
    if (frameLoaderInstances === undefined) return undefined;

    let snapshot;
    for (const instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      const maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args.frame.id_ref) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllEvents(rendererHelper, category, title) {
    const targetEvents = [];

    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, category, title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function findFirstMeaningfulPaintCandidates(rendererHelper) {
    const candidatesForFrameId = {};
    for (const ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'loading', 'firstMeaningfulPaintCandidate')) {
        continue;
      }
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      if (frameIdRef === undefined) continue;
      let list = candidatesForFrameId[frameIdRef];
      if (list === undefined) {
        candidatesForFrameId[frameIdRef] = list = [];
      }
      list.push(ev);
    }
    return candidatesForFrameId;
  }

  const URL_BLACKLIST = [
    'about:blank',
    // Chrome on Android creates main frames with the below URL for plugins.
    'data:text/html,pluginplaceholderdata',
    // Special URL used to start a navigation to an unreachable error page.
    'data:text/html,chromewebdata'
  ];
  function shouldIgnoreURL(url) {
    return URL_BLACKLIST.includes(url);
  }

  function collectTimeToEvent(
      category, eventName, rendererHelper, navigationStartFinder) {
    const targetEvents = findAllEvents(rendererHelper, category, eventName);
    const samples = [];
    for (const ev of targetEvents) {
      if (rendererHelper.isTelemetryInternalEvent(ev)) continue;
      const frameIdRef = ev.args.frame;
      const snapshot =
        findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ev.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
      const url = snapshot.args.documentLoaderURL;
      if (shouldIgnoreURL(url)) continue;
      const navigationStartEvent = navigationStartFinder.
        findNavigationStartEventForFrameBeforeTimestamp(
          frameIdRef, ev.start);
      // Ignore layout w/o preceding navigationStart, as they are not
      // attributed to any time-to-X metric.
      if (navigationStartEvent === undefined) continue;

      const timeToEvent = ev.start - navigationStartEvent.start;
      samples.push({
        value: timeToEvent,
        diagnostics: {url: new tr.v.d.GenericSet([url])}
      });
    }
    return samples;
  }

  function addFirstMeaningfulPaintSample(samples, rendererHelper,
      frameIdRef, navigationStart, fmpMarkerEvent) {
    const snapshot = findFrameLoaderSnapshotAt(
        rendererHelper, frameIdRef, fmpMarkerEvent.start);
    if (!snapshot || !snapshot.args.isLoadingMainFrame) return;
    const url = snapshot.args.documentLoaderURL;
    if (shouldIgnoreURL(url)) return;

    const navStartToFMPRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.start, fmpMarkerEvent.start);
    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, navStartToFMPRange);
    const timeToFirstMeaningfulPaint = navStartToFMPRange.duration;
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents, navStartToFMPRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: timeToFirstMeaningfulPaint,
      diagnostics: {
        'Breakdown of [navStart, FMP]': breakdownDiagnostic,
        'Start': new RelatedEventSet(navigationStart),
        'End': new RelatedEventSet(fmpMarkerEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
    return {firstMeaningfulPaint: fmpMarkerEvent.start, url};
  }

  function addFirstMeaningfulPaintCpuTimeSample(samples, rendererHelper,
      frameIdRef, navigationStart, fmpMarkerEvent) {
    const navStartToFMPCpuRange = tr.b.math.Range.fromExplicitRange(
        navigationStart.cpuStart, fmpMarkerEvent.cpuStart);
    const snapshot = findFrameLoaderSnapshotAt(
        rendererHelper, frameIdRef, fmpMarkerEvent.start);
    if (!snapshot || !snapshot.args.isLoadingMainFrame) return;
    const url = snapshot.args.documentLoaderURL;
    if (shouldIgnoreURL(url)) return;

    const mainThreadCpuTime = getMainThreadCpuTime(
        rendererHelper, navStartToFMPCpuRange);

    const breakdownTree = tr.metrics.sh.generateCpuTimeBreakdownTree(
        rendererHelper.mainThread, navStartToFMPCpuRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);
    samples.push({
      value: mainThreadCpuTime,
      diagnostics: {
        'Breakdown of [navStart, FMP]': breakdownDiagnostic,
        'Start': new RelatedEventSet(navigationStart),
        'End': new RelatedEventSet(fmpMarkerEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStart.start,
          fmp: fmpMarkerEvent.start,
        }]),
      }
    });
  }

  function getMainThreadCpuTime(rendererHelper, rangeOfInterest) {
    let mainThreadCpuTime = 0;
    for (const slice of rendererHelper.mainThread.sliceGroup.topLevelSlices) {
      if (!slice.cpuDuration) continue;
      const sliceRange = tr.b.math.Range.fromExplicitRange(slice.cpuStart,
          slice.cpuStart + slice.cpuDuration);
      const intersection = rangeOfInterest.findIntersection(sliceRange);
      mainThreadCpuTime += intersection.duration;
    }

    return mainThreadCpuTime;
  }

  function addFirstInteractiveSample(samples, rendererHelper,
      navigationStart, firstMeaningfulPaint, url) {
    if (shouldIgnoreURL(url)) return;
    const navigationStartTime = navigationStart.start;
    let firstInteractive = Infinity;
    let firstInteractiveCandidate = firstMeaningfulPaint;
    let lastLongTaskEvent = undefined;
    // Find the first interactive point X after firstMeaningfulPaint so that
    // range [X, X + INTERACTIVE_WINDOW_SIZE_MS] contains no
    // 'TaskQueueManager::ProcessTaskFromWorkQueues' slice which takes more than
    // RESPONSIVENESS_THRESHOLD_MS.
    // For more details on why TaskQueueManager::ProcessTaskFromWorkQueue is
    // chosen as a proxy for all un-interruptable task on renderer thread, see
    // https://github.com/GoogleChrome/lighthouse/issues/489
    // TODO(nedn): replace this with just "const ev of rendererHelper..." once
    // canary binary is updated.
    // (https://github.com/catapult-project/catapult/issues/2586)
    for (const ev of [...rendererHelper.mainThread.sliceGroup.childEvents()]) {
      if (ev.start < firstInteractiveCandidate) continue;
      const interactiveDurationSoFar = ev.start - firstInteractiveCandidate;
      if (interactiveDurationSoFar >= INTERACTIVE_WINDOW_SIZE_MS) {
        firstInteractive = firstInteractiveCandidate;
        break;
      }
      if (ev.title === 'TaskQueueManager::ProcessTaskFromWorkQueue' &&
          ev.duration > RESPONSIVENESS_THRESHOLD_MS) {
        firstInteractiveCandidate = ev.end - 50;
        lastLongTaskEvent = ev;
      }
    }
    const navStartToFirstInteractiveRange = tr.b.math.Range.fromExplicitRange(
        navigationStartTime, firstInteractive);

    const networkEvents = getNetworkEventsInRange(
        rendererHelper.process, navStartToFirstInteractiveRange);
    const breakdownTree = tr.metrics.sh.generateWallClockTimeBreakdownTree(
        rendererHelper.mainThread, networkEvents,
        navStartToFirstInteractiveRange);
    const breakdownDiagnostic = createBreakdownDiagnostic(breakdownTree);

    const timeToFirstInteractive = navStartToFirstInteractiveRange.duration;
    samples.push({
      value: timeToFirstInteractive,
      diagnostics: {
        'Start': new RelatedEventSet(navigationStart),
        'Last long task': new RelatedEventSet(lastLongTaskEvent),
        'Navigation infos': new tr.v.d.GenericSet([{
          url,
          pid: rendererHelper.pid,
          start: navigationStartTime,
          interactive: firstInteractive,
        }]),
        'Breakdown of [navStart, Interactive]': breakdownDiagnostic,
      }
    });
  }

  /**
   * Computes Time to first meaningful paint (TTFMP) & time to interactive (TTI)
   * for a renderer represented by |rendererHelper| and returns them as
   * histogram samples.
   *
   * First meaningful paint is the paint following the layout with the highest
   * "Layout Significance". The Layout Significance is computed inside Blink,
   * by FirstMeaningfulPaintDetector class. It logs
   * "firstMeaningfulPaintCandidate" event every time the Layout Significance
   * marks a record. TTFMP is the time between NavigationStart and the last
   * firstMeaningfulPaintCandidate event.
   *
   * Design doc: https://goo.gl/vpaxv6
   *
   * TTI is computed as the starting time of the timed window with size
   * INTERACTIVE_WINDOW_SIZE_MS that happens after FMP in which there is no
   * uninterruptable task on the main thread with size more than
   * RESPONSIVENESS_THRESHOLD_MS.
   *
   * Design doc: https://goo.gl/ISWndc
   */
  function collectFirstMeaningfulPaintAndTimeToInteractiveForRenderer(
      rendererHelper, navigationStartFinder) {
    const firstMeaningfulPaintSamples = [];
    const firstMeaningfulPaintCpuTimeSamples = [];
    const firstInteractiveSamples = [];

    function addSamples(frameIdRef, navigationStart, fmpMarkerEvent) {
      const data = addFirstMeaningfulPaintSample(
          firstMeaningfulPaintSamples, rendererHelper,
          frameIdRef, navigationStart, fmpMarkerEvent);
      addFirstMeaningfulPaintCpuTimeSample(
          firstMeaningfulPaintCpuTimeSamples, rendererHelper,
          frameIdRef, navigationStart, fmpMarkerEvent);
      if (data !== undefined) {
        addFirstInteractiveSample(
            firstInteractiveSamples, rendererHelper,
            navigationStart, data.firstMeaningfulPaint, data.url);
      }
    }

    const candidatesForFrameId =
        findFirstMeaningfulPaintCandidates(rendererHelper);

    for (const frameIdRef in candidatesForFrameId) {
      let navigationStart = undefined;
      let lastCandidate = undefined;

      // Iterate over the FMP candidates, remembering the last one.
      for (const ev of candidatesForFrameId[frameIdRef]) {
        const navigationStartForThisCandidate = navigationStartFinder.
          findNavigationStartEventForFrameBeforeTimestamp(
            frameIdRef, ev.start);
        // Ignore candidate w/o preceding navigationStart, as they are not
        // attributed to any TTFMP.
        if (navigationStartForThisCandidate === undefined) continue;

        if (navigationStart !== navigationStartForThisCandidate) {
          // New navigation is found. Compute TTFMP for current navigation,
          // and reset the state variables.
          if (navigationStart !== undefined && lastCandidate !== undefined) {
            addSamples(frameIdRef, navigationStart, lastCandidate);
          }
          navigationStart = navigationStartForThisCandidate;
        }
        lastCandidate = ev;
      }

      // Compute TTFMP for the last navigation.
      if (lastCandidate !== undefined) {
        addSamples(frameIdRef, navigationStart, lastCandidate);
      }
    }
    return {
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstInteractiveSamples
    };
  }

  function collectLoadingMetricsForRenderer(rendererHelper) {
    const navigationStartFinder = new NavigationStartFinder(rendererHelper);
    const firstPaintSamples = collectTimeToEvent(
        'loading', 'firstPaint',
        rendererHelper, navigationStartFinder);
    const firstContentfulPaintSamples = collectTimeToEvent(
        'loading', 'firstContentfulPaint',
        rendererHelper, navigationStartFinder);
    const onLoadSamples = collectTimeToEvent(
        'blink.user_timing', 'loadEventStart',
        rendererHelper, navigationStartFinder);
    const {firstMeaningfulPaintSamples, firstMeaningfulPaintCpuTimeSamples,
        firstInteractiveSamples} =
        collectFirstMeaningfulPaintAndTimeToInteractiveForRenderer(
            rendererHelper, navigationStartFinder);
    return {
      firstPaintSamples,
      firstContentfulPaintSamples,
      onLoadSamples,
      firstMeaningfulPaintSamples,
      firstMeaningfulPaintCpuTimeSamples,
      firstInteractiveSamples
    };
  }

  function addSamplesToHistogram(samples, histogram) {
    for (const sample of samples) {
      histogram.addSample(sample.value, sample.diagnostics);
    }
  }

  function loadingMetric(histograms, model) {
    const firstPaintHistogram = histograms.createHistogram(
        'timeToFirstPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'time to first paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstContentfulPaintHistogram = histograms.createHistogram(
        'timeToFirstContentfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'time to first contentful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const onLoadHistogram = histograms.createHistogram(
        'timeToOnload', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'time to onload. ' +
            'This is temporary metric used for PCv1/v2 sanity checking',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstMeaningfulPaintHistogram = histograms.createHistogram(
        'timeToFirstMeaningfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'time to first meaningful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstMeaningfulPaintCpuTimeHistogram = histograms.createHistogram(
        'cpuTimeToFirstMeaningfulPaint', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'CPU time to first meaningful paint',
          summaryOptions: SUMMARY_OPTIONS,
        });
    const firstInteractiveHistogram = histograms.createHistogram(
        'timeToFirstInteractive', timeDurationInMs_smallerIsBetter, [], {
          binBoundaries: FIRST_PAINT_BOUNDARIES,
          description: 'time to first interactive',
          summaryOptions: SUMMARY_OPTIONS,
        });

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const pid in chromeHelper.rendererHelpers) {
      const rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;

      const samplesSet =
          collectLoadingMetricsForRenderer(rendererHelper);

      addSamplesToHistogram(samplesSet.firstPaintSamples,
          firstPaintHistogram);
      addSamplesToHistogram(samplesSet.firstContentfulPaintSamples,
          firstContentfulPaintHistogram);
      addSamplesToHistogram(samplesSet.onLoadSamples, onLoadHistogram);
      addSamplesToHistogram(samplesSet.firstMeaningfulPaintSamples,
          firstMeaningfulPaintHistogram);
      addSamplesToHistogram(samplesSet.firstMeaningfulPaintCpuTimeSamples,
          firstMeaningfulPaintCpuTimeHistogram);
      addSamplesToHistogram(samplesSet.firstInteractiveSamples,
          firstInteractiveHistogram);
    }
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric,
    getNetworkEventsInRange,
    collectLoadingMetricsForRenderer,
    RESPONSIVENESS_THRESHOLD_MS,
    INTERACTIVE_WINDOW_SIZE_MS,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  const SPA_NAVIGATION_START_TO_FIRST_PAINT_DURATION_BIN_BOUNDARY =
      tr.v.HistogramBinBoundaries.createExponential(1, 1000, 50);

  /**
   * This metric measures the duration between the input event
   * causing a SPA navigation and the first paint event after it.
   */
  function spaNavigationMetric(histograms, model) {
    const histogram = new tr.v.Histogram(
        'spaNavigationStartToFpDuration',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        SPA_NAVIGATION_START_TO_FIRST_PAINT_DURATION_BIN_BOUNDARY);
    histogram.description = 'Latency between the input event causing' +
        ' a SPA navigation and the first paint event after it';
    histogram.customizeSummaryOptions({
      count: false,
      sum: false,
    });

    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (!modelHelper) {
      // Chrome isn't present.
      return;
    }
    const rendererHelpers = modelHelper.rendererHelpers;
    if (!rendererHelpers) {
      // We couldn't find any renderer processes.
      return;
    }
    const browserHelper = modelHelper.browserHelper;
    for (const rendererHelper of Object.values(rendererHelpers)) {
      const spaNavigations = tr.metrics.findSpaNavigationsOnRenderer(
          rendererHelper, browserHelper);
      for (const spaNav of spaNavigations) {
        let beginTs = 0;
        if (spaNav.navStartCandidates.inputLatencyAsyncSlice) {
          const beginData =
              spaNav.navStartCandidates.inputLatencyAsyncSlice.args.data;
          // TODO(sunjian): rename convertTimestampToModelTime to something like
          // convertTraceEventTsToModelTs and get rid of the first parameter.
          beginTs = model.convertTimestampToModelTime(
              'traceEventClock',
              beginData.INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT.time);
        } else {
          beginTs = spaNav.navStartCandidates.goToIndexSlice.start;
        }
        const rangeOfInterest = tr.b.math.Range.fromExplicitRange(
            beginTs, spaNav.firstPaintEvent.start);
        const networkEvents = tr.metrics.sh.getNetworkEventsInRange(
            rendererHelper.process, rangeOfInterest);
        const breakdownDict = tr.metrics.sh.generateWallClockTimeBreakdownTree(
            rendererHelper.mainThread, networkEvents, rangeOfInterest);
        const breakdownDiagnostic = new tr.v.d.Breakdown();
        breakdownDiagnostic.colorScheme =
            tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;
        for (const label in breakdownDict) {
          breakdownDiagnostic.set(label,
              parseInt(breakdownDict[label].total * 1e3) / 1e3);
        }
        histogram.addSample(
            rangeOfInterest.duration,
            {
              'Breakdown of [navStart, firstPaint]': breakdownDiagnostic,
              'Start': new tr.v.d.RelatedEventSet(spaNav.navigationStart),
              'End': new tr.v.d.RelatedEventSet(spaNav.firstPaintEvent),
              'Navigation infos': new tr.v.d.GenericSet([{
                url: spaNav.url,
                pid: rendererHelper.pid,
                navStart: beginTs,
                firstPaint: spaNav.firstPaintEvent.start
              }]),
            });
      }
    }
    histograms.addHistogram(histogram);
  }

  tr.metrics.MetricRegistry.register(spaNavigationMetric);

  return {
    spaNavigationMetric,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  function max(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    return Math.max(a, b);
  }

  /**
   * This class implements an interval tree.
   *    See: http://wikipedia.org/wiki/Interval_tree
   *
   * Internally the tree is a Red-Black tree. The insertion/colour is done using
   * the Left-leaning Red-Black Trees algorithm as described in:
   *       http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
   *
   * @param {function} beginPositionCb Callback to retrieve the begin position.
   * @param {function} endPositionCb Callback to retrieve the end position.
   *
   * @constructor
   */
  function IntervalTree(beginPositionCb, endPositionCb) {
    this.beginPositionCb_ = beginPositionCb;
    this.endPositionCb_ = endPositionCb;

    this.root_ = undefined;
    this.size_ = 0;
  }

  IntervalTree.prototype = {
    /**
     * Insert events into the interval tree.
     *
     * @param {Object} datum The object to insert.
     */
    insert(datum) {
      const startPosition = this.beginPositionCb_(datum);
      const endPosition = this.endPositionCb_(datum);

      const node = new IntervalTreeNode(datum,
                                      startPosition, endPosition);
      this.size_++;

      this.root_ = this.insertNode_(this.root_, node);
      this.root_.colour = Colour.BLACK;
      return datum;
    },

    insertNode_(root, node) {
      if (root === undefined) return node;

      if (root.leftNode && root.leftNode.isRed &&
          root.rightNode && root.rightNode.isRed) {
        this.flipNodeColour_(root);
      }

      if (node.key < root.key) {
        root.leftNode = this.insertNode_(root.leftNode, node);
      } else if (node.key === root.key) {
        root.merge(node);
      } else {
        root.rightNode = this.insertNode_(root.rightNode, node);
      }

      if (root.rightNode && root.rightNode.isRed &&
          (root.leftNode === undefined || !root.leftNode.isRed)) {
        root = this.rotateLeft_(root);
      }

      if (root.leftNode && root.leftNode.isRed &&
          root.leftNode.leftNode && root.leftNode.leftNode.isRed) {
        root = this.rotateRight_(root);
      }

      return root;
    },

    rotateRight_(node) {
      const sibling = node.leftNode;
      node.leftNode = sibling.rightNode;
      sibling.rightNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    rotateLeft_(node) {
      const sibling = node.rightNode;
      node.rightNode = sibling.leftNode;
      sibling.leftNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    flipNodeColour_(node) {
      node.colour = this.flipColour_(node.colour);
      node.leftNode.colour = this.flipColour_(node.leftNode.colour);
      node.rightNode.colour = this.flipColour_(node.rightNode.colour);
    },

    flipColour_(colour) {
      return colour === Colour.RED ? Colour.BLACK : Colour.RED;
    },

    /* The high values are used to find intersection. It should be called after
     * all of the nodes are inserted. Doing it each insert is _slow_. */
    updateHighValues() {
      this.updateHighValues_(this.root_);
    },

    /* There is probably a smarter way to do this by starting from the inserted
     * node, but need to handle the rotations correctly. Went the easy route
     * for now. */
    updateHighValues_(node) {
      if (node === undefined) return undefined;

      node.maxHighLeft = this.updateHighValues_(node.leftNode);
      node.maxHighRight = this.updateHighValues_(node.rightNode);

      return max(max(node.maxHighLeft, node.highValue), node.maxHighRight);
    },

    validateFindArguments_(queryLow, queryHigh) {
      if (queryLow === undefined || queryHigh === undefined) {
        throw new Error('queryLow and queryHigh must be defined');
      }
      if ((typeof queryLow !== 'number') || (typeof queryHigh !== 'number')) {
        throw new Error('queryLow and queryHigh must be numbers');
      }
    },

    /**
     * Retrieve all overlapping intervals.
     *
     * @param {number} queryLow The low value for the intersection interval.
     * @param {number} queryHigh The high value for the intersection interval.
     * @return {Array} All [begin, end] pairs inside intersecting intervals.
     */
    findIntersection(queryLow, queryHigh) {
      this.validateFindArguments_(queryLow, queryHigh);
      if (this.root_ === undefined) return [];

      const ret = [];
      this.root_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      return ret;
    },

    /**
     * Returns the number of nodes in the tree.
     */
    get size() {
      return this.size_;
    },

    /**
     * Returns the root node in the tree.
     */
    get root() {
      return this.root_;
    },

    /**
     * Dumps out the [lowValue, highValue] pairs for each node in depth-first
     * order.
     */
    dump_() {
      if (this.root_ === undefined) return [];
      return this.root_.dump();
    }
  };

  const Colour = {
    RED: 'red',
    BLACK: 'black'
  };

  function IntervalTreeNode(datum, lowValue, highValue) {
    this.lowValue_ = lowValue;

    this.data_ = [{
      datum,
      high: highValue,
      low: lowValue
    }];

    this.colour_ = Colour.RED;

    this.parentNode_ = undefined;
    this.leftNode_ = undefined;
    this.rightNode_ = undefined;

    this.maxHighLeft_ = undefined;
    this.maxHighRight_ = undefined;
  }

  IntervalTreeNode.prototype = {
    appendIntersectionsInto_(ret, queryLow, queryHigh) {
      /* This node starts has a start point at or further right then queryHigh
       * so we know this node is out and all right children are out. Just need
       * to check left */
      if (this.lowValue_ >= queryHigh) {
        if (!this.leftNode_) return;
        return this.leftNode_.appendIntersectionsInto_(
            ret, queryLow, queryHigh);
      }

      /* If we have a maximum left high value that is bigger then queryLow we
       * need to check left for matches */
      if (this.maxHighLeft_ > queryLow) {
        this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }

      /* We know that this node starts before queryHigh, if any of it's data
       * ends after queryLow we need to add those nodes */
      if (this.highValue > queryLow) {
        for (let i = (this.data.length - 1); i >= 0; --i) {
          /* data nodes are sorted by high value, so as soon as we see one
           * before low value we're done. */
          if (this.data[i].high < queryLow) break;

          ret.push(this.data[i].datum);
        }
      }

      /* check for matches in the right tree */
      if (this.rightNode_) {
        this.rightNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }
    },

    get colour() {
      return this.colour_;
    },

    set colour(colour) {
      this.colour_ = colour;
    },

    get key() {
      return this.lowValue_;
    },

    get lowValue() {
      return this.lowValue_;
    },

    get highValue() {
      return this.data_[this.data_.length - 1].high;
    },

    set leftNode(left) {
      this.leftNode_ = left;
    },

    get leftNode() {
      return this.leftNode_;
    },

    get hasLeftNode() {
      return this.leftNode_ !== undefined;
    },

    set rightNode(right) {
      this.rightNode_ = right;
    },

    get rightNode() {
      return this.rightNode_;
    },

    get hasRightNode() {
      return this.rightNode_ !== undefined;
    },

    set parentNode(parent) {
      this.parentNode_ = parent;
    },

    get parentNode() {
      return this.parentNode_;
    },

    get isRootNode() {
      return this.parentNode_ === undefined;
    },

    set maxHighLeft(high) {
      this.maxHighLeft_ = high;
    },

    get maxHighLeft() {
      return this.maxHighLeft_;
    },

    set maxHighRight(high) {
      this.maxHighRight_ = high;
    },

    get maxHighRight() {
      return this.maxHighRight_;
    },

    get data() {
      return this.data_;
    },

    get isRed() {
      return this.colour_ === Colour.RED;
    },

    merge(node) {
      for (let i = 0; i < node.data.length; i++) {
        this.data_.push(node.data[i]);
      }
      this.data_.sort(function(a, b) {
        return a.high - b.high;
      });
    },

    dump() {
      const ret = {};
      if (this.leftNode_) {
        ret.left = this.leftNode_.dump();
      }

      ret.data = this.data_.map(function(d) { return [d.low, d.high]; });

      if (this.rightNode_) {
        ret.right = this.rightNode_.dump();
      }

      return ret;
    }
  };

  return {
    IntervalTree,
  };
});


'use strict';

tr.exportTo('tr.b.math', function() {
  const tmpVec2s = [];
  for (let i = 0; i < 8; i++) {
    tmpVec2s[i] = vec2.create();
  }

  const tmpVec2a = vec4.create();
  const tmpVec4a = vec4.create();
  const tmpVec4b = vec4.create();
  const tmpMat4 = mat4.create();
  const tmpMat4b = mat4.create();

  const p00 = vec2.createXY(0, 0);
  const p10 = vec2.createXY(1, 0);
  const p01 = vec2.createXY(0, 1);
  const p11 = vec2.createXY(1, 1);

  const lerpingVecA = vec2.create();
  const lerpingVecB = vec2.create();
  function lerpVec2(out, a, b, amt) {
    vec2.scale(lerpingVecA, a, amt);
    vec2.scale(lerpingVecB, b, 1 - amt);
    vec2.add(out, lerpingVecA, lerpingVecB);
    vec2.normalize(out, out);
    return out;
  }

  /**
   * @constructor
   */
  function Quad() {
    this.p1 = vec2.create();
    this.p2 = vec2.create();
    this.p3 = vec2.create();
    this.p4 = vec2.create();
  }

  Quad.fromXYWH = function(x, y, w, h) {
    const q = new Quad();
    vec2.set(q.p1, x, y);
    vec2.set(q.p2, x + w, y);
    vec2.set(q.p3, x + w, y + h);
    vec2.set(q.p4, x, y + h);
    return q;
  };

  Quad.fromRect = function(r) {
    return new Quad.fromXYWH(
        r.x, r.y,
        r.width, r.height);
  };

  Quad.from4Vecs = function(p1, p2, p3, p4) {
    const q = new Quad();
    vec2.set(q.p1, p1[0], p1[1]);
    vec2.set(q.p2, p2[0], p2[1]);
    vec2.set(q.p3, p3[0], p3[1]);
    vec2.set(q.p4, p4[0], p4[1]);
    return q;
  };

  Quad.from8Array = function(arr) {
    if (arr.length !== 8) {
      throw new Error('Array must be 8 long');
    }
    const q = new Quad();
    q.p1[0] = arr[0];
    q.p1[1] = arr[1];
    q.p2[0] = arr[2];
    q.p2[1] = arr[3];
    q.p3[0] = arr[4];
    q.p3[1] = arr[5];
    q.p4[0] = arr[6];
    q.p4[1] = arr[7];
    return q;
  };

  Quad.prototype = {
    pointInside(point) {
      return pointInImplicitQuad(point,
          this.p1, this.p2, this.p3, this.p4);
    },

    boundingRect() {
      const x0 = Math.min(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      const y0 = Math.min(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      const x1 = Math.max(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      const y1 = Math.max(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      return new tr.b.math.Rect.fromXYWH(x0, y0, x1 - x0, y1 - y0);
    },

    clone() {
      const q = new Quad();
      vec2.copy(q.p1, this.p1);
      vec2.copy(q.p2, this.p2);
      vec2.copy(q.p3, this.p3);
      vec2.copy(q.p4, this.p4);
      return q;
    },

    scale(s) {
      const q = new Quad();
      this.scaleFast(q, s);
      return q;
    },

    scaleFast(dstQuad, s) {
      vec2.copy(dstQuad.p1, this.p1, s);
      vec2.copy(dstQuad.p2, this.p2, s);
      vec2.copy(dstQuad.p3, this.p3, s);
      vec2.copy(dstQuad.p3, this.p3, s);
    },

    isRectangle() {
      // Simple rectangle check. Note: will not handle out-of-order components.
      const bounds = this.boundingRect();
      return (
          bounds.x === this.p1[0] &&
          bounds.y === this.p1[1] &&
          bounds.width === this.p2[0] - this.p1[0] &&
          bounds.y === this.p2[1] &&
          bounds.width === this.p3[0] - this.p1[0] &&
          bounds.height === this.p3[1] - this.p2[1] &&
          bounds.x === this.p4[0] &&
          bounds.height === this.p4[1] - this.p2[1]
      );
    },

    projectUnitRect(rect) {
      const q = new Quad();
      this.projectUnitRectFast(q, rect);
      return q;
    },

    projectUnitRectFast(dstQuad, rect) {
      const v12 = tmpVec2s[0];
      const v14 = tmpVec2s[1];
      const v23 = tmpVec2s[2];
      const v43 = tmpVec2s[3];

      vec2.sub(v12, this.p2, this.p1);
      const l12 = vec2.length(v12);
      vec2.scale(v12, v12, 1 / l12);

      vec2.sub(v14, this.p4, this.p1);
      const l14 = vec2.length(v14);
      vec2.scale(v14, v14, 1 / l14);

      vec2.sub(v23, this.p3, this.p2);
      const l23 = vec2.length(v23);
      vec2.scale(v23, v23, 1 / l23);

      vec2.sub(v43, this.p3, this.p4);
      const l43 = vec2.length(v43);
      vec2.scale(v43, v43, 1 / l43);

      const b12 = tmpVec2s[0];
      const b14 = tmpVec2s[1];
      const b23 = tmpVec2s[2];
      const b43 = tmpVec2s[3];
      lerpVec2(b12, v12, v43, rect.y);
      lerpVec2(b43, v12, v43, 1 - rect.bottom);
      lerpVec2(b14, v14, v23, rect.x);
      lerpVec2(b23, v14, v23, 1 - rect.right);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
          b12, l12 * rect.x,
          b14, l14 * rect.y);
      vec2.add(dstQuad.p1, this.p1, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
          b12, l12 * -(1.0 - rect.right),
          b23, l23 * rect.y);
      vec2.add(dstQuad.p2, this.p2, tmpVec2a);


      vec2.addTwoScaledUnitVectors(tmpVec2a,
          b43, l43 * -(1.0 - rect.right),
          b23, l23 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p3, this.p3, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a,
          b43, l43 * rect.left,
          b14, l14 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p4, this.p4, tmpVec2a);
    },

    toString() {
      return 'Quad(' +
          vec2.toString(this.p1) + ', ' +
          vec2.toString(this.p2) + ', ' +
          vec2.toString(this.p3) + ', ' +
          vec2.toString(this.p4) + ')';
    }
  };

  function sign(p1, p2, p3) {
    return (p1[0] - p3[0]) * (p2[1] - p3[1]) -
        (p2[0] - p3[0]) * (p1[1] - p3[1]);
  }

  function pointInTriangle2(pt, p1, p2, p3) {
    const b1 = sign(pt, p1, p2) < 0.0;
    const b2 = sign(pt, p2, p3) < 0.0;
    const b3 = sign(pt, p3, p1) < 0.0;
    return ((b1 === b2) && (b2 === b3));
  }

  function pointInImplicitQuad(point, p1, p2, p3, p4) {
    return pointInTriangle2(point, p1, p2, p3) ||
        pointInTriangle2(point, p1, p3, p4);
  }

  return {
    pointInTriangle2,
    pointInImplicitQuad,
    Quad,
  };
});


'use strict';
/* eslint-disable no-console */

tr.exportTo('tr.b', function() {
  const ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS = 10;
  // The maximum amount of time that we allow for a task to get scheduled
  // in idle time before forcing the task to run.
  const REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS = 100;

  // Setting this to true will cause stack traces to get dumped into the
  // tasks. When an exception happens the original stack will be printed.
  //
  // NOTE: This should never be set committed as true.
  const recordRAFStacks = false;

  let pendingPreAFs = [];
  let pendingRAFs = [];
  const pendingIdleCallbacks = [];
  let currentRAFDispatchList = undefined;

  let rafScheduled = false;
  let idleWorkScheduled = false;

  function scheduleRAF() {
    if (rafScheduled) return;
    rafScheduled = true;
    if (tr.isHeadless) {
      Promise.resolve().then(function() {
        processRequests(false, 0);
      }, function(e) {
        throw e;
      });
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(processRequests.bind(this, false));
      } else {
        const delta = Date.now() - window.performance.now();
        window.webkitRequestAnimationFrame(function(domTimeStamp) {
          processRequests(false, domTimeStamp - delta);
        });
      }
    }
  }

  function nativeRequestIdleCallbackSupported() {
    return !tr.isHeadless && window.requestIdleCallback;
  }

  function scheduleIdleWork() {
    if (idleWorkScheduled) return;
    if (!nativeRequestIdleCallbackSupported()) {
      scheduleRAF();
      return;
    }
    idleWorkScheduled = true;
    window.requestIdleCallback(function(deadline, didTimeout) {
      processIdleWork(false /* forceAllTasksToRun */, deadline);
    }, { timeout: REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS });
  }

  function onAnimationFrameError(e, opt_stack) {
    console.log(e.stack);
    if (tr.isHeadless) throw e;

    if (opt_stack) console.log(opt_stack);

    if (e.message) {
      console.error(e.message, e.stack);
    } else {
      console.error(e);
    }
  }

  function runTask(task, frameBeginTime) {
    try {
      task.callback.call(task.context, frameBeginTime);
    } catch (e) {
      tr.b.onAnimationFrameError(e, task.stack);
    }
  }

  function processRequests(forceAllTasksToRun, frameBeginTime) {
    rafScheduled = false;

    const currentPreAFs = pendingPreAFs;
    currentRAFDispatchList = pendingRAFs;
    pendingPreAFs = [];
    pendingRAFs = [];
    const hasRAFTasks = currentPreAFs.length || currentRAFDispatchList.length;

    for (let i = 0; i < currentPreAFs.length; i++) {
      runTask(currentPreAFs[i], frameBeginTime);
    }

    while (currentRAFDispatchList.length > 0) {
      runTask(currentRAFDispatchList.shift(), frameBeginTime);
    }
    currentRAFDispatchList = undefined;

    if ((!hasRAFTasks && !nativeRequestIdleCallbackSupported()) ||
        forceAllTasksToRun) {
      // We assume that we want to do a fixed maximum amount of optional work
      // per frame. Hopefully rAF will eventually pass this in for us.
      const rafCompletionDeadline =
          frameBeginTime + ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS;
      processIdleWork(
          forceAllTasksToRun, {
            timeRemaining() {
              return rafCompletionDeadline - window.performance.now();
            }
          }
      );
    }

    if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
  }

  function processIdleWork(forceAllTasksToRun, deadline) {
    idleWorkScheduled = false;
    while (pendingIdleCallbacks.length > 0) {
      runTask(pendingIdleCallbacks.shift());
      // Check timer after running at least one idle task to avoid buggy
      // window.performance.now() on some platforms from blocking the idle
      // task queue.
      if (!forceAllTasksToRun &&
          (tr.isHeadless || deadline.timeRemaining() <= 0)) {
        break;
      }
    }

    if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
  }

  function getStack_() {
    if (!recordRAFStacks) return '';

    const stackLines = tr.b.stackTrace();
    // Strip off getStack_.
    stackLines.shift();
    return stackLines.join('\n');
  }

  function requestPreAnimationFrame(callback, opt_this) {
    pendingPreAFs.push({
      callback,
      context: opt_this || global,
      stack: getStack_()});
    scheduleRAF();
  }

  function requestAnimationFrameInThisFrameIfPossible(callback, opt_this) {
    if (!currentRAFDispatchList) {
      requestAnimationFrame(callback, opt_this);
      return;
    }
    currentRAFDispatchList.push({
      callback,
      context: opt_this || global,
      stack: getStack_()});
    return;
  }

  function requestAnimationFrame(callback, opt_this) {
    pendingRAFs.push({
      callback,
      context: opt_this || global,
      stack: getStack_()});
    scheduleRAF();
  }

  function animationFrame() {
    return new Promise(resolve => requestAnimationFrame(resolve));
  }

  function requestIdleCallback(callback, opt_this) {
    pendingIdleCallbacks.push({
      callback,
      context: opt_this || global,
      stack: getStack_()});
    scheduleIdleWork();
  }

  function forcePendingRAFTasksToRun(frameBeginTime) {
    if (!rafScheduled) return;
    processRequests(false, frameBeginTime);
  }

  function forceAllPendingTasksToRunForTest() {
    if (!rafScheduled && !idleWorkScheduled) return;
    processRequests(true, 0);
  }

  function timeout(ms) {
    return new Promise(resolve => window.setTimeout(resolve, ms));
  }

  function idle() {
    return new Promise(resolve => requestIdleCallback(resolve));
  }

  return {
    animationFrame,
    forceAllPendingTasksToRunForTest,
    forcePendingRAFTasksToRun,
    idle,
    onAnimationFrameError,
    requestAnimationFrame,
    requestAnimationFrameInThisFrameIfPossible,
    requestIdleCallback,
    requestPreAnimationFrame,
    timeout,
  };
});


'use strict';
tr.exportTo('tr.b', function() {
  class Mark {
    constructor(groupName, functionName) {
      if (tr.isHeadless) return;

      this.groupName_ = groupName;
      this.functionName_ = functionName;
      const guid = tr.b.GUID.allocateSimple();
      this.measureName_ = `${groupName} ${functionName}`;
      this.startMarkName_ = `${this.measureName} ${guid} start`;
      this.endMarkName_ = `${this.measureName} ${guid} end`;

      window.performance.mark(this.startMarkName_);
    }

    get groupName() {
      return this.groupName_;
    }

    get functionName() {
      return this.functionName_;
    }

    get measureName() {
      return this.measureName_;
    }

    get startMark() {
      return tr.b.getOnlyElement(window.performance.getEntriesByName(
          this.startMarkName_));
    }

    get endMark() {
      return tr.b.getOnlyElement(window.performance.getEntriesByName(
          this.endMarkName_));
    }

    get durationMs() {
      // There may be many measures named `this.measureName`, but the start and
      // end mark names contain a GUID so they are unique.
      return this.endMark.startTime - this.startMark.startTime;
    }

    end() {
      if (tr.isHeadless) return;

      window.performance.mark(this.endMarkName_);
      window.performance.measure(
          this.measureName_, this.startMarkName_, this.endMarkName_);

      if (!(window.ga instanceof Function)) return;
      // Google Analytics
      ga('send', {
        hitType: 'event',
        eventCategory: this.groupName,
        eventAction: this.functionName,
        eventValue: this.durationMs,
      });
    }
  }

  class Timing {
    static mark(groupName, functionName) {
      return new Mark(groupName, functionName);
    }

    static instant(groupName, functionName, opt_value) {
      const valueString = opt_value === undefined ? '' : ' ' + opt_value;

      /* eslint-disable no-console */
      if (console && console.timeStamp) {
        console.timeStamp(`${groupName} ${functionName}${valueString}`);
      }
      /* eslint-enable no-console */

      // Google Analytics
      if (window && window.ga instanceof Function) {
        ga('send', {
          hitType: 'event',
          eventCategory: groupName,
          eventAction: functionName,
          eventValue: opt_value,
        });
      }
    }
  }

  return {
    Timing,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const Timing = tr.b.Timing;
  /**
   * A task is a combination of a run callback, a set of subtasks, and an after
   * task.
   *
   * When executed, a task does the following things:
   * 1. Runs its callback
   * 2. Runs its subtasks
   * 3. Runs its after callback.
   *
   * The list of subtasks and after task can be mutated inside step #1 but as
   * soon as the task's callback returns, the subtask list and after task is
   * fixed and cannot be changed again.
   *
   * Use task.after().after().after() to describe the toplevel passes that make
   * up your computation. Then, use subTasks to add detail to each subtask as it
   * runs. For example:
   *    var pieces = [];
   *    taskA = new Task(function() { pieces = getPieces(); });
   *    taskA.after(function(taskA) {
   *      pieces.forEach(function(piece) {
   *        taskA.subTask(function(taskB) { piece.process(); }, this);
   *      });
   *    });
   *
   * @constructor
   */
  function Task(runCb, thisArg) {
    if (runCb !== undefined && thisArg === undefined &&
        runCb.prototype !== undefined) {
      throw new Error('Almost certainly you meant to pass a bound callback ' +
          'or thisArg.');
    }
    this.runCb_ = runCb;
    this.thisArg_ = thisArg;
    this.afterTask_ = undefined;
    this.subTasks_ = [];
    this.updatesUi_ = false;
  }

  Task.prototype = {
    get name() {
      return this.runCb_.name;
    },

    /** Sets a hint for whether or not this task updates the UI. */
    set updatesUi(value) {
      this.updatesUi_ = value;
    },

    /*
     * See constructor documentation on semantics of subtasks.
     */
    subTask(cb, thisArg) {
      if (cb instanceof Task) {
        this.subTasks_.push(cb);
      } else {
        this.subTasks_.push(new Task(cb, thisArg));
      }
      return this.subTasks_[this.subTasks_.length - 1];
    },

    /**
     * Runs the current task and returns the task that should be executed next.
     */
    run() {
      if (this.runCb_ !== undefined) this.runCb_.call(this.thisArg_, this);
      const subTasks = this.subTasks_;
      this.subTasks_ = undefined; // Prevent more subTasks from being posted.

      if (!subTasks.length) return this.afterTask_;

      // If there are subtasks, then we want to execute all the subtasks and
      // then this task's afterTask. To make this happen, we update the
      // afterTask of all the subtasks so the point upward to each other, e.g.
      // subTask[0].afterTask to subTask[1] and so on. Then, the last subTask's
      // afterTask points at this task's afterTask.
      for (let i = 1; i < subTasks.length; i++) {
        subTasks[i - 1].afterTask_ = subTasks[i];
      }
      subTasks[subTasks.length - 1].afterTask_ = this.afterTask_;
      return subTasks[0];
    },

    /*
     * See constructor documentation on semantics of after tasks.
     */
    after(cb, thisArg) {
      if (this.afterTask_) {
        throw new Error('Has an after task already');
      }
      if (cb instanceof Task) {
        this.afterTask_ = cb;
      } else {
        this.afterTask_ = new Task(cb, thisArg);
      }
      return this.afterTask_;
    },

    /*
     * Adds a task after the chain of tasks.
     */
    enqueue(cb, thisArg) {
      if (!this.afterTask_) return this.after(cb, thisArg);
      return this.afterTask_.enqueue(cb, thisArg);
    }
  };

  Task.RunSynchronously = function(task) {
    let curTask = task;
    while (curTask) {
      curTask = curTask.run();
    }
  };

  /**
   * Runs a task using raf.requestIdleCallback, returning
   * a promise for its completion.
   */
  Task.RunWhenIdle = function(task) {
    return new Promise(function(resolve, reject) {
      let curTask = task;
      function runAnother() {
        try {
          curTask = curTask.run();
        } catch (e) {
          reject(e);
          return;
        }

        if (curTask) {
          if (curTask.updatesUi_) {
            tr.b.requestAnimationFrameInThisFrameIfPossible(runAnother);
          } else {
            tr.b.requestIdleCallback(runAnother);
          }
          return;
        }

        resolve();
      }
      tr.b.requestIdleCallback(runAnother);
    });
  };

  return {
    Task,
  };
});


'use strict';

/**
 * @fileoverview Base class for auditors.
 */
tr.exportTo('tr.c', function() {
  function Auditor(model) {
    this.model_ = model;
  }

  Auditor.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Called by the Model after baking slices. May modify model.
     */
    runAnnotate() {
    },

    /**
     * Called by import to install userFriendlyCategoryDriver.
     */
    installUserFriendlyCategoryDriverIfNeeded() {
    },

    /**
     * Called by the Model after importing. Should not modify model, except
     * for adding interaction ranges and audits.
     */
    runAudit() {
    }
  };

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Auditor;
  tr.b.decorateExtensionRegistry(Auditor, options);

  return {
    Auditor,
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  function makeCaseInsensitiveRegex(pattern) {
    // See https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/
    // Regular_Expressions.
    pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(pattern, 'i');
  }

  /**
   * @constructor The generic base class for filtering a Model based on
   * various rules. The base class returns true for everything.
   */
  function Filter() { }

  Filter.prototype = {
    __proto__: Object.prototype,

    matchCounter(counter) {
      return true;
    },

    matchCpu(cpu) {
      return true;
    },

    matchProcess(process) {
      return true;
    },

    matchSlice(slice) {
      return true;
    },

    matchThread(thread) {
      return true;
    }
  };

  /**
   * @constructor A filter that matches objects by their name or category
   * case insensitive.
   * .findAllObjectsMatchingFilter
   */
  function TitleOrCategoryFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);

    if (!text.length) {
      throw new Error('Filter text is empty.');
    }
  }
  TitleOrCategoryFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice(slice) {
      if (slice.title === undefined && slice.category === undefined) {
        return false;
      }

      return this.regex_.test(slice.title) ||
          (!!slice.category && this.regex_.test(slice.category));
    }
  };

  /**
   * @constructor A filter that matches objects with the exact given title.
   */
  function ExactTitleFilter(text) {
    Filter.call(this);
    this.text_ = text;

    if (!text.length) {
      throw new Error('Filter text is empty.');
    }
  }
  ExactTitleFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice(slice) {
      return slice.title === this.text_;
    }
  };

  /**
   * @constructor A filter that matches objects by their full text contents
   * (title, category, args). Note that for performance this filter applies a
   * regex against all the keys of the slice arguments instead of recursing
   * through any embedded sub-objects.
   */
  function FullTextFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);
    this.titleOrCategoryFilter_ = new TitleOrCategoryFilter(text);
  }
  FullTextFilter.prototype = {
    __proto__: Filter.prototype,

    matchObject_(obj) {
      for (const key in obj) {
        if (!obj.hasOwnProperty(key)) continue;
        if (this.regex_.test(key)) return true;
        if (this.regex_.test(obj[key])) return true;
      }
      return false;
    },

    matchSlice(slice) {
      if (this.titleOrCategoryFilter_.matchSlice(slice)) return true;
      return this.matchObject_(slice.args);
    }
  };

  return {
    Filter,
    TitleOrCategoryFilter,
    ExactTitleFilter,
    FullTextFilter,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;

  /**
   * EventInfo is an annotation added to Events in order to document
   * what they represent, and override their title/colorId values.
   *
   * TODO(ccraik): eventually support more complex structure/paragraphs.
   *
   * @param {string} title A user-visible title for the event.
   * @param {string} description A user-visible description of the event.
   * @param {Array} docLinks A list of Objects, each of the form
   * {label: str, textContent: str, href: str}
   *
   * @constructor
   */
  function EventInfo(title, description, docLinks) {
    this.title = title;
    this.description = description;
    this.docLinks = docLinks;
    this.colorId = ColorScheme.getColorIdForGeneralPurposeString(title);
  }

  return {
    EventInfo,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function Alert(info, start, opt_associatedEvents, opt_args) {
    tr.model.TimedEvent.call(this, start);
    this.info = info;
    this.args = opt_args || {};
    this.associatedEvents = new tr.model.EventSet(opt_associatedEvents);
    this.associatedEvents.forEach(function(event) {
      event.addAssociatedAlert(this);
    }, this);
  }

  Alert.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get title() {
      return this.info.title;
    },

    get colorId() {
      return this.info.colorId;
    },

    get userFriendlyName() {
      return 'Alert ' + this.title + ' at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    }
  };

  tr.model.EventRegistry.register(
      Alert,
      {
        name: 'alert',
        pluralName: 'alerts'
      });

  return {
    Alert,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const ClockDomainId = {
    BATTOR: 'BATTOR',

    // NOTE: Exists for backwards compatibility with old Chrome traces which
    // didn't explicitly specify the clock being used.
    UNKNOWN_CHROME_LEGACY: 'UNKNOWN_CHROME_LEGACY',

    LINUX_CLOCK_MONOTONIC: 'LINUX_CLOCK_MONOTONIC',
    LINUX_FTRACE_GLOBAL: 'LINUX_FTRACE_GLOBAL',
    MAC_MACH_ABSOLUTE_TIME: 'MAC_MACH_ABSOLUTE_TIME',
    WIN_ROLLOVER_PROTECTED_TIME_GET_TIME:
        'WIN_ROLLOVER_PROTECTED_TIME_GET_TIME',
    WIN_QPC: 'WIN_QPC',

    // 'TELEMETRY' and 'SYSTRACE' aren't really clock domains because they
    // actually can use one of several clock domains, just like Chrome. However,
    // because there's a chance that they are running off of the same clock as
    // Chrome (e.g. LINUX_CLOCK_MONOTONIC) but on a separate device (i.e. on a
    // a host computer with Chrome running on an attached phone), there's a
    // chance that Chrome and the controller will erroneously get put into
    // the same clock domain. The solution for this is that clock domains should
    // actually be some (unique_device_id, clock_id) tuple. For now, though,
    // we'll hack around this by putting Telemetry into its own clock domain.
    SYSTRACE: 'SYSTRACE',
    TELEMETRY: 'TELEMETRY'
  };

  const POSSIBLE_CHROME_CLOCK_DOMAINS = new Set([
    ClockDomainId.UNKNOWN_CHROME_LEGACY,
    ClockDomainId.LINUX_CLOCK_MONOTONIC,
    ClockDomainId.MAC_MACH_ABSOLUTE_TIME,
    ClockDomainId.WIN_ROLLOVER_PROTECTED_TIME_GET_TIME,
    ClockDomainId.WIN_QPC
  ]);

  // The number of milliseconds above which the BattOr sync is no longer
  // considered "fast", and it's more accurate to use the sync start timestamp
  // instead of the normal sync timestamp due to a bug in the Chrome serial code
  // making serial reads too slow.
  const BATTOR_FAST_SYNC_THRESHOLD_MS = 3;

  /**
   * A ClockSyncManager holds clock sync markers and uses them to shift
   * timestamps from agents' clock domains onto the model's clock domain.
   *
   * In this context, a "clock domain" is a single perspective on the passage
   * of time. A single computer can have multiple clock domains because it
   * can have multiple methods of retrieving a timestamp (e.g.
   * clock_gettime(CLOCK_MONOTONIC) and clock_gettime(CLOCK_REALTIME) on Linux).
   * Another common reason for multiple clock domains within a single trace
   * is that traces can span devices (e.g. a laptop collecting a Chrome trace
   * can have its power consumption recorded by a second device and the two
   * traces can be viewed alongside each other).
   *
   * For more information on how to synchronize multiple time domains using this
   * method, see: http://bit.ly/1OVkqju.
   *
   * @constructor
   */
  function ClockSyncManager() {
    // A set of all domains seen by the ClockSyncManager.
    this.domainsSeen_ = new Set();
    this.markersBySyncId_ = new Map();
    // transformerMapByDomainId_[fromDomainId][toDomainId] returns the function
    // that converts timestamps in the "from" domain to timestamps in the "to"
    // domain.
    this.transformerMapByDomainId_ = {};
  }

  ClockSyncManager.prototype = {
    /**
     * Adds a clock sync marker to the list of known markers.
     *
     * @param {string} domainId The clock domain that the marker is in.
     * @param {string} syncId The identifier shared by both sides of the clock
     *                 sync marker.
     * @param {number} startTs The time (in ms) at which the sync started.
     * @param {number=} opt_endTs The time (in ms) at which the sync ended. If
     *                  unspecified, it's assumed to be the same as the start,
     *                  indicating an instantaneous sync.
     */
    addClockSyncMarker(domainId, syncId, startTs, opt_endTs) {
      this.onDomainSeen_(domainId);

      if (Object.values(ClockDomainId).indexOf(domainId) < 0) {
        throw new Error('"' + domainId + '" is not in the list of known ' +
            'clock domain IDs.');
      }

      if (this.modelDomainId_) {
        throw new Error('Cannot add new clock sync markers after getting ' +
            'a model time transformer.');
      }

      const marker = new ClockSyncMarker(domainId, startTs, opt_endTs);

      if (!this.markersBySyncId_.has(syncId)) {
        this.markersBySyncId_.set(syncId, [marker]);
        return;
      }

      const markers = this.markersBySyncId_.get(syncId);

      if (markers.length === 2) {
        throw new Error('Clock sync with ID "' + syncId + '" is already ' +
            'complete - cannot add a third clock sync marker to it.');
      }

      if (markers[0].domainId === domainId) {
        throw new Error('A clock domain cannot sync with itself.');
      }

      markers.push(marker);
      this.onSyncCompleted_(markers[0], marker);
    },

    // TODO(charliea): Remove this once the clockSyncMetric is no longer using
    // it.
    get markersBySyncId() {
      return this.markersBySyncId_;
    },

    /** @return {Set<String>} The string IDs of the domains seen so far. */
    get domainsSeen() {
      return this.domainsSeen_;
    },

    /**
     * Returns a function that, given a timestamp in the domain with |domainId|,
     * returns a timestamp in the model's clock domain.
     *
     * NOTE: All clock sync markers should be added before calling this function
     * for the first time. This is because the first time that this function is
     * called, a model clock domain is selected. This clock domain must have
     * syncs connecting it with all other clock domains. If multiple clock
     * domains are viable candidates, the one with the clock domain ID that is
     * the first alphabetically is selected.
     */
    getModelTimeTransformer(domainId) {
      this.onDomainSeen_(domainId);

      if (!this.modelDomainId_) {
        this.selectModelDomainId_();
      }

      return this.getTimeTransformerRaw_(domainId, this.modelDomainId_).fn;
    },

    /**
     * Returns the error associated with the transformation given by
     * |getModelTimeTransformer(domainId)|.
     */
    getTimeTransformerError(fromDomainId, toDomainId) {
      this.onDomainSeen_(fromDomainId);
      this.onDomainSeen_(toDomainId);
      return this.getTimeTransformerRaw_(fromDomainId, toDomainId).error;
    },

    getTimeTransformerRaw_(fromDomainId, toDomainId) {
      const transformer =
          this.getTransformerBetween_(fromDomainId, toDomainId);
      if (!transformer) {
        throw new Error('No clock sync markers exist pairing clock domain "' +
            fromDomainId + '" ' + 'with target clock domain "' +
            toDomainId + '".');
      }

      return transformer;
    },

    /**
     * Returns a function that, given a timestamp in the "from" domain, returns
     * a timestamp in the "to" domain.
     */
    getTransformerBetween_(fromDomainId, toDomainId) {
      // Do a breadth-first search from the "from" domain until we reach the
      // "to" domain.
      const visitedDomainIds = new Set();
      // Keep a queue of nodes to visit, starting with the "from" domain.
      const queue = [{
        domainId: fromDomainId,
        transformer: Transformer.IDENTITY
      }];

      while (queue.length > 0) {
        // NOTE: Using a priority queue here would theoretically be much more
        // efficient, but the actual performance difference is negligible given
        // how few clock domains we have in a trace.
        queue.sort((domain1, domain2) =>
            domain1.transformer.error - domain2.transformer.error);

        const current = queue.shift();

        if (current.domainId === toDomainId) {
          return current.transformer;
        }

        if (visitedDomainIds.has(current.domainId)) {
          continue;
        }
        visitedDomainIds.add(current.domainId);

        const outgoingTransformers =
            this.transformerMapByDomainId_[current.domainId];

        if (!outgoingTransformers) continue;

        // Add all nodes that are directly connected to this one to the queue.
        for (const outgoingDomainId in outgoingTransformers) {
          // We have two transformers: one to get us from the "from" domain to
          // the current domain, and another to get us from the current domain
          // to the next domain. By composing those two transformers, we can
          // create one that gets us from the "from" domain to the next domain.
          const toNextDomainTransformer =
            outgoingTransformers[outgoingDomainId];
          const toCurrentDomainTransformer = current.transformer;

          queue.push({
            domainId: outgoingDomainId,
            transformer: Transformer.compose(
                toNextDomainTransformer, toCurrentDomainTransformer)
          });
        }
      }

      return undefined;
    },

    /**
     * Selects the domain to use as the model domain from among the domains
     * with registered markers.
     *
     * This is necessary because some common domain must be chosen before all
     * timestamps can be shifted onto the same domain.
     *
     * For the time being, preference is given to Chrome clock domains. If no
     * Chrome clock domain is present, the first clock domain alphabetically
     * is selected.
     */
    selectModelDomainId_() {
      this.ensureAllDomainsAreConnected_();

      // While we're migrating to the new clock sync system, we have to make
      // sure to prefer the Chrome clock domain because legacy clock sync
      // mechanisms assume that's the case.
      for (const chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
        if (this.domainsSeen_.has(chromeDomainId)) {
          this.modelDomainId_ = chromeDomainId;
          return;
        }
      }

      const domainsSeenArray = Array.from(this.domainsSeen_);
      domainsSeenArray.sort();
      this.modelDomainId_ = domainsSeenArray[0];
    },

    /** Throws an error if all domains are not connected. */
    ensureAllDomainsAreConnected_() {
      // NOTE: this is a ridiculously inefficient way to do this. Given how few
      // clock domains we're likely to have, this shouldn't be a problem.
      let firstDomainId = undefined;
      for (const domainId of this.domainsSeen_) {
        if (!firstDomainId) {
          firstDomainId = domainId;
          continue;
        }

        if (!this.getTransformerBetween_(firstDomainId, domainId)) {
          throw new Error('Unable to select a master clock domain because no ' +
              'path can be found from "' + firstDomainId + '" to "' + domainId +
              '".');
        }
      }

      return true;
    },

    /** Observer called each time that a clock domain is seen. */
    onDomainSeen_(domainId) {
      if (domainId === ClockDomainId.UNKNOWN_CHROME_LEGACY &&
          !this.domainsSeen_.has(ClockDomainId.UNKNOWN_CHROME_LEGACY)) {
        // UNKNOWN_CHROME_LEGACY was just seen for the first time: collapse it
        // and the other Chrome clock domains into one.
        //
        // This makes sure that we don't have two separate clock sync graphs:
        // one attached to UNKNOWN_CHROME_LEGACY and the other attached to the
        // real Chrome clock domain.
        for (const chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
          if (chromeDomainId === ClockDomainId.UNKNOWN_CHROME_LEGACY) {
            continue;
          }

          this.collapseDomains_(
              ClockDomainId.UNKNOWN_CHROME_LEGACY, chromeDomainId);
        }
      }

      this.domainsSeen_.add(domainId);
    },

    /**
     * Observer called when a complete sync is made involving |marker1| and
     * |marker2|.
     */
    onSyncCompleted_(marker1, marker2) {
      const forwardTransformer = Transformer.fromMarkers(marker1, marker2);
      const backwardTransformer = Transformer.fromMarkers(marker2, marker1);

      const existingTransformer =
          this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId];
      if (!existingTransformer ||
          forwardTransformer.error < existingTransformer.error) {
        this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId] =
            forwardTransformer;
        this.getOrCreateTransformerMap_(marker2.domainId)[marker1.domainId] =
            backwardTransformer;
      }
    },

    /** Makes timestamps in the two clock domains interchangeable. */
    collapseDomains_(domain1Id, domain2Id) {
      this.getOrCreateTransformerMap_(domain1Id)[domain2Id] =
          this.getOrCreateTransformerMap_(domain2Id)[domain1Id] =
              Transformer.IDENTITY;
    },

    /**
     * Returns (and creates if it doesn't exist) the transformer map describing
     * how to transform timestamps between directly connected clock domains.
     */
    getOrCreateTransformerMap_(domainId) {
      if (!this.transformerMapByDomainId_[domainId]) {
        this.transformerMapByDomainId_[domainId] = {};
      }

      return this.transformerMapByDomainId_[domainId];
    },

    /**
     * @return {string} The clock sync graph represented in the DOT language.
     * This is useful for debugging incorrect clock sync behavior.
     */
    computeDotGraph() {
      let dotString = 'graph {\n';

      const domainsSeen = [...this.domainsSeen_].sort();
      for (const domainId of domainsSeen) {
        dotString += `  ${domainId}[shape=box]\n`;
      }

      const markersBySyncIdEntries = [...this.markersBySyncId_.entries()].sort(
          ([syncId1, markers1], [syncId2, markers2]) =>
              syncId1.localeCompare(syncId2));

      for (const [syncId, markers] of markersBySyncIdEntries) {
        const sortedMarkers = markers.sort(
            (a, b) => a.domainId.localeCompare(b.domainId));
        for (const m of markers) {
          dotString += `  "${syncId}" -- ${m.domainId} `;
          dotString += `[label="[${m.startTs}, ${m.endTs}]"]\n`;
        }
      }

      dotString += '}';

      return dotString;
    }
  };

  /**
   * A ClockSyncMarker is an internal entity that represents a marker in a
   * trace log indicating that a clock sync happened at a specified time.
   *
   * If no end timestamp argument is specified in the constructor, it's assumed
   * that the end timestamp is the same as the start (i.e. the clock sync
   * was instantaneous).
   */
  function ClockSyncMarker(domainId, startTs, opt_endTs) {
    this.domainId = domainId;
    this.startTs = startTs;
    this.endTs = opt_endTs === undefined ? startTs : opt_endTs;
  }

  ClockSyncMarker.prototype = {
    get duration() { return this.endTs - this.startTs; },
    get ts() { return this.startTs + this.duration / 2; }
  };

  /**
   * A Transformer encapsulates information about how to turn timestamps in one
   * clock domain into timestamps in another. It also stores additional data
   * about the maximum error involved in doing so.
   */
  function Transformer(fn, error) {
    this.fn = fn;
    this.error = error;
  }

  Transformer.IDENTITY = new Transformer((x => x), 0);

  /**
   * Given two transformers, creates a third that's a composition of the two.
   *
   * @param {function(Number): Number} aToB A function capable of converting a
   *     timestamp from domain A to domain B.
   * @param {function(Number): Number} bToC A function capable of converting a
   *     timestamp from domain B to domain C.
   *
   * @return {function(Number): Number} A function capable of converting a
   *     timestamp from domain A to domain C.
   */
  Transformer.compose = function(aToB, bToC) {
    return new Transformer(
        (ts) => bToC.fn(aToB.fn(ts)), aToB.error + bToC.error);
  };

  /**
   * Returns a function that, given a timestamp in |fromMarker|'s domain,
   * returns a timestamp in |toMarker|'s domain.
   */
  Transformer.fromMarkers = function(fromMarker, toMarker) {
    let fromTs = fromMarker.ts;
    let toTs = toMarker.ts;

    // TODO(charliea): Usually, we estimate that the clock sync marker is
    // issued by the agent exactly in the middle of the controller's start and
    // end timestamps. However, there's currently a bug in the Chrome serial
    // code that's making the clock sync ack for BattOr take much longer to
    // read than it should (by about 8ms). This is causing the above estimate
    // of the controller's sync timestamp to be off by a substantial enough
    // amount that it makes traces hard to read. For now, make an exception
    // for BattOr and just use the controller's start timestamp as the sync
    // time. In the medium term, we should fix the Chrome serial code in order
    // to remove this special logic and get an even more accurate estimate.
    if (fromMarker.domainId === ClockDomainId.BATTOR &&
        toMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      toTs = toMarker.startTs;
    } else if (toMarker.domainId === ClockDomainId.BATTOR &&
        fromMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      fromTs = fromMarker.startTs;
    }

    const tsShift = toTs - fromTs;
    return new Transformer(
        (ts) => ts + tsShift, fromMarker.duration + toMarker.duration);
  };

  return {
    ClockDomainId,
    ClockSyncManager,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  return {
    // Since the PID of the browser process is not known to the child processes,
    // we let them use "pid_ref = -1" to reference an object created in the
    // browser process.
    BROWSER_PROCESS_PID_REF: -1,

    // The default scope of object events, when not explicitly specified.
    OBJECT_DEFAULT_SCOPE: 'ptr',

    // Event phases that have process-local IDs, unless a global ID is
    // explicitly specified.
    LOCAL_ID_PHASES: new Set(['N', 'D', 'O', '(', ')'])
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * The value of a given measurement at a given time.
   *
   * As an example, if we're measuring the throughput of data sent over a USB
   * connection, each counter sample might represent the instantaneous
   * throughput of the connection at a given time.
   *
   * @constructor
   * @extends {Event}
   */
  function CounterSample(series, timestamp, value) {
    tr.model.Event.call(this);
    this.series_ = series;
    this.timestamp_ = timestamp;
    this.value_ = value;
  }

  CounterSample.groupByTimestamp = function(samples) {
    const samplesByTimestamp = tr.b.groupIntoMap(samples, s => s.timestamp);
    const timestamps = Array.from(samplesByTimestamp.keys());
    timestamps.sort();
    const groups = [];
    for (const ts of timestamps) {
      const group = samplesByTimestamp.get(ts);
      group.sort((x, y) => x.series.seriesIndex - y.series.seriesIndex);
      groups.push(group);
    }
    return groups;
  };

  CounterSample.prototype = {
    __proto__: tr.model.Event.prototype,

    get series() {
      return this.series_;
    },

    get timestamp() {
      return this.timestamp_;
    },

    get value() {
      return this.value_;
    },

    set timestamp(timestamp) {
      this.timestamp_ = timestamp;
    },

    addBoundsToRange(range) {
      range.addValue(this.timestamp);
    },

    getSampleIndex() {
      return tr.b.findLowIndexInSortedArray(
          this.series.timestamps,
          function(x) { return x; },
          this.timestamp_);
    },

    get userFriendlyName() {
      return 'Counter sample from ' + this.series_.title + ' at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
    }
  };


  tr.model.EventRegistry.register(
      CounterSample,
      {
        name: 'counterSample',
        pluralName: 'counterSamples'
      });

  return {
    CounterSample,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * EventContainer is a base class for any class in the trace model that
   * contains child events or child EventContainers.
   *
   * For all EventContainers, updateBounds() must be called after modifying the
   * container's events if an up-to-date bounds is expected.
   *
   * @constructor
   */
  function EventContainer() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.important = true;
    this.bounds_ = new tr.b.math.Range();
  }

  EventContainer.prototype = {
    get guid() {
      return this.guid_;
    },

    /**
     * @return {String} A stable and unique identifier that describes this
     * container's position in the event tree relative to the root. If an event
     * container 'B' is a child to another event container 'A', then container
     * B's stable ID would be 'A.B'.
     */
    get stableId() {
      throw new Error('Not implemented');
    },

    /**
     * Returns the bounds of the event container, which describe the range
     * of timestamps for all ancestor events.
     */
    get bounds() {
      return this.bounds_;
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that iterates throuch getDescendantEvents.
    /**
     * Updates the bounds of the event container. After updating, this.bounds
     * will describe the range of timestamps of all ancestor events.
     */
    updateBounds() {
      throw new Error('Not implemented');
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that iterates through getDescendantEvents.
    /**
     * Shifts the timestamps for ancestor events by 'amount' milliseconds.
     */
    shiftTimestampsForward(amount) {
      throw new Error('Not implemented');
    },


    /**
    * Returns an iterable of all child events.
    */
    * childEvents() {
    },

    /**
     * Returns an iterable of all events in this and descendant
     * event containers.
     */
    * getDescendantEvents() {
      yield* this.childEvents();
      for (const container of this.childEventContainers()) {
        yield* container.getDescendantEvents();
      }
    },

    /**
     * Returns an iterable of all child event containers.
     */
    * childEventContainers() {
    },

    /**
    * Returns an iterable containing this and all descendant event containers.
    */
    * getDescendantEventContainers() {
      yield this;
      for (const container of this.childEventContainers()) {
        yield* container.getDescendantEventContainers();
      }
    },

    /**
     * Finds topmost slices in this container (see docstring for
     * findTopmostSlices).
     */
    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
    },

    /**
     * The findTopmostSlices* series of helpers find all topmost slices
     * satisfying the given predicates.
     *
     * As an example, suppose we are trying to find slices named 'C', with the
     * following thread:
     *
     *  -> |---C---| |-----D-----|
     *       |-C-|      |---C---| <-
     *
     * findTopmostSlices would locate the pointed-to Cs, because the bottom C on
     * the  left is not the topmost C, and the right one is, even though it is
     * not itself a top-level slice.
     */
    * findTopmostSlices(eventPredicate) {
      for (const ec of this.getDescendantEventContainers()) {
        yield* ec.findTopmostSlicesInThisContainer(eventPredicate);
      }
    },

    * findTopmostSlicesNamed(name) {
      yield* this.findTopmostSlices(e => e.title === name);
    }
  };

  return {
    EventContainer,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const CounterSample = tr.model.CounterSample;

  /**
   * A container holding all samples of a given measurement over time.
   *
   * As an example, a counter series might measure the throughput of data sent
   * over a USB connection, with each sample representing the instantaneous
   * throughput of the connection.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function CounterSeries(name, color) {
    tr.model.EventContainer.call(this);

    this.name_ = name;
    this.color_ = color;

    this.timestamps_ = [];
    this.samples_ = [];

    // Set by counter.addSeries
    this.counter = undefined;
    this.seriesIndex = undefined;
  }

  CounterSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get length() {
      return this.timestamps_.length;
    },

    get name() {
      return this.name_;
    },

    get color() {
      return this.color_;
    },

    get samples() {
      return this.samples_;
    },

    get timestamps() {
      return this.timestamps_;
    },

    getSample(idx) {
      return this.samples_[idx];
    },

    getTimestamp(idx) {
      return this.timestamps_[idx];
    },

    addCounterSample(ts, val) {
      const sample = new CounterSample(this, ts, val);
      this.addSample(sample);
      return sample;
    },

    addSample(sample) {
      this.timestamps_.push(sample.timestamp);
      this.samples_.push(sample);
    },

    getStatistics(sampleIndices) {
      let sum = 0;
      let min = Number.MAX_VALUE;
      let max = -Number.MAX_VALUE;

      for (let i = 0; i < sampleIndices.length; ++i) {
        const sample = this.getSample(sampleIndices[i]).value;

        sum += sample;
        min = Math.min(sample, min);
        max = Math.max(sample, max);
      }

      return {
        min,
        max,
        avg: (sum / sampleIndices.length),
        start: this.getSample(sampleIndices[0]).value,
        end: this.getSample(sampleIndices.length - 1).value
      };
    },

    shiftTimestampsForward(amount) {
      for (let i = 0; i < this.timestamps_.length; ++i) {
        this.timestamps_[i] += amount;
        this.samples_[i].timestamp = this.timestamps_[i];
      }
    },

    * childEvents() {
      yield* this.samples_;
    },

    * childEventContainers() {
    }
  };

  return {
    CounterSeries,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * A container holding all series of a given type of measurement.
   *
   * As an example, if we're measuring the throughput of data sent over several
   * USB connections, the throughput of each cable might be added as a separate
   * series to a single counter.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function Counter(parent, id, category, name) {
    tr.model.EventContainer.call(this);

    this.parent_ = parent;
    this.id_ = id;
    this.category_ = category || '';
    this.name_ = name;

    this.series_ = [];
    this.totals = [];
  }

  Counter.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parent() {
      return this.parent_;
    },

    get id() {
      return this.id_;
    },

    get category() {
      return this.category_;
    },

    get name() {
      return this.name_;
    },

    * childEvents() {
    },

    * childEventContainers() {
      yield* this.series;
    },

    set timestamps(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesNames(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesColors(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set samples(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    addSeries(series) {
      series.counter = this;
      series.seriesIndex = this.series_.length;
      this.series_.push(series);
      return series;
    },

    getSeries(idx) {
      return this.series_[idx];
    },

    get series() {
      return this.series_;
    },

    get numSeries() {
      return this.series_.length;
    },

    get numSamples() {
      if (this.series_.length === 0) return 0;
      return this.series_[0].length;
    },

    get timestamps() {
      if (this.series_.length === 0) return [];
      return this.series_[0].timestamps;
    },

    /**
     * Obtains min, max, avg, values, start, and end for different series for
     * a given counter
     *     getSampleStatistics([0,1])
     * The statistics objects that this returns are an array of objects, one
     * object for each series for the counter in the form:
     * {min: minVal, max: maxVal, avg: avgVal, start: startVal, end: endVal}
     *
     * @param {Array.<Number>} Indices to summarize.
     * @return {Object} An array of statistics. Each element in the array
     * has data for one of the series in the selected counter.
     */
    getSampleStatistics(sampleIndices) {
      sampleIndices.sort();

      const ret = [];
      this.series_.forEach(function(series) {
        ret.push(series.getStatistics(sampleIndices));
      });
      return ret;
    },

    /**
     * Shifts all the timestamps inside this counter forward by the amount
     * specified.
     */
    shiftTimestampsForward(amount) {
      for (let i = 0; i < this.series_.length; ++i) {
        this.series_[i].shiftTimestampsForward(amount);
      }
    },

    /**
     * Updates the bounds for this counter based on the samples it contains.
     */
    updateBounds() {
      this.totals = [];
      this.maxTotal = 0;
      this.bounds.reset();

      if (this.series_.length === 0) return;

      const firstSeries = this.series_[0];
      const lastSeries = this.series_[this.series_.length - 1];

      this.bounds.addValue(firstSeries.getTimestamp(0));
      this.bounds.addValue(lastSeries.getTimestamp(lastSeries.length - 1));

      const numSeries = this.numSeries;
      this.maxTotal = -Infinity;

      // Sum the samples at each timestamp.
      // Note, this assumes that all series have all timestamps.
      for (let i = 0; i < firstSeries.length; ++i) {
        let total = 0;
        this.series_.forEach(function(series) {
          total += series.getSample(i).value;
          this.totals.push(total);
        }.bind(this));

        this.maxTotal = Math.max(total, this.maxTotal);
      }
    }
  };

  /**
   * Comparison between counters that orders by parent.compareTo, then name.
   */
  Counter.compare = function(x, y) {
    let tmp = x.parent.compareTo(y.parent);
    if (tmp !== 0) return tmp;
    tmp = x.name.localeCompare(y.name);
    if (tmp === 0) return x.tid - y.tid;
    return tmp;
  };

  return {
    Counter,
  };
});


'use strict';

/**
 * @fileoverview Provides the Slice class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Slice represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function Slice(category, title, colorId, start, args, opt_duration,
      opt_cpuStart, opt_cpuDuration, opt_argsStripped,
      opt_bindId) {
    if (new.target) {
      throw new Error('Can\'t instantiate pure virtual class Slice');
    }
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.inFlowEvents = [];
    this.outFlowEvents = [];
    this.subSlices = [];
    this.selfTime = undefined;
    this.cpuSelfTime = undefined;
    this.important = false;
    this.parentContainer = undefined;
    this.argsStripped = false;

    this.bind_id_ = opt_bindId;

    // parentSlice and isTopLevel will be set by SliceGroup.
    this.parentSlice = undefined;
    this.isTopLevel = false;
    // After SliceGroup processes Slices, isTopLevel should be equivalent to
    // !parentSlice.

    if (opt_duration !== undefined) {
      this.duration = opt_duration;
    }

    if (opt_cpuStart !== undefined) {
      this.cpuStart = opt_cpuStart;
    }

    if (opt_cpuDuration !== undefined) {
      this.cpuDuration = opt_cpuDuration;
    }

    if (opt_argsStripped !== undefined) {
      this.argsStripped = true;
    }
  }

  Slice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,


    get analysisTypeName() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Slice ' + this.title + ' at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      const parentSliceGroup = this.parentContainer.sliceGroup;
      return parentSliceGroup.stableId + '.' +
          parentSliceGroup.slices.indexOf(this);
    },

    get bindId() {
      return this.bind_id_;
    },

    findDescendentSlice(targetTitle) {
      if (!this.subSlices) {
        return undefined;
      }

      for (let i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title === targetTitle) {
          return this.subSlices[i];
        }
        const slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    get mostTopLevelSlice() {
      if (!this.parentSlice) return this;
      return this.parentSlice.mostTopLevelSlice;
    },

    getProcess() {
      const thread = this.parentContainer;
      if (thread && thread.getProcess) {
        return thread.getProcess();
      }
      return undefined;
    },

    get model() {
      const process = this.getProcess();
      if (process !== undefined) {
        return this.getProcess().model;
      }
      return undefined;
    },

    /**
     * Finds all topmost slices relative to this slice.
     *
     * Slices may have multiple direct descendants which satisfy
     * |eventPredicate|, and in this case, all of them are topmost as long as
     * this slice does not satisfy the predicate.
     *
     * For instance, suppose we are passing a predicate that checks whether
     * events titles begin with 'C'.
     *  C1.findTopmostSlicesRelativeToThisSlice() returns C1 in this example:
     * [   C1  ]
     *   [ C2 ]
     *
     * and D.findTopmostSlicesRelativeToThisSlice() returns C1 and C2 in this
     * example:
     * [      D     ]
     *   [C1]  [C2]
     */
    * findTopmostSlicesRelativeToThisSlice(eventPredicate) {
      if (eventPredicate(this)) {
        yield this;
        return;
      }
      for (const s of this.subSlices) {
        yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
      }
    },

    /**
     * Obtains all subsequent slices of this slice.
     *
     * Subsequent slices are slices that get executed after a particular
     * slice, i.e., all the functions that are called after the current one.
     *
     * For instance, E.iterateAllSubsequentSlices() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will pass F, G, then H to the provided callback.
     *
     * The reason we need subsequent slices of a particular slice is that
     * when there is flow event goes into, e.g., E, we only want to highlight
     * E's subsequent slices to indicate the execution order.
     *
     * The idea to calculate the subsequent slices of slice E is to view
     * the slice group as a tree where the top-level slice A is the root node.
     * The preorder depth-first-search (DFS) order is naturally equivalent
     * to the function call order. We just need to perform a DFS, and start
     * recording the slices after we see the occurance of E.
     */
    iterateAllSubsequentSlices(callback, opt_this) {
      const parentStack = [];
      let started = false;

      // get the root node and push it to the DFS stack
      const topmostSlice = this.mostTopLevelSlice;
      parentStack.push(topmostSlice);

      // Using the stack to perform DFS
      while (parentStack.length !== 0) {
        const curSlice = parentStack.pop();

        if (started) {
          callback.call(opt_this, curSlice);
        } else {
          started = (curSlice.guid === this.guid);
        }

        for (let i = curSlice.subSlices.length - 1; i >= 0; i--) {
          parentStack.push(curSlice.subSlices[i]);
        }
      }
    },

    get subsequentSlices() {
      const res = [];

      this.iterateAllSubsequentSlices(function(subseqSlice) {
        res.push(subseqSlice);
      });

      return res;
    },

    /**
     * Obtains the parents of a slice, from the most immediate to the root.
     *
     * For instance, E.enumerateAllAncestors() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will yield D, then A, in the order from the leaves to the root.
     */
    * enumerateAllAncestors() {
      let curSlice = this.parentSlice;
      while (curSlice) {
        yield curSlice;
        curSlice = curSlice.parentSlice;
      }
    },

    get ancestorSlices() {
      return Array.from(this.enumerateAllAncestors());
    },

    iterateEntireHierarchy(callback, opt_this) {
      const mostTopLevelSlice = this.mostTopLevelSlice;
      callback.call(opt_this, mostTopLevelSlice);
      mostTopLevelSlice.iterateAllSubsequentSlices(callback, opt_this);
    },

    get entireHierarchy() {
      const res = [];

      this.iterateEntireHierarchy(function(slice) {
        res.push(slice);
      });

      return res;
    },

    /**
     * Returns this slice, and its ancestor and subsequent slices.
     *
     * For instance, E.ancestorAndSubsequentSlices in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will return E, D, A, F, G, and H, where E is itself, D and A are
     * E's ancestors, and F, G, and H are subsequent slices of E
     */
    get ancestorAndSubsequentSlices() {
      const res = [];

      res.push(this);

      for (const aSlice of this.enumerateAllAncestors()) {
        res.push(aSlice);
      }

      this.iterateAllSubsequentSlices(function(sSlice) {
        res.push(sSlice);
      });

      return res;
    },

    * enumerateAllDescendents() {
      for (const slice of this.subSlices) {
        yield slice;
      }
      for (const slice of this.subSlices) {
        yield* slice.enumerateAllDescendents();
      }
    },

    get descendentSlices() {
      const res = [];
      for (const slice of this.enumerateAllDescendents()) {
        res.push(slice);
      }
      return res;
    }

  };

  return {
    Slice,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const Slice = tr.model.Slice;


  const SCHEDULING_STATE = {
    DEBUG: 'Debug',
    EXIT_DEAD: 'Exit Dead',
    RUNNABLE: 'Runnable',
    RUNNING: 'Running',
    SLEEPING: 'Sleeping',
    STOPPED: 'Stopped',
    TASK_DEAD: 'Task Dead',
    UNINTR_SLEEP: 'Uninterruptible Sleep',
    UNINTR_SLEEP_WAKE_KILL: 'Uninterruptible Sleep | WakeKill',
    UNINTR_SLEEP_WAKING: 'Uninterruptible Sleep | Waking',
    UNINTR_SLEEP_IO: 'Uninterruptible Sleep - Block I/O',
    UNINTR_SLEEP_WAKE_KILL_IO: 'Uninterruptible Sleep | WakeKill - Block I/O',
    UNINTR_SLEEP_WAKING_IO: 'Uninterruptible Sleep | Waking - Block I/O',
    UNKNOWN: 'UNKNOWN',
    WAKE_KILL: 'Wakekill',
    WAKING: 'Waking',
    ZOMBIE: 'Zombie'
  };

  /**
   * A ThreadTimeSlice is a slice of time on a specific thread where that thread
   * was running on a specific CPU, or in a specific sleep state.
   *
   * As a thread switches moves through its life, it sometimes goes to sleep and
   * can't run. Other times, its runnable but isn't actually assigned to a CPU.
   * Finally, sometimes it gets put on a CPU to actually execute. Each of these
   * states is represented by a ThreadTimeSlice:
   *
   *   Sleeping or runnable: cpuOnWhichThreadWasRunning is undefined
   *   Running:  cpuOnWhichThreadWasRunning is set.
   *
   * @constructor
   */
  function ThreadTimeSlice(thread, schedulingState, cat,
      start, args, opt_duration) {
    Slice.call(this, cat, schedulingState,
        this.getColorForState_(schedulingState),
        start, args, opt_duration);
    this.thread = thread;
    this.schedulingState = schedulingState;
    this.cpuOnWhichThreadWasRunning = undefined;
  }

  ThreadTimeSlice.prototype = {
    __proto__: Slice.prototype,

    getColorForState_(state) {
      const getColorIdForReservedName =
          tr.b.ColorScheme.getColorIdForReservedName;

      switch (state) {
        case SCHEDULING_STATE.RUNNABLE:
          return getColorIdForReservedName('thread_state_runnable');
        case SCHEDULING_STATE.RUNNING:
          return getColorIdForReservedName('thread_state_running');
        case SCHEDULING_STATE.SLEEPING:
          return getColorIdForReservedName('thread_state_sleeping');
        case SCHEDULING_STATE.DEBUG:
        case SCHEDULING_STATE.EXIT_DEAD:
        case SCHEDULING_STATE.STOPPED:
        case SCHEDULING_STATE.TASK_DEAD:
        case SCHEDULING_STATE.UNINTR_SLEEP:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
        case SCHEDULING_STATE.UNKNOWN:
        case SCHEDULING_STATE.WAKE_KILL:
        case SCHEDULING_STATE.WAKING:
        case SCHEDULING_STATE.ZOMBIE:
          return getColorIdForReservedName('thread_state_uninterruptible');
        case SCHEDULING_STATE.UNINTR_SLEEP_IO:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKING_IO:
          return getColorIdForReservedName('thread_state_iowait');
        default:
          return getColorIdForReservedName('thread_state_unknown');
      }
    },

    get analysisTypeName() {
      return 'tr.ui.analysis.ThreadTimeSlice';
    },

    getAssociatedCpuSlice() {
      if (!this.cpuOnWhichThreadWasRunning) return undefined;
      const cpuSlices = this.cpuOnWhichThreadWasRunning.slices;
      for (let i = 0; i < cpuSlices.length; i++) {
        const cpuSlice = cpuSlices[i];
        if (cpuSlice.start !== this.start) continue;
        if (cpuSlice.duration !== this.duration) continue;
        return cpuSlice;
      }
      return undefined;
    },

    getCpuSliceThatTookCpu() {
      if (this.cpuOnWhichThreadWasRunning) return undefined;
      let curIndex = this.thread.indexOfTimeSlice(this);
      let cpuSliceWhenLastRunning;
      while (curIndex >= 0) {
        const curSlice = this.thread.timeSlices[curIndex];
        if (!curSlice.cpuOnWhichThreadWasRunning) {
          curIndex--;
          continue;
        }
        cpuSliceWhenLastRunning = curSlice.getAssociatedCpuSlice();
        break;
      }
      if (!cpuSliceWhenLastRunning) return undefined;

      const cpu = cpuSliceWhenLastRunning.cpu;
      const indexOfSliceOnCpuWhenLastRunning =
          cpu.indexOf(cpuSliceWhenLastRunning);
      const nextRunningSlice = cpu.slices[indexOfSliceOnCpuWhenLastRunning + 1];
      if (!nextRunningSlice) return undefined;
      if (Math.abs(nextRunningSlice.start - cpuSliceWhenLastRunning.end) <
          0.00001) {
        return nextRunningSlice;
      }
      return undefined;
    }
  };

  tr.model.EventRegistry.register(
      ThreadTimeSlice,
      {
        name: 'threadTimeSlice',
        pluralName: 'threadTimeSlices'
      });


  return {
    ThreadTimeSlice,
    SCHEDULING_STATE,
  };
});


'use strict';

/**
 * @fileoverview Provides the CpuSlice class.
 */
tr.exportTo('tr.model', function() {
  const Slice = tr.model.Slice;

  /**
   * A CpuSlice represents a slice of time on a CPU.
   *
   * @constructor
   */
  function CpuSlice(cat, title, colorId, start, args, opt_duration) {
    Slice.apply(this, arguments);
    this.threadThatWasRunning = undefined;
    this.cpu = undefined;
  }

  CpuSlice.prototype = {
    __proto__: Slice.prototype,

    get analysisTypeName() {
      return 'tr.ui.analysis.CpuSlice';
    },

    getAssociatedTimeslice() {
      if (!this.threadThatWasRunning) {
        return undefined;
      }
      const timeSlices = this.threadThatWasRunning.timeSlices;
      for (let i = 0; i < timeSlices.length; i++) {
        const timeSlice = timeSlices[i];
        if (timeSlice.start !== this.start) {
          continue;
        }
        if (timeSlice.duration !== this.duration) {
          continue;
        }
        return timeSlice;
      }
      return undefined;
    }
  };

  tr.model.EventRegistry.register(
      CpuSlice,
      {
        name: 'cpuSlice',
        pluralName: 'cpuSlices'
      });

  return {
    CpuSlice,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * A snapshot of an object instance, at a given moment in time.
   *
   * Initialization of snapshots and instances is three phased:
   *
   * 1. Instances and snapshots are constructed. This happens during event
   *    importing. Little should be done here, because the object's data
   *    are still being used by the importer to reconstruct object references.
   *
   * 2. Instances and snapshtos are preinitialized. This happens after implicit
   *    objects have been found, but before any references have been found and
   *    switched to direct references. Thus, every snapshot stands on its own.
   *    This is a good time to do global field renaming and type conversion,
   *    e.g. recognizing domain-specific types and converting from C++ naming
   *    convention to JS.
   *
   * 3. Instances and snapshtos are initialized. At this point, {id_ref:
   *    '0x1000'} fields have been converted to snapshot references. This is a
   *    good time to generic initialization steps and argument verification.
   *
   * @constructor
   */
  function ObjectSnapshot(objectInstance, ts, args) {
    tr.model.Event.call(this);
    this.objectInstance = objectInstance;
    this.ts = ts;
    this.args = args;
  }

  ObjectSnapshot.prototype = {
    __proto__: tr.model.Event.prototype,

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize() {
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize() {
    },

    /**
     * Called when an object reference is resolved as this ObjectSnapshot.
     * @param {Object} item The event (async slice, slice or object) containing
     *     the resolved reference.
     * @param {Object} object The object directly containing the reference.
     * @param {String} field The field name of the reference in |object|.
     */
    referencedAt(item, object, field) {
    },

    addBoundsToRange(range) {
      range.addValue(this.ts);
    },

    get userFriendlyName() {
      return 'Snapshot of ' + this.objectInstance.userFriendlyName + ' @ ' +
             tr.b.Unit.byName.timeStampInMs.format(this.ts);
    }
  };

  tr.model.EventRegistry.register(
      ObjectSnapshot,
      {
        name: 'objectSnapshot',
        pluralName: 'objectSnapshots'
      });

  return {
    ObjectSnapshot,
  };
});


'use strict';

/**
 * @fileoverview Provides the ObjectSnapshot and ObjectHistory classes.
 */
tr.exportTo('tr.model', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * An object with a specific id, whose state has been snapshotted several
   * times.
   *
   * @constructor
   */
  function ObjectInstance(
      parent, scopedId, category, name, creationTs, opt_baseTypeName) {
    tr.model.Event.call(this);
    this.parent = parent;
    this.scopedId = scopedId;
    this.category = category;
    this.baseTypeName = opt_baseTypeName ? opt_baseTypeName : name;
    this.name = name;
    this.creationTs = creationTs;
    this.creationTsWasExplicit = false;
    this.deletionTs = Number.MAX_VALUE;
    this.deletionTsWasExplicit = false;
    this.colorId = 0;
    this.bounds = new tr.b.math.Range();
    this.snapshots = [];
    this.hasImplicitSnapshots = false;
  }

  ObjectInstance.prototype = {
    __proto__: tr.model.Event.prototype,

    get typeName() {
      return this.name;
    },

    addBoundsToRange(range) {
      range.addRange(this.bounds);
    },

    addSnapshot(ts, args, opt_name, opt_baseTypeName) {
      if (ts < this.creationTs) {
        throw new Error('Snapshots must be >= instance.creationTs');
      }
      if (ts >= this.deletionTs) {
        throw new Error('Snapshots cannot be added after ' +
                        'an objects deletion timestamp.');
      }

      let lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts === ts) {
          throw new Error('Snapshots already exists at this time!');
        }
        if (ts < lastSnapshot.ts) {
          throw new Error(
              'Snapshots must be added in increasing timestamp order');
        }
      }

      // Update baseTypeName if needed.
      if (opt_name &&
          (this.name !== opt_name)) {
        if (!opt_baseTypeName) {
          throw new Error('Must provide base type name for name update');
        }
        if (this.baseTypeName !== opt_baseTypeName) {
          throw new Error('Cannot update type name: base types dont match');
        }
        this.name = opt_name;
      }

      const snapshotConstructor =
          tr.model.ObjectSnapshot.subTypes.getConstructor(
              this.category, this.name);
      const snapshot = new snapshotConstructor(this, ts, args);
      this.snapshots.push(snapshot);
      return snapshot;
    },

    wasDeleted(ts) {
      let lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts > ts) {
          throw new Error(
              'Instance cannot be deleted at ts=' +
              ts + '. A snapshot exists that is older.');
        }
      }
      this.deletionTs = ts;
      this.deletionTsWasExplicit = true;
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize() {
      for (let i = 0; i < this.snapshots.length; i++) {
        this.snapshots[i].preInitialize();
      }
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize() {
      for (let i = 0; i < this.snapshots.length; i++) {
        this.snapshots[i].initialize();
      }
    },

    isAliveAt(ts) {
      if (ts < this.creationTs && this.creationTsWasExplicit) {
        return false;
      }
      if (ts > this.deletionTs) {
        return false;
      }

      return true;
    },

    getSnapshotAt(ts) {
      if (ts < this.creationTs) {
        if (this.creationTsWasExplicit) {
          throw new Error('ts must be within lifetime of this instance');
        }
        return this.snapshots[0];
      }
      if (ts > this.deletionTs) {
        throw new Error('ts must be within lifetime of this instance');
      }

      const snapshots = this.snapshots;
      const i = tr.b.findIndexInSortedIntervals(
          snapshots,
          function(snapshot) { return snapshot.ts; },
          function(snapshot, i) {
            if (i === snapshots.length - 1) {
              return snapshots[i].objectInstance.deletionTs;
            }
            return snapshots[i + 1].ts - snapshots[i].ts;
          },
          ts);
      if (i < 0) {
        // Note, this is a little bit sketchy: this lets early ts point at the
        // first snapshot, even before it is taken. We do this because raster
        // tasks usually post before their tile snapshots are dumped. This may
        // be a good line of code to re-visit if we start seeing strange and
        // confusing object references showing up in the traces.
        return this.snapshots[0];
      }
      if (i >= this.snapshots.length) {
        return this.snapshots[this.snapshots.length - 1];
      }
      return this.snapshots[i];
    },

    updateBounds() {
      this.bounds.reset();
      this.bounds.addValue(this.creationTs);
      if (this.deletionTs !== Number.MAX_VALUE) {
        this.bounds.addValue(this.deletionTs);
      } else if (this.snapshots.length > 0) {
        this.bounds.addValue(this.snapshots[this.snapshots.length - 1].ts);
      }
    },

    shiftTimestampsForward(amount) {
      this.creationTs += amount;
      if (this.deletionTs !== Number.MAX_VALUE) {
        this.deletionTs += amount;
      }
      this.snapshots.forEach(function(snapshot) {
        snapshot.ts += amount;
      });
    },

    get userFriendlyName() {
      return this.typeName + ' object ' + this.scopedId;
    }
  };

  tr.model.EventRegistry.register(
      ObjectInstance,
      {
        name: 'objectInstance',
        pluralName: 'objectInstances'
      });

  return {
    ObjectInstance,
  };
});


'use strict';

/**
 * @fileoverview Provides the TimeToObjectInstanceMap class.
 */
tr.exportTo('tr.model', function() {
  /**
   * Tracks all the instances associated with a given ID over its lifetime.
   *
   * A scoped id can be used multiple times throughout a trace, referring to
   * different objects at different times. This data structure does the
   * bookkeeping to figure out what ObjectInstance is referred to at a given
   * timestamp.
   *
   * @constructor
   */
  function TimeToObjectInstanceMap(
      createObjectInstanceFunction, parent, scopedId) {
    this.createObjectInstanceFunction_ = createObjectInstanceFunction;
    this.parent = parent;
    this.scopedId = scopedId;
    this.instances = [];
  }

  TimeToObjectInstanceMap.prototype = {
    idWasCreated(category, name, ts) {
      if (this.instances.length === 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.scopedId, category, name, ts));
        this.instances[0].creationTsWasExplicit = true;
        return this.instances[0];
      }

      let lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.deletionTs) {
        throw new Error('Mutation of the TimeToObjectInstanceMap must be ' +
                        'done in ascending timestamp order.');
      }
      lastInstance = this.createObjectInstanceFunction_(
          this.parent, this.scopedId, category, name, ts);
      lastInstance.creationTsWasExplicit = true;
      this.instances.push(lastInstance);
      return lastInstance;
    },

    addSnapshot(category, name, ts, args, opt_baseTypeName) {
      if (this.instances.length === 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.scopedId, category, name, ts, opt_baseTypeName));
      }

      const i = tr.b.findIndexInSortedIntervals(
          this.instances,
          function(inst) { return inst.creationTs; },
          function(inst) { return inst.deletionTs - inst.creationTs; },
          ts);

      let instance;
      if (i < 0) {
        instance = this.instances[0];
        if (ts > instance.deletionTs ||
            instance.creationTsWasExplicit) {
          throw new Error(
              'At the provided timestamp, no instance was still alive');
        }

        if (instance.snapshots.length !== 0) {
          throw new Error(
              'Cannot shift creationTs forward, ' +
              'snapshots have been added. First snap was at ts=' +
              instance.snapshots[0].ts + ' and creationTs was ' +
              instance.creationTs);
        }
        instance.creationTs = ts;
      } else if (i >= this.instances.length) {
        instance = this.instances[this.instances.length - 1];
        if (ts >= instance.deletionTs) {
          // The snap is added after our oldest and deleted instance. This means
          // that this is a new implicit instance.
          instance = this.createObjectInstanceFunction_(
              this.parent, this.scopedId, category, name, ts, opt_baseTypeName);
          this.instances.push(instance);
        } else {
          // If the ts is before the last objects deletion time, then the caller
          // is trying to add a snapshot when there may have been an instance
          // alive. In that case, try to move an instance's creationTs to
          // include this ts, provided that it has an implicit creationTs.

          // Search backward from the right for an instance that was definitely
          // deleted before this ts. Any time an instance is found that has a
          // moveable creationTs
          let lastValidIndex;
          for (let i = this.instances.length - 1; i >= 0; i--) {
            const tmp = this.instances[i];
            if (ts >= tmp.deletionTs) break;
            if (tmp.creationTsWasExplicit === false &&
                tmp.snapshots.length === 0) {
              lastValidIndex = i;
            }
          }
          if (lastValidIndex === undefined) {
            throw new Error(
                'Cannot add snapshot. No instance was alive that was mutable.');
          }
          instance = this.instances[lastValidIndex];
          instance.creationTs = ts;
        }
      } else {
        instance = this.instances[i];
      }

      return instance.addSnapshot(ts, args, name, opt_baseTypeName);
    },

    get lastInstance() {
      if (this.instances.length === 0) return undefined;
      return this.instances[this.instances.length - 1];
    },

    idWasDeleted(category, name, ts) {
      if (this.instances.length === 0) {
        this.instances.push(this.createObjectInstanceFunction_(
            this.parent, this.scopedId, category, name, ts));
      }
      let lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.creationTs) {
        throw new Error('Cannot delete an id before it was created');
      }
      if (lastInstance.deletionTs === Number.MAX_VALUE) {
        lastInstance.wasDeleted(ts);
        return lastInstance;
      }

      if (ts < lastInstance.deletionTs) {
        throw new Error('id was already deleted earlier.');
      }

      // A new instance was deleted with no snapshots in-between.
      // Create an instance then kill it.
      lastInstance = this.createObjectInstanceFunction_(
          this.parent, this.scopedId, category, name, ts);
      this.instances.push(lastInstance);
      lastInstance.wasDeleted(ts);
      return lastInstance;
    },

    getInstanceAt(ts) {
      const i = tr.b.findIndexInSortedIntervals(
          this.instances,
          function(inst) { return inst.creationTs; },
          function(inst) { return inst.deletionTs - inst.creationTs; },
          ts);
      if (i < 0) {
        if (this.instances[0].creationTsWasExplicit) {
          return undefined;
        }
        return this.instances[0];
      } else if (i >= this.instances.length) {
        return undefined;
      }
      return this.instances[i];
    }
  };

  return {
    TimeToObjectInstanceMap,
  };
});


'use strict';

/**
 * @fileoverview Provides the ObjectCollection class.
 */
tr.exportTo('tr.model', function() {
  const ObjectInstance = tr.model.ObjectInstance;
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * A collection of object instances and their snapshots, accessible by id and
   * time, or by object name.
   *
   * @constructor
   */
  function ObjectCollection(parent) {
    tr.model.EventContainer.call(this);
    this.parent = parent;
    // scope -> {id -> TimeToObjectInstanceMap}
    this.instanceMapsByScopedId_ = {};
    this.instancesByTypeName_ = {};
    this.createObjectInstance_ = this.createObjectInstance_.bind(this);
  }

  ObjectCollection.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    * childEvents() {
      for (const instance of this.getAllObjectInstances()) {
        yield instance;
        yield* instance.snapshots;
      }
    },

    createObjectInstance_(
        parent, scopedId, category, name, creationTs, opt_baseTypeName) {
      const constructor = tr.model.ObjectInstance.subTypes.getConstructor(
          category, name);
      const instance = new constructor(
          parent, scopedId, category, name, creationTs, opt_baseTypeName);
      const typeName = instance.typeName;
      let instancesOfTypeName = this.instancesByTypeName_[typeName];
      if (!instancesOfTypeName) {
        instancesOfTypeName = [];
        this.instancesByTypeName_[typeName] = instancesOfTypeName;
      }
      instancesOfTypeName.push(instance);
      return instance;
    },

    getOrCreateInstanceMap_(scopedId) {
      let dict;
      if (scopedId.scope in this.instanceMapsByScopedId_) {
        dict = this.instanceMapsByScopedId_[scopedId.scope];
      } else {
        dict = {};
        this.instanceMapsByScopedId_[scopedId.scope] = dict;
      }
      let instanceMap = dict[scopedId.id];
      if (instanceMap) return instanceMap;
      instanceMap = new tr.model.TimeToObjectInstanceMap(
          this.createObjectInstance_, this.parent, scopedId);
      dict[scopedId.id] = instanceMap;
      return instanceMap;
    },

    idWasCreated(scopedId, category, name, ts) {
      const instanceMap = this.getOrCreateInstanceMap_(scopedId);
      return instanceMap.idWasCreated(category, name, ts);
    },

    addSnapshot(
        scopedId, category, name, ts, args, opt_baseTypeName) {
      const instanceMap = this.getOrCreateInstanceMap_(scopedId);
      const snapshot = instanceMap.addSnapshot(
          category, name, ts, args, opt_baseTypeName);
      if (snapshot.objectInstance.category !== category) {
        const msg = 'Added snapshot name=' + name + ' with cat=' + category +
            ' impossible. It instance was created/snapshotted with cat=' +
            snapshot.objectInstance.category + ' name=' +
            snapshot.objectInstance.name;
        throw new Error(msg);
      }
      if (opt_baseTypeName &&
          snapshot.objectInstance.baseTypeName !== opt_baseTypeName) {
        throw new Error('Could not add snapshot with baseTypeName=' +
                        opt_baseTypeName + '. It ' +
                        'was previously created with name=' +
                        snapshot.objectInstance.baseTypeName);
      }
      if (snapshot.objectInstance.name !== name) {
        throw new Error('Could not add snapshot with name=' + name + '. It ' +
                        'was previously created with name=' +
                        snapshot.objectInstance.name);
      }
      return snapshot;
    },

    idWasDeleted(scopedId, category, name, ts) {
      const instanceMap = this.getOrCreateInstanceMap_(scopedId);
      const deletedInstance = instanceMap.idWasDeleted(category, name, ts);
      if (!deletedInstance) return;

      if (deletedInstance.category !== category) {
        const msg = 'Deleting object ' + deletedInstance.name +
            ' with a different category ' +
            'than when it was created. It previous had cat=' +
            deletedInstance.category + ' but the delete command ' +
            'had cat=' + category;
        throw new Error(msg);
      }
      if (deletedInstance.baseTypeName !== name) {
        throw new Error('Deletion requested for name=' +
                        name + ' could not proceed: ' +
                        'An existing object with baseTypeName=' +
                        deletedInstance.baseTypeName + ' existed.');
      }
    },

    autoDeleteObjects(maxTimestamp) {
      for (const imapById of Object.values(this.instanceMapsByScopedId_)) {
        for (const i2imap of Object.values(imapById)) {
          const lastInstance = i2imap.lastInstance;
          if (lastInstance.deletionTs !== Number.MAX_VALUE) continue;
          i2imap.idWasDeleted(
              lastInstance.category, lastInstance.name, maxTimestamp);
          // idWasDeleted will cause lastInstance.deletionTsWasExplicit to be
          // set to true. Unset it here.
          lastInstance.deletionTsWasExplicit = false;
        }
      }
    },

    getObjectInstanceAt(scopedId, ts) {
      let instanceMap;
      if (scopedId.scope in this.instanceMapsByScopedId_) {
        instanceMap = this.instanceMapsByScopedId_[scopedId.scope][scopedId.id];
      }
      if (!instanceMap) return undefined;
      return instanceMap.getInstanceAt(ts);
    },

    getSnapshotAt(scopedId, ts) {
      const instance = this.getObjectInstanceAt(scopedId, ts);
      if (!instance) return undefined;
      return instance.getSnapshotAt(ts);
    },

    iterObjectInstances(iter, opt_this) {
      opt_this = opt_this || this;
      for (const imapById of Object.values(this.instanceMapsByScopedId_)) {
        for (const i2imap of Object.values(imapById)) {
          i2imap.instances.forEach(iter, opt_this);
        }
      }
    },

    getAllObjectInstances() {
      const instances = [];
      this.iterObjectInstances(function(i) { instances.push(i); });
      return instances;
    },

    getAllInstancesNamed(name) {
      return this.instancesByTypeName_[name];
    },

    getAllInstancesByTypeName() {
      return this.instancesByTypeName_;
    },

    preInitializeAllObjects() {
      this.iterObjectInstances(function(instance) {
        instance.preInitialize();
      });
    },

    initializeAllObjects() {
      this.iterObjectInstances(function(instance) {
        instance.initialize();
      });
    },

    initializeInstances() {
      this.iterObjectInstances(function(instance) {
        instance.initialize();
      });
    },

    updateBounds() {
      this.bounds.reset();
      this.iterObjectInstances(function(instance) {
        instance.updateBounds();
        this.bounds.addRange(instance.bounds);
      }, this);
    },

    shiftTimestampsForward(amount) {
      this.iterObjectInstances(function(instance) {
        instance.shiftTimestampsForward(amount);
      });
    },

    addCategoriesToDict(categoriesDict) {
      this.iterObjectInstances(function(instance) {
        categoriesDict[instance.category] = true;
      });
    }
  };

  return {
    ObjectCollection,
  };
});


'use strict';

/**
 * @fileoverview Provides the AsyncSlice class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A AsyncSlice represents an interval of time during which an
   * asynchronous operation is in progress. An AsyncSlice consumes no CPU time
   * itself and so is only associated with Threads at its start and end point.
   *
   * @constructor
   */
  function AsyncSlice(category, title, colorId, start, args, duration,
      opt_isTopLevel, opt_cpuStart, opt_cpuDuration,
      opt_argsStripped) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    // We keep the original title from the trace file in originalTitle since
    // some sub-classes, e.g. NetAsyncSlice, change the title field.
    this.originalTitle = title;
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.important = false;
    this.subSlices = [];
    this.parentContainer_ = undefined;

    this.id = undefined;
    this.startThread = undefined;
    this.endThread = undefined;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
    this.argsStripped = false;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    this.duration = duration;

    // isTopLevel is set at import because only NESTABLE_ASYNC events might not
    // be topLevel. All legacy async events are toplevel by definition.
    this.isTopLevel = (opt_isTopLevel === true);

    if (opt_cpuStart !== undefined) {
      this.cpuStart = opt_cpuStart;
    }

    if (opt_cpuDuration !== undefined) {
      this.cpuDuration = opt_cpuDuration;
    }

    if (opt_argsStripped !== undefined) {
      this.argsStripped = opt_argsStripped;
    }
  }

  AsyncSlice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get analysisTypeName() {
      return this.title;
    },

    get parentContainer() {
      return this.parentContainer_;
    },

    set parentContainer(parentContainer) {
      this.parentContainer_ = parentContainer;
      for (let i = 0; i < this.subSlices.length; i++) {
        const subSlice = this.subSlices[i];
        if (subSlice.parentContainer === undefined) {
          subSlice.parentContainer = parentContainer;
        }
      }
    },

    get viewSubGroupTitle() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Async slice ' + this.title + ' at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      const parentAsyncSliceGroup = this.parentContainer.asyncSliceGroup;
      return parentAsyncSliceGroup.stableId + '.' +
          parentAsyncSliceGroup.slices.indexOf(this);
    },

    * findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this) {
      if (eventPredicate(this)) {
        yield this;
        return;
      }
      for (const s of this.subSlices) {
        yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
      }
    },

    findDescendentSlice(targetTitle) {
      if (!this.subSlices) return undefined;

      for (let i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title === targetTitle) {
          return this.subSlices[i];
        }
        const slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    * enumerateAllDescendents() {
      for (const slice of this.subSlices) {
        yield slice;
      }
      for (const slice of this.subSlices) {
        yield* slice.enumerateAllDescendents();
      }
    },

    compareTo(that) {
      return this.title.localeCompare(that.title);
    }
  };

  tr.model.EventRegistry.register(
      AsyncSlice,
      {
        name: 'asyncSlice',
        pluralName: 'asyncSlices'
      });


  return {
    AsyncSlice,
  };
});


'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A group of AsyncSlices associated with a thread.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function AsyncSliceGroup(parentContainer, opt_name) {
    tr.model.EventContainer.call(this);
    this.parentContainer_ = parentContainer;
    this.slices = [];
    this.name_ = opt_name;
    this.viewSubGroups_ = undefined;
  }

  AsyncSliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.parent.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.AsyncSliceGroup';
    },

    getSettingsKey() {
      if (!this.name_) return undefined;
      const parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name_;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push(slice) {
      slice.parentContainer = this.parentContainer;
      this.slices.push(slice);
      return slice;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified, including all nested subSlices if there are any.
     */
    shiftTimestampsForward(amount) {
      for (let sI = 0; sI < this.slices.length; sI++) {
        const slice = this.slices[sI];
        slice.start = (slice.start + amount);
        // Shift all nested subSlices recursively.
        const shiftSubSlices = function(subSlices) {
          if (subSlices === undefined || subSlices.length === 0) return;
          for (let sJ = 0; sJ < subSlices.length; sJ++) {
            subSlices[sJ].start += amount;
            shiftSubSlices(subSlices[sJ].subSlices);
          }
        };
        shiftSubSlices(slice.subSlices);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds() {
      this.bounds.reset();
      for (let i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    /**
     * Closes any open slices.
     * @param {Number=} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices() {
      const maxTimestamp = this.parentContainer_.parent.model.bounds.max;
      function autoClose(slice) {
        slice.duration = maxTimestamp - slice.start;
        for (const sub of slice.subSlices) {
          autoClose(sub);
        }
      }
      for (let i = 0; i < this.slices.length; i++) {
        const slice = this.slices[i];
        if (!slice.didNotFinish) continue;
        autoClose(slice);
      }
    },

    /**
     * Gets the sub-groups in this A-S-G defined by the group titles.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * slices that started on the same thread.
     */
    get viewSubGroups() {
      if (this.viewSubGroups_ === undefined) {
        let prefix = '';
        if (this.name !== undefined) {
          prefix = this.name + '.';
        } else {
          prefix = '';
        }

        const subGroupsByTitle = {};
        for (let i = 0; i < this.slices.length; ++i) {
          const slice = this.slices[i];
          const subGroupTitle = slice.viewSubGroupTitle;
          if (!subGroupsByTitle[subGroupTitle]) {
            subGroupsByTitle[subGroupTitle] = new AsyncSliceGroup(
                this.parentContainer_, prefix + subGroupTitle);
          }
          subGroupsByTitle[subGroupTitle].push(slice);
        }
        this.viewSubGroups_ = Object.values(subGroupsByTitle);
        this.viewSubGroups_.sort(function(a, b) {
          return a.slices[0].compareTo(b.slices[0]);
        });
      }
      return this.viewSubGroups_;
    },

    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
      for (const slice of this.slices) {
        if (slice.isTopLevel) {
          yield* slice.findTopmostSlicesRelativeToThisSlice(
              eventPredicate, opt_this);
        }
      }
    },

    * childEvents() {
      // Async slices normally don't have sub-slices, and when they do,
      // the sub-slice is specific to the type of async slice. Thus,
      // it is not expected for sub-slices to themselves have sub-sub-slices,
      // which is why we don't recurse into the sub-slices here.
      for (const slice of this.slices) {
        yield slice;
        if (slice.subSlices) {
          yield* slice.subSlices;
        }
      }
    },

    * childEventContainers() {
    }
  };

  return {
    AsyncSliceGroup,
  };
});


'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
tr.exportTo('tr.model', function() {
  const Slice = tr.model.Slice;

  /**
   * A ThreadSlice represents an interval of time on a thread resource
   * with associated nesting slice information.
   *
   * ThreadSlices are typically associated with a specific trace event pair on a
   * specific thread.
   * For example,
   *   TRACE_EVENT_BEGIN1("x","myArg", 7) at time=0.1ms
   *   TRACE_EVENT_END0()                 at time=0.3ms
   * This results in a single slice from 0.1 with duration 0.2 on a
   * specific thread.
   *
   * @constructor
   */
  function ThreadSlice(cat, title, colorId, start, args, opt_duration,
      opt_cpuStart, opt_cpuDuration, opt_argsStripped,
      opt_bindId) {
    Slice.call(this, cat, title, colorId, start, args, opt_duration,
        opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId);
    // Do not modify this directly.
    // subSlices is configured by SliceGroup.rebuildSubRows_.
    this.subSlices = [];
  }

  ThreadSlice.prototype = {
    __proto__: Slice.prototype,

    get overlappingSamples() {
      const samples = new tr.model.EventSet();
      if (!this.parentContainer || !this.parentContainer.samples) {
        return samples;
      }
      this.parentContainer.samples.forEach(function(sample) {
        if (this.start <= sample.start && sample.start <= this.end) {
          samples.push(sample);
        }
      }, this);
      return samples;
    }
  };

  tr.model.EventRegistry.register(
      ThreadSlice,
      {
        name: 'slice',
        pluralName: 'slices'
      });

  return {
    ThreadSlice,
  };
});


'use strict';

/**
 * @fileoverview Provides the SliceGroup class.
 */
tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;
  const ThreadSlice = tr.model.ThreadSlice;

  function getSliceLo(s) {
    return s.start;
  }

  function getSliceHi(s) {
    return s.end;
  }

  /**
   * A group of Slices, plus code to create them from B/E events, as
   * well as arrange them into subRows.
   *
   * Do not mutate the slices array directly. Modify it only by
   * SliceGroup mutation methods.
   *
   * @constructor
   * @param {function(new:Slice, category, title, colorId, start, args)=}
   *     opt_sliceConstructor The constructor to use when creating slices.
   * @extends {tr.model.EventContainer}
   */
  function SliceGroup(parentContainer, opt_sliceConstructor, opt_name) {
    tr.model.EventContainer.call(this);

    this.parentContainer_ = parentContainer;

    const sliceConstructor = opt_sliceConstructor || ThreadSlice;
    this.sliceConstructor = sliceConstructor;
    this.sliceConstructorSubTypes = this.sliceConstructor.subTypes;
    if (!this.sliceConstructorSubTypes) {
      throw new Error('opt_sliceConstructor must have a subtype registry.');
    }

    this.openPartialSlices_ = [];

    this.slices = [];
    this.topLevelSlices = [];
    this.haveTopLevelSlicesBeenBuilt = false;
    this.name_ = opt_name;

    if (this.model === undefined) {
      throw new Error('SliceGroup must have model defined.');
    }
  }

  SliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.SliceGroup';
    },

    getSettingsKey() {
      if (!this.name_) return undefined;
      const parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     * @param {Slice} slice The slice to be added to the slices array.
     */
    pushSlice(slice) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slice.parentContainer = this.parentContainer_;
      this.slices.push(slice);
      return slice;
    },

    /**
     * Helper function that pushes the provided slices onto the slices array.
     * @param {Array.<Slice>} slices An array of slices to be added.
     */
    pushSlices(slices) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slices.forEach(function(slice) {
        slice.parentContainer = this.parentContainer_;
        this.slices.push(slice);
      }, this);
    },

    /**
     * Opens a new slice in the group's slices.
     *
     * Calls to beginSlice and
     * endSlice must be made with non-monotonically-decreasing timestamps.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see base/color_scheme.html).
     */
    beginSlice(category, title, ts, opt_args, opt_tts,
        opt_argsStripped, opt_colorId) {
      if (this.openPartialSlices_.length) {
        const prevSlice = this.openPartialSlices_[
            this.openPartialSlices_.length - 1];
        if (ts < prevSlice.start) {
          throw new Error('Slices must be added in increasing timestamp order');
        }
      }

      const colorId = opt_colorId ||
          ColorScheme.getColorIdForGeneralPurposeString(title);
      const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      const sliceType = sliceConstructorSubTypes.getConstructor(
          category, title);
      const slice = new sliceType(category, title, colorId, ts,
                                opt_args ? opt_args : {}, null,
                                opt_tts, undefined,
                                opt_argsStripped);
      this.openPartialSlices_.push(slice);
      slice.didNotFinish = true;
      this.pushSlice(slice);

      return slice;
    },

    isTimestampValidForBeginOrEnd(ts) {
      if (!this.openPartialSlices_.length) return true;
      const top = this.openPartialSlices_[this.openPartialSlices_.length - 1];
      return ts >= top.start;
    },

    /**
     * @return {Number} The number of beginSlices for which an endSlice has not
     * been issued.
     */
    get openSliceCount() {
      return this.openPartialSlices_.length;
    },

    get mostRecentlyOpenedPartialSlice() {
      if (!this.openPartialSlices_.length) return undefined;
      return this.openPartialSlices_[this.openPartialSlices_.length - 1];
    },

    /**
     * Ends the last begun slice in this group and pushes it onto the slice
     * array.
     *
     * @param {Number} ts Timestamp when the slice ended
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see base/color_scheme.html).
     * @return {Slice} slice.
     */
    endSlice(ts, opt_tts, opt_colorId) {
      if (!this.openSliceCount) {
        throw new Error('endSlice called without an open slice');
      }

      const slice = this.openPartialSlices_[this.openSliceCount - 1];
      this.openPartialSlices_.splice(this.openSliceCount - 1, 1);
      if (ts < slice.start) {
        throw new Error('Slice ' + slice.title +
                        ' end time is before its start.');
      }

      slice.duration = ts - slice.start;
      slice.didNotFinish = false;
      slice.colorId = opt_colorId || slice.colorId;

      if (opt_tts && slice.cpuStart !== undefined) {
        slice.cpuDuration = opt_tts - slice.cpuStart;
      }

      return slice;
    },

    /**
     * Push a complete event as a Slice into the slice list.
     * The timestamp can be in any order.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Number} duration The duration of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, as defined by
     * its palette id (see base/color_scheme.html).
     */
    pushCompleteSlice(category, title, ts, duration, tts,
        cpuDuration, opt_args, opt_argsStripped,
        opt_colorId, opt_bindId) {
      const colorId = opt_colorId ||
          ColorScheme.getColorIdForGeneralPurposeString(title);
      const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      const sliceType = sliceConstructorSubTypes.getConstructor(
          category, title);
      const slice = new sliceType(category, title, colorId, ts,
                                opt_args ? opt_args : {},
                                duration, tts, cpuDuration,
                                opt_argsStripped, opt_bindId);
      if (duration === undefined) {
        slice.didNotFinish = true;
      }
      this.pushSlice(slice);
      return slice;
    },

    /**
     * Closes any open slices.
     * @param {Number=} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices() {
      this.updateBounds();
      const maxTimestamp = this.bounds.max;
      for (let sI = 0; sI < this.slices.length; sI++) {
        const slice = this.slices[sI];
        if (slice.didNotFinish) {
          slice.duration = maxTimestamp - slice.start;
        }
      }
      this.openPartialSlices_ = [];
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified.
     */
    shiftTimestampsForward(amount) {
      for (let sI = 0; sI < this.slices.length; sI++) {
        const slice = this.slices[sI];
        slice.start = (slice.start + amount);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds() {
      this.bounds.reset();
      for (let i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    copySlice(slice) {
      const sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      const sliceType = sliceConstructorSubTypes.getConstructor(slice.category,
          slice.title);
      const newSlice = new sliceType(slice.category, slice.title,
          slice.colorId, slice.start,
          slice.args, slice.duration, slice.cpuStart, slice.cpuDuration);
      newSlice.didNotFinish = slice.didNotFinish;
      return newSlice;
    },

    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
      if (!this.haveTopLevelSlicesBeenBuilt) {
        throw new Error('Nope');
      }

      for (const s of this.topLevelSlices) {
        yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
      }
    },

    * childEvents() {
      yield* this.slices;
    },

    * childEventContainers() {
    },

    getSlicesOfName(title) {
      const slices = [];
      for (let i = 0; i < this.slices.length; i++) {
        if (this.slices[i].title === title) {
          slices.push(this.slices[i]);
        }
      }
      return slices;
    },

    iterSlicesInTimeRange(callback, start, end) {
      const ret = [];
      tr.b.iterateOverIntersectingIntervals(
          this.topLevelSlices,
          function(s) { return s.start; },
          function(s) { return s.duration; },
          start,
          end,
          function(topLevelSlice) {
            callback(topLevelSlice);
            for (const slice of topLevelSlice.enumerateAllDescendents()) {
              callback(slice);
            }
          });
      return ret;
    },

    findFirstSlice() {
      if (!this.haveTopLevelSlicesBeenBuilt) {
        throw new Error('Nope');
      }
      if (0 === this.slices.length) return undefined;
      return this.slices[0];
    },

    findSliceAtTs(ts) {
      if (!this.haveTopLevelSlicesBeenBuilt) throw new Error('Nope');
      let i = tr.b.findIndexInSortedClosedIntervals(
          this.topLevelSlices,
          getSliceLo, getSliceHi,
          ts);
      if (i === -1 || i === this.topLevelSlices.length) {
        return undefined;
      }

      let curSlice = this.topLevelSlices[i];

      // Now recurse on slice looking for subSlice of given ts.
      while (true) {
        i = tr.b.findIndexInSortedClosedIntervals(
            curSlice.subSlices,
            getSliceLo, getSliceHi,
            ts);
        if (i === -1 || i === curSlice.subSlices.length) {
          return curSlice;
        }
        curSlice = curSlice.subSlices[i];
      }
    },

    findNextSliceAfter(ts, refGuid) {
      let i = tr.b.findLowIndexInSortedArray(this.slices, getSliceLo, ts);
      if (i === this.slices.length) {
        return undefined;
      }
      for (; i < this.slices.length; i++) {
        const slice = this.slices[i];
        if (slice.start > ts) return slice;
        if (slice.guid <= refGuid) continue;
        return slice;
      }
      return undefined;
    },

    /**
     * This function assumes that if any slice has a cpu duration then
     * then the group is considered to have cpu duration.
     */
    hasCpuDuration_() {
      if (this.slices.some(function(slice) {
        return slice.cpuDuration !== undefined;
      })) return true;
      return false;
    },

    /**
     * Construct subSlices for this group.
     * Populate the group topLevelSlices, parent slices get a subSlices[],
     * a selfThreadTime and a selfTime, child slices get a parentSlice
     * reference.
     */
    createSubSlices() {
      this.haveTopLevelSlicesBeenBuilt = true;
      this.createSubSlicesImpl_();
      // If another source has cpu time, we can augment the cpuDuration of the
      // slices in the group with that cpu time. This should be done only if
      // the original source does not include cpuDuration.
      if (!this.hasCpuDuration_() && this.parentContainer.timeSlices) {
        this.addCpuTimeToSubslices_(this.parentContainer.timeSlices);
      }
      this.slices.forEach(function(slice) {
        let selfTime = slice.duration;
        for (let i = 0; i < slice.subSlices.length; i++) {
          selfTime -= slice.subSlices[i].duration;
        }
        slice.selfTime = selfTime;

        if (slice.cpuDuration === undefined) return;

        let cpuSelfTime = slice.cpuDuration;
        for (let i = 0; i < slice.subSlices.length; i++) {
          if (slice.subSlices[i].cpuDuration !== undefined) {
            cpuSelfTime -= slice.subSlices[i].cpuDuration;
          }
        }
        slice.cpuSelfTime = cpuSelfTime;
      });
    },
    createSubSlicesImpl_() {
      const precisionUnit = this.model.intrinsicTimeUnit;


      // Note that this doesn't check whether |child| should be added to
      // |parent|'s descendant slices instead of |parent| directly.
      function addSliceIfBounds(parent, child) {
        if (parent.bounds(child, precisionUnit)) {
          child.parentSlice = parent;
          if (parent.subSlices === undefined) {
            parent.subSlices = [];
          }
          parent.subSlices.push(child);
          return true;
        }
        return false;
      }

      if (!this.slices.length) return;

      const ops = [];
      for (let i = 0; i < this.slices.length; i++) {
        if (this.slices[i].subSlices) {
          this.slices[i].subSlices.splice(0,
              this.slices[i].subSlices.length);
        }
        ops.push(i);
      }

      const originalSlices = this.slices;
      ops.sort(function(ix, iy) {
        const x = originalSlices[ix];
        const y = originalSlices[iy];
        if (x.start !== y.start) {
          return x.start - y.start;
        }

        // Elements get inserted into the slices array in order of when the
        // slices start. Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier
        // in the slices array (and thus ending earlier) start earlier.
        return ix - iy;
      });

      const slices = new Array(this.slices.length);
      for (let i = 0; i < ops.length; i++) {
        slices[i] = originalSlices[ops[i]];
      }

      // Actually build the subrows.
      let rootSlice = slices[0];
      this.topLevelSlices = [];
      this.topLevelSlices.push(rootSlice);
      rootSlice.isTopLevel = true;
      for (let i = 1; i < slices.length; i++) {
        const slice = slices[i];
        while (rootSlice !== undefined &&
               (!addSliceIfBounds(rootSlice, slice))) {
          rootSlice = rootSlice.parentSlice;
        }
        if (rootSlice === undefined) {
          this.topLevelSlices.push(slice);
          slice.isTopLevel = true;
        }
        rootSlice = slice;
      }

      // Keep the slices in sorted form.
      this.slices = slices;
    },
    addCpuTimeToSubslices_(timeSlices) {
      const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
      let sliceIdx = 0;
      timeSlices.forEach(function(timeSlice) {
        if (timeSlice.schedulingState === SCHEDULING_STATE.RUNNING) {
          while (sliceIdx < this.topLevelSlices.length) {
            if (this.addCpuTimeToSubslice_(this.topLevelSlices[sliceIdx],
                timeSlice)) {
              // The current top-level slice and children are fully
              // accounted for, proceed to next top-level slice.
              sliceIdx++;
            } else {
              // The current top-level runs beyond the time slice, break out
              // so we can potentially add more time slices to it
              break;
            }
          }
        }
      }, this);
    },
    /* Add run-time of this timeSlice to the passed in slice
     * and all of it's children (recursively).
     * Returns whether the slice ends before or at the end of the
     * time slice, signaling we are done with this slice.
     */
    addCpuTimeToSubslice_(slice, timeSlice) {
      // Make sure they overlap
      if (slice.start > timeSlice.end || slice.end < timeSlice.start) {
        return slice.end <= timeSlice.end;
      }

      // Compute actual overlap
      let duration = timeSlice.duration;
      if (slice.start > timeSlice.start) {
        duration -= slice.start - timeSlice.start;
      }
      if (timeSlice.end > slice.end) {
        duration -= timeSlice.end - slice.end;
      }

      if (slice.cpuDuration) {
        slice.cpuDuration += duration;
      } else {
        slice.cpuDuration = duration;
      }

      for (let i = 0; i < slice.subSlices.length; i++) {
        this.addCpuTimeToSubslice_(slice.subSlices[i], timeSlice);
      }

      return slice.end <= timeSlice.end;
    }
  };

  /**
   * Merge two slice groups.
   *
   * If the two groups do not nest properly some of the slices of groupB will
   * be split to accomodate the improper nesting.  This is done to accomodate
   * combined kernel and userland call stacks on Android.  Because userland
   * tracing is done by writing to the trace_marker file, the kernel calls
   * that get invoked as part of that write may not be properly nested with
   * the userland call trace.  For example the following sequence may occur:
   *
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   enter some_function
   *     kernel exit  sys_write
   *     ...
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   exit  some_function
   *     kernel exit  sys_write
   *
   * This is handled by splitting the sys_write call into two slices as
   * follows:
   *
   *     | sys_write |            some_function            | sys_write (cont.) |
   *                 | sys_write (cont.) |     | sys_write |
   *
   * The colorId of both parts of the split slices are kept the same, and the
   * " (cont.)" suffix is appended to the later parts of a split slice.
   *
   * The two input SliceGroups are not modified by this, and the merged
   * SliceGroup will contain a copy of each of the input groups' slices (those
   * copies may be split).
   */
  SliceGroup.merge = function(groupA, groupB) {
    // This is implemented by traversing the two slice groups in reverse
    // order.  The slices in each group are sorted by ascending end-time, so
    // we must do the traversal from back to front in order to maintain the
    // sorting.
    //
    // We traverse the two groups simultaneously, merging as we go.  At each
    // iteration we choose the group from which to take the next slice based
    // on which group's next slice has the greater end-time.  During this
    // traversal we maintain a stack of currently "open" slices for each input
    // group.  A slice is considered "open" from the time it gets reached in
    // our input group traversal to the time we reach an slice in this
    // traversal with an end-time before the start time of the "open" slice.
    //
    // Each time a slice from groupA is opened or closed (events corresponding
    // to the end-time and start-time of the input slice, respectively) we
    // split all of the currently open slices from groupB.

    if (groupA.openPartialSlices_.length > 0) {
      throw new Error('groupA has open partial slices');
    }

    if (groupB.openPartialSlices_.length > 0) {
      throw new Error('groupB has open partial slices');
    }

    if (groupA.parentContainer !== groupB.parentContainer) {
      throw new Error('Different parent threads. Cannot merge');
    }

    if (groupA.sliceConstructor !== groupB.sliceConstructor) {
      throw new Error('Different slice constructors. Cannot merge');
    }

    const result = new SliceGroup(groupA.parentContainer,
                                groupA.sliceConstructor,
                                groupA.name_);

    const slicesA = groupA.slices;
    const slicesB = groupB.slices;
    let idxA = 0;
    let idxB = 0;
    const openA = [];
    const openB = [];

    const splitOpenSlices = function(when) {
      for (let i = 0; i < openB.length; i++) {
        const oldSlice = openB[i];
        const oldEnd = oldSlice.end;
        if (when < oldSlice.start || oldEnd < when) {
          throw new Error('slice should not be split');
        }

        const newSlice = result.copySlice(oldSlice);
        newSlice.start = when;
        newSlice.duration = oldEnd - when;
        if (newSlice.title.indexOf(' (cont.)') === -1) {
          newSlice.title += ' (cont.)';
        }
        oldSlice.duration = when - oldSlice.start;
        openB[i] = newSlice;
        result.pushSlice(newSlice);
      }
    };

    const closeOpenSlices = function(upTo) {
      while (openA.length > 0 || openB.length > 0) {
        const nextA = openA[openA.length - 1];
        const nextB = openB[openB.length - 1];
        const endA = nextA && nextA.end;
        const endB = nextB && nextB.end;

        if ((endA === undefined || endA > upTo) &&
            (endB === undefined || endB > upTo)) {
          return;
        }

        if (endB === undefined || endA < endB) {
          splitOpenSlices(endA);
          openA.pop();
        } else {
          openB.pop();
        }
      }
    };

    while (idxA < slicesA.length || idxB < slicesB.length) {
      const sA = slicesA[idxA];
      const sB = slicesB[idxB];
      let nextSlice;
      let isFromB;

      if (sA === undefined || (sB !== undefined && sA.start > sB.start)) {
        nextSlice = result.copySlice(sB);
        isFromB = true;
        idxB++;
      } else {
        nextSlice = result.copySlice(sA);
        isFromB = false;
        idxA++;
      }

      closeOpenSlices(nextSlice.start);

      result.pushSlice(nextSlice);

      if (isFromB) {
        openB.push(nextSlice);
      } else {
        splitOpenSlices(nextSlice.start);
        openA.push(nextSlice);
      }
    }

    closeOpenSlices();

    return result;
  };

  return {
    SliceGroup,
  };
});


'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
tr.exportTo('tr.model', function() {
  const AsyncSlice = tr.model.AsyncSlice;
  const AsyncSliceGroup = tr.model.AsyncSliceGroup;
  const SliceGroup = tr.model.SliceGroup;
  const ThreadSlice = tr.model.ThreadSlice;
  const ThreadTimeSlice = tr.model.ThreadTimeSlice;

  /**
   * A Thread stores all the trace events collected for a particular
   * thread. We organize the synchronous slices on a thread by "subrows," where
   * subrow 0 has all the root slices, subrow 1 those nested 1 deep, and so on.
   * The asynchronous slices are stored in an AsyncSliceGroup object.
   *
   * The slices stored on a Thread should be instances of
   * ThreadSlice.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Thread(parent, tid) {
    if (!parent) {
      throw new Error('Parent must be provided.');
    }

    tr.model.EventContainer.call(this);
    this.parent = parent;
    this.sortIndex = 0;
    this.tid = tid;
    this.name = undefined;
    this.samples_ = undefined; // Set during createSubSlices

    this.sliceGroup = new SliceGroup(this, ThreadSlice, 'slices');
    this.timeSlices = undefined;
    this.kernelSliceGroup = new SliceGroup(
        this, ThreadSlice, 'kernel-slices');
    this.asyncSliceGroup = new AsyncSliceGroup(this, 'async-slices');
  }

  Thread.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get model() {
      return this.parent.model;
    },

    get stableId() {
      return this.parent.stableId + '.' + this.tid;
    },

    compareTo(that) {
      return Thread.compare(this, that);
    },

    * childEventContainers() {
      if (this.sliceGroup.length) {
        yield this.sliceGroup;
      }
      if (this.kernelSliceGroup.length) {
        yield this.kernelSliceGroup;
      }
      if (this.asyncSliceGroup.length) {
        yield this.asyncSliceGroup;
      }
    },

    * childEvents() {
      if (this.timeSlices) {
        yield* this.timeSlices;
      }
    },

    iterateAllPersistableObjects(cb) {
      cb(this);
      if (this.sliceGroup.length) {
        cb(this.sliceGroup);
      }
      this.asyncSliceGroup.viewSubGroups.forEach(cb);
    },

    /**
     * Shifts all the timestamps inside this thread forward by the amount
     * specified.
     */
    shiftTimestampsForward(amount) {
      this.sliceGroup.shiftTimestampsForward(amount);

      if (this.timeSlices) {
        for (let i = 0; i < this.timeSlices.length; i++) {
          const slice = this.timeSlices[i];
          slice.start += amount;
        }
      }

      this.kernelSliceGroup.shiftTimestampsForward(amount);
      this.asyncSliceGroup.shiftTimestampsForward(amount);
    },

    /**
     * Determines whether this thread is empty. If true, it usually implies
     * that it should be pruned from the model.
     */
    get isEmpty() {
      if (this.sliceGroup.length) return false;
      if (this.sliceGroup.openSliceCount) return false;
      if (this.timeSlices && this.timeSlices.length) return false;
      if (this.kernelSliceGroup.length) return false;
      if (this.asyncSliceGroup.length) return false;
      if (this.samples_.length) return false;
      return true;
    },

    /**
     * Updates the bounds based on the
     * current objects associated with the thread.
     */
    updateBounds() {
      this.bounds.reset();

      this.sliceGroup.updateBounds();
      this.bounds.addRange(this.sliceGroup.bounds);

      this.kernelSliceGroup.updateBounds();
      this.bounds.addRange(this.kernelSliceGroup.bounds);

      this.asyncSliceGroup.updateBounds();
      this.bounds.addRange(this.asyncSliceGroup.bounds);

      if (this.timeSlices && this.timeSlices.length) {
        this.bounds.addValue(this.timeSlices[0].start);
        this.bounds.addValue(
            this.timeSlices[this.timeSlices.length - 1].end);
      }

      if (this.samples_ && this.samples_.length) {
        this.bounds.addValue(this.samples_[0].start);
        this.bounds.addValue(
            this.samples_[this.samples_.length - 1].end);
      }
    },

    addCategoriesToDict(categoriesDict) {
      for (let i = 0; i < this.sliceGroup.length; i++) {
        categoriesDict[this.sliceGroup.slices[i].category] = true;
      }
      for (let i = 0; i < this.kernelSliceGroup.length; i++) {
        categoriesDict[this.kernelSliceGroup.slices[i].category] = true;
      }
      for (let i = 0; i < this.asyncSliceGroup.length; i++) {
        categoriesDict[this.asyncSliceGroup.slices[i].category] = true;
      }
      if (this.samples_) {
        for (let i = 0; i < this.samples_.length; i++) {
          categoriesDict[this.samples_[i].category] = true;
        }
      }
    },

    autoCloseOpenSlices() {
      this.sliceGroup.autoCloseOpenSlices();
      this.asyncSliceGroup.autoCloseOpenSlices();
      this.kernelSliceGroup.autoCloseOpenSlices();
    },

    mergeKernelWithUserland() {
      if (this.kernelSliceGroup.length > 0) {
        const newSlices = SliceGroup.merge(
            this.sliceGroup, this.kernelSliceGroup);
        this.sliceGroup.slices = newSlices.slices;
        this.kernelSliceGroup = new SliceGroup(this);
        this.updateBounds();
      }
    },

    createSubSlices() {
      this.sliceGroup.createSubSlices();
      this.samples_ = this.parent.model.samples.filter(sample =>
          sample.thread === this);
    },

    /**
     * @return {String} A user-friendly name for this thread.
     */
    get userFriendlyName() {
      return this.name || this.tid;
    },

    /**
     * @return {String} User friendly details about this thread.
     */
    get userFriendlyDetails() {
      return 'tid: ' + this.tid +
          (this.name ? ', name: ' + this.name : '');
    },

    getSettingsKey() {
      if (!this.name) return undefined;
      const parentKey = this.parent.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name;
    },

    getProcess() {
      return this.parent;
    },

    /*
     * Returns the index of the slice in the timeSlices array, or undefined.
     */
    indexOfTimeSlice(timeSlice) {
      const i = tr.b.findLowIndexInSortedArray(
          this.timeSlices,
          function(slice) { return slice.start; },
          timeSlice.start);
      if (this.timeSlices[i] !== timeSlice) return undefined;
      return i;
    },

    /*
     * Returns an object with the CPU number used as keys,
     * and the value of each key object is the amount of milliseconds spent
     * running on this CPU.
     * Additionally, stats.total contains the total time
     * spent running on all CPUs.
     */
    getCpuStatsForRange(range) {
      const stats = {};
      stats.total = 0;

      if (!this.timeSlices) return stats;

      function addStatsForSlice(threadTimeSlice) {
        const freqRange = tr.b.math.Range.fromExplicitRange(
            threadTimeSlice.start, threadTimeSlice.end);
        const intersection = freqRange.findIntersection(range);

        if (threadTimeSlice.schedulingState ===
            tr.model.SCHEDULING_STATE.RUNNING) {
          const cpu = threadTimeSlice.cpuOnWhichThreadWasRunning;
          if (!(cpu.cpuNumber in stats)) {
            stats[cpu.cpuNumber] = 0;
          }

          stats[cpu.cpuNumber] += intersection.duration;
          stats.total += intersection.duration;
        }
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices,
          function(x) { return x.start; },
          function(x) { return x.end; },
          range.min,
          range.max,
          addStatsForSlice);
      return stats;
    },

    getSchedulingStatsForRange(start, end) {
      const stats = {};

      if (!this.timeSlices) return stats;

      function addStatsForSlice(threadTimeSlice) {
        const overlapStart = Math.max(threadTimeSlice.start, start);
        const overlapEnd = Math.min(threadTimeSlice.end, end);
        const schedulingState = threadTimeSlice.schedulingState;

        if (!(schedulingState in stats)) stats[schedulingState] = 0;
        stats[schedulingState] += overlapEnd - overlapStart;
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices,
          function(x) { return x.start; },
          function(x) { return x.end; },
          start,
          end,
          addStatsForSlice);
      return stats;
    },

    get samples() {
      return this.samples_;
    },

    /**
     * Returns substring of this.name from beginning to the first numeric
     * character or the character '/'.
     *
     * Example:
     * ThreadName12      -> ThreadName
     * ThreadName/34123  -> ThreadName
     * ThreadName1/34123 -> ThreadName
     */
    get type() {
      const re = /^[^0-9|\/]+/;
      const matches = re.exec(this.name);
      if (matches && matches[0]) return matches[0];

      // If a thread is named 42GPU, let's not try to find its type.
      // We should fix the thread name.
      throw new Error('Could not determine thread type for thread name ' +
          this.name);
    }
  };

  /**
   * Comparison between threads that orders first by parent.compareTo,
   * then by names, then by tid.
   */
  Thread.compare = function(x, y) {
    let tmp = x.parent.compareTo(y.parent);
    if (tmp) return tmp;

    tmp = x.sortIndex - y.sortIndex;
    if (tmp) return tmp;

    if (x.name !== undefined) {
      if (y.name !== undefined) {
        tmp = x.name.localeCompare(y.name);
      } else {
        tmp = -1;
      }
    } else if (y.name !== undefined) {
      tmp = 1;
    }
    if (tmp) return tmp;

    return x.tid - y.tid;
  };

  return {
    Thread,
  };
});


'use strict';

/**
 * @fileoverview Provides the ProcessBase class.
 */
tr.exportTo('tr.model', function() {
  const Thread = tr.model.Thread;
  const Counter = tr.model.Counter;

  /**
   * The ProcessBase is a partial base class, upon which Kernel
   * and Process are built.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function ProcessBase(model) {
    if (!model) {
      throw new Error('Must provide a model');
    }
    tr.model.EventContainer.call(this);
    this.model = model;
    this.threads = {};
    this.counters = {};
    this.objects = new tr.model.ObjectCollection(this);
    this.sortIndex = 0;
  }

  ProcessBase.compare = function(x, y) {
    return x.sortIndex - y.sortIndex;
  };

  ProcessBase.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get stableId() {
      throw new Error('Not implemented');
    },

    * childEventContainers() {
      yield* Object.values(this.threads);
      yield* Object.values(this.counters);
      yield this.objects;
    },

    iterateAllPersistableObjects(cb) {
      cb(this);
      for (const tid in this.threads) {
        this.threads[tid].iterateAllPersistableObjects(cb);
      }
    },

    /**
     * Gets the number of threads in this process.
     */
    get numThreads() {
      let n = 0;
      for (const p in this.threads) {
        n++;
      }
      return n;
    },

    /**
     * Shifts all the timestamps inside this process forward by the amount
     * specified.
     */
    shiftTimestampsForward(amount) {
      for (const child of this.childEventContainers()) {
        child.shiftTimestampsForward(amount);
      }
    },

    /**
     * Closes any open slices.
     */
    autoCloseOpenSlices() {
      for (const tid in this.threads) {
        const thread = this.threads[tid];
        thread.autoCloseOpenSlices();
      }
    },

    autoDeleteObjects(maxTimestamp) {
      this.objects.autoDeleteObjects(maxTimestamp);
    },

    /**
     * Called by the model after finalizing imports,
     * but before joining refs.
     */
    preInitializeObjects() {
      this.objects.preInitializeAllObjects();
    },

    /**
     * Called by the model after joining refs.
     */
    initializeObjects() {
      this.objects.initializeAllObjects();
    },

    /**
     * Merge slices from the kernel with those from userland for each thread.
     */
    mergeKernelWithUserland() {
      for (const tid in this.threads) {
        const thread = this.threads[tid];
        thread.mergeKernelWithUserland();
      }
    },

    updateBounds() {
      this.bounds.reset();
      for (const tid in this.threads) {
        this.threads[tid].updateBounds();
        this.bounds.addRange(this.threads[tid].bounds);
      }
      for (const id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
      this.objects.updateBounds();
      this.bounds.addRange(this.objects.bounds);
    },

    addCategoriesToDict(categoriesDict) {
      for (const tid in this.threads) {
        this.threads[tid].addCategoriesToDict(categoriesDict);
      }
      for (const id in this.counters) {
        categoriesDict[this.counters[id].category] = true;
      }
      this.objects.addCategoriesToDict(categoriesDict);
    },

    findAllThreadsMatching(predicate, opt_this) {
      const threads = [];
      for (const tid in this.threads) {
        const thread = this.threads[tid];
        if (predicate.call(opt_this, thread)) {
          threads.push(thread);
        }
      }
      return threads;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed(name) {
      const threads = this.findAllThreadsMatching(function(thread) {
        if (!thread.name) return false;
        return thread.name === name;
      });
      return threads;
    },

    findAtMostOneThreadNamed(name) {
      const threads = this.findAllThreadsNamed(name);
      if (threads.length === 0) return undefined;
      if (threads.length > 1) {
        throw new Error('Expected no more than one ' + name);
      }
      return threads[0];
    },

    /**
     * Removes threads from the process that are fully empty.
     */
    pruneEmptyContainers() {
      const threadsToKeep = {};
      for (const tid in this.threads) {
        const thread = this.threads[tid];
        if (!thread.isEmpty) {
          threadsToKeep[tid] = thread;
        }
      }
      this.threads = threadsToKeep;
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * or undefined if it doesn't exist.
     */
    getThread(tid) {
      return this.threads[tid];
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * creating it if it doesn't exist.
     */
    getOrCreateThread(tid) {
      if (!this.threads[tid]) {
        this.threads[tid] = new Thread(this, tid);
      }
      return this.threads[tid];
    },

    /**
     * @return {Counter} The counter on this process with the given
     * category/name combination, creating it if it doesn't exist.
     */
    getOrCreateCounter(cat, name) {
      const id = cat + '.' + name;
      if (!this.counters[id]) {
        this.counters[id] = new Counter(this, id, cat, name);
      }
      return this.counters[id];
    },

    getSettingsKey() {
      throw new Error('Not implemented');
    },

    createSubSlices() {
      for (const tid in this.threads) {
        this.threads[tid].createSubSlices();
      }
    }
  };

  return {
    ProcessBase,
  };
});


'use strict';

/**
 * @fileoverview Provides the Cpu class.
 */
tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Counter = tr.model.Counter;
  const CpuSlice = tr.model.CpuSlice;

  /**
   * The Cpu represents a Cpu from the kernel's point of view.
   * @constructor
   */
  function Cpu(kernel, number) {
    if (kernel === undefined || number === undefined) {
      throw new Error('Missing arguments');
    }
    this.kernel = kernel;
    this.cpuNumber = number;
    this.slices = [];
    this.counters = {};
    this.bounds_ = new tr.b.math.Range();
    this.samples_ = undefined; // Set during createSubSlices

    // Start timestamp of the last active thread.
    this.lastActiveTimestamp_ = undefined;

    // Identifier of the last active thread. On Linux, it's a pid while on
    // Windows it's a thread id.
    this.lastActiveThread_ = undefined;

    // Name and arguments of the last active thread.
    this.lastActiveName_ = undefined;
    this.lastActiveArgs_ = undefined;
  }

  Cpu.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get samples() {
      return this.samples_;
    },

    get userFriendlyName() {
      return 'CPU ' + this.cpuNumber;
    },

    * findTopmostSlicesInThisContainer(eventPredicate, opt_this) {
      // All CpuSlices are toplevel since CpuSlices do not nest.
      for (const s of this.slices) {
        yield* s.findTopmostSlicesRelativeToThisSlice(
            eventPredicate, opt_this);
      }
    },

    * childEvents() {
      yield* this.slices;

      if (this.samples_) {
        yield* this.samples_;
      }
    },

    * childEventContainers() {
      yield* Object.values(this.counters);
    },

    /**
     * @return {Counter} The counter on this CPU with the given category/name
     * combination, creating it if it doesn't exist.
     */
    getOrCreateCounter(cat, name) {
      const id = cat + '.' + name;
      if (!this.counters[id]) {
        this.counters[id] = new Counter(this, id, cat, name);
      }
      return this.counters[id];
    },

    /**
     * @return {Counter} the counter on this CPU with the given category/name
     * combination, or undefined if it doesn't exist.
     */
    getCounter(cat, name) {
      const id = cat + '.' + name;
      if (!this.counters[id]) {
        return undefined;
      }
      return this.counters[id];
    },

    /**
     * Shifts all the timestamps inside this CPU forward by the amount
     * specified.
     */
    shiftTimestampsForward(amount) {
      for (let sI = 0; sI < this.slices.length; sI++) {
        this.slices[sI].start = (this.slices[sI].start + amount);
      }
      for (const id in this.counters) {
        this.counters[id].shiftTimestampsForward(amount);
      }
    },

    /**
     * Updates the range based on the current slices attached to the cpu.
     */
    updateBounds() {
      this.bounds_.reset();
      if (this.slices.length) {
        this.bounds_.addValue(this.slices[0].start);
        this.bounds_.addValue(this.slices[this.slices.length - 1].end);
      }
      for (const id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds_.addRange(this.counters[id].bounds);
      }
      if (this.samples_ && this.samples_.length) {
        this.bounds_.addValue(this.samples_[0].start);
        this.bounds_.addValue(
            this.samples_[this.samples_.length - 1].end);
      }
    },

    createSubSlices() {
      this.samples_ = this.kernel.model.samples.filter(function(sample) {
        return sample.cpu === this;
      }, this);
    },

    addCategoriesToDict(categoriesDict) {
      for (let i = 0; i < this.slices.length; i++) {
        categoriesDict[this.slices[i].category] = true;
      }
      for (const id in this.counters) {
        categoriesDict[this.counters[id].category] = true;
      }
      for (let i = 0; i < this.samples_.length; i++) {
        categoriesDict[this.samples_[i].category] = true;
      }
    },

    /*
     * Returns the index of the slice in the CPU's slices, or undefined.
     */
    indexOf(cpuSlice) {
      const i = tr.b.findLowIndexInSortedArray(
          this.slices,
          function(slice) { return slice.start; },
          cpuSlice.start);
      if (this.slices[i] !== cpuSlice) return undefined;
      return i;
    },

    /**
     * Closes the thread running on the CPU. |endTimestamp| is the timestamp
     * at which the thread was unscheduled. |args| is merged with the arguments
     * specified when the thread was initially scheduled.
     */
    closeActiveThread(endTimestamp, args) {
      // Don't generate a slice if the last active thread is the idle task.
      if (this.lastActiveThread_ === undefined ||
          this.lastActiveThread_ === 0) {
        return;
      }

      if (endTimestamp < this.lastActiveTimestamp_) {
        throw new Error('The end timestamp of a thread running on CPU ' +
                        this.cpuNumber + ' is before its start timestamp.');
      }

      // Merge |args| with |this.lastActiveArgs_|. If a key is in both
      // dictionaries, the value from |args| is used.
      for (const key in args) {
        this.lastActiveArgs_[key] = args[key];
      }

      const duration = endTimestamp - this.lastActiveTimestamp_;
      const slice = new tr.model.CpuSlice(
          '', this.lastActiveName_,
          ColorScheme.getColorIdForGeneralPurposeString(this.lastActiveName_),
          this.lastActiveTimestamp_,
          this.lastActiveArgs_,
          duration);
      slice.cpu = this;
      this.slices.push(slice);

      // Clear the last state.
      this.lastActiveTimestamp_ = undefined;
      this.lastActiveThread_ = undefined;
      this.lastActiveName_ = undefined;
      this.lastActiveArgs_ = undefined;
    },

    switchActiveThread(timestamp, oldThreadArgs, newThreadId,
        newThreadName, newThreadArgs) {
      // Close the previous active thread and generate a slice.
      this.closeActiveThread(timestamp, oldThreadArgs);

      // Keep track of the new thread.
      this.lastActiveTimestamp_ = timestamp;
      this.lastActiveThread_ = newThreadId;
      this.lastActiveName_ = newThreadName;
      this.lastActiveArgs_ = newThreadArgs;
    },

    /**
     * Returns the frequency statistics for this CPU;
     * the returned object contains the frequencies as keys,
     * and the duration at this frequency in milliseconds as the value,
     * for the range that was specified.
     */
    getFreqStatsForRange(range) {
      const stats = {};

      function addStatsForFreq(freqSample, index) {
        // Counters don't have an explicit end or duration;
        // calculate the end by looking at the starting point
        // of the next value in the series, or if that doesn't
        // exist, assume this frequency is held until the end.
        const freqEnd = (index < freqSample.series_.length - 1) ?
            freqSample.series_.samples_[index + 1].timestamp : range.max;

        const freqRange = tr.b.math.Range.fromExplicitRange(
            freqSample.timestamp, freqEnd);
        const intersection = freqRange.findIntersection(range);
        if (!(freqSample.value in stats)) {
          stats[freqSample.value] = 0;
        }
        stats[freqSample.value] += intersection.duration;
      }

      const freqCounter = this.getCounter('', 'Clock Frequency');
      if (freqCounter !== undefined) {
        const freqSeries = freqCounter.getSeries(0);
        if (!freqSeries) return;

        tr.b.iterateOverIntersectingIntervals(freqSeries.samples_,
            function(x) { return x.timestamp; },
            function(x, index) {
              if (index < freqSeries.length - 1) {
                return freqSeries.samples_[index + 1].timestamp;
              }
              return range.max;
            },
            range.min,
            range.max,
            addStatsForFreq);
      }

      return stats;
    }
  };

  /**
   * Comparison between processes that orders by cpuNumber.
   */
  Cpu.compare = function(x, y) {
    return x.cpuNumber - y.cpuNumber;
  };


  return {
    Cpu,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const Event = tr.model.Event;
  const EventRegistry = tr.model.EventRegistry;

  /**
   * A sample that contains a power measurement (in W).
   *
   * @constructor
   * @extends {Event}
   */
  function PowerSample(series, start, powerInW) {
    Event.call(this);

    this.series_ = series;
    this.start_ = parseFloat(start);
    this.powerInW_ = parseFloat(powerInW);
  }

  PowerSample.prototype = {
    __proto__: Event.prototype,

    get series() {
      return this.series_;
    },

    get start() {
      return this.start_;
    },

    set start(value) {
      this.start_ = value;
    },

    get powerInW() {
      return this.powerInW_;
    },

    set powerInW(value) {
      this.powerInW_ = value;
    },

    addBoundsToRange(range) {
      range.addValue(this.start);
    }
  };

  EventRegistry.register(
      PowerSample,
      {
        name: 'powerSample',
        pluralName: 'powerSamples'
      });

  return {
    PowerSample,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const PowerSample = tr.model.PowerSample;

  /**
   * A container holding a time series of power samples.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function PowerSeries(device) {
    tr.model.EventContainer.call(this);

    this.device_ = device;
    this.samples_ = [];
  }

  PowerSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get device() {
      return this.device_;
    },

    get samples() {
      return this.samples_;
    },

    get stableId() {
      return this.device_.stableId + '.PowerSeries';
    },

    /**
     * Adds a power sample to the series and returns it.
     *
     * Note: Samples must be added in chronological order.
     */
    addPowerSample(ts, val) {
      const sample = new PowerSample(this, ts, val);
      this.samples_.push(sample);
      return sample;
    },

    /**
     * Returns the total energy (in Joules) consumed between the specified
     * start and end timestamps (in milliseconds).
     */
    getEnergyConsumedInJ(start, end) {
      const measurementRange = tr.b.math.Range.fromExplicitRange(start, end);

      let energyConsumedInJ = 0;
      let startIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, start) - 1;
      const endIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, end);

      if (startIndex < 0) {
        startIndex = 0;
      }

      for (let i = startIndex; i < endIndex; i++) {
        const sample = this.samples[i];
        const nextSample = this.samples[i + 1];

        const sampleRange = new tr.b.math.Range();
        sampleRange.addValue(sample.start);
        sampleRange.addValue(nextSample ? nextSample.start : sample.start);

        const intersectionRangeInMs = measurementRange.findIntersection(
            sampleRange);

        const durationInS = tr.b.convertUnit(intersectionRangeInMs.duration,
            tr.b.UnitPrefixScale.METRIC.MILLI,
            tr.b.UnitPrefixScale.METRIC.NONE);

        energyConsumedInJ += durationInS * sample.powerInW;
      }

      return energyConsumedInJ;
    },

    getSamplesWithinRange(start, end) {
      const startIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, start);
      const endIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, end);
      return this.samples.slice(startIndex, endIndex);
    },

    shiftTimestampsForward(amount) {
      for (let i = 0; i < this.samples_.length; ++i) {
        this.samples_[i].start += amount;
      }
    },

    updateBounds() {
      this.bounds.reset();

      if (this.samples_.length === 0) return;

      this.bounds.addValue(this.samples_[0].start);
      this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
    },

    * childEvents() {
      yield* this.samples_;
    },
  };

  return {
    PowerSeries,
  };
});


'use strict';

/**
 * @fileoverview Provides the Device class.
 */
tr.exportTo('tr.model', function() {
  /**
   * Device represents the device-level objects in the model.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Device(model) {
    if (!model) {
      throw new Error('Must provide a model.');
    }

    tr.model.EventContainer.call(this);

    this.powerSeries_ = undefined;
    this.cpuUsageSeries_ = undefined;
    this.vSyncTimestamps_ = [];
  }

  Device.compare = function(x, y) {
    return x.guid - y.guid;
  };

  Device.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    compareTo(that) {
      return Device.compare(this, that);
    },

    get userFriendlyName() {
      return 'Device';
    },

    get userFriendlyDetails() {
      return 'Device';
    },

    get stableId() {
      return 'Device';
    },

    getSettingsKey() {
      return 'device';
    },

    get powerSeries() {
      return this.powerSeries_;
    },

    set powerSeries(powerSeries) {
      this.powerSeries_ = powerSeries;
    },

    get cpuUsageSeries() {
      return this.cpuUsageSeries_;
    },

    set cpuUsageSeries(cpuUsageSeries) {
      this.cpuUsageSeries_ = cpuUsageSeries;
    },

    get vSyncTimestamps() {
      return this.vSyncTimestamps_;
    },

    set vSyncTimestamps(value) {
      this.vSyncTimestamps_ = value;
    },

    updateBounds() {
      this.bounds.reset();
      for (const child of this.childEventContainers()) {
        child.updateBounds();
        this.bounds.addRange(child.bounds);
      }
    },

    shiftTimestampsForward(amount) {
      for (const child of this.childEventContainers()) {
        child.shiftTimestampsForward(amount);
      }

      for (let i = 0; i < this.vSyncTimestamps_.length; i++) {
        this.vSyncTimestamps_[i] += amount;
      }
    },

    addCategoriesToDict(categoriesDict) {
    },

    * childEventContainers() {
      if (this.powerSeries_) {
        yield this.powerSeries_;
      }
      if (this.cpuUsageSeries_) {
        yield this.cpuUsageSeries_;
      }
    }
  };

  return {
    Device,
  };
});


'use strict';

/**
 * @fileoverview Provides the Flow class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Flow represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function FlowEvent(category, id, title, colorId, start, args, opt_duration) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.args = args;

    this.id = id;

    this.startSlice = undefined;
    this.endSlice = undefined;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    if (opt_duration !== undefined) {
      this.duration = opt_duration;
    }
  }

  FlowEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get userFriendlyName() {
      return 'Flow event named ' + this.title + ' at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
    }
  };

  tr.model.EventRegistry.register(
      FlowEvent,
      {
        name: 'flowEvent',
        pluralName: 'flowEvents'
      });

  return {
    FlowEvent,
  };
});


'use strict';

/**
 * @fileoverview Class describing rendered frames.
 *
 * Because a frame is produced by multiple threads, it does not inherit from
 * TimedEvent, and has no duration.
 */
tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Statistics = tr.b.math.Statistics;

  const FRAME_PERF_CLASS = {
    GOOD: 'good',
    BAD: 'bad',
    TERRIBLE: 'terrible',
    NEUTRAL: 'generic_work'
  };

  /**
   * @constructor
   * @param {Array} associatedEvents Selection of events composing the frame.
   * @param {Array} threadTimeRanges Array of {thread, start, end}
   * for each thread, describing the critical path of the frame.
   */
  function Frame(associatedEvents, threadTimeRanges, opt_args) {
    tr.model.Event.call(this);

    this.threadTimeRanges = threadTimeRanges;
    this.associatedEvents = new tr.model.EventSet(associatedEvents);
    this.args = opt_args || {};

    this.title = 'Frame';
    this.start = Statistics.min(
        threadTimeRanges, function(x) { return x.start; });
    this.end = Statistics.max(
        threadTimeRanges, function(x) { return x.end; });
    this.totalDuration = Statistics.sum(
        threadTimeRanges, function(x) { return x.end - x.start; });

    this.perfClass = FRAME_PERF_CLASS.NEUTRAL;
  }

  Frame.prototype = {
    __proto__: tr.model.Event.prototype,

    set perfClass(perfClass) {
      this.colorId = ColorScheme.getColorIdForReservedName(perfClass);
      this.perfClass_ = perfClass;
    },

    get perfClass() {
      return this.perfClass_;
    },

    shiftTimestampsForward(amount) {
      this.start += amount;
      this.end += amount;

      for (let i = 0; i < this.threadTimeRanges.length; i++) {
        this.threadTimeRanges[i].start += amount;
        this.threadTimeRanges[i].end += amount;
      }
    },

    addBoundsToRange(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    }
  };

  tr.model.EventRegistry.register(
      Frame,
      {
        name: 'frame',
        pluralName: 'frames'
      });

  return {
    Frame,
    FRAME_PERF_CLASS,
  };
});


'use strict';

/**
 * @fileoverview Provides the ContainerMemoryDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * The ContainerMemoryDump represents an abstract container memory dump.
   * @constructor
   */
  function ContainerMemoryDump(start) {
    tr.model.TimedEvent.call(this, start);

    this.levelOfDetail = undefined;

    this.memoryAllocatorDumps_ = undefined;
    this.memoryAllocatorDumpsByFullName_ = undefined;
  }

  /**
   * Memory dump level of detail. See base::trace_event::MemoryDumpLevelOfDetail
   * in the Chromium repository.
   *
   * @enum
   */
  ContainerMemoryDump.LevelOfDetail = {
    BACKGROUND: 0,
    LIGHT: 1,
    DETAILED: 2
  };

  ContainerMemoryDump.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    shiftTimestampsForward(amount) {
      this.start += amount;
    },

    get memoryAllocatorDumps() {
      return this.memoryAllocatorDumps_;
    },

    set memoryAllocatorDumps(memoryAllocatorDumps) {
      this.memoryAllocatorDumps_ = memoryAllocatorDumps;
      this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
    },

    getMemoryAllocatorDumpByFullName(fullName) {
      if (this.memoryAllocatorDumps_ === undefined) return undefined;

      // Lazily generate the index if necessary.
      if (this.memoryAllocatorDumpsByFullName_ === undefined) {
        const index = {};
        function addDumpsToIndex(dumps) {
          dumps.forEach(function(dump) {
            index[dump.fullName] = dump;
            addDumpsToIndex(dump.children);
          });
        }
        addDumpsToIndex(this.memoryAllocatorDumps_);
        this.memoryAllocatorDumpsByFullName_ = index;
      }

      return this.memoryAllocatorDumpsByFullName_[fullName];
    },

    forceRebuildingMemoryAllocatorDumpByFullNameIndex() {
      // Clear the index and generate it lazily.
      this.memoryAllocatorDumpsByFullName_ = undefined;
    },

    iterateRootAllocatorDumps(fn, opt_this) {
      if (this.memoryAllocatorDumps === undefined) return;
      this.memoryAllocatorDumps.forEach(fn, opt_this || this);
    }
  };

  return {
    ContainerMemoryDump,
  };
});


'use strict';

/**
 * @fileoverview Provides the MemoryAllocatorDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * @constructor
   */
  function MemoryAllocatorDump(containerMemoryDump, fullName, opt_guid) {
    this.fullName = fullName;
    this.parent = undefined;
    this.children = [];

    // String -> Scalar.
    this.numerics = {};

    // String -> string.
    this.diagnostics = {};

    // The associated container memory dump.
    this.containerMemoryDump = containerMemoryDump;

    // Ownership relationship between memory allocator dumps.
    this.owns = undefined;
    this.ownedBy = [];

    // Map from sibling dumps (other children of this dump's parent) to the
    // proportion of this dump's size which they (or their descendants) own.
    this.ownedBySiblingSizes = new Map();

    // Retention relationship between memory allocator dumps.
    this.retains = [];
    this.retainedBy = [];

    // Weak memory allocator dumps are removed from the model after import in
    // tr.model.GlobalMemoryDump.removeWeakDumps(). See
    // base::trace_event::MemoryAllocatorDump::Flags::WEAK in the Chromium
    // codebase.
    this.weak = false;

    // A list of information about the memory allocator dump (e.g. about how
    // its fields were calculated). Each item should be an object with
    // a mandatory 'type' property and type-specific extra arguments (see
    // MemoryAllocatorDumpInfoType).
    this.infos = [];

    // For debugging purposes.
    this.guid = opt_guid;
  }

  /**
   * Size numeric names. Please refer to the Memory Dump Graph Metric
   * Calculation design document for more details (https://goo.gl/fKg0dt).
   */
  MemoryAllocatorDump.SIZE_NUMERIC_NAME = 'size';
  MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME = 'effective_size';
  MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME = 'resident_size';
  MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME =
      MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;

  MemoryAllocatorDump.prototype = {
    get name() {
      return this.fullName.substring(this.fullName.lastIndexOf('/') + 1);
    },

    get quantifiedName() {
      return '\'' + this.fullName + '\' in ' +
          this.containerMemoryDump.containerName;
    },

    getDescendantDumpByFullName(fullName) {
      return this.containerMemoryDump.getMemoryAllocatorDumpByFullName(
          this.fullName + '/' + fullName);
    },

    isDescendantOf(otherDump) {
      if (this === otherDump) return true;
      if (this.parent === undefined) return false;
      return this.parent.isDescendantOf(otherDump);
    },

    addNumeric(name, numeric) {
      if (!(numeric instanceof tr.b.Scalar)) {
        throw new Error('Numeric value must be an instance of Scalar.');
      }
      if (name in this.numerics) {
        throw new Error('Duplicate numeric name: ' + name + '.');
      }
      this.numerics[name] = numeric;
    },

    addDiagnostic(name, text) {
      if (typeof text !== 'string') {
        throw new Error('Diagnostic text must be a string.');
      }
      if (name in this.diagnostics) {
        throw new Error('Duplicate diagnostic name: ' + name + '.');
      }
      this.diagnostics[name] = text;
    },

    aggregateNumericsRecursively(opt_model) {
      const numericNames = new Set();

      // Aggregate descendants's numerics recursively and gather children's
      // numeric names.
      this.children.forEach(function(child) {
        child.aggregateNumericsRecursively(opt_model);
        for (const [item, value] of Object.entries(child.numerics)) {
          numericNames.add(item, value);
        }
      }, this);

      // Aggregate children's numerics.
      numericNames.forEach(function(numericName) {
        if (numericName === MemoryAllocatorDump.SIZE_NUMERIC_NAME ||
            numericName === MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME ||
            this.numerics[numericName] !== undefined) {
            // Don't aggregate size and effective size numerics. These are
            // calculated in GlobalMemoryDump.prototype.calculateSizes() and
            // GlobalMemoryDump.prototype.calculateEffectiveSizes respectively.
            // Also don't aggregate numerics that the parent already has.
          return;
        }

        this.numerics[numericName] = MemoryAllocatorDump.aggregateNumerics(
            this.children.map(function(child) {
              return child.numerics[numericName];
            }), opt_model);
      }, this);
    }
  };

  // TODO(petrcermak): Consider moving this to tr.v.Histogram.
  MemoryAllocatorDump.aggregateNumerics = function(numerics, opt_model) {
    let shouldLogWarning = !!opt_model;
    let aggregatedUnit = undefined;
    let aggregatedValue = 0;

    // Aggregate the units and sum up the values of the numerics.
    numerics.forEach(function(numeric) {
      if (numeric === undefined) return;

      const unit = numeric.unit;
      if (aggregatedUnit === undefined) {
        aggregatedUnit = unit;
      } else if (aggregatedUnit !== unit) {
        if (shouldLogWarning) {
          opt_model.importWarning({
            type: 'numeric_parse_error',
            message: 'Multiple units provided for numeric: \'' +
                aggregatedUnit.unitName + '\' and \'' + unit.unitName + '\'.'
          });
          shouldLogWarning = false;  // Don't log multiple warnings.
        }
        // Use the most generic unit when the numerics don't agree (best
        // effort).
        aggregatedUnit = tr.b.Unit.byName.unitlessNumber_smallerIsBetter;
      }

      aggregatedValue += numeric.value;
    }, this);

    if (aggregatedUnit === undefined) return undefined;

    return new tr.b.Scalar(aggregatedUnit, aggregatedValue);
  };

  /**
   * @constructor
   */
  function MemoryAllocatorDumpLink(source, target, opt_importance) {
    this.source = source;
    this.target = target;
    this.importance = opt_importance;
    this.size = undefined;
  }

  /**
   * Types of size numeric information.
   *
   * @enum
   */
  const MemoryAllocatorDumpInfoType = {
    // The provided size of a MemoryAllocatorDump was less than the aggregated
    // size of its children.
    //
    // Mandatory extra args:
    //   * providedSize: The inconsistent provided size.
    //   * dependencySize: The aggregated size of the children.
    PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN: 0,

    // The provided size of a MemoryAllocatorDump was less than the size of its
    // largest owner.
    //
    // Mandatory extra args:
    //   * providedSize: The inconsistent provided size.
    //   * dependencySize: The size of the largest owner.
    PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER: 1
  };

  return {
    MemoryAllocatorDump,
    MemoryAllocatorDumpLink,
    MemoryAllocatorDumpInfoType,
  };
});


'use strict';

/**
 * @fileoverview Provides the GlobalMemoryDump class.
 */
tr.exportTo('tr.model', function() {
  /**
   * The GlobalMemoryDump represents a simultaneous memory dump of all
   * processes.
   * @constructor
   */
  function GlobalMemoryDump(model, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.model = model;
    this.processMemoryDumps = {};
  }

  // Size numeric names.
  const SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
  const EFFECTIVE_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;

  // Size numeric info types.
  const MemoryAllocatorDumpInfoType = tr.model.MemoryAllocatorDumpInfoType;
  const PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN =
      MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN;
  const PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER =
      MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER;

  function getSize(dump) {
    const numeric = dump.numerics[SIZE_NUMERIC_NAME];
    if (numeric === undefined) return 0;
    return numeric.value;
  }

  function hasSize(dump) {
    return dump.numerics[SIZE_NUMERIC_NAME] !== undefined;
  }

  function optional(value, defaultValue) {
    if (value === undefined) return defaultValue;
    return value;
  }

  GlobalMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Global memory dump at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get containerName() {
      return 'global space';
    },

    finalizeGraph() {
      // 1. Transitively remove weak memory allocator dumps and all their
      // owners and descendants from the model. This must be performed before
      // any other steps.
      this.removeWeakDumps();

      // 2. Add ownership links from tracing MADs to descendants of malloc or
      // winheap MADs so that tracing would be automatically discounted from
      // them later (step 3).
      this.setUpTracingOverheadOwnership();

      // 3. Aggregate all other numerics of all MADs (*excluding* sizes and
      // effective sizes) and propagate numerics from global MADs to their
      // owners (*including* sizes and effective sizes). This step must be
      // carried out before the sizes of all MADs are calculated (step 3).
      // Otherwise, the propagated sizes of all MADs would not be aggregated.
      this.aggregateNumerics();

      // 4. Calculate the sizes of all memory allocator dumps (MADs). This step
      // requires that the memory allocator dump graph has been finalized (step
      // 1) and numerics were propagated from global MADs (step 2). Subsequent
      // modifications of the graph will most likely break the calculation
      // invariants.
      this.calculateSizes();

      // 5. Calculate the effective sizes of all MADs. This step requires that
      // the sizes of all MADs have already been calculated (step 3).
      this.calculateEffectiveSizes();

      // 6. Discount tracing from VM regions stats. This steps requires that
      // resident sizes (step 2) and sizes (step 3) of the tracing MADs have
      // already been calculated.
      this.discountTracingOverheadFromVmRegions();

      // 7. The above steps (especially steps 1 and 3) can create new memory
      // allocator dumps, so we force rebuilding the memory allocator dump
      // indices of all container memory dumps.
      this.forceRebuildingMemoryAllocatorDumpByFullNameIndices();
    },

    removeWeakDumps() {
      // Mark all transitive owners and children of weak memory allocator dumps
      // as weak.
      this.traverseAllocatorDumpsInDepthFirstPreOrder(function(dump) {
        if (dump.weak) return;
        if ((dump.owns !== undefined && dump.owns.target.weak) ||
            (dump.parent !== undefined && dump.parent.weak)) {
          dump.weak = true;
        }
      });

      function removeWeakDumpsFromListRecursively(dumps) {
        tr.b.inPlaceFilter(dumps, function(dump) {
          if (dump.weak) {
            // The dump is weak, so remove it. This will implicitly remove all
            // its descendants, which are also weak due to the initial marking
            // step.
            return false;
          }

          // This dump is non-weak, so keep it. Recursively remove its weak
          // descendants and ownership links from weak dumps instead.
          removeWeakDumpsFromListRecursively(dump.children);
          tr.b.inPlaceFilter(dump.ownedBy, function(ownershipLink) {
            return !ownershipLink.source.weak;
          });

          return true;
        });
      }

      this.iterateContainerDumps(function(containerDump) {
        const memoryAllocatorDumps = containerDump.memoryAllocatorDumps;
        if (memoryAllocatorDumps !== undefined) {
          removeWeakDumpsFromListRecursively(memoryAllocatorDumps);
        }
      });
    },

    /**
     * Calculate the size of all memory allocator dumps in the dump graph.
     *
     * The size refers to the allocated size of a (sub)component. It is a
     * natural extension of the optional size numeric provided by
     * MemoryAllocatorDump(s):
     *
     *   - If a MAD provides a size numeric, then its size is assumed to be
     *     equal to it.
     *   - If a MAD does not provide a size numeric, then its size is assumed
     *     to be the maximum of (1) the size of the largest owner of the MAD
     *     and (2) the aggregated size of the MAD's children.
     *
     * Metric motivation: "How big is a (sub)system?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     */
    calculateSizes() {
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateMemoryAllocatorDumpSize_.bind(this));
    },

    /**
     * Calculate the size of the given MemoryAllocatorDump. This method assumes
     * that the size of both the children and owners of the dump has already
     * been calculated.
     */
    calculateMemoryAllocatorDumpSize_(dump) {
      // This flag becomes true if the size numeric of the current dump should
      // be defined, i.e. if (1) the current dump's size numeric is defined,
      // (2) the size of at least one of its children is defined or (3) the
      // size of at least one of its owners is defined.
      let shouldDefineSize = false;

      // This helper function returns the value of the size numeric of the
      // given dependent memory allocator dump. If the numeric is defined, the
      // shouldDefineSize flag above is also set to true (because condition
      // (2) or (3) is satisfied). Otherwise, zero is returned (and the flag is
      // left unchanged).
      function getDependencySize(dependencyDump) {
        const numeric = dependencyDump.numerics[SIZE_NUMERIC_NAME];
        if (numeric === undefined) return 0;
        shouldDefineSize = true;
        return numeric.value;
      }

      // 1. Get the size provided by the dump. If present, define a function
      // for checking dependent size consistency (a dump must always be bigger
      // than all its children aggregated together and/or its largest owner).
      const sizeNumeric = dump.numerics[SIZE_NUMERIC_NAME];
      let size = 0;
      let checkDependencySizeIsConsistent = function() { /* no-op */ };
      if (sizeNumeric !== undefined) {
        size = sizeNumeric.value;
        shouldDefineSize = true;
        if (sizeNumeric.unit !== tr.b.Unit.byName.sizeInBytes_smallerIsBetter) {
          this.model.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Invalid unit of \'size\' numeric of memory allocator ' +
                'dump ' + dump.quantifiedName + ': ' +
                sizeNumeric.unit.unitName + '.'
          });
        }
        checkDependencySizeIsConsistent = function(
            dependencySize, dependencyInfoType, dependencyName) {
          if (size >= dependencySize) return;
          this.model.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Size provided by memory allocator dump \'' +
                dump.fullName + '\'' +
                tr.b.Unit.byName.sizeInBytes.format(size) +
                ') is less than ' + dependencyName + ' (' +
                tr.b.Unit.byName.sizeInBytes.format(dependencySize) + ').'
          });
          dump.infos.push({
            type: dependencyInfoType,
            providedSize: size,
            dependencySize
          });
        }.bind(this);
      }

      // 2. Aggregate size of children. The recursive function traverses all
      // descendants and ensures that double-counting due to ownership within a
      // subsystem is avoided.
      let aggregatedChildrenSize = 0;
      // Owned child dump name -> (Owner child dump name -> overlapping size).
      const allOverlaps = {};
      dump.children.forEach(function(childDump) {
        function aggregateDescendantDump(descendantDump) {
          // Don't count this descendant dump if it owns another descendant of
          // the current dump (would cause double-counting).
          const ownedDumpLink = descendantDump.owns;
          if (ownedDumpLink !== undefined &&
              ownedDumpLink.target.isDescendantOf(dump)) {
            // If the target owned dump is a descendant of a *different* child
            // of the the current dump (i.e. not childDump), then we remember
            // the ownership so that we could explain why the size of the
            // current dump is not equal to the sum of its children.
            let ownedChildDump = ownedDumpLink.target;
            while (ownedChildDump.parent !== dump) {
              ownedChildDump = ownedChildDump.parent;
            }
            if (childDump !== ownedChildDump) {
              const ownedBySiblingSize = getDependencySize(descendantDump);
              if (ownedBySiblingSize > 0) {
                const previousTotalOwnedBySiblingSize =
                    ownedChildDump.ownedBySiblingSizes.get(childDump) || 0;
                const updatedTotalOwnedBySiblingSize =
                    previousTotalOwnedBySiblingSize + ownedBySiblingSize;
                ownedChildDump.ownedBySiblingSizes.set(
                    childDump, updatedTotalOwnedBySiblingSize);
              }
            }
            return;
          }

          // If this descendant dump is a leaf node, add its size to the
          // aggregated size.
          if (descendantDump.children.length === 0) {
            aggregatedChildrenSize += getDependencySize(descendantDump);
            return;
          }

          // If this descendant dump is an intermediate node, recurse down into
          // its children. Note that the dump's size is NOT added because it is
          // an aggregate of its children (would cause double-counting).
          descendantDump.children.forEach(aggregateDescendantDump);
        }
        aggregateDescendantDump(childDump);
      });
      checkDependencySizeIsConsistent(
          aggregatedChildrenSize,
          PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN,
          'the aggregated size of its children');

      // 3. Calculate the largest owner size.
      let largestOwnerSize = 0;
      dump.ownedBy.forEach(function(ownershipLink) {
        const owner = ownershipLink.source;
        const ownerSize = getDependencySize(owner);
        largestOwnerSize = Math.max(largestOwnerSize, ownerSize);
      });
      checkDependencySizeIsConsistent(
          largestOwnerSize,
          PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER,
          'the size of its largest owner');

      // If neither the dump nor any of its dependencies (children and owners)
      // provide a size, do NOT add a zero size numeric.
      if (!shouldDefineSize) {
        // The rest of the pipeline relies on size being either a valid
        // Scalar, or undefined.
        delete dump.numerics[SIZE_NUMERIC_NAME];
        return;
      }

      // A dump must always be bigger than all its children aggregated
      // together and/or its largest owner.
      size = Math.max(size, aggregatedChildrenSize, largestOwnerSize);

      dump.numerics[SIZE_NUMERIC_NAME] = new tr.b.Scalar(
          tr.b.Unit.byName.sizeInBytes_smallerIsBetter, size);

      // Add a virtual child to make up for extra size of the dump with
      // respect to its children (if applicable).
      if (aggregatedChildrenSize < size &&
          dump.children !== undefined && dump.children.length > 0) {
        const virtualChild = new tr.model.MemoryAllocatorDump(
            dump.containerMemoryDump, dump.fullName + '/<unspecified>');
        virtualChild.parent = dump;
        dump.children.unshift(virtualChild);
        virtualChild.numerics[SIZE_NUMERIC_NAME] = new tr.b.Scalar(
            tr.b.Unit.byName.sizeInBytes_smallerIsBetter,
            size - aggregatedChildrenSize);
      }
    },

    /**
     * Calculate the effective size of all memory allocator dumps in the dump
     * graph.
     *
     * The effective size refers to the amount of memory a particular component
     * is using/consuming. In other words, every (reported) byte of used memory
     * is uniquely attributed to exactly one component. Consequently, unlike
     * size, effective size is cumulative, i.e. the sum of the effective sizes
     * of (top-level) components is equal to the total amount of (reported)
     * used memory.
     *
     * Metric motivation: "How much memory does a (sub)system use?" or "For how
     * much memory should a (sub)system be 'charged'?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     *
     * This method assumes that the size of all contained memory allocator
     * dumps has already been calculated [see calculateSizes()].
     */
    calculateEffectiveSizes() {
      // 1. Calculate not-owned and not-owning sub-sizes of all MADs
      // (depth-first post-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpSubSizes_.bind(this));

      // 2. Calculate owned and owning coefficients of owned and owner MADs
      // respectively (arbitrary traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpOwnershipCoefficient_.bind(this));

      // 3. Calculate cumulative owned and owning coefficients of all MADs
      // (depth-first pre-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPreOrder(
          this.calculateDumpCumulativeOwnershipCoefficient_.bind(this));

      // 4. Calculate the effective sizes of all MADs (depth-first post-order
      // traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(
          this.calculateDumpEffectiveSize_.bind(this));
    },

    /**
     * Calculate not-owned and not-owning sub-sizes of a memory allocator dump
     * from its children's (sub-)sizes.
     *
     * Not-owned sub-size refers to the aggregated memory of all children which
     * is not owned by other MADs. Conversely, not-owning sub-size is the
     * aggregated memory of all children which do not own another MAD. The
     * diagram below illustrates these two concepts:
     *
     *     ROOT 1                         ROOT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 1 (!)
     *     not-owning sub-size: 0 (!)     not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     PARENT 1   ===== owns =====>   PARENT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     CHILD 1                        CHILD 2
     *     size [given]: 4                size [given]: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     * This method assumes that (1) the size of the dump, its children, and its
     * owners [see calculateSizes()] and (2) the not-owned and not-owning
     * sub-sizes of both the children and owners of the dump have already been
     * calculated [depth-first post-order traversal].
     */
    calculateDumpSubSizes_(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      // If the dump is a leaf node, then both sub-sizes are equal to the size.
      if (dump.children === undefined || dump.children.length === 0) {
        const size = getSize(dump);
        dump.notOwningSubSize_ = size;
        dump.notOwnedSubSize_ = size;
        return;
      }

      // Calculate this dump's not-owning sub-size by summing up the not-owning
      // sub-sizes of children MADs which do not own another MAD.
      let notOwningSubSize = 0;
      dump.children.forEach(function(childDump) {
        if (childDump.owns !== undefined) return;
        notOwningSubSize += optional(childDump.notOwningSubSize_, 0);
      });
      dump.notOwningSubSize_ = notOwningSubSize;

      // Calculate this dump's not-owned sub-size.
      let notOwnedSubSize = 0;
      dump.children.forEach(function(childDump) {
        // If the child dump is not owned, then add its not-owned sub-size.
        if (childDump.ownedBy.length === 0) {
          notOwnedSubSize += optional(childDump.notOwnedSubSize_, 0);
          return;
        }
        // If the child dump is owned, then add the difference between its size
        // and the largest owner.
        let largestChildOwnerSize = 0;
        childDump.ownedBy.forEach(function(ownershipLink) {
          largestChildOwnerSize = Math.max(
              largestChildOwnerSize, getSize(ownershipLink.source));
        });
        notOwnedSubSize += getSize(childDump) - largestChildOwnerSize;
      });
      dump.notOwnedSubSize_ = notOwnedSubSize;
    },

    /**
     * Calculate owned and owning coefficients of a memory allocator dump and
     * its owners.
     *
     * The owning coefficient refers to the proportion of a dump's not-owning
     * sub-size which is attributed to the dump (only relevant to owning MADs).
     * Conversely, the owned coefficient is the proportion of a dump's
     * not-owned sub-size, which is attributed to it (only relevant to owned
     * MADs).
     *
     * The not-owned size of the owned dump is split among its owners in the
     * order of the ownership importance as demonstrated by the following
     * example:
     *
     *                                          memory allocator dumps
     *                                   OWNED  OWNER1  OWNER2  OWNER3  OWNER4
     *       not-owned sub-size [given]     10       -       -       -       -
     *      not-owning sub-size [given]      -       6       7       5       8
     *               importance [given]      -       2       2       1       0
     *    attributed not-owned sub-size      2       -       -       -       -
     *   attributed not-owning sub-size      -       3       4       0       1
     *                owned coefficient   2/10       -       -       -       -
     *               owning coefficient      -     3/6     4/7     0/5     1/8
     *
     * Explanation: Firstly, 6 bytes are split equally among OWNER1 and OWNER2
     * (highest importance). OWNER2 owns one more byte, so its attributed
     * not-owning sub-size is 6/2 + 1 = 4 bytes. OWNER3 is attributed no size
     * because it is smaller than the owners with higher priority. However,
     * OWNER4 is larger, so it's attributed the difference 8 - 7 = 1 byte.
     * Finally, 2 bytes remain unattributed and are hence kept in the OWNED
     * dump as attributed not-owned sub-size. The coefficients are then
     * directly calculated as fractions of the sub-sizes and corresponding
     * attributed sub-sizes.
     *
     * Note that we always assume that all ownerships of a dump overlap (e.g.
     * OWNER3 is subsumed by both OWNER1 and OWNER2). Hence, the table could
     * be alternatively represented as follows:
     *
     *                                 owned memory range
     *              0   1   2    3    4    5    6        7        8   9  10
     *   Priority 2 |  OWNER1 + OWNER2 (split)  | OWNER2 |
     *   Priority 1 | (already attributed) |
     *   Priority 0 | - - -  (already attributed)  - - - | OWNER4 |
     *    Remainder | - - - - - (already attributed) - - - - - -  | OWNED |
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()]
     * and (2) the not-owned size of the dump and not-owning sub-sizes of its
     * owners [see the first step of calculateEffectiveSizes()] have already
     * been calculated. Note that the method doesn't make any assumptions about
     * the order in which dumps are visited.
     */
    calculateDumpOwnershipCoefficient_(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      // We only need to consider owned dumps.
      if (dump.ownedBy.length === 0) return;

      // Sort the owners in decreasing order of ownership importance and
      // increasing order of not-owning sub-size (in case of equal importance).
      const owners = dump.ownedBy.map(function(ownershipLink) {
        return {
          dump: ownershipLink.source,
          importance: optional(ownershipLink.importance, 0),
          notOwningSubSize: optional(ownershipLink.source.notOwningSubSize_, 0)
        };
      });
      owners.sort(function(a, b) {
        if (a.importance === b.importance) {
          return a.notOwningSubSize - b.notOwningSubSize;
        }
        return b.importance - a.importance;
      });

      // Loop over the list of owners and distribute the owned dump's not-owned
      // sub-size among them according to their ownership importance and
      // not-owning sub-size.
      let currentImportanceStartPos = 0;
      let alreadyAttributedSubSize = 0;
      while (currentImportanceStartPos < owners.length) {
        const currentImportance = owners[currentImportanceStartPos].importance;

        // Find the position of the first owner with lower priority.
        let nextImportanceStartPos = currentImportanceStartPos + 1;
        while (nextImportanceStartPos < owners.length &&
               owners[nextImportanceStartPos].importance ===
                  currentImportance) {
          nextImportanceStartPos++;
        }

        // Visit the owners with the same importance in increasing order of
        // not-owned sub-size, split the owned memory among them appropriately,
        // and calculate their owning coefficients.
        let attributedNotOwningSubSize = 0;
        for (let pos = currentImportanceStartPos; pos < nextImportanceStartPos;
             pos++) {
          const owner = owners[pos];
          const notOwningSubSize = owner.notOwningSubSize;
          if (notOwningSubSize > alreadyAttributedSubSize) {
            attributedNotOwningSubSize +=
                (notOwningSubSize - alreadyAttributedSubSize) /
                (nextImportanceStartPos - pos);
            alreadyAttributedSubSize = notOwningSubSize;
          }

          let owningCoefficient = 0;
          if (notOwningSubSize !== 0) {
            owningCoefficient = attributedNotOwningSubSize / notOwningSubSize;
          }
          owner.dump.owningCoefficient_ = owningCoefficient;
        }

        currentImportanceStartPos = nextImportanceStartPos;
      }

      // Attribute the remainder of the owned dump's not-owned sub-size to
      // the dump itself and calculate its owned coefficient.
      const notOwnedSubSize = optional(dump.notOwnedSubSize_, 0);
      const remainderSubSize = notOwnedSubSize - alreadyAttributedSubSize;
      let ownedCoefficient = 0;
      if (notOwnedSubSize !== 0) {
        ownedCoefficient = remainderSubSize / notOwnedSubSize;
      }
      dump.ownedCoefficient_ = ownedCoefficient;
    },

    /**
     * Calculate cumulative owned and owning coefficients of a memory allocator
     * dump from its (non-cumulative) owned and owning coefficients and the
     * cumulative coefficients of its parent and/or owned dump.
     *
     * The cumulative coefficients represent the total effect of all
     * (non-strict) ancestor ownerships on a memory allocator dump. The
     * cumulative owned coefficient of a MAD can be calculated simply as:
     *
     *   cumulativeOwnedC(M) = ownedC(M) * cumulativeOwnedC(parent(M))
     *
     * This reflects the assumption that if a parent of a child MAD is
     * (partially) owned, then the parent's owner also indirectly owns (a part
     * of) the child MAD.
     *
     * The cumulative owning coefficient of a MAD depends on whether the MAD
     * owns another dump:
     *
     *                           [if M doesn't own another MAD]
     *                         / cumulativeOwningC(parent(M))
     *   cumulativeOwningC(M) =
     *                         \ [if M owns another MAD]
     *                           owningC(M) * cumulativeOwningC(owned(M))
     *
     * The reasoning behind the first case is similar to the one for cumulative
     * owned coefficient above. The only difference is that we don't need to
     * include the dump's (non-cumulative) owning coefficient because it is
     * implicitly 1.
     *
     * The formula for the second case is derived as follows: Since the MAD
     * owns another dump, its memory is not included in its parent's not-owning
     * sub-size and hence shouldn't be affected by the parent's corresponding
     * cumulative coefficient. Instead, the MAD indirectly owns everything
     * owned by its owned dump (and so it should be affected by the
     * corresponding coefficient).
     *
     * Note that undefined coefficients (and coefficients of non-existent
     * dumps) are implicitly assumed to be 1.
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()],
     * (2) the (non-cumulative) owned and owning coefficients of the dump [see
     * the second step of calculateEffectiveSizes()], and (3) the cumulative
     * coefficients of the dump's parent and owned MADs (if present)
     * [depth-first pre-order traversal] have already been calculated.
     */
    calculateDumpCumulativeOwnershipCoefficient_(dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      let cumulativeOwnedCoefficient = optional(dump.ownedCoefficient_, 1);
      const parent = dump.parent;
      if (dump.parent !== undefined) {
        cumulativeOwnedCoefficient *= dump.parent.cumulativeOwnedCoefficient_;
      }
      dump.cumulativeOwnedCoefficient_ = cumulativeOwnedCoefficient;

      let cumulativeOwningCoefficient;
      if (dump.owns !== undefined) {
        cumulativeOwningCoefficient = dump.owningCoefficient_ *
            dump.owns.target.cumulativeOwningCoefficient_;
      } else if (dump.parent !== undefined) {
        cumulativeOwningCoefficient = dump.parent.cumulativeOwningCoefficient_;
      } else {
        cumulativeOwningCoefficient = 1;
      }
      dump.cumulativeOwningCoefficient_ = cumulativeOwningCoefficient;
    },

    /**
     * Calculate the effective size of a memory allocator dump.
     *
     * In order to simplify the (already complex) calculation, we use the fact
     * that effective size is cumulative (unlike regular size), i.e. the
     * effective size of a non-leaf node is equal to the sum of effective sizes
     * of its children. The effective size of a leaf MAD is calculated as:
     *
     *   effectiveSize(M) = size(M) * cumulativeOwningC(M) * cumulativeOwnedC(M)
     *
     * This method assumes that (1) the size of the dump and its children [see
     * calculateSizes()] and (2) the cumulative owning and owned coefficients
     * of the dump (if it's a leaf node) [see the third step of
     * calculateEffectiveSizes()] or the effective sizes of its children (if
     * it's a non-leaf node) [depth-first post-order traversal] have already
     * been calculated.
     */
    calculateDumpEffectiveSize_(dump) {
      // Completely skip dumps with undefined size. As a result, each dump will
      // have defined effective size if and only if it has defined size.
      if (!hasSize(dump)) {
        // The rest of the pipeline relies on effective size being either a
        // valid Scalar, or undefined.
        delete dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME];
        return;
      }

      let effectiveSize;
      if (dump.children === undefined || dump.children.length === 0) {
        // Leaf dump.
        effectiveSize = getSize(dump) * dump.cumulativeOwningCoefficient_ *
            dump.cumulativeOwnedCoefficient_;
      } else {
        // Non-leaf dump.
        effectiveSize = 0;
        dump.children.forEach(function(childDump) {
          if (!hasSize(childDump)) return;
          effectiveSize +=
              childDump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME].value;
        });
      }
      dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME] = new tr.b.Scalar(
          tr.b.Unit.byName.sizeInBytes_smallerIsBetter, effectiveSize);
    },

    aggregateNumerics() {
      // 1. Aggregate numerics in this global memory dump.
      this.iterateRootAllocatorDumps(function(dump) {
        dump.aggregateNumericsRecursively(this.model);
      });

      // 2. Propagate numerics and diagnostics from global memory allocator
      // dumps to their owners.
      this.iterateRootAllocatorDumps(
          this.propagateNumericsAndDiagnosticsRecursively);

      // 3. Aggregate numerics in the associated process memory dumps.
      for (const processMemoryDump of Object.values(this.processMemoryDumps)) {
        processMemoryDump.iterateRootAllocatorDumps(function(dump) {
          dump.aggregateNumericsRecursively(this.model);
        }, this);
      }
    },

    propagateNumericsAndDiagnosticsRecursively(globalAllocatorDump) {
      ['numerics', 'diagnostics'].forEach(function(field) {
        for (const [name, value] of
            Object.entries(globalAllocatorDump[field])) {
          globalAllocatorDump.ownedBy.forEach(function(ownershipLink) {
            const processAllocatorDump = ownershipLink.source;
            if (processAllocatorDump[field][name] !== undefined) {
              // Numerics and diagnostics provided by process memory allocator
              // dumps themselves have precedence over numerics and diagnostics
              // propagated from global memory allocator dumps.
              return;
            }
            processAllocatorDump[field][name] = value;
          });
        }
      });

      // Recursively propagate numerics from all child memory allocator dumps.
      globalAllocatorDump.children.forEach(
          this.propagateNumericsAndDiagnosticsRecursively, this);
    },

    setUpTracingOverheadOwnership() {
      for (const dump of Object.values(this.processMemoryDumps)) {
        dump.setUpTracingOverheadOwnership(this.model);
      }
    },

    discountTracingOverheadFromVmRegions() {
      // TODO(petrcermak): Consider factoring out all the finalization code and
      // constants to a single file.
      for (const dump of Object.values(this.processMemoryDumps)) {
        dump.discountTracingOverheadFromVmRegions(this.model);
      }
    },

    forceRebuildingMemoryAllocatorDumpByFullNameIndices() {
      this.iterateContainerDumps(function(containerDump) {
        containerDump.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
      });
    },

    iterateContainerDumps(fn) {
      fn.call(this, this);
      for (const processDump of Object.values(this.processMemoryDumps)) {
        fn.call(this, processDump);
      }
    },

    iterateAllRootAllocatorDumps(fn) {
      this.iterateContainerDumps(function(containerDump) {
        containerDump.iterateRootAllocatorDumps(fn, this);
      });
    },

    /**
     * Traverse the memory dump graph in a depth first post-order, i.e.
     * children and owners of a memory allocator dump are visited before the
     * dump itself. This method will throw an exception if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPostOrder(fn) {
      const visitedDumps = new WeakSet();
      const openDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump)) return;

        if (openDumps.has(dump)) {
          throw new Error(dump.userFriendlyName + ' contains a cycle');
        }
        openDumps.add(dump);

        // Visit owners before the dumps they own.
        dump.ownedBy.forEach(function(ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children before parents.
        dump.children.forEach(visit, this);

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        openDumps.delete(dump);
      }

      this.iterateAllRootAllocatorDumps(visit);
    },

    /**
     * Traverse the memory dump graph in a depth first pre-order, i.e.
     * children and owners of a memory allocator dump are visited after the
     * dump itself. This method will not visit some dumps if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPreOrder(fn) {
      const visitedDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump)) return;

        // If this dumps owns another dump which hasn't been visited yet, then
        // wait for this dump to be visited later.
        if (dump.owns !== undefined && !visitedDumps.has(dump.owns.target)) {
          return;
        }

        // If this dump's parent hasn't been visited yet, then wait for this
        // dump to be visited later.
        if (dump.parent !== undefined && !visitedDumps.has(dump.parent)) {
          return;
        }

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        // Visit owners after the dumps they own.
        dump.ownedBy.forEach(function(ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children after parents.
        dump.children.forEach(visit, this);
      }

      this.iterateAllRootAllocatorDumps(visit);
    }
  };

  tr.model.EventRegistry.register(
      GlobalMemoryDump,
      {
        name: 'globalMemoryDump',
        pluralName: 'globalMemoryDumps'
      });

  return {
    GlobalMemoryDump,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const InstantEventType = {
    GLOBAL: 1,
    PROCESS: 2
  };

  /**
   * An InstantEvent is a zero-duration event.
   *
   * @constructor
   */
  function InstantEvent(category, title, colorId, start, args) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;

    this.type = undefined;
  }

  InstantEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype
  };

  /**
   * A GlobalInstantEvent is a zero-duration event that's not tied to any
   * particular process.
   *
   * An example is a trace event that's issued when a new USB device is plugged
   * into the machine.
   *
   * @constructor
   */
  function GlobalInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.GLOBAL;
  }

  GlobalInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,
    get userFriendlyName() {
      return 'Global instant event ' + this.title + ' @ ' +
          tr.b.Unit.byName.timeStampInMs.format(start);
    }
  };

  /**
   * A ProcessInstantEvent is a zero-duration event that's tied to a
   * particular process.
   *
   * An example is a trace event that's issued when a kill signal is received.
   *
   * @constructor
   */
  function ProcessInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.PROCESS;
  }

  ProcessInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,

    get userFriendlyName() {
      return 'Process-level instant event ' + this.title + ' @ ' +
          tr.b.Unit.byName.timeStampInMs.format(start);
    }
  };

  tr.model.EventRegistry.register(
      InstantEvent,
      {
        name: 'instantEvent',
        pluralName: 'instantEvents'
      });

  return {
    GlobalInstantEvent,
    ProcessInstantEvent,

    InstantEventType,
    InstantEvent,
  };
});


'use strict';

/**
 * @fileoverview Provides the Process class.
 */
tr.exportTo('tr.model', function() {
  const Cpu = tr.model.Cpu;
  const ProcessBase = tr.model.ProcessBase;

  /**
   * The Kernel represents kernel-level objects in the model.
   * @constructor
   */
  function Kernel(model) {
    ProcessBase.call(this, model);

    this.cpus = {};
    this.softwareMeasuredCpuCount_ = undefined;
  }

  /**
   * Comparison between kernels is pretty meaningless.
   */
  Kernel.compare = function(x, y) {
    return 0;
  };

  Kernel.prototype = {
    __proto__: ProcessBase.prototype,

    compareTo(that) {
      return Kernel.compare(this, that);
    },

    get userFriendlyName() {
      return 'Kernel';
    },

    get userFriendlyDetails() {
      return 'Kernel';
    },

    get stableId() {
      return 'Kernel';
    },

    /**
     * @return {Cpu} Gets a specific Cpu or creates one if
     * it does not exist.
     */
    getOrCreateCpu(cpuNumber) {
      if (!this.cpus[cpuNumber]) {
        this.cpus[cpuNumber] = new Cpu(this, cpuNumber);
      }
      return this.cpus[cpuNumber];
    },

    get softwareMeasuredCpuCount() {
      return this.softwareMeasuredCpuCount_;
    },

    set softwareMeasuredCpuCount(softwareMeasuredCpuCount) {
      if (this.softwareMeasuredCpuCount_ !== undefined &&
          this.softwareMeasuredCpuCount_ !== softwareMeasuredCpuCount) {
        throw new Error(
            'Cannot change the softwareMeasuredCpuCount once it is set');
      }

      this.softwareMeasuredCpuCount_ = softwareMeasuredCpuCount;
    },

    /**
     * Estimates how many cpus are in the system, for use in system load
     * estimation.
     *
     * If kernel trace was provided, uses that data. Otherwise, uses the
     * software measured cpu count.
     */
    get bestGuessAtCpuCount() {
      const realCpuCount = Object.keys(this.cpus).length;
      if (realCpuCount !== 0) {
        return realCpuCount;
      }
      return this.softwareMeasuredCpuCount;
    },

    updateBounds() {
      ProcessBase.prototype.updateBounds.call(this);
      for (const cpuNumber in this.cpus) {
        const cpu = this.cpus[cpuNumber];
        cpu.updateBounds();
        this.bounds.addRange(cpu.bounds);
      }
    },

    createSubSlices() {
      ProcessBase.prototype.createSubSlices.call(this);
      for (const cpuNumber in this.cpus) {
        const cpu = this.cpus[cpuNumber];
        cpu.createSubSlices();
      }
    },

    addCategoriesToDict(categoriesDict) {
      ProcessBase.prototype.addCategoriesToDict.call(this, categoriesDict);
      for (const cpuNumber in this.cpus) {
        this.cpus[cpuNumber].addCategoriesToDict(categoriesDict);
      }
    },

    getSettingsKey() {
      return 'kernel';
    },

    * childEventContainers() {
      yield* ProcessBase.prototype.childEventContainers.call(this);
      yield* Object.values(this.cpus);
    },
  };

  return {
    Kernel,
  };
});


'use strict';

/**
 * @fileoverview Provides the Event Index class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Event Index maps an id to all the events that have that particular id
   *
   * @constructor
   */
  function ModelIndices(model) {
    // For now the only indices we construct are for flowEvents
    this.flowEventsById_ = {};
    model.flowEvents.forEach(function(fe) {
      if (fe.id !== undefined) {
        if (!this.flowEventsById_.hasOwnProperty(fe.id)) {
          this.flowEventsById_[fe.id] = [];
        }
        this.flowEventsById_[fe.id].push(fe);
      }
    }, this);
  }

  ModelIndices.prototype = {
    addEventWithId(id, event) {
      if (!this.flowEventsById_.hasOwnProperty(id)) {
        this.flowEventsById_[id] = [];
      }
      this.flowEventsById_[id].push(event);
    },

    getFlowEventsWithId(id) {
      if (!this.flowEventsById_.hasOwnProperty(id)) {
        return [];
      }
      return this.flowEventsById_[id];
    }
  };

  return {
    ModelIndices,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * @constructor
   */
  function ModelStats() {
    this.traceEventCountsByKey_ = new Map();
    this.allTraceEventStats_ = [];

    this.traceEventStatsInTimeIntervals_ = new Map();
    this.allTraceEventStatsInTimeIntervals_ = [];

    this.hasEventSizesinBytes_ = false;

    this.traceImportDurationMs_ = undefined;
  }

  ModelStats.prototype = {
    TIME_INTERVAL_SIZE_IN_MS: 100,

    willProcessBasicTraceEvent(phase, category, title, ts,
        opt_eventSizeinBytes) {
      const key = phase + '/' + category + '/' + title;
      let eventStats = this.traceEventCountsByKey_.get(key);
      if (eventStats === undefined) {
        eventStats = {
          phase,
          category,
          title,
          numEvents: 0,
          totalEventSizeinBytes: 0
        };
        this.traceEventCountsByKey_.set(key, eventStats);
        this.allTraceEventStats_.push(eventStats);
      }
      eventStats.numEvents++;

      const timeIntervalKey = Math.floor(
          tr.b.Unit.timestampFromUs(ts) / this.TIME_INTERVAL_SIZE_IN_MS);
      let eventStatsByTimeInverval =
          this.traceEventStatsInTimeIntervals_.get(timeIntervalKey);
      if (eventStatsByTimeInverval === undefined) {
        eventStatsByTimeInverval = {
          timeInterval: timeIntervalKey,
          numEvents: 0,
          totalEventSizeinBytes: 0
        };
        this.traceEventStatsInTimeIntervals_.set(timeIntervalKey,
            eventStatsByTimeInverval);
        this.allTraceEventStatsInTimeIntervals_.push(eventStatsByTimeInverval);
      }
      eventStatsByTimeInverval.numEvents++;

      if (opt_eventSizeinBytes !== undefined) {
        this.hasEventSizesinBytes_ = true;
        eventStats.totalEventSizeinBytes += opt_eventSizeinBytes;
        eventStatsByTimeInverval.totalEventSizeinBytes += opt_eventSizeinBytes;
      }
    },

    get allTraceEventStats() {
      return this.allTraceEventStats_;
    },

    get allTraceEventStatsInTimeIntervals() {
      return this.allTraceEventStatsInTimeIntervals_;
    },

    get hasEventSizesinBytes() {
      return this.hasEventSizesinBytes_;
    },

    get traceImportDurationMs() {
      return this.traceImportDurationMs_;
    },

    set traceImportDurationMs(traceImportDurationMs) {
      this.traceImportDurationMs_ = traceImportDurationMs;
    }
  };

  return {
    ModelStats,
  };
});


'use strict';

/**
 * @fileoverview Provides classes for representing and classifying VM regions.
 *
 * See https://goo.gl/5SSPv0 for more details.
 */
tr.exportTo('tr.model', function() {
  /**
   * A single virtual memory region (also called a memory map).
   *
   * @constructor
   */
  function VMRegion(startAddress, sizeInBytes, protectionFlags,
      mappedFile, byteStats) {
    this.startAddress = startAddress;
    this.sizeInBytes = sizeInBytes;
    this.protectionFlags = protectionFlags;
    this.mappedFile = mappedFile || '';
    this.byteStats = byteStats || {};
  }

  VMRegion.PROTECTION_FLAG_READ = 4;
  VMRegion.PROTECTION_FLAG_WRITE = 2;
  VMRegion.PROTECTION_FLAG_EXECUTE = 1;
  VMRegion.PROTECTION_FLAG_MAYSHARE = 128;

  VMRegion.prototype = {
    get uniqueIdWithinProcess() {
      // This value is assumed to be unique within a process.
      return this.mappedFile + '#' + this.startAddress;
    },

    get protectionFlagsToString() {
      if (this.protectionFlags === undefined) return undefined;
      return (
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_READ ? 'r' : '-') +
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_WRITE ? 'w' : '-') +
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_EXECUTE ?
              'x' : '-') +
          (this.protectionFlags & VMRegion.PROTECTION_FLAG_MAYSHARE ? 's' : 'p')
      );
    }
  };

  VMRegion.fromDict = function(dict) {
    return new VMRegion(
        dict.startAddress,
        dict.sizeInBytes,
        dict.protectionFlags,
        dict.mappedFile,
        dict.byteStats);
  };

  /**
   * Node in a VM region classification tree.
   *
   * Note: Most users of this class should use the
   * VMRegionClassificationNode.fromRegions static method instead of this
   * constructor because it leads to better performance due to fewer memory
   * allocations.
   *
   * @constructor
   */
  function VMRegionClassificationNode(opt_rule) {
    this.rule_ = opt_rule || VMRegionClassificationNode.CLASSIFICATION_RULES;

    // True iff this node or any of its descendant classification nodes has at
    // least one classified VM region.
    this.hasRegions = false;

    // Total virtual size and byte stats of all regions matching this node's
    // rule (including its sub-rules).
    this.sizeInBytes = undefined;
    this.byteStats = {};

    // Array of child classification nodes if this is an intermediate node.
    this.children_ = undefined;

    // Array of VM regions. If this is an intermediate node, then the regions
    // are cached for lazy tree construction (i.e. its child classification
    // nodes yet have to be built).
    this.regions_ = [];
  }

  /**
   * Rules for classifying memory maps.
   *
   * These rules are derived from core/jni/android_os_Debug.cpp in Android.
   */
  VMRegionClassificationNode.CLASSIFICATION_RULES = {
    name: 'Total',
    children: [
      {
        name: 'Android',
        file: /^\/dev\/ashmem(?!\/libc malloc)/,
        children: [
          {
            name: 'Java runtime',
            file: /^\/dev\/ashmem\/dalvik-/,
            children: [
              {
                name: 'Spaces',
                file: /\/dalvik-(alloc|main|large object|non moving|zygote) space/,  // @suppress longLineCheck
                children: [
                  {
                    name: 'Normal',
                    file: /\/dalvik-(alloc|main)/
                  },
                  {
                    name: 'Large',
                    file: /\/dalvik-large object/
                  },
                  {
                    name: 'Zygote',
                    file: /\/dalvik-zygote/
                  },
                  {
                    name: 'Non-moving',
                    file: /\/dalvik-non moving/
                  }
                ]
              },
              {
                name: 'Linear Alloc',
                file: /\/dalvik-LinearAlloc/
              },
              {
                name: 'Indirect Reference Table',
                file: /\/dalvik-indirect.ref/
              },
              {
                name: 'Cache',
                file: /\/dalvik-jit-code-cache/
              },
              {
                name: 'Accounting'
              }
            ]
          },
          {
            name: 'Cursor',
            file: /\/CursorWindow/
          },
          {
            name: 'Ashmem'
          }
        ]
      },
      {
        name: 'Native heap',
        file: /^((\[heap\])|(\[anon:)|(\/dev\/ashmem\/libc malloc)|(\[discounted tracing overhead\])|$)/  // @suppress longLineCheck
      },
      {
        name: 'Stack',
        file: /^\[stack/
      },
      {
        name: 'Files',
        file: /\.((((jar)|(apk)|(ttf)|(odex)|(oat)|(art))$)|(dex)|(so))/,
        children: [
          {
            name: 'so',
            file: /\.so/
          },
          {
            name: 'jar',
            file: /\.jar$/
          },
          {
            name: 'apk',
            file: /\.apk$/
          },
          {
            name: 'ttf',
            file: /\.ttf$/
          },
          {
            name: 'dex',
            file: /\.((dex)|(odex$))/
          },
          {
            name: 'oat',
            file: /\.oat$/
          },
          {
            name: 'art',
            file: /\.art$/
          }
        ]
      },
      {
        name: 'Devices',
        file: /(^\/dev\/)|(anon_inode:dmabuf)/,
        children: [
          {
            name: 'GPU',
            file: /\/((nv)|(mali)|(kgsl))/
          },
          {
            name: 'DMA',
            file: /anon_inode:dmabuf/
          }
        ]
      }
    ]
  };
  VMRegionClassificationNode.OTHER_RULE = { name: 'Other' };

  VMRegionClassificationNode.fromRegions = function(regions, opt_rules) {
    const tree = new VMRegionClassificationNode(opt_rules);
    tree.regions_ = regions;
    for (let i = 0; i < regions.length; i++) {
      tree.addStatsFromRegion_(regions[i]);
    }
    return tree;
  };

  VMRegionClassificationNode.prototype = {
    get title() {
      return this.rule_.name;
    },

    get children() {
      if (this.isLeafNode) {
        return undefined;  // Leaf nodes don't have children (by definition).
      }
      if (this.children_ === undefined) {
        this.buildTree_();  // Lazily classify VM regions.
      }
      return this.children_;
    },

    get regions() {
      if (!this.isLeafNode) {
        // Intermediate nodes only temporarily cache VM regions for lazy tree
        // construction.
        return undefined;
      }
      return this.regions_;
    },

    get allRegionsForTesting() {
      if (this.regions_ !== undefined) {
        if (this.children_ !== undefined) {
          throw new Error('Internal error: a VM region classification node ' +
              'cannot have both regions and children');
        }
        // Leaf node (or caching internal node).
        return this.regions_;
      }

      // Intermediate node.
      let regions = [];
      this.children_.forEach(function(childNode) {
        regions = regions.concat(childNode.allRegionsForTesting);
      });
      return regions;
    },

    get isLeafNode() {
      const children = this.rule_.children;
      return children === undefined || children.length === 0;
    },

    addRegion(region) {
      this.addRegionRecursively_(region, true /* addStatsToThisNode */);
    },

    someRegion(fn, opt_this) {
      if (this.regions_ !== undefined) {
        // Leaf node (or caching internal node).
        return this.regions_.some(fn, opt_this);
      }

      // Intermediate node.
      return this.children_.some(function(childNode) {
        return childNode.someRegion(fn, opt_this);
      });
    },

    addRegionRecursively_(region, addStatsToThisNode) {
      if (addStatsToThisNode) {
        this.addStatsFromRegion_(region);
      }

      if (this.regions_ !== undefined) {
        if (this.children_ !== undefined) {
          throw new Error('Internal error: a VM region classification node ' +
              'cannot have both regions and children');
        }
        // Leaf node or an intermediate node caching VM regions (add the
        // region to this node and don't classify further).
        this.regions_.push(region);
        return;
      }

      // Non-leaf rule (classify region row further down the tree).
      function regionRowMatchesChildNide(child) {
        const fileRegExp = child.rule_.file;
        if (fileRegExp === undefined) return true;
        return fileRegExp.test(region.mappedFile);
      }

      let matchedChild = this.children_.find(regionRowMatchesChildNide);
      if (matchedChild === undefined) {
        // Region belongs to the 'Other' node (created lazily).
        if (this.children_.length !== this.rule_.children.length) {
          throw new Error('Internal error');
        }
        matchedChild = new VMRegionClassificationNode(
            VMRegionClassificationNode.OTHER_RULE);
        this.children_.push(matchedChild);
      }

      matchedChild.addRegionRecursively_(region, true);
    },

    buildTree_() {
      const cachedRegions = this.regions_;
      this.regions_ = undefined;

      this.buildChildNodesRecursively_();
      for (let i = 0; i < cachedRegions.length; i++) {
        // Note that we don't add the VM region's stats to this node because
        // they have already been added to it.
        this.addRegionRecursively_(
            cachedRegions[i], false /* addStatsToThisNode */);
      }
    },

    buildChildNodesRecursively_() {
      if (this.children_ !== undefined) {
        throw new Error(
            'Internal error: Classification node already has children');
      }
      if (this.regions_ !== undefined && this.regions_.length !== 0) {
        throw new Error(
            'Internal error: Classification node should have no regions');
      }

      if (this.isLeafNode) {
        return;  // Leaf node: Nothing to do.
      }

      // Intermediate node: Clear regions and build children recursively.
      this.regions_ = undefined;
      this.children_ = this.rule_.children.map(function(childRule) {
        const child = new VMRegionClassificationNode(childRule);
        child.buildChildNodesRecursively_();
        return child;
      });
    },

    addStatsFromRegion_(region) {
      this.hasRegions = true;

      // Aggregate virtual size.
      const regionSizeInBytes = region.sizeInBytes;
      if (regionSizeInBytes !== undefined) {
        this.sizeInBytes = (this.sizeInBytes || 0) + regionSizeInBytes;
      }

      // Aggregate byte stats.
      const thisByteStats = this.byteStats;
      const regionByteStats = region.byteStats;
      for (const byteStatName in regionByteStats) {
        const regionByteStatValue = regionByteStats[byteStatName];
        if (regionByteStatValue === undefined) continue;
        thisByteStats[byteStatName] =
            (thisByteStats[byteStatName] || 0) + regionByteStatValue;
      }
    }
  };

  return {
    VMRegion,
    VMRegionClassificationNode,
  };
});


'use strict';

/**
 * @fileoverview Provides the ProcessMemoryDump class.
 */
tr.exportTo('tr.model', function() {
  // Names of MemoryAllocatorDump(s) from which tracing overhead should be
  // discounted.
  const DISCOUNTED_ALLOCATOR_NAMES = ['winheap', 'malloc'];

  // The path to where the tracing overhead dump should be added to the
  // winheap/malloc allocator dump tree.
  const TRACING_OVERHEAD_PATH = ['allocated_objects', 'tracing_overhead'];

  const SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
  const RESIDENT_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME;

  function getSizeNumericValue(dump, sizeNumericName) {
    const sizeNumeric = dump.numerics[sizeNumericName];
    if (sizeNumeric === undefined) return 0;
    return sizeNumeric.value;
  }

  /**
   * The ProcessMemoryDump represents a memory dump of a single process.
   * @constructor
   */
  function ProcessMemoryDump(globalMemoryDump, process, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.process = process;
    this.globalMemoryDump = globalMemoryDump;

    // Process memory totals (optional object) with the following fields (also
    // optional):
    //   - residentBytes: Total resident bytes (number)
    //   - peakResidentBytes: Peak resident bytes (number)
    //   - arePeakResidentBytesResettable: Flag whether peak resident bytes are
    //     resettable (boolean)
    //   - platformSpecific: Map from OS-specific total names (string) to sizes
    //     (number)
    this.totals = undefined;

    this.vmRegions = undefined;

    // Map from allocator names to heap dumps.
    this.heapDumps = undefined;

    this.tracingOverheadOwnershipSetUp_ = false;
    this.tracingOverheadDiscountedFromVmRegions_ = false;
  }

  ProcessMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Process memory dump at ' +
          tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get containerName() {
      return this.process.userFriendlyName;
    },

    get processMemoryDumps() {
      const dumps = {};
      dumps[this.process.pid] = this;
      return dumps;
    },

    get hasOwnVmRegions() {
      return this.vmRegions !== undefined;
    },

    setUpTracingOverheadOwnership(opt_model) {
      // Make sure that calling this method twice won't lead to
      // 'double-discounting'.
      if (this.tracingOverheadOwnershipSetUp_) return;

      this.tracingOverheadOwnershipSetUp_ = true;

      const tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
      if (tracingDump === undefined || tracingDump.owns !== undefined) {
        // The tracing dump either doesn't exist, or it already owns another
        // dump.
        return;
      }

      if (tracingDump.owns !== undefined) return;

      // Add an ownership link from tracing to
      // malloc/allocated_objects/tracing_overhead or
      // winheap/allocated_objects/tracing_overhead.
      const hasDiscountedFromAllocatorDumps = DISCOUNTED_ALLOCATOR_NAMES.some(
          function(allocatorName) {
            // First check if the allocator root exists.
            const allocatorDump = this.getMemoryAllocatorDumpByFullName(
                allocatorName);
            if (allocatorDump === undefined) {
              return false;  // Allocator doesn't exist, try another one.
            }

            let nextPathIndex = 0;
            let currentDump = allocatorDump;
            let currentFullName = allocatorName;

            // Descend from the root towards tracing_overhead as long as the
            // dumps on the path exist.
            for (; nextPathIndex < TRACING_OVERHEAD_PATH.length;
                 nextPathIndex++) {
              const childFullName = currentFullName + '/' +
              TRACING_OVERHEAD_PATH[nextPathIndex];
              const childDump = this.getMemoryAllocatorDumpByFullName(
                  childFullName);
              if (childDump === undefined) break;

              currentDump = childDump;
              currentFullName = childFullName;
            }

            // Create the missing descendant dumps on the path from the root
            // towards tracing_overhead.
            for (; nextPathIndex < TRACING_OVERHEAD_PATH.length;
                 nextPathIndex++) {
              const childFullName = currentFullName + '/' +
              TRACING_OVERHEAD_PATH[nextPathIndex];
              const childDump = new tr.model.MemoryAllocatorDump(
              currentDump.containerMemoryDump, childFullName);
              childDump.parent = currentDump;
              currentDump.children.push(childDump);

              currentFullName = childFullName;
              currentDump = childDump;
            }

            // Add the ownership link.
            const ownershipLink =
            new tr.model.MemoryAllocatorDumpLink(tracingDump, currentDump);
            tracingDump.owns = ownershipLink;
            currentDump.ownedBy.push(ownershipLink);
            return true;
          }, this);

      // Force rebuilding the memory allocator dump index (if we've just added
      // a new memory allocator dump).
      if (hasDiscountedFromAllocatorDumps) {
        this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
      }
    },

    discountTracingOverheadFromVmRegions(opt_model) {
      // Make sure that calling this method twice won't lead to
      // 'double-discounting'.
      if (this.tracingOverheadDiscountedFromVmRegions_) return;
      this.tracingOverheadDiscountedFromVmRegions_ = true;

      const tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
      if (tracingDump === undefined) return;

      const discountedSize =
          getSizeNumericValue(tracingDump, SIZE_NUMERIC_NAME);
      const discountedResidentSize =
          getSizeNumericValue(tracingDump, RESIDENT_SIZE_NUMERIC_NAME);

      if (discountedSize <= 0 && discountedResidentSize <= 0) return;

      // Subtract the tracing size from the totals.
      if (this.totals !== undefined) {
        if (this.totals.residentBytes !== undefined) {
          this.totals.residentBytes -= discountedResidentSize;
        }
        if (this.totals.peakResidentBytes !== undefined) {
          this.totals.peakResidentBytes -= discountedResidentSize;
        }
      }

      // Subtract the tracing size from VM regions. More precisely, subtract
      // tracing resident_size from byte stats (private dirty and PSS) and
      // tracing size from virtual size by injecting a fake VM region with
      // negative values.
      if (this.vmRegions !== undefined) {
        const hasSizeInBytes = this.vmRegions.sizeInBytes !== undefined;
        const hasPrivateDirtyResident =
            this.vmRegions.byteStats.privateDirtyResident !== undefined;
        const hasProportionalResident =
            this.vmRegions.byteStats.proportionalResident !== undefined;

        if ((hasSizeInBytes && discountedSize > 0) ||
            ((hasPrivateDirtyResident || hasProportionalResident) &&
                discountedResidentSize > 0)) {
          const byteStats = {};
          if (hasPrivateDirtyResident) {
            byteStats.privateDirtyResident = -discountedResidentSize;
          }
          if (hasProportionalResident) {
            byteStats.proportionalResident = -discountedResidentSize;
          }
          this.vmRegions.addRegion(tr.model.VMRegion.fromDict({
            mappedFile: '[discounted tracing overhead]',
            sizeInBytes: hasSizeInBytes ? -discountedSize : undefined,
            byteStats
          }));
        }
      }
    }
  };

  ProcessMemoryDump.hookUpMostRecentVmRegionsLinks = function(processDumps) {
    let mostRecentVmRegions = undefined;

    processDumps.forEach(function(processDump) {
      // Update the most recent VM regions from the current dump.
      if (processDump.vmRegions !== undefined) {
        mostRecentVmRegions = processDump.vmRegions;
      }

      // Set the most recent VM regions of the current dump.
      processDump.mostRecentVmRegions = mostRecentVmRegions;
    });
  };

  tr.model.EventRegistry.register(
      ProcessMemoryDump,
      {
        name: 'processMemoryDump',
        pluralName: 'processMemoryDumps'
      });

  return {
    ProcessMemoryDump,
  };
});


'use strict';

/**
 * @fileoverview Provides the Process class.
 */
tr.exportTo('tr.model', function() {
  const ProcessBase = tr.model.ProcessBase;
  const ProcessInstantEvent = tr.model.ProcessInstantEvent;
  const Frame = tr.model.Frame;
  const ProcessMemoryDump = tr.model.ProcessMemoryDump;

  /**
   * The Process represents a single userland process in the
   * trace.
   * @constructor
   */
  function Process(model, pid) {
    if (model === undefined) {
      throw new Error('model must be provided');
    }
    if (pid === undefined) {
      throw new Error('pid must be provided');
    }
    tr.model.ProcessBase.call(this, model);
    this.pid = pid;
    this.name = undefined;
    this.labels = [];
    this.uptime_seconds = 0;
    this.instantEvents = [];
    this.memoryDumps = [];
    this.frames = [];
    this.activities = [];
  }

  /**
   * Comparison between processes that orders by pid.
   */
  Process.compare = function(x, y) {
    let tmp = tr.model.ProcessBase.compare(x, y);
    if (tmp) return tmp;

    if (x.name !== undefined) {
      if (y.name !== undefined) {
        tmp = x.name.localeCompare(y.name);
      } else {
        tmp = -1;
      }
    } else if (y.name !== undefined) {
      tmp = 1;
    }
    if (tmp) return tmp;

    tmp = tr.b.compareArrays(x.labels, y.labels,
        function(x, y) { return x.localeCompare(y); });
    if (tmp) return tmp;

    return x.pid - y.pid;
  };

  Process.prototype = {
    __proto__: tr.model.ProcessBase.prototype,

    get stableId() {
      return this.pid;
    },

    compareTo(that) {
      return Process.compare(this, that);
    },

    * childEvents() {
      yield* ProcessBase.prototype.childEvents.call(this);
      yield* this.instantEvents;
      yield* this.frames;
      yield* this.memoryDumps;
    },

    addLabelIfNeeded(labelName) {
      for (let i = 0; i < this.labels.length; i++) {
        if (this.labels[i] === labelName) return;
      }
      this.labels.push(labelName);
    },

    get userFriendlyName() {
      let res;
      if (this.name) {
        res = this.name + ' (pid ' + this.pid + ')';
      } else {
        res = 'Process ' + this.pid;
      }
      if (this.labels.length) {
        res += ': ' + this.labels.join(', ');
      }
      if (this.uptime_seconds) {
        res += ', uptime:' + this.uptime_seconds + 's';
      }
      return res;
    },

    get userFriendlyDetails() {
      if (this.name) {
        return this.name + ' (pid ' + this.pid + ')';
      }
      return 'pid: ' + this.pid;
    },

    getSettingsKey() {
      if (!this.name) return undefined;
      if (!this.labels.length) return 'processes.' + this.name;
      return 'processes.' + this.name + '.' + this.labels.join('.');
    },

    shiftTimestampsForward(amount) {
      for (let i = 0; i < this.instantEvents.length; i++) {
        this.instantEvents[i].start += amount;
      }

      for (let i = 0; i < this.frames.length; i++) {
        this.frames[i].shiftTimestampsForward(amount);
      }

      for (let i = 0; i < this.memoryDumps.length; i++) {
        this.memoryDumps[i].shiftTimestampsForward(amount);
      }

      for (let i = 0; i < this.activities.length; i++) {
        this.activities[i].shiftTimestampsForward(amount);
      }

      tr.model.ProcessBase.prototype
          .shiftTimestampsForward.apply(this, arguments);
    },

    updateBounds() {
      tr.model.ProcessBase.prototype.updateBounds.apply(this);

      for (let i = 0; i < this.frames.length; i++) {
        this.frames[i].addBoundsToRange(this.bounds);
      }

      for (let i = 0; i < this.memoryDumps.length; i++) {
        this.memoryDumps[i].addBoundsToRange(this.bounds);
      }

      for (let i = 0; i < this.activities.length; i++) {
        this.activities[i].addBoundsToRange(this.bounds);
      }
    },

    sortMemoryDumps() {
      this.memoryDumps.sort(function(x, y) {
        return x.start - y.start;
      });
      tr.model.ProcessMemoryDump.hookUpMostRecentVmRegionsLinks(
          this.memoryDumps);
    }
  };

  return {
    Process,
  };
});


'use strict';

/**
 * @fileoverview Provides the Sample class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A Sample represents a sample taken at an instant in time,
   * plus its call stack and parameters associated with that sample.
   *
   * @constructor
   */
  function Sample(start, title, leafNode, thread, opt_cpu, opt_weight,
      opt_args) {
    tr.model.TimedEvent.call(this, start);

    this.start_ = start;
    this.title_ = title;
    this.leafNode_ = leafNode;
    this.thread_ = thread;
    this.colorId_ = leafNode.colorId;

    this.cpu_ = opt_cpu;
    this.weight_ = opt_weight;
    this.args = opt_args || {};
  }

  Sample.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get title() {
      return this.title_;
    },

    get colorId() {
      return this.colorId_;
    },

    get thread() {
      return this.thread_;
    },

    get leafNode() {
      return this.leafNode_;
    },

    get userFriendlyName() {
      return 'Sample at ' +
        tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get userFriendlyStack() {
      return this.leafNode_.userFriendlyStack;
    },

    getNodesAsArray() {
      const nodes = [];
      let node = this.leafNode_;
      while (node !== undefined) {
        nodes.push(node);
        node = node.parentNode;
      }
      return nodes;
    },

    get cpu() {
      return this.cpu_;
    },

    get weight() {
      return this.weight_;
    },
  };

  tr.model.EventRegistry.register(
      Sample,
      {
        name: 'Sample',
        pluralName: 'Samples'
      });

  return {
    Sample,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function StackFrame(parentFrame, id, title, colorId, opt_sourceInfo) {
    if (id === undefined) {
      throw new Error('id must be given');
    }
    this.parentFrame_ = parentFrame;
    this.id = id;
    this.title_ = title;
    this.colorId = colorId;
    this.children = [];
    this.sourceInfo_ = opt_sourceInfo;

    if (this.parentFrame_) {
      this.parentFrame_.addChild(this);
    }
  }

  StackFrame.prototype = {
    get parentFrame() {
      return this.parentFrame_;
    },

    get title() {
      if (this.sourceInfo_) {
        const src = this.sourceInfo_.toString();
        return this.title_ + (src === '' ? '' : ' ' + src);
      }
      return this.title_;
    },

    /**
     * Attempts to find the domain of the origin of the script either from this
     * stack trace or from its ancestors.
     */
    get domain() {
      let result = 'unknown';
      if (this.sourceInfo_ && this.sourceInfo_.domain) {
        result = this.sourceInfo_.domain;
      }
      if (result === 'unknown' && this.parentFrame) {
        result = this.parentFrame.domain;
      }
      return result;
    },

    get sourceInfo() {
      return this.sourceInfo_;
    },

    set parentFrame(parentFrame) {
      if (this.parentFrame_) {
        Polymer.dom(this.parentFrame_).removeChild(this);
      }
      this.parentFrame_ = parentFrame;
      if (this.parentFrame_) {
        this.parentFrame_.addChild(this);
      }
    },

    addChild(child) {
      this.children.push(child);
    },

    removeChild(child) {
      const i = this.children.indexOf(child.id);
      if (i === -1) {
        throw new Error('omg');
      }
      this.children.splice(i, 1);
    },

    removeAllChildren() {
      for (let i = 0; i < this.children.length; i++) {
        this.children[i].parentFrame_ = undefined;
      }
      this.children.splice(0, this.children.length);
    },

    /**
     * Returns stackFrames where the most specific frame is first.
     */
    get stackTrace() {
      const stack = [this];
      let cur = this.parentFrame;
      while (cur) {
        stack.push(cur);
        cur = cur.parentFrame;
      }
      return stack;
    },

    getUserFriendlyStackTrace() {
      return this.stackTrace.map(function(x) { return x.title; });
    }
  };

  return {
    StackFrame,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  /**
   * Segment represents a range of time during which the set of active
   * UserExpectations does not change. Segments are guaranteed to not overlap,
   * whereas UserExpectations can overlap. After UserModelBuilder builds the
   * UserExpectations in the model, it segments the timeline into
   * non-overlapping Segments and adds the constituent UserExpectations to each
   * Segment.
   */
  class Segment extends tr.model.TimedEvent {
    constructor(start, duration) {
      super(start);
      this.duration = duration;
      this.expectations_ = [];
    }

    get expectations() {
      return this.expectations_;
    }

    clone() {
      const clone = new Segment(this.start, this.duration);
      clone.expectations.push(...this.expectations);
      return clone;
    }

    addSegment(other) {
      this.duration += other.duration;
      this.expectations.push(...other.expectations);
    }
  }

  return {
    Segment,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  class UserModel extends tr.model.EventContainer {
    constructor(parentModel) {
      super();
      this.parentModel_ = parentModel;
      this.expectations_ = new tr.model.EventSet();
      this.segments_ = [];
    }

    get stableId() {
      return 'UserModel';
    }

    get parentModel() {
      return this.parentModel_;
    }

    sortExpectations() {
      this.expectations_.sortEvents((x, y) => (x.start - y.start));
    }

    get expectations() {
      return this.expectations_;
    }

    shiftTimestampsForward(amount) {
    }

    addCategoriesToDict(categoriesDict) {
    }

    get segments() {
      return this.segments_;
    }

    * childEvents() {
      yield* this.expectations;
    }

    * childEventContainers() {
    }

    updateBounds() {
      this.bounds.reset();
      for (const expectation of this.expectations) {
        expectation.addBoundsToRange(this.bounds);
      }
    }

    /**
     * Return a new array of new Segments by merging adjacent segments when
     * |getKeyForSegment| returns identical keys.
     * |getKeyForSegment| is called with each Segment and the index of that
     * Segment.
     *
     * @param {!function(!tr.model.um.Segment, number):*} getKeyForSegment
     * @return {!Array.<!tr.model.um.Segment>}
     */
    resegment(getKeyForSegment) {
      const newSegments = [];
      let prevKey = undefined;
      let prevSegment = undefined;
      for (let i = 0; i < this.segments.length; ++i) {
        const segment = this.segments[i];
        const key = getKeyForSegment(segment, i);
        if (prevSegment !== undefined && key === prevKey) {
          prevSegment.addSegment(segment);
        } else {
          prevSegment = segment.clone();
          newSegments.push(prevSegment);
        }
        prevKey = key;
      }
      return newSegments;
    }
  }

  return {
    UserModel,
  };
});


'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
tr.exportTo('tr', function() {
  const Process = tr.model.Process;
  const Device = tr.model.Device;
  const Kernel = tr.model.Kernel;
  const GlobalMemoryDump = tr.model.GlobalMemoryDump;
  const GlobalInstantEvent = tr.model.GlobalInstantEvent;
  const FlowEvent = tr.model.FlowEvent;
  const Alert = tr.model.Alert;
  const Sample = tr.model.Sample;

  /**
   * @constructor
   */
  function Model() {
    tr.model.EventContainer.call(this);
    tr.b.EventTarget.decorate(this);

    this.timestampShiftToZeroAmount_ = 0;

    this.faviconHue = 'blue'; // Should be a key from favicons.html

    this.device = new Device(this);
    this.kernel = new Kernel(this);
    this.processes = {};
    this.metadata = [];
    this.categories = [];
    this.instantEvents = [];
    this.flowEvents = [];
    this.clockSyncManager = new tr.model.ClockSyncManager();
    this.intrinsicTimeUnit_ = undefined;

    this.stackFrames = {};
    this.samples = [];

    this.alerts = [];
    this.userModel = new tr.model.um.UserModel(this);

    this.flowIntervalTree = new tr.b.IntervalTree((f) => f.start, (f) => f.end);
    this.globalMemoryDumps = [];

    this.userFriendlyCategoryDrivers_ = [];

    this.annotationsByGuid_ = {};
    this.modelIndices = undefined;

    this.stats = new tr.model.ModelStats();

    this.importWarnings_ = [];
    this.reportedImportWarnings_ = {};

    this.isTimeHighResolution_ = true;

    this.patchupsToApply_ = [];

    this.doesHelperGUIDSupportThisModel_ = {};
    this.helpersByConstructorGUID_ = {};
    this.eventsByStableId_ = undefined;
  }

  Model.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    getEventByStableId(stableId) {
      if (this.eventsByStableId_ === undefined) {
        this.eventsByStableId_ = {};
        for (const event of this.getDescendantEvents()) {
          this.eventsByStableId_[event.stableId] = event;
        }
      }
      return this.eventsByStableId_[stableId];
    },

    getOrCreateHelper(constructor) {
      if (!constructor.guid) {
        throw new Error('Helper constructors must have GUIDs');
      }

      if (this.helpersByConstructorGUID_[constructor.guid] === undefined) {
        if (this.doesHelperGUIDSupportThisModel_[constructor.guid] ===
            undefined) {
          this.doesHelperGUIDSupportThisModel_[constructor.guid] =
            constructor.supportsModel(this);
        }

        if (!this.doesHelperGUIDSupportThisModel_[constructor.guid]) {
          return undefined;
        }

        this.helpersByConstructorGUID_[constructor.guid] = new constructor(
            this);
      }
      return this.helpersByConstructorGUID_[constructor.guid];
    },

    * childEvents() {
      yield* this.globalMemoryDumps;
      yield* this.instantEvents;
      yield* this.flowEvents;
      yield* this.alerts;
      yield* this.samples;
    },

    * childEventContainers() {
      yield this.userModel;
      yield this.device;
      yield this.kernel;
      yield* Object.values(this.processes);
    },

    /**
     * Some objects in the model can persist their state in ModelSettings.
     *
     * This iterates through them.
     */
    iterateAllPersistableObjects(callback) {
      this.kernel.iterateAllPersistableObjects(callback);
      for (const pid in this.processes) {
        this.processes[pid].iterateAllPersistableObjects(callback);
      }
    },

    updateBounds() {
      this.bounds.reset();
      const bounds = this.bounds;
      for (const ec of this.childEventContainers()) {
        ec.updateBounds();
        bounds.addRange(ec.bounds);
      }
      for (const event of this.childEvents()) {
        event.addBoundsToRange(bounds);
      }
    },

    shiftWorldToZero() {
      const shiftAmount = -this.bounds.min;
      this.timestampShiftToZeroAmount_ = shiftAmount;
      for (const ec of this.childEventContainers()) {
        ec.shiftTimestampsForward(shiftAmount);
      }

      for (const event of this.childEvents()) {
        event.start += shiftAmount;
      }
      this.updateBounds();
    },

    convertTimestampToModelTime(sourceClockDomainName, ts) {
      if (sourceClockDomainName !== 'traceEventClock') {
        throw new Error('Only traceEventClock is supported.');
      }
      return tr.b.Unit.timestampFromUs(ts) +
        this.timestampShiftToZeroAmount_;
    },

    get numProcesses() {
      let n = 0;
      for (const p in this.processes) {
        n++;
      }
      return n;
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid. Returns
     * undefined if the process doesn't exist.
     */
    getProcess(pid) {
      return this.processes[pid];
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid or
     * creates one if it does not exist.
     */
    getOrCreateProcess(pid) {
      if (!this.processes[pid]) {
        this.processes[pid] = new Process(this, pid);
      }
      return this.processes[pid];
    },

    addStackFrame(stackFrame) {
      if (this.stackFrames[stackFrame.id]) {
        throw new Error('Stack frame already exists');
      }
      this.stackFrames[stackFrame.id] = stackFrame;
      return stackFrame;
    },

    /**
     * Generates the set of categories from the slices and counters.
     */
    updateCategories_() {
      const categoriesDict = {};
      this.userModel.addCategoriesToDict(categoriesDict);
      this.device.addCategoriesToDict(categoriesDict);
      this.kernel.addCategoriesToDict(categoriesDict);
      for (const pid in this.processes) {
        this.processes[pid].addCategoriesToDict(categoriesDict);
      }

      this.categories = [];
      for (const category in categoriesDict) {
        if (category !== '') {
          this.categories.push(category);
        }
      }
    },

    getAllThreads() {
      const threads = [];
      for (const tid in this.kernel.threads) {
        threads.push(process.threads[tid]);
      }
      for (const pid in this.processes) {
        const process = this.processes[pid];
        for (const tid in process.threads) {
          threads.push(process.threads[tid]);
        }
      }
      return threads;
    },

    /**
     * @param {(!function(!tr.model.Process): boolean)=} opt_predicate Optional
     *     predicate for filtering the returned processes. If undefined, all
     *     process in the model will be returned.
     * @return {!Array<!tr.model.Process>} An array of processes in the model.
     */
    getAllProcesses(opt_predicate) {
      const processes = [];
      for (const pid in this.processes) {
        const process = this.processes[pid];
        if (opt_predicate === undefined || opt_predicate(process)) {
          processes.push(process);
        }
      }
      return processes;
    },

    /**
     * @return {Array} An array of all the counters in the model.
     */
    getAllCounters() {
      const counters = [];
      counters.push.apply(
          counters, Object.values(this.device.counters || {}));
      counters.push.apply(
          counters, Object.values(this.kernel.counters || {}));
      for (const pid in this.processes) {
        const process = this.processes[pid];
        for (const tid in process.counters) {
          counters.push(process.counters[tid]);
        }
      }
      return counters;
    },

    getAnnotationByGUID(guid) {
      return this.annotationsByGuid_[guid];
    },

    addAnnotation(annotation) {
      if (!annotation.guid) {
        throw new Error('Annotation with undefined guid given');
      }

      this.annotationsByGuid_[annotation.guid] = annotation;
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    removeAnnotation(annotation) {
      this.annotationsByGuid_[annotation.guid].onRemove();
      delete this.annotationsByGuid_[annotation.guid];
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    getAllAnnotations() {
      return Object.values(this.annotationsByGuid_);
    },

    addUserFriendlyCategoryDriver(ufcd) {
      this.userFriendlyCategoryDrivers_.push(ufcd);
    },

    /**
     * Gets the user friendly category string from an event.
     *
     * Returns undefined if none is known.
     */
    getUserFriendlyCategoryFromEvent(event) {
      for (let i = 0; i < this.userFriendlyCategoryDrivers_.length; i++) {
        const ufc = this.userFriendlyCategoryDrivers_[i].fromEvent(event);
        if (ufc !== undefined) return ufc;
      }
      return undefined;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed(name) {
      const namedThreads = [];
      namedThreads.push.apply(
          namedThreads,
          this.kernel.findAllThreadsNamed(name));
      for (const pid in this.processes) {
        namedThreads.push.apply(
            namedThreads,
            this.processes[pid].findAllThreadsNamed(name));
      }
      return namedThreads;
    },

    get importOptions() {
      return this.importOptions_;
    },

    set importOptions(options) {
      this.importOptions_ = options;
    },

    /**
     * Returns a time unit that is used to format values and determines the
     * precision of the timestamp values.
     */
    get intrinsicTimeUnit() {
      if (this.intrinsicTimeUnit_ === undefined) {
        return tr.b.TimeDisplayModes.ms;
      }
      return this.intrinsicTimeUnit_;
    },

    set intrinsicTimeUnit(value) {
      if (this.intrinsicTimeUnit_ === value) return;
      if (this.intrinsicTimeUnit_ !== undefined) {
        throw new Error('Intrinsic time unit already set');
      }
      this.intrinsicTimeUnit_ = value;
    },

    get isTimeHighResolution() {
      return this.isTimeHighResolution_;
    },

    set isTimeHighResolution(value) {
      this.isTimeHighResolution_ = value;
    },

    /**
     * Returns a link to a trace data file that this model was imported from.
     * This is NOT the URL of a site being traced, but instead an indicator of
     * where the data is stored.
     */
    get canonicalUrl() {
      return this.canonicalUrl_;
    },

    set canonicalUrl(value) {
      if (this.canonicalUrl_ === value) return;
      if (this.canonicalUrl_ !== undefined) {
        throw new Error('canonicalUrl already set');
      }
      this.canonicalUrl_ = value;
    },

    /**
     * Saves a warning that happened during import.
     *
     * Warnings are typically logged to the console, and optionally, the
     * more critical ones are shown to the user.
     *
     * @param {Object} data The import warning data. Data must provide two
     *    accessors: type, message. The types are used to determine if we
     *    should output the message, we'll only output one message of each type.
     *    The message is the actual warning content.
     */
    importWarning(data) {
      data.showToUser = !!data.showToUser;

      this.importWarnings_.push(data);

      // Only log each warning type once. We may want to add some kind of
      // flag to allow reporting all importer warnings.
      if (this.reportedImportWarnings_[data.type] === true) return;

      this.reportedImportWarnings_[data.type] = true;
    },

    get hasImportWarnings() {
      return (this.importWarnings_.length > 0);
    },

    get importWarnings() {
      return this.importWarnings_;
    },

    get importWarningsThatShouldBeShownToUser() {
      return this.importWarnings_.filter(function(warning) {
        return warning.showToUser;
      });
    },

    autoCloseOpenSlices() {
      // Sort the samples.
      this.samples.sort(function(x, y) {
        return x.start - y.start;
      });

      this.updateBounds();
      this.kernel.autoCloseOpenSlices();
      for (const pid in this.processes) {
        this.processes[pid].autoCloseOpenSlices();
      }
    },

    createSubSlices() {
      this.kernel.createSubSlices();
      for (const pid in this.processes) {
        this.processes[pid].createSubSlices();
      }
    },

    preInitializeObjects() {
      for (const pid in this.processes) {
        this.processes[pid].preInitializeObjects();
      }
    },

    initializeObjects() {
      for (const pid in this.processes) {
        this.processes[pid].initializeObjects();
      }
    },

    pruneEmptyContainers() {
      this.kernel.pruneEmptyContainers();
      for (const pid in this.processes) {
        this.processes[pid].pruneEmptyContainers();
      }
    },

    mergeKernelWithUserland() {
      for (const pid in this.processes) {
        this.processes[pid].mergeKernelWithUserland();
      }
    },

    computeWorldBounds(shiftWorldToZero) {
      this.updateBounds();
      this.updateCategories_();

      if (shiftWorldToZero) {
        this.shiftWorldToZero();
      }
    },

    buildFlowEventIntervalTree() {
      for (let i = 0; i < this.flowEvents.length; ++i) {
        const flowEvent = this.flowEvents[i];
        this.flowIntervalTree.insert(flowEvent);
      }
      this.flowIntervalTree.updateHighValues();
    },

    cleanupUndeletedObjects() {
      for (const pid in this.processes) {
        this.processes[pid].autoDeleteObjects(this.bounds.max);
      }
    },

    sortMemoryDumps() {
      this.globalMemoryDumps.sort(function(x, y) {
        return x.start - y.start;
      });

      for (const pid in this.processes) {
        this.processes[pid].sortMemoryDumps();
      }
    },

    finalizeMemoryGraphs() {
      this.globalMemoryDumps.forEach(function(dump) {
        dump.finalizeGraph();
      });
    },

    buildEventIndices() {
      this.modelIndices = new tr.model.ModelIndices(this);
    },

    sortAlerts() {
      this.alerts.sort(function(x, y) {
        return x.start - y.start;
      });
    },

    applyObjectRefPatchups() {
      // Change all the fields pointing at id_refs to their real values.
      const unresolved = [];
      this.patchupsToApply_.forEach(function(patchup) {
        if (patchup.pidRef in this.processes) {
          const snapshot = this.processes[patchup.pidRef].objects.getSnapshotAt(
              patchup.scopedId, patchup.ts);
          if (snapshot) {
            patchup.object[patchup.field] = snapshot;
            snapshot.referencedAt(patchup.item, patchup.object, patchup.field);
            return;
          }
        }
        unresolved.push(patchup);
      }, this);
      this.patchupsToApply_ = unresolved;
    },

    replacePIDRefsInPatchups(oldPidRef, newPidRef) {
      this.patchupsToApply_.forEach(function(patchup) {
        if (patchup.pidRef === oldPidRef) {
          patchup.pidRef = newPidRef;
        }
      });
    },

    /**
     * Called by the model to join references between objects, after final model
     * bounds have been computed.
     */
    joinRefs() {
      this.joinObjectRefs_();
      this.applyObjectRefPatchups();
    },

    joinObjectRefs_() {
      for (const [pid, process] of Object.entries(this.processes)) {
        this.joinObjectRefsForProcess_(pid, process);
      }
    },

    joinObjectRefsForProcess_(pid, process) {
      // Iterate the world, looking for id_refs
      for (const thread of Object.values(process.threads)) {
        thread.asyncSliceGroup.slices.forEach(function(item) {
          this.searchItemForIDRefs_(pid, 'start', item);
        }, this);
        thread.sliceGroup.slices.forEach(function(item) {
          this.searchItemForIDRefs_(pid, 'start', item);
        }, this);
      }
      process.objects.iterObjectInstances(function(instance) {
        instance.snapshots.forEach(function(item) {
          this.searchItemForIDRefs_(pid, 'ts', item);
        }, this);
      }, this);
    },

    searchItemForIDRefs_(pid, itemTimestampField, item) {
      if (!item.args && !item.contexts) return;
      const patchupsToApply = this.patchupsToApply_;

      function handleField(object, fieldName, fieldValue) {
        if (!fieldValue || (!fieldValue.id_ref && !fieldValue.idRef)) {
          return;
        }

        const scope = fieldValue.scope || tr.model.OBJECT_DEFAULT_SCOPE;
        const idRef = fieldValue.id_ref || fieldValue.idRef;
        const scopedId = new tr.model.ScopedId(scope, idRef);
        const pidRef = fieldValue.pid_ref || fieldValue.pidRef || pid;
        const ts = item[itemTimestampField];
        // We have to delay the actual change to the new value until after all
        // refs have been located. Otherwise, we could end up recursing in
        // ways we definitely didn't intend.
        patchupsToApply.push({
          item,
          object,
          field: fieldName,
          pidRef,
          scopedId,
          ts});
      }
      function iterObjectFieldsRecursively(object) {
        if (!(object instanceof Object)) return;

        if ((object instanceof tr.model.ObjectSnapshot) ||
            (object instanceof Float32Array) ||
            (object instanceof tr.b.math.Quad)) {
          return;
        }

        if (object instanceof Array) {
          for (let i = 0; i < object.length; i++) {
            handleField(object, i, object[i]);
            iterObjectFieldsRecursively(object[i]);
          }
          return;
        }

        for (const key in object) {
          const value = object[key];
          handleField(object, key, value);
          iterObjectFieldsRecursively(value);
        }
      }

      iterObjectFieldsRecursively(item.args);
      iterObjectFieldsRecursively(item.contexts);
    }
  };

  return {
    Model,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  // Bin boundaries for clock sync latency. 0-20 ms with 0.2 ms bins.
  // 20 ms is a good upper limit because the highest latencies we've seen are
  // around 10-15 ms, and we expect average latency to go down as we improve
  // the clock sync mechanism.
  const LATENCY_BOUNDS = tr.v.HistogramBinBoundaries.createLinear(0, 20, 100);

  function clockSyncLatencyMetric(values, model) {
    const domains = Array.from(model.clockSyncManager.domainsSeen).sort();
    for (let i = 0; i < domains.length; i++) {
      for (let j = i + 1; j < domains.length; j++) {
        const latency = model.clockSyncManager.getTimeTransformerError(
            domains[i], domains[j]);
        const hist = new tr.v.Histogram('clock_sync_latency_' +
            domains[i].toLowerCase() + '_to_' + domains[j].toLowerCase(),
            tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, LATENCY_BOUNDS);
        hist.customizeSummaryOptions({
          avg: true,
          count: false,
          max: false,
          min: false,
          std: false,
          sum: false,
        });
        hist.description = 'Clock sync latency for domain ' + domains[i] +
            ' to domain ' + domains[j];
        hist.addSample(latency);
        values.addHistogram(hist);
      }
    }
  }

  tr.metrics.MetricRegistry.register(clockSyncLatencyMetric);

  return {
    clockSyncLatencyMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  // Use a lower bound of 0.01 for the metric boundaries (when no CPU time
  // is consumed) and an upper bound of 50 (fifty cores are all active
  // for the entire time). We can't use zero exactly for the lower bound with an
  // exponential histogram.
  const CPU_TIME_PERCENTAGE_BOUNDARIES =
      tr.v.HistogramBinBoundaries.createExponential(0.01, 50, 200);

  /**
   * This metric measures total CPU time for Chrome processes, per second of
   *   clock time.
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function cpuTimeMetric(histograms, model, opt_options) {
    let rangeOfInterest = model.bounds;

    if (opt_options && opt_options.rangeOfInterest) {
      rangeOfInterest = opt_options.rangeOfInterest;
    } else {
      // If no range of interest is provided, limit the relevant range to
      // Chrome processes. This prevents us from normalizing against non-Chrome
      // related slices in the trace.
      const chromeHelper = model.getOrCreateHelper(
          tr.model.helpers.ChromeModelHelper);
      if (chromeHelper) {
        const chromeBounds = chromeHelper.chromeBounds;
        if (chromeBounds) {
          rangeOfInterest = chromeBounds;
        }
      }
    }

    let allProcessCpuTime = 0;

    for (const pid in model.processes) {
      const process = model.processes[pid];
      if (tr.model.helpers.ChromeRendererHelper.isTracingProcess(process)) {
        continue;
      }

      let processCpuTime = 0;
      for (const tid in process.threads) {
        const thread = process.threads[tid];
        let threadCpuTime = 0;
        thread.sliceGroup.topLevelSlices.forEach(function(slice) {
          if (slice.duration === 0) return;
          if (!slice.cpuDuration) return;
          const sliceRange = tr.b.math.Range.fromExplicitRange(
              slice.start, slice.end);
          const intersection = rangeOfInterest.findIntersection(sliceRange);
          const fractionOfSliceInsideRangeOfInterest =
              intersection.duration / slice.duration;

          // We assume that if a slice doesn't lie entirely inside the range of
          // interest, then the CPU time is evenly distributed inside of the
          // slice.
          threadCpuTime +=
              slice.cpuDuration * fractionOfSliceInsideRangeOfInterest;
        });
        processCpuTime += threadCpuTime;
      }
      allProcessCpuTime += processCpuTime;
    }

    // Normalize cpu time by clock time.
    let normalizedAllProcessCpuTime = 0;
    if (rangeOfInterest.duration > 0) {
      normalizedAllProcessCpuTime =
          allProcessCpuTime / rangeOfInterest.duration;
    }

    const unit = tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
    const cpuTimeHist = new tr.v.Histogram(
        'cpu_time_percentage', unit, CPU_TIME_PERCENTAGE_BOUNDARIES);
    cpuTimeHist.description =
        'Percent CPU utilization, normalized against a single core. Can be ' +
        'greater than 100% if machine has multiple cores.';
    cpuTimeHist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: false
    });
    cpuTimeHist.addSample(normalizedAllProcessCpuTime);
    histograms.addHistogram(cpuTimeHist);
  }

  tr.metrics.MetricRegistry.register(cpuTimeMetric, {
    supportsRangeOfInterest: true
  });

  return {
    cpuTimeMetric,
  };
});


'use strict';

tr.exportTo('tr.v.d', function() {
  /**
   * Add related names GenericSet diagnostic.
   *
   * @param {!tr.v.HistogramSet} histograms
   */
  function addRelatedNames(histograms) {
    for (const hist of histograms) {
      const relatedNames = new Set();
      for (const [name, diagnostic] of hist.diagnostics) {
        if (diagnostic instanceof tr.v.d.RelatedHistogramMap) {
          for (const [relationshipName, relatedHist] of diagnostic) {
            relatedNames.add(relatedHist.name);
          }
        }
      }
      if (relatedNames.size) {
        hist.diagnostics.set(
            tr.v.d.RESERVED_NAMES.RELATED_NAMES,
            new tr.v.d.GenericSet(relatedNames));
      }
    }
  }

  return {
    addRelatedNames,
  };
});


'use strict';

tr.exportTo('tr.v', function() {
  /*
   * HistogramGrouping objects are registered named functions that map from
   * Histogram objects to strings.
   *
   * They are used to group Histograms by
   * tr.v.HistogramSet.groupHistogramsRecursively()
   *
   * The tr-ui-b-grouping-table-groupby-picker module within the
   * tr-v-ui-histogram-set-controls module allows users to select and reorder
   * groupings.
   */
  class HistogramGrouping {
    /**
     * @param {string} key
     * @param {!function(!tr.v.Histogram):string} callback
     */
    constructor(key, callback) {
      this.key_ = key;
      this.callback_ = callback;

      HistogramGrouping.BY_KEY.set(key, this);
    }

    get key() {
      return this.key_;
    }

    get callback() {
      return this.callback_;
    }

    get label() {
      return this.key;
    }

    /**
     * @param {!Set.<string>} tags
     * @param {string} diagnosticName
     * @return {!Array.<!HistogramGrouping>}
     */
    static buildFromTags(tags, diagnosticName) {
      const booleanTags = new Set();
      const keyValueTags = new Set();
      for (const tag of tags) {
        if (tag.includes(':')) {
          const key = tag.split(':')[0];
          if (booleanTags.has(key)) {
            throw new Error(
                `Tag "${key}" cannot be both boolean and key-value`);
          }
          keyValueTags.add(key);
        } else {
          if (keyValueTags.has(tag)) {
            throw new Error(
                `Tag "${tag}" cannot be both boolean and key-value`);
          }
          booleanTags.add(tag);
        }
      }

      const groupings = [];
      for (const tag of booleanTags) {
        groupings.push(HistogramGrouping.buildBooleanTagGrouping_(
            tag, diagnosticName));
      }
      for (const tag of keyValueTags) {
        groupings.push(HistogramGrouping.buildKeyValueTagGrouping_(
            tag, diagnosticName));
      }
      return groupings;
    }

    static buildBooleanTagGrouping_(tag, diagnosticName) {
      return new HistogramGrouping(`${tag}Tag`, h => {
        const tags = h.diagnostics.get(diagnosticName);
        if (tags === undefined || !tags.has(tag)) return `~${tag}`;
        return tag;
      });
    }

    static buildKeyValueTagGrouping_(tag, diagnosticName) {
      return new HistogramGrouping(`${tag}Tag`, h => {
        const tags = h.diagnostics.get(diagnosticName);
        if (tags === undefined) return `~${tag}`;
        const values = new Set();
        for (const value of tags) {
          const kvp = value.split(':');
          if (kvp.length < 2 || kvp[0] !== tag) continue;
          values.add(kvp[1]);
        }
        if (values.size === 0) return `~${tag}`;
        const sortedValues = Array.from(values);
        sortedValues.sort();
        return sortedValues.join(',');
      }, `${tag} tag`);
    }
  }

  HistogramGrouping.BY_KEY = new Map();

  HistogramGrouping.HISTOGRAM_NAME = new HistogramGrouping('name', h => h.name);

  HistogramGrouping.DISPLAY_LABEL = new HistogramGrouping(
      'displayLabel', hist => {
        const labels = hist.diagnostics.get(tr.v.d.RESERVED_NAMES.LABELS);
        if (labels !== undefined && labels.size > 0) {
          return Array.from(labels).join(',');
        }

        const benchmarks = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.BENCHMARKS);
        const start = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.BENCHMARK_START);
        if (benchmarks === undefined) {
          if (start === undefined) return 'Value';

          return start.toString();
        }
        const benchmarksStr = Array.from(benchmarks).join('\n');

        if (start === undefined) return benchmarksStr;

        return benchmarksStr + '\n' + start.toString();
      });

  class GenericSetGrouping extends HistogramGrouping {
    constructor(name) {
      super(name, undefined);
      this.callback_ = this.compute_.bind(this);
    }

    compute_(hist) {
      const diag = hist.diagnostics.get(this.key);
      if (diag === undefined) return '';
      const parts = Array.from(diag);
      parts.sort();
      return parts.join(',');
    }
  }

  GenericSetGrouping.NAMES = [
    tr.v.d.RESERVED_NAMES.ARCHITECTURES,
    tr.v.d.RESERVED_NAMES.BENCHMARKS,
    tr.v.d.RESERVED_NAMES.BOTS,
    tr.v.d.RESERVED_NAMES.BUILDS,
    tr.v.d.RESERVED_NAMES.MASTERS,
    tr.v.d.RESERVED_NAMES.MEMORY_AMOUNTS,
    tr.v.d.RESERVED_NAMES.OS_NAMES,
    tr.v.d.RESERVED_NAMES.OS_VERSIONS,
    tr.v.d.RESERVED_NAMES.PRODUCT_VERSIONS,
    tr.v.d.RESERVED_NAMES.STORIES,
    tr.v.d.RESERVED_NAMES.STORYSET_REPEATS,
  ];

  for (const name of GenericSetGrouping.NAMES) {
    // Instantiating a HistogramGrouping adds it to BY_KEY.
    new GenericSetGrouping(name);
  }

  class DateRangeGrouping extends HistogramGrouping {
    constructor(name) {
      super(name, undefined);
      this.callback_ = this.compute_.bind(this);
    }

    compute_(hist) {
      const diag = hist.diagnostics.get(this.key);
      if (diag === undefined) return '';
      return diag.toString();
    }
  }

  DateRangeGrouping.NAMES = [
    tr.v.d.RESERVED_NAMES.BENCHMARK_START,
    tr.v.d.RESERVED_NAMES.TRACE_START,
  ];

  for (const name of DateRangeGrouping.NAMES) {
    new DateRangeGrouping(name);
  }

  return {
    HistogramGrouping,
    GenericSetGrouping,
    DateRangeGrouping,
  };
});


'use strict';

tr.exportTo('tr.v', function() {
  class HistogramSet {
    constructor(opt_histograms) {
      this.histogramsByGuid_ = new Map();
      this.sharedDiagnosticsByGuid_ = new Map();

      if (opt_histograms !== undefined) {
        for (const hist of opt_histograms) {
          this.addHistogram(hist);
        }
      }
    }

    /**
     * Create a Histogram, configure it, add samples to it, and add it to this
     * HistogramSet.
     *
     * |samples| can be either
     *  0. a number, or
     *  1. a dictionary {value: number, diagnostics: dictionary}, or
     *  2. an array of
     *     2a. number, or
     *     2b. dictionaries {value, diagnostics}.
     *
     * @param {string} name
     * @param {!tr.b.Unit} unit
     * @param {number|!Object|!Array.<(number|!Object)>} samples
     * @param {!Object=} opt_options
     * @param {!tr.v.HistogramBinBoundaries} opt_options.binBoundaries
     * @param {!Object|!Map} opt_options.summaryOptions
     * @param {!Object|!Map} opt_options.diagnostics
     * @param {string} opt_options.description
     * @param {string} opt_options.shortName
     * @return {!tr.v.Histogram}
     */
    createHistogram(name, unit, samples, opt_options) {
      const hist = tr.v.Histogram.create(name, unit, samples, opt_options);
      this.addHistogram(hist);
      return hist;
    }

    /**
     * @param {!tr.v.Histogram} hist
     * @param {(!Object|!tr.v.d.DiagnosticMap)=} opt_diagnostics
     */
    addHistogram(hist, opt_diagnostics) {
      if (this.histogramsByGuid_.has(hist.guid)) {
        throw new Error('Cannot add same Histogram twice');
      }

      if (opt_diagnostics !== undefined) {
        if (!(opt_diagnostics instanceof Map)) {
          opt_diagnostics = Object.entries(opt_diagnostics);
        }
        for (const [name, diagnostic] of opt_diagnostics) {
          hist.diagnostics.set(name, diagnostic);
        }
      }

      this.histogramsByGuid_.set(hist.guid, hist);
    }

    /**
     * Add a Diagnostic to all Histograms in this HistogramSet in such a way
     * that it will only be serialized once rather than once per Histogram.
     *
     * @param {string} name
     * @param {!tr.v.d.Diagnostic} diagnostic
     */
    addSharedDiagnostic(name, diagnostic) {
      this.sharedDiagnosticsByGuid_.set(diagnostic.guid, diagnostic);

      for (const hist of this) {
        hist.diagnostics.set(name, diagnostic);
      }
    }

    get length() {
      return this.histogramsByGuid_.size;
    }

    * [Symbol.iterator]() {
      for (const hist of this.histogramsByGuid_.values()) {
        yield hist;
      }
    }

    /**
     * Filters Histograms by matching their name exactly.
     *
     * @param {string} name Histogram name.
     * @return {!Array.<!tr.v.Histogram>}
     */
    getHistogramsNamed(name) {
      return [...this].filter(h => h.name === name);
    }

    /**
     * Filters to find the Histogram that matches the specified name exactly.
     * If no Histogram with that name exists, undefined is returned. If multiple
     * Histograms with the name exist, an error is thrown.
     *
     * @param {string} name Histogram name.
     * @return {tr.v.Histogram}
     */
    getHistogramNamed(name) {
      const histograms = this.getHistogramsNamed(name);
      if (histograms.length === 0) return undefined;
      if (histograms.length > 1) {
        throw new Error(
            `Unexpectedly found multiple histograms named "${name}"`);
      }

      return histograms[0];
    }

    /**
     * Lookup a Histogram by its guid.
     *
     * @param {string} guid
     * @return {!tr.v.Histogram|undefined}
     */
    lookupHistogram(guid) {
      return this.histogramsByGuid_.get(guid);
    }

    /**
     * Lookup a Diagnostic by its guid.
     *
     * @param {string} guid
     * @return {!tr.v.d.Diagnostic|undefined}
     */
    lookupDiagnostic(guid) {
      return this.sharedDiagnosticsByGuid_.get(guid);
    }

    resolveRelatedHistograms() {
      const handleDiagnosticMap = dm => {
        for (const [name, diagnostic] of dm) {
          if (diagnostic instanceof tr.v.d.RelatedHistogramMap) {
            diagnostic.resolve(this);
          }
        }
      };

      for (const hist of this) {
        hist.diagnostics.resolveSharedDiagnostics(this);

        handleDiagnosticMap(hist.diagnostics);

        for (const dm of hist.nanDiagnosticMaps) {
          handleDiagnosticMap(dm);
        }

        for (const bin of hist.allBins) {
          for (const dm of bin.diagnosticMaps) {
            handleDiagnosticMap(dm);
          }
        }
      }
    }

    /**
     * Convert dicts to either Histograms or shared Diagnostics.
     * Does not resolve RelatedHistogramMap diagnostics. See
     * resolveRelatedHistograms().
     *
     * @param {!Object} dicts
     */
    importDicts(dicts) {
      for (const dict of dicts) {
        if (dict.type && tr.v.d.Diagnostic.findTypeInfoWithName(dict.type)) {
          this.sharedDiagnosticsByGuid_.set(dict.guid,
              tr.v.d.Diagnostic.fromDict(dict));
        } else {
          this.addHistogram(tr.v.Histogram.fromDict(dict));
        }
      }
    }

    /**
     * Serialize all of the Histograms and shared Diagnostics to an Array of
     * dictionaries.
     *
     * @return {!Array.<!Object>}
     */
    asDicts() {
      const dicts = [];
      for (const diagnostic of this.sharedDiagnosticsByGuid_.values()) {
        dicts.push(diagnostic.asDict());
      }
      for (const hist of this) {
        dicts.push(hist.asDict());
      }
      return dicts;
    }

    /**
     * Find the Histograms that are not contained in any other Histograms'
     * RelatedHistogramMap diagnostics.
     *
     * @return {!Array.<!tr.v.Histogram>}
     */
    get sourceHistograms() {
      const sourceHistograms = new Map(this.histogramsByGuid_);
      // If a Histogram is in a RelatedHistogramMap,
      // which can be owned either by Histograms or by numeric samples, then it
      // is not a source Histogram.
      function deleteSourceHistograms(diagnosticMap) {
        for (const [name, diagnostic] of diagnosticMap) {
          if (diagnostic instanceof tr.v.d.RelatedHistogramMap) {
            for (const [name, relatedHist] of diagnostic) {
              sourceHistograms.delete(relatedHist.guid);
            }
          }
        }
      }

      for (const hist of this) {
        deleteSourceHistograms(hist.diagnostics);
        for (const dm of hist.nanDiagnosticMaps) {
          deleteSourceHistograms(dm);
        }
        for (const b of hist.allBins) {
          for (const dm of b.diagnosticMaps) {
            deleteSourceHistograms(dm);
          }
        }
      }
      return new HistogramSet([...sourceHistograms.values()]);
    }

    /**
     * Return a nested Map, whose keys are strings and leaf values are Arrays of
     * Histograms.
     * See GROUPINGS for example |groupings|.
     * Groupings are skipped when |opt_skipGroupingCallback| is specified and
     * returns true.
     *
     * @typedef {!Array.<tr.v.Histogram>} HistogramArray
     * @typedef {!Map.<string,!(HistogramArray|HistogramArrayMap)>}
     *   HistogramArrayMap
     * @typedef {!Map.<string,!HistogramArray>} LeafHistogramArrayMap
     *
     * @param {!Array.<!tr.v.HistogramGrouping>} groupings
     * @param {!function(!Grouping, !LeafHistogramArrayMap):boolean=}
     *   opt_skipGroupingCallback
     *
     * @return {!(HistogramArray|HistogramArrayMap)}
     */
    groupHistogramsRecursively(groupings, opt_skipGroupingCallback) {
      function recurse(histograms, level) {
        if (level === groupings.length) {
          return histograms;  // recursion base case
        }

        const grouping = groupings[level];
        const groupedHistograms = tr.b.groupIntoMap(
            histograms, grouping.callback);

        if (opt_skipGroupingCallback && opt_skipGroupingCallback(
            grouping, groupedHistograms)) {
          return recurse(histograms, level + 1);
        }

        for (const [key, group] of groupedHistograms) {
          groupedHistograms.set(key, recurse(group, level + 1));
        }

        return groupedHistograms;
      }

      return recurse([...this], 0);
    }

    /*
     * Histograms and Diagnostics are merged two at a time, without considering
     * any others, so it is possible for two merged Diagnostics to be equivalent
     * but not identical, which is inefficient. This method replaces equivalent
     * Diagnostics with shared Diagnostics so that the HistogramSet can be
     * serialized more efficiently and so that these Diagnostics can be compared
     * quickly when merging relationship Diagnostics.
     */
    deduplicateDiagnostics() {
      const namesToCandidates = new Map();  // string: Set<Diagnostic>
      const diagnosticsToHistograms = new Map();  // Diagnostic: Histogram

      for (const hist of this) {
        for (const [name, candidate] of hist.diagnostics) {
          if (candidate.equals === undefined) continue;

          diagnosticsToHistograms.set(candidate, hist);

          if (!namesToCandidates.has(name)) {
            namesToCandidates.set(name, new Set());
          }
          namesToCandidates.get(name).add(candidate);
        }
      }

      for (const [name, candidates] of namesToCandidates) {
        const diagnosticsToCounts = new Map();

        for (const candidate of candidates) {
          let found = false;
          for (const [test, count] of diagnosticsToCounts) {
            if (candidate.equals(test)) {
              const hist = diagnosticsToHistograms.get(candidate);
              hist.diagnostics.set(name, test);
              diagnosticsToCounts.set(test, count + 1);
              found = true;
              break;
            }
          }
          if (!found) {
            diagnosticsToCounts.set(candidate, 1);
          }
        }

        for (const [diagnostic, count] of diagnosticsToCounts) {
          if (count > 1) {
            this.sharedDiagnosticsByGuid_.set(diagnostic.guid, diagnostic);
          }
        }
      }
    }

    /**
     * @param {!Iterable.<string>} names of GenericSet diagnostics
     * @return {!Array.<!tr.v.HistogramGrouping>}
     */
    buildGroupingsFromTags(names) {
      const tags = new Map();  // name: Set<string>
      for (const hist of this) {
        for (const name of names) {
          if (!hist.diagnostics.has(name)) continue;
          if (!tags.has(name)) tags.set(name, new Set());
          for (const tag of hist.diagnostics.get(name)) {
            tags.get(name).add(tag);
          }
        }
      }

      const groupings = [];
      for (const [name, values] of tags) {
        const built = tr.v.HistogramGrouping.buildFromTags(values, name);
        for (const grouping of built) {
          groupings.push(grouping);
        }
      }
      return groupings;
    }

    /*
     * RelatedHistogram diagnostics cannot be merged when Histograms are merged
     * because the related Histograms might not exist yet. Callers must
     * call HistogramSet.deduplicateDiagnostics() and then
     * HistogramSet.mergeRelationships() after merging Histograms in order to
     * merge RelatedHistogram diagnostics.
     */
    mergeRelationships() {
      for (const hist of this) {
        hist.diagnostics.mergeRelationships(hist);
      }
    }
  }

  return {
    HistogramSet,
  };
});


'use strict';
tr.exportTo('tr.e.chrome', function() {
  // TODO(dproy): Because title and category are properties of TimedEvent
  // subclasses and not TimedEvent itself, we have to write our own "has title
  // and category" function rather than having it provided by TimedEvent.
  // This should be fixed.
  // https://github.com/catapult-project/catapult/issues/2784
  function hasTitleAndCategory(event, title, category) {
    return event.title === title && event.category &&
      tr.b.getCategoryParts(event.category).includes(category);
  }

  function getNavStartTimestamps(rendererHelper) {
    const navStartTimestamps = [];
    for (const e of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (hasTitleAndCategory(e, 'navigationStart', 'blink.user_timing')) {
        navStartTimestamps.push(e.start);
      }
    }
    return navStartTimestamps;
  }

  /**
   * Returns a map of renderer PIDs to array of timestamps at which the
   * renderer became interactive.
   */
  function getInteractiveTimestamps(model) {
    const interactiveTimestampsMap = new Map();
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      const timestamps = [];
      interactiveTimestampsMap.set(rendererHelper.pid, timestamps);
      const samples = tr.metrics.sh.collectLoadingMetricsForRenderer(
          rendererHelper).firstInteractiveSamples;
      for (const sample of samples) {
        timestamps.push(tr.b.getOnlyElement(
            sample.diagnostics['Navigation infos']).interactive);
      }
    }
    return interactiveTimestampsMap;
  }

  /**
   * Returns an Array of task windows that start with the supplied interactive
   * timestamps.
   *
   * A task window is defined as the range of time from the time when the page
   * became interactive until either
   *
   *   1. The beginning of the next navigationStart event or
   *   2. The end of the trace
   *
   * This function only works when timestamps are from the same renderer. If
   * windows for multiple renderers need to be computed, the timestamps should
   * be separated for each renderer and this function should be called
   * separately for each.
   *
   * @param {!Array.<number>} interactiveTimestamps
   * @param {!Array.<number>} navStartTimestamps
   * @param {!number} traceEndTimestamp
   * @returns {!Array.<tr.b.math.Range>}
   */
  function getPostInteractiveTaskWindows(
      interactiveTimestamps, navStartTimestamps, traceEndTimestamp) {
    let navStartTsIndex = 0;
    let lastTaskWindowEndTs = undefined;
    const taskWindows = [];
    for (const currTTI of interactiveTimestamps) {
      // Find the first navigation start event after the interactive
      // timestamp.
      while (navStartTsIndex < navStartTimestamps.length &&
          navStartTimestamps[navStartTsIndex] < currTTI) {
        navStartTsIndex++;
      }

      const taskWindowEndTs = navStartTsIndex < navStartTimestamps.length ?
          navStartTimestamps[navStartTsIndex] : traceEndTimestamp;

      if (taskWindowEndTs === lastTaskWindowEndTs) {
        // This is the case where we have two different interactive timestamps
        // with no navigationStart event between them. This is only possible
        // when two different pages are sharing the same renderer process (and
        // therefore the same renderer scheduler). We cannot define a proper
        // task window in this case to calculate Estimated Input Latency.
        throw Error('Encountered two consecutive interactive timestamps ' +
            'with no navigationStart between them. ' +
            'PostInteractiveTaskWindow is not well defined in this case.');
      }

      taskWindows.push(tr.b.math.Range.fromExplicitRange(
          currTTI, taskWindowEndTs));
      lastTaskWindowEndTs = taskWindowEndTs;
    }
    return taskWindows;
  }

  /**
   * Returns the contribution of the given task to expected queueing time
   * in the given time window.
   *
   * The result is probabilityOf(task) * expectedQueueTimeDueTo(task),
   * where
   * - probabilityOf(task) = probability of input arriving while the given
   *   task is running.
   * - expectedQueueingTimeDueTo(task) = expected time until the end of the
   *   given task for input arriving while the task is running.
   *
   * We assume that input arrival time is uniformly distributed in the given
   * time window.
   *
   * @param {!tr.b.math.Range} A time window.
   * @param {!Array.<!{start: number, end: number, weight: number}>} A list of
   *        weighted tasks. The weight of a task must be between 0.0 and 1.0.
   * @returns {number}
   */
  function contributionToEQT(window, task) {
    const startInWindow = Math.max(window.min, task.start);
    const endInWindow = Math.min(window.max, task.end);
    const durationInWindow = endInWindow - startInWindow;
    if (durationInWindow <= 0) return 0;
    const probabilityOfTask = durationInWindow / (window.max - window.min);
    const minQueueingTime = task.end - endInWindow;
    const maxQueueingTime = task.end - startInWindow;
    const expectedQueueingTimeDueToTask =
        (maxQueueingTime + minQueueingTime) / 2;
    return probabilityOfTask * expectedQueueingTimeDueToTask;
  }

  /**
   * Returns weighted expected queueing time (EQT) for the given time window and
   * the given set of weighted tasks. The tasks must not overlap.
   *
   * The weighted EQT is computed as
   *   sum(contributionToEQT(window, task) * task.weight)
   * for all tasks in weightedTasks, where
   * - contributionToEQT is the function defined above.
   * - task.weight is an arbitrary number between 0.0 and 1.0. This is useful
   *   for computing contribution of chrome subcomponents (e.g. GC) to
   *   the expected queueing time for EQT diagnostics.
   *
   * We assume that input arrival time is uniformly distributed in the given
   * time window.
   *
   * @param {!tr.b.math.Range} A time window.
   * @param {!Array.<!{start: number, end: number, weight: number}>} A list of
   *        weighted tasks. The weight of a task must be between 0.0 and 1.0.
   * @returns {number}
   */
  function weightedExpectedQueueingTime(window, weightedTasks) {
    let result = 0;
    for (const task of weightedTasks) {
      result += contributionToEQT(window, task) * task.weight;
    }
    return result;
  }

  /**
   * Returns expected queueing time for the given time window and
   * the given set of tasks. The tasks must not overlap.
   *
   * @param {!tr.b.math.Range} A time window.
   * @param {!Array.<!{start: number, end: number}>} A list of tasks.
   * @returns {number}
   */
  function expectedQueueingTime(window, tasks) {
    return weightedExpectedQueueingTime(window, tasks.map(function(task) {
      return { start: task.start, end: task.end, weight: 1 };
    }));
  }

  /**
   * Object of this calss represents the sliding window and maintains its
   * main invariant: windowEQT = firstTaskEQT + innerEQT + lastTaskEQT.
   * It is intended to be used only in maxExpectedQueueingTimeInSlidingWindow().
   */
  class SlidingWindow {
    /**
     * @param {number} The starting time of the sliding window.
     * @param {number} The window size.
     * @param {!Array.<!{start: number, end: number}>} A list of tasks sorted by
     *     task start time.
     */
    constructor(startTime, windowSize, sortedTasks) {
      /**
       * @private @const {number} The window size.
       */
      this.windowSize_ = windowSize;
      /**
       * @private @const {!Array.<!{start: number, end: number}>} The tasks.
       */
      this.sortedTasks_ = sortedTasks;
      /**
       * @private {!tr.b.math.Range} The endpoints of the sliding window.
       */
      this.range_ = tr.b.math.Range.fromExplicitRange(
          startTime, startTime + windowSize);
      /**
       * @private {number} The index of the first task in the sortedTasks that
       *     ends after this window starts:
       *     this.range_.min < this.sortedTasks_[this.firstTaskIndex_].end.
       */
      this.firstTaskIndex_ =
          sortedTasks.findIndex(task => startTime < task.end);
      if (this.firstTaskIndex_ === -1) {
        this.firstTaskIndex_ = sortedTasks.length;
      }
      /**
       * @private {number} The index of the last task in the sortedTasks that
       *     starts before this window ends:
       *     this.range.max > this.sortedTasks_[lastTaskIndex_].start.
       */
      this.lastTaskIndex_ = -1;
      while (this.lastTaskIndex_ + 1 < sortedTasks.length &&
          sortedTasks[this.lastTaskIndex_ + 1].start < startTime + windowSize) {
        this.lastTaskIndex_++;
      }
      /**
       * @private {number} The sum of EQT contributions for all tasks between
       *     the first task and the last task (excluding the first and the last
       *     tasks). All such tasks are completely inside the window.
       */
      this.innerEQT_ = 0;
      for (let i = this.firstTaskIndex_ + 1; i < this.lastTaskIndex_; i++) {
        this.innerEQT_ += contributionToEQT(this.range_, sortedTasks[i]);
      }
    }

    /**
     * @returns the EQT for this window.
     */
    get getEQT() {
      let firstTaskEQT = 0;
      if (this.firstTaskIndex_ < this.sortedTasks_.length) {
        firstTaskEQT = contributionToEQT(this.range_,
            this.sortedTasks_[this.firstTaskIndex_]);
      }
      let lastTaskEQT = 0;
      if (this.firstTaskIndex_ < this.lastTaskIndex_) {
        lastTaskEQT = contributionToEQT(this.range_,
            this.sortedTasks_[this.lastTaskIndex_]);
      }
      return firstTaskEQT + this.innerEQT_ + lastTaskEQT;
    }

    /**
     * Moves the window to the given time t.
     * @param {number} The time.
     */
    slide(t) {
      this.range_ = tr.b.math.Range.fromExplicitRange(t, t + this.windowSize_);
      if (this.firstTaskIndex_ < this.sortedTasks_.length &&
          this.sortedTasks_[this.firstTaskIndex_].end <= t) {
        // The first task moved out of the window.
        this.firstTaskIndex_++;
        if (this.firstTaskIndex_ < this.lastTaskIndex_) {
          // The new first window was accounted in innerEQT. Undo that.
          this.innerEQT_ -= contributionToEQT(this.range_,
              this.sortedTasks_[this.firstTaskIndex_]);
        }
      }
      if (this.lastTaskIndex_ + 1 < this.sortedTasks_.length &&
          this.sortedTasks_[this.lastTaskIndex_ + 1].start <
              t + this.windowSize_) {
        // A new task moved in the window.
        if (this.firstTaskIndex_ < this.lastTaskIndex_) {
          // The old last task is completely inside the window.
          // Account it in innerEQT.
          this.innerEQT_ += contributionToEQT(this.range_,
              this.sortedTasks_[this.lastTaskIndex_]);
        }
        this.lastTaskIndex_++;
      }
    }
  }

  /**
   * Returns maximum expected queueing time for time window of the given size
   * that slides from the startTime to the endTime:
   *   max { expectedQueueingTime(window(t, t + windowSize), tasks),
   *         for all startTime <= t && t + w <= endTime }.
   * See https://goo.gl/jmWpMl for the description of the algorithm.
   *
   * @param {number} start time for the sliding window.
   * @param {number} end time for the sliding window.
   * @param {number} the size of the sliding window.
   * @param {!Array.<!{start: number, end: number}>} A list of tasks.
   *        The tasks must not overlap.
   * @returns {number}
   */
  function maxExpectedQueueingTimeInSlidingWindow(startTime, endTime,
      windowSize, tasks) {
    if (windowSize <= 0) {
      throw Error('The window size must be positive number');
    }
    if (startTime + windowSize > endTime) {
      throw Error('The sliding window must fit in the specified time range');
    }

    const sortedTasks = tasks.slice().sort((a, b) => a.start - b.start);

    for (let i = 1; i < sortedTasks.length; i++) {
      // Due to floating-point precision errors it might happen that the end
      // of the previous task is larger than the start of the current task.
      // Here is an example from a real trace:
      // Task 1: start=25851.0181016922 end=25851.0481016922
      // Task 2: start=25851.0251016616 end=34496.0291013717.
      // To account for precision errors we consider tasks as overlapping
      // if the overlap is sufficiently large.
      const PRECISION_MS = 0.1;
      if (sortedTasks[i - 1].end > sortedTasks[i].start + PRECISION_MS) {
        throw Error('Tasks must not overlap');
      }
      // Ensure that the previous task finishes not later than the current task.
      if (sortedTasks[i - 1].end > sortedTasks[i].start) {
        const midpoint = (sortedTasks[i - 1].end + sortedTasks[i].start) / 2;
        sortedTasks[i - 1].end = midpoint;
        sortedTasks[i].start = midpoint;
      }
    }

    // Collect all time points that the sliding window needs to stop at.
    // See https://goo.gl/jmWpMl for justification.
    let endpoints = [];
    endpoints.push(startTime);
    endpoints.push(endTime - windowSize);
    for (const task of tasks) {
      endpoints.push(task.start - windowSize);
      endpoints.push(task.start);
      endpoints.push(task.end - windowSize);
      endpoints.push(task.end);
    }
    endpoints = endpoints.filter(
        x => (startTime <= x && x + windowSize <= endTime));
    endpoints.sort((a, b) => a - b);

    // Slide the window and compute maxEQT.
    const slidingWindow = new SlidingWindow(
        endpoints[0], windowSize, sortedTasks);
    let maxEQT = 0;
    for (const t of endpoints) {
      slidingWindow.slide(t);
      maxEQT = Math.max(maxEQT, slidingWindow.getEQT);
    }
    return maxEQT;
  }

  return {
    getPostInteractiveTaskWindows,
    getNavStartTimestamps,
    getInteractiveTimestamps,
    expectedQueueingTime,
    maxExpectedQueueingTimeInSlidingWindow,
    weightedExpectedQueueingTime
  };
});


'use strict';

/**
 * @fileoverview
 * This file defines the input latency metric estimated as the maximum
 * expected queueing time (EQT) in sliding window of size 500ms.
 *
 * The EQT is defined as the average queueing time of a hypothetical input
 * event arriving at a random time in the given time window.
 * For more information see:
 * - https://goo.gl/OQ2bX6
 * - https://goo.gl/jmWpMl
 * - https://goo.gl/lga4iO
 */
tr.exportTo('tr.metrics.sh', function() {
  // The size of the sliding window is chosen arbitrarily (see
  // https://goo.gl/lga4iO).
  const WINDOW_SIZE_MS = 500;
  const EQT_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createExponential(0.01, WINDOW_SIZE_MS, 50);

  /**
   * Returns true if the slice contains a forced GC event. Some stories force
   * garbage collection before sampling memory usage. Since a forced GC takes
   * long time we need to ignore it to avoid biasing the input latency results.
   */
  function containsForcedGC_(slice) {
    return slice.findTopmostSlicesRelativeToThisSlice(
        tr.metrics.v8.utils.isForcedGarbageCollectionEvent).length > 0;
  }

  /**
   * @param {!string} name Name of the histogram.
   * @param {!string} description Description of the histogram.
   * @returns {!tr.v.Histogram}
   */
  function createHistogramForEQT_(name, description) {
    const histogram = new tr.v.Histogram(name,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, EQT_BOUNDARIES);
    histogram.customizeSummaryOptions({
      avg: false,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: false,
    });
    histogram.description = description;
    return histogram;
  }

  /**
   * Computes the maximum expected queueing time in the sliding time window
   * of size 500ms (WINDOW_SIZE_MS). The function produces four Histograms:
   * - total:500ms_window:renderer_eqt,
   * - total:500ms_window:renderer_eqt_cpu,
   * - interactive:500ms_window:renderer_eqt.
   * - interactive:500ms_window:renderer_eqt_cpu.
   * The 'total' histograms are computed for the whole trace. The 'interactive'
   * histograms are computed for the time while the page is interactive.
   * The 'cpu' histograms use the CPU time of the events instead of the wall-
   * clock times. Each renderer process adds one sample to the histograms.
   */
  function expectedQueueingTimeMetric(histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const rendererHelpers = Object.values(chromeHelper.rendererHelpers);
    const rendererToInteractiveTimestamps =
        tr.e.chrome.getInteractiveTimestamps(model);
    addExpectedQueueingTimeMetric_(
        'renderer_eqt',
        event => {return {start: event.start, duration: event.duration};},
        rendererHelpers, rendererToInteractiveTimestamps, histograms, model);
    addExpectedQueueingTimeMetric_(
        'renderer_eqt_cpu',
        event => {return {start: event.cpuStart, duration: event.cpuDuration};},
        rendererHelpers, rendererToInteractiveTimestamps, histograms, model);
  }

  /**
  * @callback EventTimesCallback
  * @param {!tr.b.Event} event
  * @return {{start: !number, duration: !number}} event start time and duration.
  */

  /**
   * The actual implementation of the EQT metric.
   * @param {!string} eqtName the metric name part of the histogram name.
   * @param {!EventTimesCallback} getEventTimes.
   * @param {!Array.<tr.model.helpers.ChromeRendererHelper>} rendererHelpers.
   * @param {!Map.<number, Array.<number>>} rendererToInteractiveTimestamps
   *     a map from renderer pid to an array of interactive timestamps.
   */
  function addExpectedQueueingTimeMetric_(eqtName, getEventTimes,
      rendererHelpers, rendererToInteractiveTimestamps, histograms, model) {
    /**
     * Extracts tasks for EQT computation from the given renderer.
     * A task is a pair of {start, end} times.
     */
    function getTasks(rendererHelper) {
      const tasks = [];
      for (const slice of rendererHelper.mainThread.sliceGroup.topLevelSlices) {
        const times = getEventTimes(slice);
        if (times.duration > 0 && !containsForcedGC_(slice)) {
          tasks.push({start: times.start, end: times.start + times.duration});
        }
      }
      return tasks;
    }
    const totalHistogram = createHistogramForEQT_(
        `total:${WINDOW_SIZE_MS}ms_window:${eqtName}`,
        `The maximum EQT in a ${WINDOW_SIZE_MS}ms sliding window` +
        ' for a given renderer');
    const interactiveHistogram = createHistogramForEQT_(
        `interactive:${WINDOW_SIZE_MS}ms_window:${eqtName}`,
        `The maximum EQT in a ${WINDOW_SIZE_MS}ms sliding window` +
        ' for a given renderer while the page is interactive');
    for (const rendererHelper of rendererHelpers) {
      if (rendererHelper.isChromeTracingUI) continue;
      const tasks = getTasks(rendererHelper);
      totalHistogram.addSample(
          tr.e.chrome.maxExpectedQueueingTimeInSlidingWindow(
              rendererHelper.mainThread.bounds.min,
              rendererHelper.mainThread.bounds.max,
              WINDOW_SIZE_MS, tasks));
      const interactiveTimestamps =
        rendererToInteractiveTimestamps.get(rendererHelper.pid);
      if (interactiveTimestamps.length === 0) continue;
      if (interactiveTimestamps.length > 1) {
        // TODO(ulan): Support multiple interactive time windows when
        // https://crbug.com/692112 is fixed.
        continue;
      }
      const interactiveWindow =
          tr.b.math.Range.fromExplicitRange(interactiveTimestamps[0], Infinity)
          .findIntersection(rendererHelper.mainThread.bounds);
      interactiveHistogram.addSample(
          tr.e.chrome.maxExpectedQueueingTimeInSlidingWindow(
              interactiveWindow.min, interactiveWindow.max,
              WINDOW_SIZE_MS, tasks));
    }
    addV8ContributionToExpectedQueueingTime_(
        eqtName, getEventTimes, totalHistogram, interactiveHistogram,
        rendererToInteractiveTimestamps, histograms, model);
    histograms.addHistogram(totalHistogram);
    histograms.addHistogram(interactiveHistogram);
  }

  /**
   * Adds v8 related diagnostic histograms for the total and interactive EQT
   * of the renderer.
   * Sample histograms:
   * - total:500ms_window:renderer_eqt:v8,
   * - total:500ms_window:renderer_eqt:v8:gc,
   * - interactive:500ms_window:renderer_eqt:v8:gc:scavenger,
   * - interactive:500ms_window:renderer_eqt:v8:compile.
   * @param {!string} eqtName the metric name part of the histogram name.
   * @param {!EventTimesCallback} getEventTimes.
   * @param {!tr.v.Histogram} totalEqtHistogram.
   * @param {!tr.v.Histogram} interactiveEqtHistogram.
   * @param {!Map.<number, Array.<number>>} rendererToInteractiveTimestamps
   *     a map from renderer pid to an array of interactive timestamps.
   */
  function addV8ContributionToExpectedQueueingTime_(
      eqtName, getEventTimes, totalEqtHistogram, interactiveEqtHistogram,
      rendererToInteractiveTimestamps, histograms, model) {
    if (!model.categories.includes('v8')) return;
    const breakdownForTotal = new tr.v.d.RelatedHistogramMap();
    const breakdownForInteractive = new tr.v.d.RelatedHistogramMap();
    const eventNamesWithTaskExtractors =
        getV8EventNamesWithTaskExtractors_(getEventTimes);
    for (const [eventName, getTasks] of eventNamesWithTaskExtractors) {
      const contribution = contributionToExpectedQueueingTime_(
          eqtName, eventName, getTasks, rendererToInteractiveTimestamps,
          histograms, model);
      breakdownForTotal.set(eventName, contribution.total);
      breakdownForInteractive.set(eventName, contribution.interactive);
    }
    totalEqtHistogram.diagnostics.set('v8', breakdownForTotal);
    interactiveEqtHistogram.diagnostics.set('v8', breakdownForInteractive);
  }

  /**
  * @callback TaskExtractor
  * @param {!tr.model.helpers.ChromeRendererHelper} rendererHelper
  * @return {Array.<{start: !number, end: !number}>}
  */

  /**
   * @param {!EventTimesCallback} getEventTimes.
   * @returns {!Map.<string, TaskExtractor>} a map from V8 event names to
   *     the corresponding task extractor functions.
   */
  function getV8EventNamesWithTaskExtractors_(getEventTimes) {
    /**
     * @param {!tr.b.Event} slice.
     * @param {!function(tr.b.Event): boolean} predicate that selects V8 events.
     * @param {function(tr.b.Event): boolean} excludePredicate that excludes
     *     V8 events.
     * @returns {!number} the total duration of topmost subslices of the given
     *     slice that satisfy the given |predicate| after filtering out any
     *     events that satisfy the |excludePredicate| in the subslices.
     */
    function durationOfTopmostSubSlices(slice, predicate, excludePredicate) {
      let duration = 0;
      for (const sub of slice.findTopmostSlicesRelativeToThisSlice(predicate)) {
        duration += getEventTimes(sub).duration;
        if (excludePredicate !== null && excludePredicate !== undefined) {
          duration -= durationOfTopmostSubSlices(sub, excludePredicate);
        }
      }
      return duration;
    }

    /**
     * @param {!function(tr.b.Event): boolean} predicate that selects V8 events.
     * @param {function(tr.b.Event): boolean} excludePredicate that excludes
     *     V8 events.
     * @returns {!TaskExtractor} a function that extracts tasks from the given
     *     renderer. Each task is a pair of {start, end} times and its duration
     *     represents the contribution of the events selected by the
     *     given |predicate| and |excludePredicate|.
     */
    function taskExtractor(predicate, excludePredicate) {
      return function(rendererHelper) {
        const slices = rendererHelper.mainThread.sliceGroup.topLevelSlices;
        const result = [];
        for (const slice of slices) {
          const times = getEventTimes(slice);
          if (times.duration > 0 && !containsForcedGC_(slice)) {
            const duration = durationOfTopmostSubSlices(
                slice, predicate, excludePredicate);
            result.push({start: times.start, end: times.start + duration});
          }
        }
        return result;
      };
    }

    return new Map([
      [
        'v8',
        taskExtractor(tr.metrics.v8.utils.isV8Event)
      ],
      [
        'v8:compile',
        taskExtractor(tr.metrics.v8.utils.isCompileEvent)
      ],
      [
        'v8:compile:optimize',
        taskExtractor(tr.metrics.v8.utils.isCompileOptimizeEvent)
      ],
      [
        'v8:compile:parse',
        taskExtractor(tr.metrics.v8.utils.isCompileParseEvent)
      ],
      [
        'v8:compile:compile-unoptimize',
        taskExtractor(tr.metrics.v8.utils.isCompileUnoptimizeEvent,
            tr.metrics.v8.utils.isCompileParseEvent)
      ],
      [
        'v8:execute',
        taskExtractor(tr.metrics.v8.utils.isV8ExecuteEvent)
      ],
      [
        'v8:gc',
        taskExtractor(tr.metrics.v8.utils.isGarbageCollectionEvent)
      ],
      [
        'v8:gc:full-mark-compactor',
        taskExtractor(tr.metrics.v8.utils.isFullMarkCompactorEvent)
      ],
      [
        'v8:gc:incremental-marking',
        taskExtractor(tr.metrics.v8.utils.isIncrementalMarkingEvent)
      ],
      [
        'v8:gc:latency-mark-compactor',
        taskExtractor(tr.metrics.v8.utils.isLatencyMarkCompactorEvent)
      ],
      [
        'v8:gc:memory-mark-compactor',
        taskExtractor(tr.metrics.v8.utils.isMemoryMarkCompactorEvent)
      ],
      [
        'v8:gc:scavenger',
        taskExtractor(tr.metrics.v8.utils.isScavengerEvent)
      ]
    ]);
  }

  /**
   * Computes the contribution of the selected events to the expected queueing
   * time. We define the contribution as the maximum expected queueing time in
   * the sliding time window of size 500ms (WINDOW_SIZE_MS) for the trace that
   * is modified as follows:
   * - from each top-level task remove all subevents except the selected events.
   * - removing subevents shrinks a task by shifting its end time closer to
   *   the start time. The start time does not change.
   *
   * Similar to the expectedQueueingTime this function computes two histograms:
   * total and interactive. For example:
   * - total:500ms_window:renderer_eqt:v8,
   * - interactive:500ms_window:renderer_eqt:v8.
   * Each renderer process adds one sample to the histograms.
   * Both histograms are added to the given histogram set.
   *
   * @param {!string} eqtName the metric name part of the histogram name.
   * @param {!string} eventName the name describing the selected events. This
   *     name will be added to metric names.
   * @param {!TaskExtractor} getTasks a function that given a renderer returns
   *     tasks for computing the EQT taking into account the contribution of
   *     the selected events.
   * @param {!Map.<number, Array.<number>>} rendererToInteractiveTimestamps
   *     a map from renderer pid to an array of interactive timestamps.
   * @returns {{total: !tr.v.Histogram, interactive: !tr.v.Histogram}}
   */
  function contributionToExpectedQueueingTime_(
      eqtName, eventName, getTasks,
      rendererToInteractiveTimestamps, histograms, model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const totalHistogram = createHistogramForEQT_(
        `total:${WINDOW_SIZE_MS}ms_window:${eqtName}:${eventName}`,
        `Contribution to the expected queueing time by ${eventName}` +
        ' for a given renderer. It is computed as the maximum EQT in' +
        ` a ${WINDOW_SIZE_MS}ms sliding window after shrinking top-level` +
        ` tasks to contain only ${eventName} subevents`);
    const interactiveHistogram = createHistogramForEQT_(
        `interactive:${WINDOW_SIZE_MS}ms_window:${eqtName}:${eventName}`,
        `Contribution to the expected queueing time by ${eventName}` +
        ' for a given renderer while the page is interactive. It is computed' +
        ` as the maximum EQT in a ${WINDOW_SIZE_MS}ms sliding window after` +
        ` shrinking top-level tasks to contain only ${eventName} subevents`);
    const rendererHelpers = Object.values(chromeHelper.rendererHelpers);
    for (const rendererHelper of rendererHelpers) {
      if (rendererHelper.isChromeTracingUI) continue;
      const tasks = getTasks(rendererHelper);
      totalHistogram.addSample(
          tr.e.chrome.maxExpectedQueueingTimeInSlidingWindow(
              rendererHelper.mainThread.bounds.min,
              rendererHelper.mainThread.bounds.max,
              WINDOW_SIZE_MS, tasks));
      const interactiveTimestamps =
          rendererToInteractiveTimestamps.get(rendererHelper.pid);
      if (interactiveTimestamps.length === 0) continue;
      if (interactiveTimestamps.length > 1) {
        // TODO(ulan): Support multiple interactive time windows when
        // https://crbug.com/692112 is fixed.
        continue;
      }
      const interactiveWindow =
          tr.b.math.Range.fromExplicitRange(interactiveTimestamps[0], Infinity)
          .findIntersection(rendererHelper.mainThread.bounds);
      interactiveHistogram.addSample(
          tr.e.chrome.maxExpectedQueueingTimeInSlidingWindow(
              interactiveWindow.min, interactiveWindow.max,
              WINDOW_SIZE_MS, tasks));
    }
    histograms.addHistogram(totalHistogram);
    histograms.addHistogram(interactiveHistogram);
    return {
      total: totalHistogram,
      interactive: interactiveHistogram
    };
  }

  tr.metrics.MetricRegistry.register(expectedQueueingTimeMetric);

  return {
    expectedQueueingTimeMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const LONG_TASK_MS = 50;

  // Anything longer than this should be so rare that its length beyond this is
  // uninteresting.
  const LONGEST_TASK_MS = 1000;

  /**
   * This helper function calls |cb| for each of the top-level tasks on the
   * given thread in the given range whose duration is longer than LONG_TASK_MS.
   *
   * @param {tr.model.Thread} thread
   * @param {tr.b.math.Range=} opt_range
   * @param {function()} cb
   * @param {Object=} opt_this
   */
  function iterateLongTopLevelTasksOnThreadInRange(
      thread, opt_range, cb, opt_this) {
    thread.sliceGroup.topLevelSlices.forEach(function(slice) {
      if (opt_range &&
          !opt_range.intersectsExplicitRangeInclusive(slice.start, slice.end)) {
        return;
      }

      if (slice.duration < LONG_TASK_MS) return;

      cb.call(opt_this, slice);
    });
  }

  /**
   * This helper function calls |cb| for each of the main renderer threads in
   * the model.
   *
   * @param {tr.model.Model} model The model.
   * @param {function()} cb Callback.
   * @param {Object=} opt_this Context object.
   */
  function iterateRendererMainThreads(model, cb, opt_this) {
    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (modelHelper !== undefined) {
      Object.values(modelHelper.rendererHelpers).forEach(
          function(rendererHelper) {
            if (!rendererHelper.mainThread) return;

            cb.call(opt_this, rendererHelper.mainThread);
          });
    }
  }

  /**
   * This metric directly measures long tasks on renderer main threads.
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function longTasksMetric(histograms, model, opt_options) {
    const rangeOfInterest = opt_options ? opt_options.rangeOfInterest :
      undefined;
    const longTaskHist = new tr.v.Histogram('long tasks',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        tr.v.HistogramBinBoundaries.createLinear(
            LONG_TASK_MS, LONGEST_TASK_MS, 40));
    longTaskHist.description = 'durations of long tasks';
    const slices = new tr.model.EventSet();
    iterateRendererMainThreads(model, function(thread) {
      iterateLongTopLevelTasksOnThreadInRange(
          thread, rangeOfInterest, function(task) {
            longTaskHist.addSample(task.duration,
                {relatedEvents: new tr.v.d.RelatedEventSet([task])});
            slices.push(task);
            slices.addEventSet(task.descendentSlices);
          });
    });
    histograms.addHistogram(longTaskHist);

    const sampleForEvent = undefined;
    const breakdown = tr.v.d.RelatedHistogramBreakdown.buildFromEvents(
        histograms, 'long tasks ', slices,
        e => (model.getUserFriendlyCategoryFromEvent(e) || 'unknown'),
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, sampleForEvent,
        tr.v.HistogramBinBoundaries.createExponential(1, LONGEST_TASK_MS, 40));
    breakdown.colorScheme =
      tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;
    longTaskHist.diagnostics.set('category', breakdown);
  }

  tr.metrics.MetricRegistry.register(longTasksMetric, {
    supportsRangeOfInterest: true
  });

  return {
    longTasksMetric,
    iterateLongTopLevelTasksOnThreadInRange,
    iterateRendererMainThreads,
    LONG_TASK_MS,
    LONGEST_TASK_MS,
  };
});


'use strict';

/**
 * @fileoverview Multi-dimensional view data structure.
 *
 * A multi-dimensional view provides a hierarchical representation of a
 * collection of multi-dimensional paths with associated scalar values. Unlike
 * separate single-dimensional views (e.g. one tree for each dimension),
 * multi-dimensional views facilitate aggregation over combinations of
 * substrings of the path dimensions (rather than just substrings of a single
 * path dimension).
 *
 * Every view consists of multi-dimensional nodes (see MultiDimensionalViewNode
 * for more details). This file also provides a builder class for constructing
 * top-down and bottom-up representations of arbitrary collections of
 * multi-dimensional paths (see MultiDimensionalViewBuilder for more details).
 *
 * Example: Given the following collection of two dimensional paths:
 *
 *   <===================== Path =====================>   <== Total values ===>
 *    <------- dimension 0 ------->  <- dimension 1 ->    <- v 0 ->  <- v 1 ->
 *   [['Run()', 'Exec()', 'Call()'], ['Obj', 'View']  ]: [1        , 3
 *   [['Run()', 'Exec()', 'Call()'], ['Obj', 'Widget']]: [2        , 5
 *   [['Run()', 'Exec()', 'Load()'], ['Obj']          ]: [4        , 11
 *   [['Run()', 'Exec()']          , ['int']          ]: [8        , 7
 *   [['Run()']                    , ['Obj', 'Window']]: [16       , 0
 *   [['Stop()']                   , ['Obj']          ]: [32       , 13
 *
 * a multi-dimensional view provides a recursive breakdown of the aggregated
 * values, e.g. (total values shown in square brackets):
 *
 *   (root): [63, 39]
 *     |
 *     | break down by 0th dimension
 *     v
 *   Run():  [31, 26]
 *     |
 *     | break down by 0th dimension
 *     v
 *   Exec(): [15, 26]
 *     |
 *     | break down by 1st dimension
 *     v
 *   Obj:    [7, 19]
 *     |
 *     | break down by 0th dimension again
 *     v
 *   Call(): [3, 8]
 *     |
 *     | break down by 1st dimension again
 *     v
 *   View:   [1, 3]
 *
 * Observe that the recursive breakdown above is over both dimensions.
 * Furthermore, the underlying single-dimension paths (Run() -> Exec() -> Call()
 * and Obj -> View) can be arbitrarily interleaved in the breakdown.
 */
tr.exportTo('tr.b', function() {
  /**
   * Node of a multi-dimensional view.
   *
   * The structure of a view is encoded in the nodes using links to their
   * children wrt each dimension. The diagram below shows how the nodes
   * corresponding to the following four two-dimensional view paths:
   *
   *   1. [['A', 'B'], ['1', '2']]
   *   2. [['A', 'C'], ['1', '2']]
   *   3. [['A', 'B'], ['1', '3']]
   *   4. [['A', 'C'], ['1', '3']]
   *
   * can be reached from the root of a two-dimensional view using these links
   * ('*' stands for undefined):
   *
   *                       +---------------------+
   *                       | title: [*,*] (root) |
   *                       +---------------------+
   *                     children wrt    children wrt
   *                    0th dimension    1st dimension
   *                              |        :
   *              _______A________|        :........1.........
   *             |                                           :
   *             v                                           v
   *         +--------------+                     +--------------+
   *         | title: [A,*] |                     | title: [*,1] |
   *         +--------------+                     +--------------+
   *    children wrt   children wrt         children wrt   children wrt
   *   0th dimension   1st dimension       0th dimension   1st dimension
   *           | |       :.....1......    _____A_____|       : :
   *        _B_| |__C__              :   |             ...2..: :.3..
   *       |           |             :   |             :           :
   *       v           v             v   v             v           v
   *   +-------+   +-------+       +-------+       +-------+   +-------+
   *   | [B,*] |   | [C,*] |       | [A,1] |       | [*,2] |   | [*,3] |
   *   +-------+   +-------+       +-------+       +-------+   +-------+
   *       :        ___:_____B______| | : :......3.....|....       |
   *       :.1..   |   :.1..    __C___| :...2...    _A_|   :    _A_|
   *           :   |       :   |               :   |       :   |
   *           v   v       v   v               v   v       v   v
   *         +-------+   +-------+           +-------+   +-------+
   *         | [B,1] |   | [C,1] |           | [A,2] |   | [A,3] |
   *         +-------+   +-------+           +-------+   +-------+
   *           :   :       :   :.......3.......||..........   ||
   *           :   :..3....:................   BC         :   BC
   *           :     ______:_______________:___||         :   ||
   *           2    |      2        _______:____|   ______:___||
   *           :    |      :       |       :       |      :    |
   *           v    v      v       v       v       v      v    v
   *       +----------+   +----------+   +----------+   +----------+
   *       |  [B,2]   |   |  [C,2]   |   |  [B,3]   |   |  [C,3]   |
   *       | (node 1) |   | (node 2) |   | (node 3) |   | (node 4) |
   *       +----------+   +----------+   +----------+   +----------+
   *
   * The self/total values of a node represents the aggregated values of all
   * paths (in the collection from which the view was built) matching the node
   * excluding/including the node's descendants.
   *
   * Terminology examples:
   *
   *   - Children of [A,*] wrt 0th dimension: [B,*], [C,*]
   *   - Children of [A,*] (wrt all dimensions): [B,*], [C,*], [A,1]
   *   - Descendants of [A,*] wrt 1st dimension: [A,1], [A,2], [A,3]
   *   - Single-dimensional descendants of [A,*]: [A,1], [A,2], [A,3], [B,*],
   *     [C,*]
   *   - Descendants of [A,*] (wrt all dimensions): [A,1], [A,2], [A,3], [B,*],
   *     [C,*], [B,1], [C,1], [B,2], [C,2], [B,3], [C,3]
   *
   * @{constructor}
   */
  function MultiDimensionalViewNode(title, valueCount) {
    // List of titles of this node wrt each dimension.
    this.title = title;

    // Map from child name to child node for each dimension.
    const dimensions = title.length;
    this.children = new Array(dimensions);
    for (let i = 0; i < dimensions; i++) {
      this.children[i] = new Map();
    }

    // For each value index (from 0 to |valueCount| - 1), we store the self and
    // total values together with a Boolean flag whether the value is only a
    // lower bound (i.e. aggregated from children rather than provided
    // directly).
    this.values = new Array(valueCount);
    for (let v = 0; v < valueCount; v++) {
      this.values[v] = { self: 0, total: 0, totalState: NOT_PROVIDED };
    }
  }

  /**
   * States of total values stored in multi-dimensional view nodes.
   *
   * @enum
   */
  MultiDimensionalViewNode.TotalState = {
    // Neither total nor self value was provided for either the node or any of
    // its descendants.
    NOT_PROVIDED: 0,

    // The total value was NOT provided for the node, but the self value was
    // provided for the node or the total or self value was provided for at
    // least one of its descendants.
    LOWER_BOUND: 1,

    // The total value was provided for the node.
    EXACT: 2
  };
  // Cache the total value states to avoid repeated object field lookups.
  const NOT_PROVIDED = MultiDimensionalViewNode.TotalState.NOT_PROVIDED;
  const LOWER_BOUND = MultiDimensionalViewNode.TotalState.LOWER_BOUND;
  const EXACT = MultiDimensionalViewNode.TotalState.EXACT;

  MultiDimensionalViewNode.prototype = {
    /** Duck type <tr-ui-b-table> rows. */
    get subRows() {
      return Array.from(this.children[0].values());
    }
  };

  /**
   * Builder for multi-dimensional views.
   *
   * Given a collection of multi-dimensional paths, a builder can be used to
   * construct the following three representations of the paths:
   *
   *   1. Top-down tree view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their prefix.
   *
   *   2. Top-down heavy view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their substring
   *
   *   3. Bottom-up heavy view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their substring reversed.
   *
   * For example, the following collection of 2-dimensional paths (with single
   * values):
   *
   *                  2-dimensional path                | self
   *    Time (0th dimension) | Activity (1st dimension) | value
   *   ========================+========================+=======
   *    Saturday             | Cooking                  |   1 h
   *    Saturday             | Sports -> Football       |   2 h
   *    Sunday               | Sports -> Basketball     |   3 h
   *
   * gives rise to the following top-down tree view, which aggregates the
   * scalar values over prefixes of the given paths:
   *
   *                              +---------+
   *                              |    *    |
   *                              |    *    |
   *                              | self=0  |
   *                              | total=6 |
   *                              +---------+
   *                                | : | :
   *         _________Cooking_______| : | :............Sunday............
   *        |                         : |                               :
   *        |            ...Saturday..: |_Sports_                       :
   *        |            :                       |                      :
   *        v            v                       v                      v
   *   +---------+  +---------+            +---------+             +---------+
   *   |    *    |  |   Sat   |            |    *    |             |   Sun   |
   *   | Cooking |  |    *    |            | Sports  |             |    *    |
   *   | self=0  |  | self=0  |            | self=0  |             | self=0  |
   *   | total=1 |  | total=3 |            | total=5 |             | total=3 |
   *   +---------+  +---------+            +---------+             +---------+
   *      :          |   |                   : | | :                     |
   *    Saturday     | Sports                : | | :                  Sports
   *      :          |   |  .....Saturday....: | | :.....Sunday.......   |
   *      :    _Cook_|   |  :            _Foot_| |_Bask_             :   |
   *      :   |          |  :           |               |            :   |
   *      v   v          v  v           v               v            v   v
   *   +---------+  +---------+  +------------+  +--------------+  +---------+
   *   |   Sat   |  |   Sat   |  |     *      |  |      *       |  |   Sun   |
   *   | Cooking |  | Sports  |  | S/Football |  | S/Basketball |  | Sports  |
   *   | self=1  |  | self=0  |  | self=0     |  | self=0       |  | self=0  |
   *   | total=1 |  | total=2 |  | total=2    |  | total=3      |  | total=3 |
   *   +---------+  +---------+  +------------+  +--------------+  +---------+
   *                    |              :                 :               |
   *                    |_Foot_  ..Sat.:                 :.Sun..   _Bask_|
   *                           | :                             :  |
   *                           v v                             v  v
   *                     +------------+                   +--------------+
   *                     |    Sat     |                   |     Sun      |
   *                     | S/Football |                   | S/Basketball |
   *                     | self=2     |                   | self=3       |
   *                     | total=2    |                   | total=3      |
   *                     +------------+                   +--------------+
   *
   * To build a multi-dimensional view of a collection of multi-dimensional
   * paths, you create a builder, add the paths to it and then use it to
   * construct the view. For example, the following code generates the
   * 2-dimensional top-down tree view shown above:
   *
   *   const builder = new MultiDimensionalViewBuilder(2);
   *   builder.addPath([['Saturday'], ['Cooking']], [1], SELF);
   *   builder.addPath([['Saturday'], ['Sports', 'Football']], [2], SELF);
   *   builder.addPath([['Sunday'], ['Sports', 'Basketball']], [3], SELF);
   *   const treeViewRoot = builder.buildTopDownTreeView();
   *
   * The heavy views can be constructed analogously (by calling
   * buildTopDownHeavyView() or buildBottomUpHeavyView() at the end instead).
   *
   * Note that the same builder can be used to construct both the tree and
   * heavy views (for the same collection of paths). However, no more paths can
   * be added once either view has been built.
   *
   * @{constructor}
   */
  function MultiDimensionalViewBuilder(dimensions, valueCount) {
    if (typeof(dimensions) !== 'number' || dimensions < 0) {
      throw new Error('Dimensions must be a non-negative number');
    }
    this.dimensions_ = dimensions;

    if (typeof(valueCount) !== 'number' || valueCount < 0) {
      throw new Error('Number of values must be a non-negative number');
    }
    this.valueCount_ = valueCount;

    this.buildRoot_ = this.createRootNode_();
    this.topDownTreeViewRoot_ = undefined;
    this.topDownHeavyViewRoot_ = undefined;
    this.bottomUpHeavyViewNode_ = undefined;
    this.complete_ = false;

    this.maxDimensionDepths_ = new Array(dimensions);
    for (let d = 0; d < dimensions; d++) {
      this.maxDimensionDepths_[d] = 0;
    }
  }

  /** @{enum} */
  MultiDimensionalViewBuilder.ValueKind = {
    SELF: 0,
    TOTAL: 1
  };

  /**
   * Types of multi-dimensional views provided by MultiDimensionalViewBuilder.
   *
   * @enum
   */
  MultiDimensionalViewBuilder.ViewType = {
    TOP_DOWN_TREE_VIEW: 0,
    TOP_DOWN_HEAVY_VIEW: 1,
    BOTTOM_UP_HEAVY_VIEW: 2
  };

  MultiDimensionalViewBuilder.prototype = {
    /**
     * Add values associated with a multi-dimensional path to the tree.
     *
     * The path must have the same number of dimensions as the builder. Its
     * elements must be single-dimension paths (lists of strings) of arbitrary
     * length (empty for the root of the given dimension). Starting from the
     * root of the tree, each single-dimension path is traversed from left to
     * right to reach the node corresponding to the whole path.
     *
     * The length of the provided list of values must be equal to the builder's
     * value count. The builder supports adding both kinds of values
     * (self/total) wrt all value indices for an arbitrary multi-dimensional
     * path. The rationale for adding total values (in addition to/instead of
     * self values) is to cater for missing sub-paths. Example: Consider the
     * following collection of single-dimensional paths (with single values):
     *
     *   [['Loop::Run()', 'Execute()', 'FunctionBig']]:       self=99000
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall1']]:    self=1
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall2']]:    self=1
     *   ...
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall1000']]: self=1
     *
     * If we required that only self values could be added to the builder, then
     * all of the 1001 paths would need to be provided (most likely in a trace)
     * to obtain the correct total of [['Loop::Run()', 'Execute()']]. However,
     * since we allow adding total values as well, only the following 2 paths
     * need to be provided to get the correct numbers explaining 99% of the
     * aggregated total value:
     *
     *   [['Loop::Run()', 'Execute()']]:                total=100000
     *   [['Loop::Run()', 'Execute()', 'FunctionBig']]: self=99000
     *
     * In other words, the long tail containing 1000 small paths need not be
     * dumped (greatly reducing the size of a trace where applicable).
     *
     * Important: No paths can be added to a builder once either view has been
     * built!
     */
    addPath(path, values, valueKind) {
      if (this.buildRoot_ === undefined) {
        throw new Error(
            'Paths cannot be added after either view has been built');
      }
      if (path.length !== this.dimensions_) {
        throw new Error('Path must be ' + this.dimensions_ + '-dimensional');
      }
      if (values.length !== this.valueCount_) {
        throw new Error('Must provide ' + this.valueCount_ + ' values');
      }

      let isTotal;
      switch (valueKind) {
        case MultiDimensionalViewBuilder.ValueKind.SELF:
          isTotal = false;
          break;
        case MultiDimensionalViewBuilder.ValueKind.TOTAL:
          isTotal = true;
          break;
        default:
          throw new Error('Invalid value kind: ' + valueKind);
      }

      let node = this.buildRoot_;
      for (let d = 0; d < path.length; d++) {
        const singleDimensionPath = path[d];
        const singleDimensionPathLength = singleDimensionPath.length;
        this.maxDimensionDepths_[d] =
            Math.max(this.maxDimensionDepths_[d], singleDimensionPathLength);
        for (let i = 0; i < singleDimensionPathLength; i++) {
          node = this.getOrCreateChildNode_(node, d, singleDimensionPath[i]);
        }
      }

      for (let v = 0; v < this.valueCount_; v++) {
        const addedValue = values[v];
        if (addedValue === undefined) continue;
        const nodeValue = node.values[v];
        if (isTotal) {
          nodeValue.total += addedValue;
          nodeValue.totalState = EXACT;
        } else {
          nodeValue.self += addedValue;
          nodeValue.totalState = Math.max(nodeValue.totalState, LOWER_BOUND);
        }
      }
    },


    get complete() {
      return this.complete_;
    },

    /**
     * Force all MultiDimensionalViewNode's to have totalState EXACT.
     * Set to true only if all SELF paths for the tree have been provided.
     * Setting unnecessary if providing TOTAL values.
     *
     * MultiDimensionalViewBuilder allows both 'self' and 'total' values to be
     * entered for paths then later when the veiws are constructed it
     * determines the total and whether that total is exact or a lower bound
     * for each node. When total values are provided we know that that total
     * is exact however when self values are provided the computed totals
     * *could* be complete ...if the user has provided the all the self
     * values for the whole tree. We can't know this within the
     * MultiDimensionalViewBuilder so this flag allows the user to specify
     * that this is the case.
     *
     * Important: Can't be set once any view has been built.
     */
    set complete(isComplete) {
      if (this.buildRoot_ === undefined) {
        throw new Error('Can\'t set complete after any view has been built.');
      }
      this.complete_ = isComplete;
    },

    buildView(viewType) {
      switch (viewType) {
        case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW:
          return this.buildTopDownTreeView();
        case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW:
          return this.buildTopDownHeavyView();
        case MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW:
          return this.buildBottomUpHeavyView();
        default:
          throw new Error('Unknown multi-dimensional view type: ' + viewType);
      }
    },

    /**
     * Build the top-down tree view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildTopDownTreeView() {
      if (this.topDownTreeViewRoot_ === undefined) {
        const treeViewRoot = this.buildRoot_;
        this.buildRoot_ = undefined;

        this.setUpMissingChildRelationships_(treeViewRoot,
            0 /* firstDimensionToSetUp */);
        this.finalizeTotalValues_(treeViewRoot,
            0 /* firstDimensionToFinalize */,
            new WeakMap() /* dimensionalSelfSumsMap */);

        this.topDownTreeViewRoot_ = treeViewRoot;
      }

      return this.topDownTreeViewRoot_;
    },

    /**
     * Build the top-down heavy view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildTopDownHeavyView() {
      if (this.topDownHeavyViewRoot_ === undefined) {
        this.topDownHeavyViewRoot_ = this.buildGenericHeavyView_(
            this.addDimensionToTopDownHeavyViewNode_.bind(this));
      }
      return this.topDownHeavyViewRoot_;
    },

    /**
     * Build the bottom-up heavy view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildBottomUpHeavyView() {
      if (this.bottomUpHeavyViewNode_ === undefined) {
        this.bottomUpHeavyViewNode_ = this.buildGenericHeavyView_(
            this.addDimensionToBottomUpHeavyViewNode_.bind(this));
      }
      return this.bottomUpHeavyViewNode_;
    },

    createRootNode_() {
      return new MultiDimensionalViewNode(
          new Array(this.dimensions_) /* title */, this.valueCount_);
    },

    getOrCreateChildNode_(
        parentNode, dimension, childDimensionTitle) {
      if (dimension < 0 || dimension >= this.dimensions_) {
        throw new Error('Invalid dimension');
      }

      const dimensionChildren = parentNode.children[dimension];

      let childNode = dimensionChildren.get(childDimensionTitle);
      if (childNode !== undefined) {
        return childNode;
      }

      const childTitle = parentNode.title.slice();
      childTitle[dimension] = childDimensionTitle;
      childNode = new MultiDimensionalViewNode(childTitle, this.valueCount_);
      dimensionChildren.set(childDimensionTitle, childNode);

      return childNode;
    },

    /**
     * Set up missing child relationships.
     *
     * When an arbitrary multi-dimensional path [path1, path2, ..., pathN] is
     * added to the build tree (see addPath), only the nodes on the path1 ->
     * path2 -> ... -> pathN chain are created (i.e. no interleavings of the
     * single-dimensional paths are added to the tree). This method recursively
     * adds all the missing paths.
     *
     * Two-dimensional example:
     *
     *    Initial build tree   .       After path      .  After missing child
     *        (root only)      .    [[A, B], [1, 2]]   .   relationships were
     *                         .       was added       .        set up
     *                         .                       .
     *           +---+         .         +---+         .         +---+
     *           |*,*|         .         |*,*|         .         |*,*|
     *           +---+         .         +---+         .         +---+
     *                         .         A             .         A   1
     *                         .         |             .         |   :
     *                         .         v             .         v   V
     *                         .     +---+             .     +---+   +---+
     *                         .     |A,*|             .     |A,*|   |*,1|
     *                         .     +---+             .     +---+   +---+
     *                         .     B                 .     B   1   A   2
     *                         .     |                 .     |   :   |   :
     *                         .     v                 .     v   v   v   v
     *                         . +---+                 . +---+   +---+   +---+
     *                         . |B,*|                 . |B,*|   |A,1|   |*,2|
     *                         . +---+                 . +---+   +---+   +---+
     *                         .     1                 .     1   B   2   A
     *                         .     :                 .     :   |   :   |
     *                         .     v                 .     v   v   v   v
     *                         .     +---+             .     +---+   +---+
     *                         .     |B,1|             .     |B,1|   |A,2|
     *                         .     +---+             .     +---+   +---+
     *                         .         2             .         2   B
     *                         .         :             .         :   |
     *                         .         v             .         v   V
     *                         .         +---+         .         +---+
     *                         .         |B,2|         .         |B,2|
     *                         .         +---+         .         +---+
     */
    setUpMissingChildRelationships_(node, firstDimensionToSetUp) {
      // Missing child relationships of this node wrt dimensions 0, ...,
      // (firstDimensionToSetUp - 1) and all descendants of the associated
      // children have already been set up. Now we do the same for dimensions
      // firstDimensionToSetUp, ..., (this.dimensions_ - 1).
      for (let d = firstDimensionToSetUp; d < this.dimensions_; d++) {
        // Step 1. Gather the names of all children wrt the current dimension.
        const currentDimensionChildTitles = new Set(node.children[d].keys());
        for (let i = 0; i < d; i++) {
          for (const previousDimensionChildNode of node.children[i].values()) {
            for (const previousDimensionGrandChildTitle of
                 previousDimensionChildNode.children[d].keys()) {
              currentDimensionChildTitles.add(previousDimensionGrandChildTitle);
            }
          }
        }

        // Step 2. Add missing children wrt the current dimension and
        // recursively set up its missing child relationships.
        for (const currentDimensionChildTitle of currentDimensionChildTitles) {
          // Add a missing child (if it doesn't exist).
          const currentDimensionChildNode =
              this.getOrCreateChildNode_(node, d, currentDimensionChildTitle);

          // Set-up child relationships (of the child node) wrt dimensions 0,
          // ..., d - 1.
          for (let i = 0; i < d; i++) {
            for (const previousDimensionChildNode of
                node.children[i].values()) {
              const previousDimensionGrandChildNode =
                  previousDimensionChildNode.children[d].get(
                      currentDimensionChildTitle);
              if (previousDimensionGrandChildNode !== undefined) {
                currentDimensionChildNode.children[i].set(
                    previousDimensionChildNode.title[i],
                    previousDimensionGrandChildNode);
              }
            }
          }

          // Set-up child relationships (of the child node) wrt dimensions d,
          // ..., (this.dimensions_ - 1).
          this.setUpMissingChildRelationships_(currentDimensionChildNode, d);
        }
      }
    },

    /**
     * Finalize the total values of a multi-dimensional tree.
     *
     * The intermediate builder tree, a node of which we want to finalize
     * recursively, already has the right shape. The only thing that needs to
     * be done is to propagate self and total values from subsumed child nodes
     * in each dimension and update total value states appropriately.
     *
     * To derive the expression for the lower bound on the total value wrt
     * value index V (from 1 to |this.valueCount_| - 1), we rely on the
     * following assumptions:
     *
     *   1. Self/total values associated with different value indices are
     *      independent. From this point onwards, "self/total value" refers to
     *      self/total value wrt the fixed value index V.
     *
     *   2. Each node's self value does NOT overlap with the self or total value
     *      of any other node.
     *
     *   3. The total values of a node's children wrt a single dimension (e.g.
     *      [path1/A, path2] and [path1/B, path2]) do NOT overlap.
     *
     *   4. The total values of a node's children wrt different dimensions
     *      (e.g. [path1/A, path2] and [path1, path2/1]) MIGHT overlap.
     *
     * As a consequence of assumptions 1 and 3, the total value of a node can
     * be split into the part that cannot overlap (so-called "self-sum") and
     * the part that can overlap (so-called "residual"):
     *
     *   total(N, V) = selfSum(N, V) + residual(N, V)                   (A)
     *
     * where the self-sum is calculated as the sum of the node's self value
     * plus the sum of its descendants' self values (summed over all
     * dimensions):
     *
     *   selfSum(N, V) = self(N, V) + sum over all descendants C of N {
     *       self(C, V)                                                 (B)
     *   }
     *
     * Observe that the residual of a node does not include any self value (of
     * any node in the view). Furthermore, by assumption 2, we derive that the
     * residuals of a node's children wrt a single dimension don't overlap. On
     * the other hand, the residuals of a node's children wrt different
     * dimensions might overlap. This gives us the following lower bound on the
     * residual of a node:
     *
     *   residual(N, V) >= minResidual(N, V) = max over dimensions D {
     *       sum over children C of N at dimension D {
     *           residual(C, V)                                         (C)
     *       }
     *   })
     *
     * By combining equation (A) and inequality (C), we get a lower bound on
     * the total value of a node:
     *
     *   total(N, V) >= selfSum(N, V) + minResidual(N, V)
     *
     * For example, given a two-dimensional node [path1, path2] with self value
     * 10 and four children (2 wrt each dimension):
     *
     *    Child            | Self value | Total value
     *   ==================+============+=============
     *    [path1/A, path2] |         21 |          30
     *    [path1/B, path2] |         25 |          32
     *    [path1, path2/1] |         3  |          15
     *    [path1, path2/2] |         40 |          41
     *
     * and assuming that the children have no further descendants (i.e. their
     * residual values are equal to the differences between their total and
     * self values), the lower bound on the total value of [path1, path2] is:
     *
     *   total([path1, path2], 0)
     *       >= selfSum([path1, path2], 0) +
     *          minResidual([path1, path2], 0)
     *        = self([path1, path2], 0) +
     *          sum over all descendants C of [path1, path2] {
     *              self (C, 0)
     *          } +
     *          max over dimensions D {
     *              sum over children C of [path1, path2] at dimension D {
     *                  residual(C, 0)
     *              }
     *          }
     *        = self([path1, path2], 0) +
     *          ((self([path1/A, path2], 0) + self([path1/B, path2], 0)) +
     *           (self([path1, path2/1], 0) + self([path1, path2/2], 0))) +
     *          max(residual([path1/A, path2], 0) +
     *              residual([path1/B, path2], 0),
     *              residual([path1, path2/1], 0) +
     *              residual([path1, path2/2], 0))
     *        = 10 +
     *          ((21 + 25) + (3 + 40)) +
     *          max((30 - 21) + (32 - 25), (15 - 3) + (41 - 40))
     *        = 115
     *
     * To reduce the complexity of the calculation, we keep a temporary list of
     * dimensional self-sums for each node that we have already visited. For a
     * given node, the Kth element in the list is equal to the self size of the
     * node plus the sum of self sizes of all its descendants wrt dimensions 0
     * to K (inclusive). The list has two important properties:
     *
     *   1. The last element in the list is equal to the self-sum of the
     *      associated node (equation (B)).
     *
     *   2. The calculation of the list can be performed recursively using the
     *      lists of the associated node's children (avoids square complexity
     *      in the size of the graph):
     *
     *        dimensionalSelfSum(N, V)[D] =
     *            self(N, V) +
     *            sum I = 0 to D {
     *                sum over children C of N at dimension I {
     *                    dimensionalSelfSum(C, V)[I]
     *                }
     *            }
     *
     * This method also (recursively) ensures that, for each value index V, if
     * at least one of the descendants C of node N has at least a LOWER_BOUND
     * on total(C, V), then the N will also be marked as having a LOWER_BOUND
     * on total(N, V) (unless N contains the EXACT value of total(N, V), in
     * which case its relevant totalState won't be modified).
     */
    finalizeTotalValues_(
        node, firstDimensionToFinalize, dimensionalSelfSumsMap) {
      // Dimension D -> Value index V -> dimensionalSelfSum(|node|, V)[D].
      const dimensionalSelfSums = new Array(this.dimensions_);

      // Value index V -> minResidual(|node|, V).
      const minResidual = new Array(this.valueCount_);
      for (let v = 0; v < this.valueCount_; v++) minResidual[v] = 0;

      // Value index V -> |node| value V.
      const nodeValues = node.values;

      // Value index V -> dimensionalSelfSum(|node|, V)[|d|].
      const nodeSelfSums = new Array(this.valueCount_);
      for (let v = 0; v < this.valueCount_; v++) {
        nodeSelfSums[v] = nodeValues[v].self;
      }

      for (let d = 0; d < this.dimensions_; d++) {
        // Value index V -> sum over children C of |node| at dimension |d| {
        // residual(C, V) }.
        const childResidualSums = new Array(this.valueCount_);
        for (let v = 0; v < this.valueCount_; v++) {
          childResidualSums[v] = 0;
        }

        for (const childNode of node.children[d].values()) {
          if (d >= firstDimensionToFinalize) {
            this.finalizeTotalValues_(childNode, d, dimensionalSelfSumsMap);
          }
          // Dimension D -> Value index V ->
          // dimensionalSelfSum(|childNode|, V)[D].
          const childNodeSelfSums = dimensionalSelfSumsMap.get(childNode);
          const childNodeValues = childNode.values;
          for (let v = 0; v < this.valueCount_; v++) {
            nodeSelfSums[v] += childNodeSelfSums[d][v];
            const residual = childNodeValues[v].total -
                childNodeSelfSums[this.dimensions_ - 1][v];
            childResidualSums[v] += residual;
            if (this.complete) {
              nodeValues[v].totalState = EXACT;
            } else if (childNodeValues[v].totalState > NOT_PROVIDED) {
              nodeValues[v].totalState = Math.max(
                  nodeValues[v].totalState, LOWER_BOUND);
            }
          }
        }

        dimensionalSelfSums[d] = nodeSelfSums.slice();
        for (let v = 0; v < this.valueCount_; v++) {
          minResidual[v] = Math.max(minResidual[v], childResidualSums[v]);
        }
      }

      for (let v = 0; v < this.valueCount_; v++) {
        nodeValues[v].total = Math.max(
            nodeValues[v].total, nodeSelfSums[v] + minResidual[v]);
      }

      if (dimensionalSelfSumsMap.has(node)) {
        throw new Error('Internal error: Node finalized more than once');
      }
      dimensionalSelfSumsMap.set(node, dimensionalSelfSums);
    },

    /**
     * Build a generic heavy view of the multi-dimensional view.
     */
    buildGenericHeavyView_(treeViewNodeHandler) {
      // 1. Clone the root node of the top-down tree view node (except
      // children).
      const treeViewRoot = this.buildTopDownTreeView();
      const heavyViewRoot = this.createRootNode_();
      heavyViewRoot.values = treeViewRoot.values;

      // 2. Create recursion depth trackers (to avoid total value
      // double-counting).
      const recursionDepthTrackers = new Array(this.dimensions_);
      for (let d = 0; d < this.dimensions_; d++) {
        recursionDepthTrackers[d] =
            new RecursionDepthTracker(this.maxDimensionDepths_[d], d);
      }

      // 3. Add all paths associated with the single-dimensional descendants of
      // the top-down tree view root node to the heavy view root node
      // (depending on the type of the target heavy view).
      this.addDimensionsToGenericHeavyViewNode_(treeViewRoot, heavyViewRoot,
          0 /* startDimension */, recursionDepthTrackers,
          false /* previousDimensionsRecursive */, treeViewNodeHandler);

      // 4. Set up missing child relationships.
      this.setUpMissingChildRelationships_(heavyViewRoot,
          0 /* firstDimensionToSetUp */);

      return heavyViewRoot;
    },

    /**
     * Add all paths associated with the single-dimensional descendants of a
     * top-down tree-view node wrt multiple dimensions to a generic heavy-view
     * node (depending on the type of the target heavy view).
     */
    addDimensionsToGenericHeavyViewNode_(treeViewParentNode,
        heavyViewParentNode, startDimension, recursionDepthTrackers,
        previousDimensionsRecursive, treeViewNodeHandler) {
      for (let d = startDimension; d < this.dimensions_; d++) {
        this.addDimensionDescendantsToGenericHeavyViewNode_(treeViewParentNode,
            heavyViewParentNode, d, recursionDepthTrackers,
            previousDimensionsRecursive, treeViewNodeHandler);
      }
    },

    /**
     * Add all paths associated with the descendants of a top-down tree-view
     * node wrt a single dimension to a generic heavy-view node (depending on
     * the type of the target heavy view).
     */
    addDimensionDescendantsToGenericHeavyViewNode_(treeViewParentNode,
        heavyViewParentNode, currentDimension, recursionDepthTrackers,
        previousDimensionsRecursive, treeViewNodeHandler) {
      const treeViewChildren = treeViewParentNode.children[currentDimension];
      const recursionDepthTracker = recursionDepthTrackers[currentDimension];
      for (const treeViewChildNode of treeViewChildren.values()) {
        recursionDepthTracker.push(treeViewChildNode);

        // Add all paths associated with the child node to the heavy view-node
        // parent node.
        treeViewNodeHandler(
            treeViewChildNode, heavyViewParentNode, currentDimension,
            recursionDepthTrackers, previousDimensionsRecursive);

        // Recursively add all paths associated with the descendants of the
        // tree view child node wrt the current dimension to the heavy-view
        // parent node.
        this.addDimensionDescendantsToGenericHeavyViewNode_(treeViewChildNode,
            heavyViewParentNode, currentDimension, recursionDepthTrackers,
            previousDimensionsRecursive, treeViewNodeHandler);

        recursionDepthTracker.pop();
      }
    },

    /**
     * Add a top-down tree-view child node together with its single-dimensional
     * subtree to a top-down heavy-view parent node (tree-view node handler for
     * top-down heavy view).
     *
     * Sample resulting top-down heavy view:
     *
     *       +----------------+                    +-----------------+
     *       |     source     |                    |   destination   |
     *       | tree-view root |  ===============>  | heavy-view root |
     *       |     self=0     |                    |     self=0      |
     *       |    total=48    |                    |    total=48     |
     *       +----------------+                    +-----------------+
     *         |            |                  ______|      |      |______
     *         v            v                 v             v             v
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *    |    A*    | |    B     |      |    A***  | |    B     | |    C     |
     *    | self=10  | | self=12  |      | self=13  | | self=13  | | self=2   |
     *    | total=30 | | total=18 |      | total=30 | | total=34 | | total=7  |
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *         |                              :            :   :.........
     *         v                              v            v            v
     *    +----------+                   ............ ............ ............
     *    |    B     |                   :    B     : :    A     : :    C     :
     *    | self=1   |                   : self=1   : : self=3   : : self=2   :
     *    | total=16 |                   : total=16 : : total=8  : : total=7  :
     *    +----------+                   ............ ............ ............
     *         |   |________                  :   :.........
     *         v            v                 v            v
     *    +----------+ +----------+      ............ ............
     *    |    A**   | |    C     |      :    A     : :    C     :
     *    | self=3   | | self=2   |      : self=3   : : self=2   :
     *    | total=8  | | total=7  |      : total=8  : : total=7  :
     *    +----------+ +----------+      ............ ............
     *
     * Observe that care needs to be taken when dealing with recursion to avoid
     * double-counting, e.g. the total value of A** (8) was not added to the
     * total value of A*** (30) because it is already included in the total
     * value of A* (30) (which was also added to A***). That is why we need to
     * keep track of the path we traversed along the current dimension (to
     * determine whether total value should be added or not).
     */
    addDimensionToTopDownHeavyViewNode_(
        treeViewChildNode, heavyViewParentNode, currentDimension,
        recursionDepthTrackers, previousDimensionsRecursive) {
      this.addDimensionToTopDownHeavyViewNodeRecursively_(treeViewChildNode,
          heavyViewParentNode, currentDimension, recursionDepthTrackers,
          previousDimensionsRecursive, 1 /* subTreeDepth */);
    },

    addDimensionToTopDownHeavyViewNodeRecursively_(
        treeViewChildNode, heavyViewParentNode, currentDimension,
        recursionDepthTrackers, previousDimensionsRecursive, subTreeDepth) {
      const recursionDepthTracker = recursionDepthTrackers[currentDimension];
      const currentDimensionRecursive =
          subTreeDepth <= recursionDepthTracker.recursionDepth;
      const currentOrPreviousDimensionsRecursive =
          currentDimensionRecursive || previousDimensionsRecursive;

      const dimensionTitle = treeViewChildNode.title[currentDimension];
      const heavyViewChildNode = this.getOrCreateChildNode_(
          heavyViewParentNode, currentDimension, dimensionTitle);

      this.addNodeValues_(treeViewChildNode, heavyViewChildNode,
          !currentOrPreviousDimensionsRecursive /* addTotal */);

      // Add the descendants of the tree-view child node wrt the next
      // dimensions as children of the heavy-view child node.
      this.addDimensionsToGenericHeavyViewNode_(treeViewChildNode,
          heavyViewChildNode, currentDimension + 1, recursionDepthTrackers,
          currentOrPreviousDimensionsRecursive,
          this.addDimensionToTopDownHeavyViewNode_.bind(this));

      for (const treeViewGrandChildNode of
           treeViewChildNode.children[currentDimension].values()) {
        recursionDepthTracker.push(treeViewGrandChildNode);

        // Recursively add the tree-view grandchild node to the heavy-view
        // child node.
        this.addDimensionToTopDownHeavyViewNodeRecursively_(
            treeViewGrandChildNode, heavyViewChildNode, currentDimension,
            recursionDepthTrackers, previousDimensionsRecursive,
            subTreeDepth + 1);

        recursionDepthTracker.pop();
      }
    },

    /**
     * Add a top-down tree-view child node together with all its ancestors wrt
     * the given dimension as descendants of a bottom-up heavy-view parent node
     * in the reverse order (tree-view node handler for bottom-up heavy view).
     *
     * Sample resulting bottom-up heavy view:
     *
     *       +----------------+                    +-----------------+
     *       |     source     |                    |   destination   |
     *       | tree-view root |  ===============>  | heavy-view root |
     *       |     self=0     |                    |     self=0      |
     *       |    total=48    |                    |    total=48     |
     *       +----------------+                    +-----------------+
     *         |            |                  ______|      |      |______
     *         v            v                 v             v             v
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *    |    A*    | |    B     |      |    A***  | |    B     | |    C     |
     *    | self=10  | | self=12  |      | self=13  | | self=13  | | self=2   |
     *    | total=30 | | total=18 |      | total=30 | | total=34 | | total=7  |
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *         |                              :            :            :
     *         v                              v            v            v
     *    +----------+                   ............ ............ ............
     *    |    B#    |                   :    B     : :    A     : :    B##   :
     *    | self=1   |                   : self=3   : : self=1   : : self=2   :
     *    | total=16 |                   : total=8  : : total=16 : : total=7  :
     *    +----------+                   ............ ............ ............
     *         |   |________                  :                         :
     *         v            v                 v                         v
     *    +----------+ +----------+      ............              ............
     *    |    A**   | |    C     |      :    A     :              :    A     :
     *    | self=3   | | self=2   |      : self=3   :              : self=2   :
     *    | total=8  | | total=7  |      : total=8  :              : total=7  :
     *    +----------+ +----------+      ............              ............
     *
     * Similarly to the construction of the top-down heavy view, care needs to
     * be taken when dealing with recursion to avoid double-counting, e.g. the
     * total value of A** (8) was not added to the total value of A*** (30)
     * because it is already included in the total value of A* (30) (which was
     * also added to A***). That is why we need to keep track of the path we
     * traversed along the current dimension (to determine whether total value
     * should be added or not).
     *
     * Note that when we add an ancestor (B#) of a top-down tree-view node (C)
     * to the bottom-up heavy view, the values of the original tree-view node
     * (C) (rather than the ancestor's values) are added to the corresponding
     * heavy-view node (B##).
     */
    addDimensionToBottomUpHeavyViewNode_(
        treeViewChildNode, heavyViewParentNode, currentDimension,
        recursionDepthTrackers, previousDimensionsRecursive) {
      const recursionDepthTracker = recursionDepthTrackers[currentDimension];
      const bottomIndex = recursionDepthTracker.bottomIndex;
      const topIndex = recursionDepthTracker.topIndex;
      const firstNonRecursiveIndex =
          bottomIndex + recursionDepthTracker.recursionDepth;
      const viewNodePath = recursionDepthTracker.viewNodePath;

      const trackerAncestorNode = recursionDepthTracker.trackerAncestorNode;
      let heavyViewDescendantNode = heavyViewParentNode;
      for (let i = bottomIndex; i < topIndex; i++) {
        const treeViewAncestorNode = viewNodePath[i];
        const dimensionTitle = treeViewAncestorNode.title[currentDimension];
        heavyViewDescendantNode = this.getOrCreateChildNode_(
            heavyViewDescendantNode, currentDimension, dimensionTitle);

        const currentDimensionRecursive = i < firstNonRecursiveIndex;
        const currentOrPreviousDimensionsRecursive =
            currentDimensionRecursive || previousDimensionsRecursive;

        // The self and total values are taken from the original top-down tree
        // view child node (rather than the ancestor node).
        this.addNodeValues_(treeViewChildNode, heavyViewDescendantNode,
            !currentOrPreviousDimensionsRecursive);

        // Add the descendants of the tree-view child node wrt the next
        // dimensions as children of the heavy-view child node.
        this.addDimensionsToGenericHeavyViewNode_(treeViewChildNode,
            heavyViewDescendantNode, currentDimension + 1,
            recursionDepthTrackers, currentOrPreviousDimensionsRecursive,
            this.addDimensionToBottomUpHeavyViewNode_.bind(this));
      }
    },

    addNodeValues_(sourceNode, targetNode, addTotal) {
      const targetNodeValues = targetNode.values;
      const sourceNodeValues = sourceNode.values;
      for (let v = 0; v < this.valueCount_; v++) {
        const targetNodeValue = targetNodeValues[v];
        const sourceNodeValue = sourceNodeValues[v];
        targetNodeValue.self += sourceNodeValue.self;
        if (addTotal) {
          targetNodeValue.total += sourceNodeValue.total;
          if (this.complete) {
            targetNodeValue.totalState = EXACT;
          } else if (sourceNodeValue.totalState > NOT_PROVIDED) {
            targetNodeValue.totalState = Math.max(
                targetNodeValue.totalState, LOWER_BOUND);
          }
        }
      }
    }
  };

  /**
   * Recursion depth tracker.
   *
   * This class tracks the recursion depth of the current stack (updated via
   * the push and pop methods). The recursion depth of a stack is the lengh of
   * its longest leaf suffix that is repeated within the stack itself.
   *
   * For example, the recursion depth of the stack A -> B -> C -> A -> B -> B
   * -> C (where C is the leaf node) is 2 because the suffix B -> C is repeated
   * within it.
   *
   * @{constructor}
   */
  function RecursionDepthTracker(maxDepth, dimension) {
    this.titlePath = new Array(maxDepth);
    this.viewNodePath = new Array(maxDepth);
    this.bottomIndex = this.topIndex = maxDepth;

    this.dimension_ = dimension;
    this.currentTrackerNode_ =
        this.createNode_(0 /* recursionDepth */, undefined /* parent */);
  }

  RecursionDepthTracker.prototype = {
    push(viewNode) {
      if (this.bottomIndex === 0) {
        throw new Error('Cannot push to a full tracker');
      }
      const title = viewNode.title[this.dimension_];
      this.bottomIndex--;
      this.titlePath[this.bottomIndex] = title;
      this.viewNodePath[this.bottomIndex] = viewNode;

      let childTrackerNode = this.currentTrackerNode_.children.get(title);
      if (childTrackerNode !== undefined) {
        // Child node already exists, so we don't need to calculate anything.
        this.currentTrackerNode_ = childTrackerNode;
        return;
      }

      // Child node doesn't exist yet, so we need to calculate its recursion
      // depth.
      const maxLengths = zFunction(this.titlePath, this.bottomIndex);
      let recursionDepth = 0;
      for (let i = 0; i < maxLengths.length; i++) {
        recursionDepth = Math.max(recursionDepth, maxLengths[i]);
      }

      childTrackerNode =
          this.createNode_(recursionDepth, this.currentTrackerNode_);
      this.currentTrackerNode_.children.set(title, childTrackerNode);
      this.currentTrackerNode_ = childTrackerNode;
    },

    pop() {
      if (this.bottomIndex === this.topIndex) {
        throw new Error('Cannot pop from an empty tracker');
      }

      this.titlePath[this.bottomIndex] = undefined;
      this.viewNodePath[this.bottomIndex] = undefined;
      this.bottomIndex++;

      this.currentTrackerNode_ = this.currentTrackerNode_.parent;
    },

    get recursionDepth() {
      return this.currentTrackerNode_.recursionDepth;
    },

    createNode_(recursionDepth, parent) {
      return {
        recursionDepth,
        parent,
        children: new Map()
      };
    }
  };

  /**
   * Calculate the Z-function of (a suffix of) a list.
   *
   * Z-function: Given a list (or a string) of length n, for each index i from
   * 1 to n - 1, find the length z[i] of the longest substring starting at
   * position i which is also a prefix of the list. This function returns the
   * list of maximum lengths z.
   *
   * Mathematically, for each i from 1 to n - 1, z[i] is the maximum value such
   * that [list[0], ..., list[i - 1]] = [list[i], ..., list[i + z[i] - 1]].
   * z[0] is defined to be zero for convenience.
   *
   * Example:
   *
   *   Input (list): ['A', 'B', 'A', 'C', 'A', 'B', 'A']
   *   Output (z):   [ 0 ,  0 ,  1 ,  0 ,  3 ,  0 ,  1 ]
   *
   * Unlike the brute-force approach (which is O(n^2) in the worst case), the
   * complexity of this implementation is linear in the size of the list, i.e.
   * O(n).
   *
   * Source: http://e-maxx-eng.github.io/string/z-function.html
   */
  function zFunction(list, startIndex) {
    const n = list.length - startIndex;
    if (n === 0) return [];

    const z = new Array(n);
    z[0] = 0;

    for (let i = 1, left = 0, right = 0; i < n; ++i) {
      let maxLength;
      if (i <= right) {
        maxLength = Math.min(right - i + 1, z[i - left]);
      } else {
        maxLength = 0;
      }

      while (i + maxLength < n && list[startIndex + maxLength] ===
             list[startIndex + i + maxLength]) {
        ++maxLength;
      }

      if (i + maxLength - 1 > right) {
        left = i;
        right = i + maxLength - 1;
      }

      z[i] = maxLength;
    }

    return z;
  }

  return {
    MultiDimensionalViewBuilder,
    MultiDimensionalViewNode,

    // Exports below are for testing only.
    RecursionDepthTracker,
    zFunction,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  class FixedColorScheme {

    /**
     * @param {!Map} namesToColors
     * @constructor
     */
    constructor(namesToColors) {
      this.namesToColors_ = namesToColors;
    }

    /**
     * Create a color scheme where each name in names gets assigned a fixed
     * color. This color is arbitrary but unique within the color scheme.
     * @param {!Array<string>} names
     * @return {tr.b.FixedColorScheme}
     */
    static fromNames(names) {
      const namesToColors = new Map();
      const generator = new tr.b.SinebowColorGenerator();
      for (const name of names) {
        namesToColors.set(name, generator.colorForKey(name));
      }
      return new FixedColorScheme(namesToColors);
    }

    /**
     * Return color associated with |name|.
     * @param {!string} name
     * @return {tr.b.Color}
     */
    getColor(name) {
      const color = this.namesToColors_.get(name);
      if (color === undefined) throw new Error('Unknown color: ' + name);
      return color;
    }
  }

  const MemoryColumnColorScheme = new FixedColorScheme(new Map([
      ['used_memory_column', new tr.b.Color(0, 0, 255)],
      ['older_used_memory_column', new tr.b.Color(153, 204, 255)],
      ['tracing_memory_column', new tr.b.Color(153, 153, 153)]
  ]));

  function FixedColorSchemeRegistry() {}
  FixedColorSchemeRegistry.lookUp = function(name) {
    const info = this.findTypeInfoMatching(info => info.metadata.name === name);
    if (!info) return undefined;
    return info.constructor();
  };
  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(FixedColorSchemeRegistry, options);

  return {
    MemoryColumnColorScheme,
    FixedColorScheme,
    FixedColorSchemeRegistry,
  };
});


'use strict';

tr.exportTo('tr.e.chrome.chrome_processes', function() {
  const CHROME_PROCESS_NAMES = {
    BROWSER: 'browser_process',
    RENDERER: 'renderer_processes', // Intentionally plural.
    ALL: 'all_processes',
    GPU: 'gpu_process',
    PPAPI: 'ppapi_process',
    UNKNOWN: 'unknown_processes',
  };

  const PROCESS_COLOR_SCHEME_NAME = 'ChromeProcessNames';
  const PROCESS_COLOR_SCHEME =
      tr.b.FixedColorScheme.fromNames(Object.values(CHROME_PROCESS_NAMES));

  tr.b.FixedColorSchemeRegistry.register(() => PROCESS_COLOR_SCHEME, {
    name: PROCESS_COLOR_SCHEME_NAME,
  });

  /**
   * Converts name to lower case and replaces spaces with underscores.
   */
  function canonicalizeName(name) {
    return name.toLowerCase().replace(' ', '_');
  }

  /**
   * Convert raw process name to canonical process names used in catapult.
   *
   * Examples:
   * browser  -> CHROME_PROCESS_NAME.BROWSER
   * renderer -> CHROME_PROCESS_NAME.RENDERER
   */
  function canonicalizeProcessName(rawProcessName) {
    if (!rawProcessName) return CHROME_PROCESS_NAMES.UNKNOWN;

    const baseCanonicalName = canonicalizeName(rawProcessName);
    switch (baseCanonicalName) {
      case 'renderer': return CHROME_PROCESS_NAMES.RENDERER;
      case 'browser': return CHROME_PROCESS_NAMES.BROWSER;
    }

    if (Object.values(CHROME_PROCESS_NAMES).includes(baseCanonicalName)) {
      return baseCanonicalName;
    }

    return CHROME_PROCESS_NAMES.UNKNOWN;
  }

  return {
    CHROME_PROCESS_NAMES,
    PROCESS_COLOR_SCHEME,
    PROCESS_COLOR_SCHEME_NAME,
    canonicalizeName,
    canonicalizeProcessName,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
  const LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
  const DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;
  const sizeInBytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;
  const count_smallerIsBetter = tr.b.Unit.byName.count_smallerIsBetter;
  const DISPLAYED_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;

  const LEVEL_OF_DETAIL_NAMES = new Map();
  LEVEL_OF_DETAIL_NAMES.set(BACKGROUND, 'background');
  LEVEL_OF_DETAIL_NAMES.set(LIGHT, 'light');
  LEVEL_OF_DETAIL_NAMES.set(DETAILED, 'detailed');

  // Some detailed dumps contain heap profiler information.
  const HEAP_PROFILER_DETAIL_NAME = 'heap_profiler';

  const BOUNDARIES_FOR_UNIT_MAP = new WeakMap();
  // For unitless numerics (process counts), we use 20 linearly scaled bins
  // from 0 to 20.
  BOUNDARIES_FOR_UNIT_MAP.set(count_smallerIsBetter,
      tr.v.HistogramBinBoundaries.createLinear(0, 20, 20));
  // For size numerics (subsystem and vm stats), we use 1 bin from 0 B to
  // 1 KiB and 4*24 exponentially scaled bins from 1 KiB to 16 GiB (=2^24 KiB).
  BOUNDARIES_FOR_UNIT_MAP.set(sizeInBytes_smallerIsBetter,
      new tr.v.HistogramBinBoundaries(0)
          .addBinBoundary(1024 /* 1 KiB */)
          .addExponentialBins(16 * 1024 * 1024 * 1024 /* 16 GiB */, 4 * 24));

  const CHROME_PROCESS_NAMES =
      tr.e.chrome.chrome_processes.CHROME_PROCESS_NAMES;

  function memoryMetric(values, model, opt_options) {
    const rangeOfInterest =
      opt_options ? opt_options.rangeOfInterest : undefined;
    const browserNameToGlobalDumps =
        splitGlobalDumpsByBrowserName(model, rangeOfInterest);
    addGeneralMemoryDumpValues(browserNameToGlobalDumps, values);
    addDetailedMemoryDumpValues(browserNameToGlobalDumps, values);
    addMemoryDumpCountValues(browserNameToGlobalDumps, values);
  }

  /**
   * Splits the global memory dumps in |model| by browser name.
   *
   * @param {!tr.Model} model The trace model from which the global dumps
   *     should be extracted.
   * @param {!tr.b.math.Range=} opt_rangeOfInterest If provided, global memory
   *     dumps that do not inclusively intersect the range will be skipped.
   * @return {!Map<string, !Array<!tr.model.GlobalMemoryDump>} A map from
   *     browser names to the associated global memory dumps.
   */
  function splitGlobalDumpsByBrowserName(model, opt_rangeOfInterest) {
    const chromeModelHelper =
        model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    const browserNameToGlobalDumps = new Map();
    const globalDumpToBrowserHelper = new WeakMap();

    // 1. For each browser process in the model, add its global memory dumps to
    // |browserNameToGlobalDumps|. |chromeModelHelper| can be undefined if
    // it fails to find any browser, renderer or GPU process (see
    // tr.model.helpers.ChromeModelHelper.supportsModel).
    if (chromeModelHelper) {
      chromeModelHelper.browserHelpers.forEach(function(helper) {
        // Retrieve the associated global memory dumps and check that they
        // haven't been classified as belonging to another browser process.
        const globalDumps = skipDumpsThatDoNotIntersectRange(
            helper.process.memoryDumps.map(d => d.globalMemoryDump),
            opt_rangeOfInterest);
        globalDumps.forEach(function(globalDump) {
          const existingHelper = globalDumpToBrowserHelper.get(globalDump);
          if (existingHelper !== undefined) {
            throw new Error('Memory dump ID clash across multiple browsers ' +
                'with PIDs: ' + existingHelper.pid + ' and ' + helper.pid);
          }
          globalDumpToBrowserHelper.set(globalDump, helper);
        });

        makeKeyUniqueAndSet(browserNameToGlobalDumps,
            tr.e.chrome.chrome_processes.canonicalizeName(helper.browserName),
            globalDumps);
      });
    }

    // 2. If any global memory dump does not have any associated browser
    // process for some reason, associate it with an 'unknown_browser' browser
    // so that we don't lose the data.
    const unclassifiedGlobalDumps = skipDumpsThatDoNotIntersectRange(
        model.globalMemoryDumps.filter(g => !globalDumpToBrowserHelper.has(g)),
        opt_rangeOfInterest);
    if (unclassifiedGlobalDumps.length > 0) {
      makeKeyUniqueAndSet(
          browserNameToGlobalDumps, 'unknown_browser', unclassifiedGlobalDumps);
    }

    return browserNameToGlobalDumps;
  }

  function skipDumpsThatDoNotIntersectRange(dumps, opt_range) {
    if (!opt_range) return dumps;
    return dumps.filter(d => opt_range.intersectsExplicitRangeInclusive(
        d.start, d.end));
  }


  const USER_FRIENDLY_BROWSER_NAMES = {
    'chrome': 'Chrome',
    'webview': 'WebView',
    'unknown_browser': 'an unknown browser'
  };

  /**
   * Convert a canonical browser name used in value names to a user-friendly
   * name used in value descriptions.
   *
   * Examples:
   *
   *   CANONICAL BROWSER NAME -> USER-FRIENDLY NAME
   *   chrome                 -> Chrome
   *   unknown_browser        -> an unknown browser
   *   webview2               -> WebView(2)
   *   unexpected             -> 'unexpected' browser
   */
  function convertBrowserNameToUserFriendlyName(browserName) {
    for (const baseName in USER_FRIENDLY_BROWSER_NAMES) {
      if (!browserName.startsWith(baseName)) continue;

      const userFriendlyBaseName = USER_FRIENDLY_BROWSER_NAMES[baseName];
      const suffix = browserName.substring(baseName.length);
      if (suffix.length === 0) {
        return userFriendlyBaseName;
      } else if (/^\d+$/.test(suffix)) {
        return userFriendlyBaseName + '(' + suffix + ')';
      }
    }
    return '\'' + browserName + '\' browser';
  }


  /**
   * Convert a canonical process name used in value names to a user-friendly
   * name used in value descriptions.
   */
  function convertProcessNameToUserFriendlyName(processName,
      opt_requirePlural) {
    switch (processName) {
      case CHROME_PROCESS_NAMES.BROWSER:
        return opt_requirePlural ? 'browser processes' : 'the browser process';
      case CHROME_PROCESS_NAMES.RENDERER:
        return 'renderer processes';
      case CHROME_PROCESS_NAMES.GPU:
        return opt_requirePlural ? 'GPU processes' : 'the GPU process';
      case CHROME_PROCESS_NAMES.PPAPI:
        return opt_requirePlural ? 'PPAPI processes' : 'the PPAPI process';
      case CHROME_PROCESS_NAMES.ALL:
        return 'all processes';
      case CHROME_PROCESS_NAMES.UNKNOWN:
        return 'unknown processes';
      default:
        return '\'' + processName + '\' processes';
    }
  }

  /**
   * Function for adding entries with duplicate keys to a map without
   * overriding existing entries.
   *
   * This is achieved by appending numeric indices (2, 3, 4, ...) to duplicate
   * keys. Example:
   *
   *   const map = new Map();
   *   // map = Map {}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'a');
   *   // map = Map {"key" => "a"}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'b');
   *   // map = Map {"key" => "a", "key2" => "b"}.
   *                                ^^^^
   *   makeKeyUniqueAndSet(map, 'key', 'c');
   *   // map = Map {"key" => "a", "key2" => "b", "key3" => "c"}.
   *                                ^^^^           ^^^^
   */
  function makeKeyUniqueAndSet(map, key, value) {
    let uniqueKey = key;
    let nextIndex = 2;
    while (map.has(uniqueKey)) {
      uniqueKey = key + nextIndex;
      nextIndex++;
    }
    map.set(uniqueKey, value);
  }

  /**
   * Add general memory dump values calculated from all global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * PROCESS COUNTS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         process_count
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: count_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome[:{v8, malloc, ...}]:
   *         {effective_size, allocated_objects_size, locked_size}
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addGeneralMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps,
        gmd => true /* process all global memory dumps */,
        function(processDump, addProcessScalar) {
          // Increment memory:<browser-name>:<process-name>:process_count value.
          addProcessScalar({
            source: 'process_count',
            property: PROCESS_COUNT,
            value: 1
          });

          if (processDump.totals !== undefined) {
            addProcessScalar({
              source: 'reported_by_os',
              property: RESIDENT_SIZE,
              component: ['system_memory'],
              value: processDump.totals.residentBytes
            });
            addProcessScalar({
              source: 'reported_by_os',
              property: PEAK_RESIDENT_SIZE,
              component: ['system_memory'],
              value: processDump.totals.peakResidentBytes
            });
          }

          // Add memory:<browser-name>:<process-name>:reported_by_chrome:...
          // values.
          if (processDump.memoryAllocatorDumps === undefined) return;

          processDump.memoryAllocatorDumps.forEach(function(rootAllocatorDump) {
            CHROME_VALUE_PROPERTIES.forEach(function(property) {
              addProcessScalar({
                source: 'reported_by_chrome',
                component: [rootAllocatorDump.name],
                property,
                value: rootAllocatorDump.numerics[property.name]
              });
            });
            // Some dump providers add allocated objects size as
            // "allocated_objects" child dump.
            if (rootAllocatorDump.numerics.allocated_objects_size ===
                    undefined) {
              const allocatedObjectsDump =
                  rootAllocatorDump.getDescendantDumpByFullName(
                      'allocated_objects');
              if (allocatedObjectsDump !== undefined) {
                addProcessScalar({
                  source: 'reported_by_chrome',
                  component: [rootAllocatorDump.name],
                  property: ALLOCATED_OBJECTS_SIZE,
                  value: allocatedObjectsDump.numerics.size
                });
              }
            }
          });

          // Add memory:<browser-name>:<process-name>:reported_by_chrome:v8:
          //     {heap, allocated_by_malloc}:...
          addV8MemoryDumpValues(processDump, addProcessScalar);
        },
        function(componentTree) {
          // Subtract memory:<browser-name>:<process-name>:reported_by_chrome:
          // tracing:<size-property> from memory:<browser-name>:<process-name>:
          // reported_by_chrome:<size-property> if applicable.
          const tracingNode = componentTree.children[1].get('tracing');
          if (tracingNode === undefined) return;

          for (let i = 0; i < componentTree.values.length; i++) {
            componentTree.values[i].total -= tracingNode.values[i].total;
          }
        }, values);
  }

  /**
   * Add memory dump values calculated from V8 components excluding
   * 'heap_spaces/other_spaces'.
   *
   * @param {!tr.model.ProcessMemoryDump} processDump The process memory dump.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8MemoryDumpValues(processDump, addProcessScalar) {
    const v8Dump = processDump.getMemoryAllocatorDumpByFullName('v8');
    if (v8Dump === undefined) return;

    v8Dump.children.forEach(function(isolateDump) {
      // v8:allocated_by_malloc:...
      const mallocDump = isolateDump.getDescendantDumpByFullName('malloc');
      if (mallocDump !== undefined) {
        addV8ComponentValues(mallocDump, ['v8', 'allocated_by_malloc'],
            addProcessScalar);
      }
      // v8:heap:...
      const heapDump = isolateDump.getDescendantDumpByFullName('heap_spaces');
      if (heapDump !== undefined) {
        addV8ComponentValues(heapDump, ['v8', 'heap'], addProcessScalar);
        heapDump.children.forEach(function(spaceDump) {
          if (spaceDump.name === 'other_spaces') return;

          addV8ComponentValues(spaceDump, ['v8', 'heap', spaceDump.name],
              addProcessScalar);
        });
      }
    });

    // V8 generates bytecode when interpreting and code objects when
    // compiling the javascript. Total code size includes the size
    // of code and bytecode objects.
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: CODE_AND_METADATA_SIZE,
      value: v8Dump.numerics.code_and_metadata_size
    });
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: CODE_AND_METADATA_SIZE,
      value: v8Dump.numerics.bytecode_and_metadata_size
    });
  }

  /**
   * Add memory dump values calculated from the specified V8 component.
   *
   * @param {!tr.model.MemoryAllocatorDump} v8Dump The V8 memory dump.
   * @param {!Array<string>} componentPath The component path for reporting.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8ComponentValues(componentDump, componentPath,
      addProcessScalar) {
    CHROME_VALUE_PROPERTIES.forEach(function(property) {
      addProcessScalar({
        source: 'reported_by_chrome',
        component: componentPath,
        property,
        value: componentDump.numerics[property.name]
      });
    });
  }

  const PROCESS_COUNT = {
    unit: count_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      if (componentPath.length > 0) {
        throw new Error('Unexpected process count non-empty component path: ' +
            componentPath.join(':'));
      }
      return 'total number of ' + convertProcessNameToUserFriendlyName(
          processName, true /* opt_requirePlural */);
    }
  };

  const EFFECTIVE_SIZE = {
    name: 'effective_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'effective size',
        componentPreposition: 'of'
      });
    }
  };

  const ALLOCATED_OBJECTS_SIZE = {
    name: 'allocated_objects_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'size of all objects allocated',
        totalUserFriendlyPropertyName: 'size of all allocated objects',
        componentPreposition: 'by'
      });
    }
  };

  const SHIM_ALLOCATED_OBJECTS_SIZE = {
    name: 'shim_allocated_objects_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'size of all objects allocated through shim',
        totalUserFriendlyPropertyName:
            'size of all allocated objects through shim',
        componentPreposition: 'by'
      });
    }
  };

  const LOCKED_SIZE = {
    name: 'locked_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'locked (pinned) size',
        componentPreposition: 'of'
      });
    }
  };

  const PEAK_SIZE = {
    name: 'peak_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'peak size',
        componentPreposition: 'of'
      });
    }
  };

  const CODE_AND_METADATA_SIZE = {
    name: 'code_and_metadata_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyNamePrefix: 'size of',
        userFriendlyPropertyName: 'code and metadata'
      });
    }
  };

  const CHROME_VALUE_PROPERTIES = [
    EFFECTIVE_SIZE,
    ALLOCATED_OBJECTS_SIZE,
    SHIM_ALLOCATED_OBJECTS_SIZE,
    LOCKED_SIZE,
    PEAK_SIZE
  ];

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_chrome:... value.
   *
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['malloc']).
   * @param {string} processName The canonical name of the process.
   * @param {{
   *     userFriendlyPropertyName: string,
   *     userFriendlyPropertyNamePrefix: (string|undefined),
   *     totalUserFriendlyPropertyName: (string|undefined),
   *     componentPreposition: (string|undefined) }}
   *     formatSpec Specification of how the property should be formatted.
   * @return {string} Prefix for the value's description (e.g.
   *     'effective size of malloc in the browser process').
   */
  function buildChromeValueDescriptionPrefix(
      componentPath, processName, formatSpec) {
    const nameParts = [];
    if (componentPath.length === 0) {
      nameParts.push('total');
      if (formatSpec.totalUserFriendlyPropertyName) {
        nameParts.push(formatSpec.totalUserFriendlyPropertyName);
      } else {
        if (formatSpec.userFriendlyPropertyNamePrefix) {
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        }
        nameParts.push(formatSpec.userFriendlyPropertyName);
      }
      nameParts.push('reported by Chrome for');
    } else {
      if (formatSpec.componentPreposition === undefined) {
        // Use component name as an adjective
        // (e.g. 'size of V8 code and metadata').
        if (formatSpec.userFriendlyPropertyNamePrefix) {
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        }
        nameParts.push(componentPath.join(':'));
        nameParts.push(formatSpec.userFriendlyPropertyName);
      } else {
        // Use component name as a noun with a preposition
        // (e.g. 'size of all objects allocated BY MALLOC').
        if (formatSpec.userFriendlyPropertyNamePrefix) {
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        }
        nameParts.push(formatSpec.userFriendlyPropertyName);
        nameParts.push(formatSpec.componentPreposition);
        if (componentPath[componentPath.length - 1] === 'allocated_by_malloc') {
          nameParts.push('objects allocated by malloc for');
          nameParts.push(
              componentPath.slice(0, componentPath.length - 1).join(':'));
        } else {
          nameParts.push(componentPath.join(':'));
        }
      }
      nameParts.push('in');
    }
    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  const RESIDENT_SIZE = {
    name: 'resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'resident set size (RSS)');
    }
  };

  const PEAK_RESIDENT_SIZE = {
    name: 'peak_resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'peak resident set size');
    }
  };

  const PROPORTIONAL_RESIDENT_SIZE = {
    name: 'proportional_resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'proportional resident size (PSS)');
    }
  };

  const PRIVATE_DIRTY_SIZE = {
    name: 'private_dirty_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'private dirty size');
    }
  };

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_os:... value.
   *
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['system', 'java_heap']).
   * @param {string} processName The canonical name of the process.
   * @param {string} userFriendlyPropertyName User-friendly name of the
   *     underlying property (e.g. 'private dirty size').
   * @return {string} Prefix for the value's description (e.g.
   *     'total private dirty size of the Java heal in the GPU process').
   */
  function buildOsValueDescriptionPrefix(
      componentPath, processName, userFriendlyPropertyName) {
    if (componentPath.length > 2) {
      throw new Error('OS value component path for \'' +
          userFriendlyPropertyName + '\' too long: ' + componentPath.join(':'));
    }

    const nameParts = [];
    if (componentPath.length < 2) {
      nameParts.push('total');
    }

    nameParts.push(userFriendlyPropertyName);

    if (componentPath.length > 0) {
      switch (componentPath[0]) {
        case 'system_memory':
          if (componentPath.length > 1) {
            const userFriendlyComponentName =
                SYSTEM_VALUE_COMPONENTS[componentPath[1]].userFriendlyName;
            if (userFriendlyComponentName === undefined) {
              throw new Error('System value sub-component for \'' +
                  userFriendlyPropertyName + '\' unknown: ' +
                  componentPath.join(':'));
            }
            nameParts.push('of', userFriendlyComponentName, 'in');
          } else {
            nameParts.push('of system memory (RAM) used by');
          }
          break;

        case 'gpu_memory':
          if (componentPath.length > 1) {
            nameParts.push('of the', componentPath[1]);
            nameParts.push('Android memtrack component in');
          } else {
            nameParts.push('of GPU memory (Android memtrack) used by');
          }
          break;

        default:
          throw new Error('OS value component for \'' +
              userFriendlyPropertyName + '\' unknown: ' +
              componentPath.join(':'));
      }
    } else {
      nameParts.push('reported by the OS for');
    }

    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  /**
   * Add heavy memory dump values calculated from heavy global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * MEMORY USAGE REPORTED BY THE OS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:system_memory:[{ashmem, native_heap, java_heap}:]
   *         {proportional_resident_size, private_dirty_size}
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:gpu_memory:[{gl, graphics, ...}:]
   *         proportional_resident_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome:v8:code_and_metadata_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addDetailedMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps,
        g => g.levelOfDetail === DETAILED,
        function(processDump, addProcessScalar) {
          // Add memory:<browser-name>:<process-name>:reported_by_os:
          // system_memory:... values.
          for (const [componentName, componentSpec] of
              Object.entries(SYSTEM_VALUE_COMPONENTS)) {
            const node = getDescendantVmRegionClassificationNode(
                processDump.vmRegions, componentSpec.classificationPath);
            const componentPath = ['system_memory'];
            if (componentName) componentPath.push(componentName);
            addProcessScalar({
              source: 'reported_by_os',
              component: componentPath,
              property: PROPORTIONAL_RESIDENT_SIZE,
              value: node === undefined ?
                  0 : (node.byteStats.proportionalResident || 0)
            });
            addProcessScalar({
              source: 'reported_by_os',
              component: componentPath,
              property: PRIVATE_DIRTY_SIZE,
              value: node === undefined ?
                  0 : (node.byteStats.privateDirtyResident || 0)
            });
          }

          // Add memory:<browser-name>:<process-name>:reported_by_os:
          // gpu_memory:... values.
          const memtrackDump = processDump.getMemoryAllocatorDumpByFullName(
              'gpu/android_memtrack');
          if (memtrackDump !== undefined) {
            memtrackDump.children.forEach(function(memtrackChildDump) {
              addProcessScalar({
                source: 'reported_by_os',
                component: ['gpu_memory', memtrackChildDump.name],
                property: PROPORTIONAL_RESIDENT_SIZE,
                value: memtrackChildDump.numerics.memtrack_pss
              });
            });
          }
        }, function(componentTree) {}, values);
  }

  // Specifications of components reported by the system.
  const SYSTEM_VALUE_COMPONENTS = {
    '': {
      classificationPath: [],
    },
    'java_heap': {
      classificationPath: ['Android', 'Java runtime', 'Spaces'],
      userFriendlyName: 'the Java heap'
    },
    'ashmem': {
      classificationPath: ['Android', 'Ashmem'],
      userFriendlyName: 'ashmem'
    },
    'native_heap': {
      classificationPath: ['Native heap'],
      userFriendlyName: 'the native heap'
    },
    'stack': {
      classificationPath: ['Stack'],
      userFriendlyName: 'the thread stacks'
    }
  };

  /**
   * Get the descendant of a VM region classification |node| specified by the
   * given |path| of child node titles. If |node| is undefined or such a
   * descendant does not exist, this function returns undefined.
   */
  function getDescendantVmRegionClassificationNode(node, path) {
    for (let i = 0; i < path.length; i++) {
      if (node === undefined) break;

      node = node.children.find(c => c.title === path[i]);
    }
    return node;
  }

  /**
   * Add global memory dump counts to |values|. In particular, this function
   * adds the following values:
   *
   *   * DUMP COUNTS
   *     memory:{chrome, webview}:all_processes:dump_count
   *         [:{light, detailed, heap_profiler}]
   *     type: tr.v.Histogram
   *     unit: count_smallerIsBetter
   *
   * Note that unlike all other values generated by the memory metric, the
   * global memory dump counts are NOT instances of tr.v.Histogram
   * because it doesn't make sense to aggregate them (they are already counts
   * over all global dumps associated with the relevant browser).
   */
  function addMemoryDumpCountValues(browserNameToGlobalDumps, values) {
    browserNameToGlobalDumps.forEach(function(globalDumps, browserName) {
      let totalDumpCount = 0;
      const levelOfDetailNameToDumpCount = {};
      LEVEL_OF_DETAIL_NAMES.forEach(function(levelOfDetailName) {
        levelOfDetailNameToDumpCount[levelOfDetailName] = 0;
      });
      levelOfDetailNameToDumpCount[HEAP_PROFILER_DETAIL_NAME] = 0;

      globalDumps.forEach(function(globalDump) {
        totalDumpCount++;

        // Increment the level-of-detail-specific dump count (if possible).
        const levelOfDetailName =
            LEVEL_OF_DETAIL_NAMES.get(globalDump.levelOfDetail);
        if (levelOfDetailName === undefined) {
          return;  // Unknown level of detail.
        }
        levelOfDetailNameToDumpCount[levelOfDetailName]++;
        if (globalDump.levelOfDetail === DETAILED) {
          if (detectHeapProfilerInMemoryDump(globalDump)) {
            levelOfDetailNameToDumpCount[HEAP_PROFILER_DETAIL_NAME]++;
          }
        }
      });

      // Add memory:<browser-name>:all_processes:dump_count[:<level>] values.
      reportMemoryDumpCountAsValue(browserName, undefined /* total */,
          totalDumpCount, values);
      for (const [levelOfDetailName, levelOfDetailDumpCount] of
          Object.entries(levelOfDetailNameToDumpCount)) {
        reportMemoryDumpCountAsValue(browserName, levelOfDetailName,
            levelOfDetailDumpCount, values);
      }
    });
  }

  /**
   * Check whether detailed global dump has heap profiler information or not.
   */
  function detectHeapProfilerInMemoryDump(globalDump) {
    for (const processDump of Object.values(globalDump.processMemoryDumps)) {
      if (processDump.heapDumps && processDump.heapDumps.malloc) {
        const mallocDump = processDump.heapDumps.malloc;
        if (mallocDump.entries && mallocDump.entries.length > 0) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Add a tr.v.Histogram value to |values| reporting that the number of
   * |levelOfDetailName| memory dumps added by |browserName| was
   * |levelOfDetailCount|.
   */
  function reportMemoryDumpCountAsValue(
      browserName, levelOfDetailName, levelOfDetailDumpCount, values) {
    // Construct the name of the memory value.
    const nameParts = ['memory', browserName, 'all_processes', 'dump_count'];
    if (levelOfDetailName !== undefined) {
      nameParts.push(levelOfDetailName);
    }
    const name = nameParts.join(':');

    // Build the underlying histogram for the memory value.
    const histogram = new tr.v.Histogram(name, count_smallerIsBetter,
        BOUNDARIES_FOR_UNIT_MAP.get(count_smallerIsBetter));
    histogram.addSample(levelOfDetailDumpCount);

    // If |levelOfDetail| argument is undefined it means a total value.
    const userFriendlyLevelOfDetail =
        (levelOfDetailName || 'all').replace('_', ' ');

    // Build the options for the memory value.
    histogram.description = [
      'total number of',
      userFriendlyLevelOfDetail,
      'memory dumps added by',
      convertBrowserNameToUserFriendlyName(browserName),
      'to the trace'
    ].join(' ');

    // Report the memory value.
    values.addHistogram(histogram);
  }

  /**
   * Add generic values extracted from process memory dumps and aggregated by
   * process name and component path into |values|.
   *
   * For each browser and set of global dumps in |browserNameToGlobalDumps|,
   * |customProcessDumpValueExtractor| is applied to every process memory dump
   * associated with the global memory dump. The second argument provided to the
   * callback is a function for adding extracted values:
   *
   *   function sampleProcessDumpCallback(processDump, addProcessValue) {
   *     ...
   *     addProcessScalar({
   *       source: 'reported_by_chrome',
   *       component: ['system', 'native_heap'],
   *       property: 'proportional_resident_size',
   *       value: pssExtractedFromProcessDump2,
   *       descriptionPrefixBuilder(componentPath) {
   *         return 'PSS of ' + componentPath.join('/') + ' in';
   *       }
   *     });
   *     ...
   *   }
   *
   * For each global memory dump, the extracted values are summed by process
   * name (browser_process, renderer_processes, ..., all_processes) and
   * component path (e.g. gpu is a sum of gpu:gl, gpu:graphics, ...). The sums
   * are then aggregated over all global memory dumps associated with the given
   * browser. For example, assuming that |customProcessDumpValueExtractor|
   * extracts 'proportional_resident_size' values for component paths
   * ['X', 'A'], ['X', 'B'] and ['Y'] under the same 'source' from each process
   * memory dump, the following values will be reported (for Chrome):
   *
   *    memory:chrome:browser_process:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    ...
   *
   *    memory:chrome:all_processes:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all process dumps in global dump 1,
   *          ...
   *          sum of X:A in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all process dumps in global dump 1,
   *          ...
   *          sum of Y in all process dumps in global dump N
   *    ]
   *
   *    memory:chrome:all_processes:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all process dumps in global dump N
   *        ]
   *
   * where global dumps 1 to N are the global dumps associated with the given
   * browser.
   *
   * @param {!Map<string, !Array<!tr.model.GlobalMemoryDump>}
   *     browserNameToGlobalDumps Map from browser names to arrays of global
   *     memory dumps. The generic values will be extracted from the associated
   *     process memory dumps.
   * @param {!function(!tr.model.GlobalMemoryDump): boolean}
   *     customGlobalDumpFilter Predicate for filtering global memory dumps.
   * @param {!function(
   *     !tr.model.ProcessMemoryDump,
   *     !function(!{
   *         source: string,
   *         componentPath: (!Array<string>|undefined),
   *         property: !{name: string, unit: !tr.b.Unit, buildDescriptionPrefix:
   *                     !function(!Array<string>, string): string},
   *         value: (!tr.v.Histogram|number|undefined)
   *     }))}
   *     customProcessDumpValueExtractor Callback for extracting values from a
   *     process memory dump.
   * @param {!function(!tr.b.MultiDimensionalViewNode)}
   *     customComponentTreeModifier Callback applied to every component tree
   *     wrt each process name.
   * @param {!tr.v.HistogramSet} values List of values to which the
   *     resulting aggregated values are added.
   */
  function addMemoryDumpValues(browserNameToGlobalDumps, customGlobalDumpFilter,
      customProcessDumpValueExtractor, customComponentTreeModifier,
      values) {
    browserNameToGlobalDumps.forEach(function(globalDumps, browserName) {
      const filteredGlobalDumps = globalDumps.filter(customGlobalDumpFilter);
      const sourceToPropertyToBuilder = extractDataFromGlobalDumps(
          filteredGlobalDumps, customProcessDumpValueExtractor);
      reportDataAsValues(sourceToPropertyToBuilder, browserName,
          customComponentTreeModifier, values);
    });
  }

  /**
   * For each global memory dump in |globalDumps|, calculate per-process-name
   * sums of values extracted by |customProcessDumpValueExtractor| from the
   * associated process memory dumps.
   *
   * This function returns the following nested map structure:
   *
   *  Source name (Map key, e.g. 'reported_by_os')
   *    -> Property (Map key, e.g. PROPORTIONAL_RESIDENT_SIZE)
   *      -> processAndComponentTreeBuilder
   *
   *  where |processAndComponentTreeBuilder| is a
   *  tr.b.MultiDimensionalViewBuilder:
   *
   *  Process name (0th dimension key, e.g. 'browser_process') x
   *  Component path (1st dimension keys, e.g. ['system', 'native_heap'])
   *    -> Sum of value over the processes (number).
   *
   * See addMemoryDumpValues for more details.
   */
  function extractDataFromGlobalDumps(
      globalDumps, customProcessDumpValueExtractor) {
    const sourceToPropertyToBuilder = new Map();
    const dumpCount = globalDumps.length;
    globalDumps.forEach(function(globalDump, dumpIndex) {
      for (const processDump of Object.values(globalDump.processMemoryDumps)) {
        extractDataFromProcessDump(
            processDump, sourceToPropertyToBuilder, dumpIndex, dumpCount,
            customProcessDumpValueExtractor);
      }
    });
    return sourceToPropertyToBuilder;
  }

  function extractDataFromProcessDump(processDump, sourceToPropertyToBuilder,
      dumpIndex, dumpCount, customProcessDumpValueExtractor) {
    // Process name is typically 'browser', 'renderer', etc.
    const rawProcessName = processDump.process.name;
    const processNamePath =
        [tr.e.chrome.chrome_processes.canonicalizeProcessName(rawProcessName)];

    customProcessDumpValueExtractor(
        processDump,
        function addProcessScalar(spec) {
          if (spec.value === undefined) return;

          const component = spec.component || [];
          function createDetailsForErrorMessage() {
            return ['source=', spec.source, ', property=',
              spec.property.name || '(undefined)', ', component=',
              component.length === 0 ? '(empty)' : component.join(':'),
              ' in ', processDump.process.userFriendlyName].join('');
          }

          let value;
          if (spec.value instanceof tr.b.Scalar) {
            value = spec.value.value;
            if (spec.value.unit !== spec.property.unit) {
              throw new Error('Scalar unit for ' +
                  createDetailsForErrorMessage() + ' (' +
                  spec.value.unit.unitName +
                  ') doesn\'t match the unit of the property (' +
                  spec.property.unit.unitName + ')');
            }
          } else {
            value = spec.value;
          }

          let propertyToBuilder = sourceToPropertyToBuilder.get(spec.source);
          if (propertyToBuilder === undefined) {
            propertyToBuilder = new Map();
            sourceToPropertyToBuilder.set(spec.source, propertyToBuilder);
          }

          let builder = propertyToBuilder.get(spec.property);
          if (builder === undefined) {
            builder = new tr.b.MultiDimensionalViewBuilder(
                2 /* dimensions (process name and component path) */,
                dumpCount /* valueCount */),
            propertyToBuilder.set(spec.property, builder);
          }

          const values = new Array(dumpCount);
          values[dumpIndex] = value;

          builder.addPath(
              [processNamePath, component] /* path */, values,
              tr.b.MultiDimensionalViewBuilder.ValueKind.TOTAL /* valueKind */);
        });
  }

  function reportDataAsValues(sourceToPropertyToBuilder, browserName,
      customComponentTreeModifier, values) {
    // For each source name (e.g. 'reported_by_os')...
    sourceToPropertyToBuilder.forEach(function(propertyToBuilder, sourceName) {
      // For each property (e.g. EFFECTIVE_SIZE)...
      propertyToBuilder.forEach(function(builders, property) {
        const tree = builders.buildTopDownTreeView();
        reportComponentDataAsValues(browserName, sourceName, property,
            [] /* processPath */, [] /* componentPath */, tree, values,
            customComponentTreeModifier);
      });
    });
  }

  /**
   * For the given |browserName| (e.g. 'chrome'), |property|
   * (e.g. EFFECTIVE_SIZE), |processPath| (e.g. ['browser_process']),
   * |componentPath| (e.g. ['v8']), add
   * a tr.v.Histogram with |unit| aggregating the total
   * values of the associated |componentNode| across all timestamps
   * (corresponding to global memory dumps associated with the given browser)
   * |values| for each process (e.g. 'gpu_process', 'browser_process', etc).
   * We also report a special 'all_processes' histogram which agregates all
   * others, this has a RelatedHistogramBreakdown diagnostic explaining
   * how it is built from the other histograms.
   *
   * See addMemoryDumpValues for more details.
   */
  function reportComponentDataAsValues(browserName, sourceName, property,
      processPath, componentPath, tree, values, customComponentTreeModifier,
      opt_cachedHistograms) {
    const cachedHistograms = opt_cachedHistograms || new Map();
    function recurse(processPath, componentPath, node) {
      return reportComponentDataAsValues(browserName, sourceName, property,
          processPath, componentPath, node, values,
          customComponentTreeModifier, cachedHistograms);
    }

    function buildHistogram(processPath, componentPath, node) {
      return buildNamedMemoryNumericFromNode(
          browserName,
          sourceName,
          property,
          processPath.length === 0 ? 'all_processes' : processPath[0],
          componentPath,
          node);
    }

    customComponentTreeModifier(tree);
    const histogram = buildHistogram(processPath, componentPath, tree);
    if (cachedHistograms.has(histogram.name)) {
      return cachedHistograms.get(histogram.name);
    }
    cachedHistograms.set(histogram.name, histogram);

    const processBreakdown = new tr.v.d.RelatedHistogramBreakdown();
    processBreakdown.colorScheme =
      tr.e.chrome.chrome_processes.PROCESS_COLOR_SCHEME_NAME;
    for (const [childProcessName, childProcessNode] of tree.children[0]) {
      processPath.push(childProcessName);
      const childProcessHistogram =
        recurse(processPath, componentPath, childProcessNode);
      processBreakdown.set(childProcessName, childProcessHistogram);
      processPath.pop();
    }

    const componentBreakdown = new tr.v.d.RelatedHistogramBreakdown();
    for (const [childComponentName, childComponentNode] of tree.children[1]) {
      componentPath.push(childComponentName);
      const childComponentHistogram =
        recurse(processPath, componentPath, childComponentNode);
      componentBreakdown.set(childComponentName, childComponentHistogram);
      componentPath.pop();
    }

    values.addHistogram(histogram);
    if (tree.children[0].size > 0) {
      histogram.diagnostics.set('processes', processBreakdown);
    }
    if (tree.children[1].size > 0) {
      histogram.diagnostics.set('components', componentBreakdown);
    }

    return histogram;
  }

  /**
   * Gets the name for a histogram.
   * The histograms have the following naming scheme:
   * memory:chrome:browser_process:reported_by_chrome:v8:heap:effective_size_avg
   *        ^browser ^process      ^source            ^component  ^property
   */
  function getNumericName(
      browserName, sourceName, propertyName, processName, componentPath) {
    // Construct the name of the memory value.
    const nameParts = ['memory', browserName, processName, sourceName].concat(
        componentPath);
    if (propertyName !== undefined) nameParts.push(propertyName);
    return nameParts.join(':');
  }

  /**
   * Gets the description of a histogram.
   */
  function getNumericDescription(
      property, browserName, processName, componentPath) {
    return [
      property.buildDescriptionPrefix(componentPath, processName),
      'in',
      convertBrowserNameToUserFriendlyName(browserName)
    ].join(' ');
  }

  /**
   * Create a memory tr.v.Histogram with |unit| and add all total values in
   * |node| to it. Names and describes the histogram according to the
   * |browserName|, |sourceName|, |property|, |processName| and
   * |componentPath|.
   */
  function buildNamedMemoryNumericFromNode(
      browserName, sourceName, property, processName, componentPath, node) {
    const name = getNumericName(
        browserName, sourceName, property.name, processName, componentPath);
    const description = getNumericDescription(
        property, browserName, processName, componentPath);

    // Build the underlying numeric for the memory value.
    const numeric = buildMemoryNumericFromNode(name, node, property.unit);
    numeric.description = description;
    return numeric;
  }

  /**
   * Create a memory tr.v.Histogram with |unit| and add all total values in
   * |node| to it.
   */
  function buildMemoryNumericFromNode(name, node, unit) {
    const histogram = new tr.v.Histogram(
        name, unit, BOUNDARIES_FOR_UNIT_MAP.get(unit));
    node.values.forEach(v => histogram.addSample(v.total));
    return histogram;
  }

  tr.metrics.MetricRegistry.register(memoryMetric, {
    supportsRangeOfInterest: true
  });

  return {
    memoryMetric,
  };
});


'use strict';

tr.exportTo('tr.e.chrome', function() {
  class CpuTime {
    /**
     * Returns the total cpu time consumed within |range| by |thread|.
     */
    static getCpuTimeForThread(thread, range) {
      let totalCpuTime = 0;
      tr.b.iterateOverIntersectingIntervals(
          thread.sliceGroup.topLevelSlices,
          slice => slice.start, slice => slice.end,
          range.min, range.max,
          slice => {
            if (slice.duration === 0) return;
            if (!slice.cpuDuration) return;

            const intersection = range.findIntersection(slice.range);
            const fractionOfSliceInsideRangeOfInterest =
                intersection.duration / slice.duration;

            // We assume that if a slice doesn't lie entirely inside the range
            // of interest, then the CPU time is evenly distributed inside of
            // the slice.
            totalCpuTime +=
                slice.cpuDuration * fractionOfSliceInsideRangeOfInterest;
          });

      return totalCpuTime;
    }

    /**
     * Returns two level map of rail stage to initiator type to set of bounds of
     * associated segments, intersected with |rangeOfInterest|.
     *
     * For each rail stage, we additionally have a key 'all_initiators' that
     * returns all the segment bounds associated with that rail stage across all
     * initiator types. For completeness, there is an additional rail stage
     * 'all_stages' that has all the segment bounds across all rail stages.
     *
     * If a segment is not contained within |rangeOfInterest| it is not
     * included.
     *
     * There is a unique segment bound for each segment in the map. For example,
     * assume
     * - |segmentA| is associated with both Click Response and Scroll Animation
     * - |bound1| is the interesting bound of |segmentA| in Response -> Click
     *   set.
     * - |bound2| is the interesting bound of |segmentA| in Animation -> Scroll
     *   set.
     * Then bound1 === bound2. These segment bounds can therefore be used as
     * keys in a map to represent the segment.
     *
     * Example return value (all bounds are intersected with |rangeOfInterest|):
     *
     * {
     *   'Animation': {
     *     'CSS': {Segment bounds for CSS Animation},
     *     'Video': {Segment bounds for Video Animation},
     *     ...
     *     'all_initiators': {All Animation segment bounds}
     *   },
     *   'Response': {
     *     'Click': {Segment bounds for Click Response},
     *     'Scroll': {Segment bounds for Scroll Response},
     *     ...
     *     'all_initiators': {All Response segment bounds}
     *   },
     *   ...
     *   'all_stages': {
     *     'all_initiators': {All segment bounds}
     *   }
     * }
     *
     * @param {!Array.<!tr.model.um.Segment>} segments
     * @param {!Array.<!tr.b.math.Range>} rangeOfInterest
     * @returns {!Map.<string, Map.<string, Set.<!tr.b.math.Range>>}
     */
    static getStageToInitiatorToSegmentBounds(segments, rangeOfInterest) {
      const stageToInitiatorToRanges = new Map();
      stageToInitiatorToRanges.set('all_stages',
          new Map([['all_initiators', new Set()]]));
      const allRanges =
          stageToInitiatorToRanges.get('all_stages').get('all_initiators');

      for (const segment of segments) {
        if (!rangeOfInterest.intersectsRangeInclusive(segment.range)) continue;
        const intersectingRange =
            rangeOfInterest.findIntersection(segment.range);
        allRanges.add(intersectingRange);

        for (const expectation of segment.expectations) {
          const stageTitle = expectation.stageTitle;
          if (!stageToInitiatorToRanges.has(stageTitle)) {
            stageToInitiatorToRanges.set(stageTitle,
                new Map([['all_initiators', new Set()]]));
          }

          const initiatorToRanges = stageToInitiatorToRanges.get(stageTitle);
          initiatorToRanges.get('all_initiators').add(intersectingRange);

          const initiatorType = expectation.initiatorType;
          if (initiatorType) {
            if (!initiatorToRanges.has(initiatorType)) {
              initiatorToRanges.set(initiatorType, new Set());
            }
            initiatorToRanges.get(initiatorType).add(intersectingRange);
          }
        }
      }
      return stageToInitiatorToRanges;
    }

    /**
     * Returns a map of range in |ranges| to total cpu time used by |thread|
     * during that range.
     *
     * Ranges are not interned like Strings, so if you call get() on this Map,
     * you must use the Range objects from |ranges| as the key. You cannot
     * construct a new range object with the same bounds as a range in |ranges|
     * and retrieve the cpu time.
     *
     * @param {!Iterable.<!tr.b.math.Range>} ranges
     * @param {!Iterable.<!tr.model.Thread>} thread
     * @returns {!Map.<!tr.b.math.Range, !tr.model.Thread>}
     */
    static computeCpuTimesForRanges_(ranges, thread) {
      const rangeToCpuTime = new Map();
      for (const range of ranges) {
        rangeToCpuTime.set(range, CpuTime.getCpuTimeForThread(thread, range));
      }
      return rangeToCpuTime;
    }

    /**
     * Returns the root node of a MultiDimensionalView in TopDownTreeView for
     * cpu time.
     *
     * The returned tree view is three dimensional (processType, threadType, and
     * railStage + initiator). Rail stage and initiator are not separate
     * dimensions because they are not independent - there is no such thing as
     * CSS Response or Scroll Load.
     *
     * Each node in the tree view contains two values - cpuUsage and cpuTotal.
     *
     * See cpu_time_multidimensinoal_view.md for more details about the returned
     * multidimensional view.
     *
     * @param {!tr.Model} model
     * @param {!tr.b.math.Range} rangeOfInterest
     * @returns {!tr.b.MultiDimensionalViewNode}
     */
    static constructMultiDimensionalView(model, rangeOfInterest) {
      const mdvBuilder = new tr.b.MultiDimensionalViewBuilder(
        3 /* dimensions (process, thread and rail stage / initiator) */,
        2 /* valueCount (cpuUsage and cpuTotal) */);

      const stageToInitiatorToRanges =
          CpuTime.getStageToInitiatorToSegmentBounds(
              model.userModel.segments, rangeOfInterest);

      const allSegmentBoundsInRange =
          stageToInitiatorToRanges.get('all_stages').get('all_initiators');

      for (const [pid, process] of Object.entries(model.processes)) {
        const processType =
            tr.e.chrome.chrome_processes.canonicalizeProcessName(process.name);
        for (const [tid, thread] of Object.entries(process.threads)) {
          // Cache cpuTime for each segment bound.
          const rangeToCpuTime = CpuTime.computeCpuTimesForRanges_(
              allSegmentBoundsInRange, thread);

          for (const [stage, initiatorToRanges] of stageToInitiatorToRanges) {
            for (const [initiator, ranges] of initiatorToRanges) {
              const cpuTime = tr.b.math.Statistics.sum(ranges,
                  range => rangeToCpuTime.get(range));
              const duration = tr.b.math.Statistics.sum(ranges,
                  range => range.duration);
              const cpuTimePerSecond = cpuTime / duration;
              mdvBuilder.addPath(
                  [[processType], [thread.type], [stage, initiator]],
                  [cpuTimePerSecond, cpuTime],
                  tr.b.MultiDimensionalViewBuilder.ValueKind.TOTAL);
            }
          }
        }
      }

      return mdvBuilder.buildTopDownTreeView();
    }
  }

  return {
    CpuTime,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  const CPU_PERCENTAGE_UNIT =
      tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
  const CPU_TIME_UNIT = tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;

  /**
   * Returns a deep clone of CPU time multidimensional view path object.
   *
   * @param {!Array.<!Array.<string>>} previousPath
   * @returns {!Array.<!Array.<string>>}
   */
  function clonePath_(previousPath) {
    return previousPath.map(subPath => subPath.map(x => x));
  }


  /**
   * Returns an object containing the processType, threadType, railStage, and
   * initiatorType encoded in the provided CPU time multidimensional view path
   * object. Decoding the path into this object can make code easier to
   * understand than indexing directly into the path array.
   *
   * @param {!Array.<!Array.<string>>} path - A path in a CPU time
   * multidimensional tree view.
   * @returns {Object.<string, string>}
   */
  function decodePath_(path) {
    return {
      processType: path[0][0],
      threadType: path[1][0],
      railStage: path[2][0],
      initiatorType: path[2][1]
    };
  }

  /**
   * Returns a unique string representation of |path|.
   *
   * Paths are of the following form in CPU time multidimensional trees:
   *   [[processType], [threadType], [railStage, initiatorType]]
   *
   * The returned string is of the form
   *   "$processtype:$threadType:$railStage:$initiatorType".
   *
   * @param {Array.<!Array.<string>>} path
   * @returns {string}
   */
  function stringifyPathName_(path) {
    const decodedPath = decodePath_(path);
    return [
      decodedPath.processType,
      decodedPath.threadType,
      decodedPath.railStage,
      decodedPath.initiatorType
    ].join(':');
  }

  /**
   * This class is used to traverse a multidimensional tree view and report CPU
   * percentage and CPU time from the tree as histograms.
   */
  class CpuTimeTreeDataReporter {
    constructor() {
      this.visitedSet_ = new Set();
    }

    /**
     * Extracts CPU percentage and CPU time values from |node| located at |path|
     * and adds values as histograms to |this.histogramSet_|. Each value is
     * added as a single sample histogram.
     *
     * @param {!tr.b.MultiDimensionalViewNode} node
     * @param {!Array.<!Array.<string>>} path
     */
    reportValuesFromNode_(node, path) {
      const decodedPath = decodePath_(path);
      const processType = decodedPath.processType || 'all_processes';
      const threadType = decodedPath.threadType || 'all_threads';

      // We need some RAIL stage and some initiator type to process a node.
      // All RAIL stages and all initiator types are handled by the special
      // 'all_stages' and 'all_initiators' nodes respectively.
      if (!decodedPath.railStage || !decodedPath.initiatorType) return;
      const {railStage, initiatorType} = decodedPath;

      const serializedPathName =
          [processType, threadType, railStage, initiatorType].join(':');

      // node.values is a two element array. The first element holds
      // cpuPercentage data and the second holds cpuTime data. The final
      // '.total' (as opposed to '.self') signifies we're including all the data
      // from children nodes. This is an artifact of how the multidimensional
      // view data structure works and is not very relevant - we exclusively use
      // '.total' for CPU time.
      const cpuPercentageValue = node.values[0].total;
      const cpuTimeValue = node.values[1].total;

      this.histogramSet_.createHistogram(`cpuPercentage:${serializedPathName}`,
          CPU_PERCENTAGE_UNIT, cpuPercentageValue);
      this.histogramSet_.createHistogram(`cpuTime:${serializedPathName}`,
          CPU_TIME_UNIT, cpuTimeValue);
    }


    /**
     * Traverses all the paths of a multidimensional view subtree and reports
     * node data to |this.histogramSet_|.
     *
     * @param {!tr.b.MultiDimensionalViewNode} root - Root of the subtree.
     * @param {!Array.<!Array.<string>>} rootPath - Path of the subtree root
     * node with respect to |this.rootNode_|.
     */
    reportDataFromTree_(root, rootPath) {
      const rootPathString = stringifyPathName_(rootPath);
      if (this.visitedSet_.has(rootPathString)) return;
      this.visitedSet_.add(rootPathString);

      this.reportValuesFromNode_(root, rootPath);

      for (let dimension = 0; dimension < root.children.length; dimension++) {
        const children = root.children[dimension];
        for (const [name, node] of children) {
          const childPath = clonePath_(rootPath);
          childPath[dimension].push(name);
          this.reportDataFromTree_(node, childPath);
        }
      }
    }

    /**
     * Adds values from the multidimensional tree view rooted at |rootNode| as
     * single value histograms in |histogramSet|.
     *
     * @param {!tr.b.MultiDimensionalViewNode} rootNode
     * @param {!tr.v.HistogramSet} histogramSet
     */
    addTreeValuesToHistogramSet(rootNode, histogramSet) {
      const rootPath = [[], [], []];
      this.rootNode_ = rootNode;
      this.histogramSet_ = histogramSet;
      this.reportDataFromTree_(this.rootNode_, rootPath);
    }

    /**
     * Reports values from the multidimensional tree view rooted at |rootNode|
     * as single value histograms in |histogramSet|.
     *
     * The histograms are dynamically generated from the tree. The histogram
     * names are of the form
     *   "${cpuTime|cpuPercentage}:${processType}:${threadType}:" +
     *   "${railStage}:${railStageInitiator}"
     *
     * cpuTime histograms contain total consumed cpu time, while cpuPercentage
     * histograms contain cpu time as a percentage of wall time. In multicore
     * situations, this percentage can be larger than 100.
     *
     * @param {!tr.b.MultiDimensionalViewNode} rootNode
     * @param {!tr.v.HistogramSet} histogramSet
     */
    static reportToHistogramSet(rootNode, histogramSet) {
      const reporter = new CpuTimeTreeDataReporter();
      reporter.addTreeValuesToHistogramSet(rootNode, histogramSet);
    }
  }

  return {
    CpuTimeTreeDataReporter,
  };
});


'use strict';

/**
 * @fileoverview Implements the new CPU time metric. This will eventually
 * replace the current cpu_time_metric.html, but we're running this alongside
 * the existing metric while we monitor its quality.
 *
 */
tr.exportTo('tr.metrics.sh', function() {
  /**
   * This metric measures total CPU time and CPU time per unit of wall clock
   * time for all combinations of process type, thread type, RAIL
   * stage, and RAIL stage initiator present in the model.
   *
   * The metric generates histograms of the form
   *   ${cpuTime|cpuPercentage}:${process_type}:${thread_type}:
   *   ${rail_stage}:${rail_stage_initiator}
   *
   * 'cpuTime' histograms represent total consumed CPU time, while
   * 'cpuPercentage' histograms represent CPU time as a percentage of wall clock
   * time.
   *
   * Example histograms generated by this metric:
   * - cpuTime:browser_process:CrBrowserMain:Animation:CSS
   * - cpuPercentage:gpu_process:CrGpuMain:Response:Scroll

   * For a given model, a single sample is generated for each histogram. For
   * example, if the model contains three renderer processes, and 10 different
   * Scroll Response ranges, the histogram
   * cpuPercentage:renderer_process:CrRendererMain:Response:Scroll will still
   * contain a single sample: the total CPU time consumed by all three renderer
   * main threads over all 10 Scroll Response phases, divided by the total
   * duration of those ranges. Since the three different main threads can
   * potentially be running on three different CPU cores, the sample value of a
   * cpuPercentage histogram can be more than 100%.
   *
   * The histograms are created as needed from the model - if a certain
   * combination of process, thread, RAIL stage and initiator does not occur in
   * the model, the histogram for that combination is not added.
   *
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function newCpuTimeMetric(histograms, model, opt_options) {
    const rangeOfInterest = opt_options && opt_options.rangeOfInterest ?
       opt_options.rangeOfInterest : model.bounds;

    const rootNode = tr.e.chrome.CpuTime.constructMultiDimensionalView(
        model, rangeOfInterest);

    tr.metrics.sh.CpuTimeTreeDataReporter.reportToHistogramSet(
        rootNode, histograms);
  }

  tr.metrics.MetricRegistry.register(newCpuTimeMetric, {
    supportsRangeOfInterest: true
  });

  return {
    newCpuTimeMetric,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const AsyncSlice = tr.model.AsyncSlice;
  const EventSet = tr.model.EventSet;

  const UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
  const ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  const BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  const END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';

  const MAIN_RENDERER_THREAD_NAME = 'CrRendererMain';
  const COMPOSITOR_THREAD_NAME = 'Compositor';

  const POSTTASK_FLOW_EVENT = 'disabled-by-default-toplevel.flow';
  const IPC_FLOW_EVENT = 'disabled-by-default-ipc.flow';

  const INPUT_EVENT_TYPE_NAMES = {
    CHAR: 'Char',
    CLICK: 'GestureClick',
    CONTEXT_MENU: 'ContextMenu',
    FLING_CANCEL: 'GestureFlingCancel',
    FLING_START: 'GestureFlingStart',
    KEY_DOWN: 'KeyDown',
    KEY_DOWN_RAW: 'RawKeyDown',
    KEY_UP: 'KeyUp',
    LATENCY_SCROLL_UPDATE: 'ScrollUpdate',
    MOUSE_DOWN: 'MouseDown',
    MOUSE_ENTER: 'MouseEnter',
    MOUSE_LEAVE: 'MouseLeave',
    MOUSE_MOVE: 'MouseMove',
    MOUSE_UP: 'MouseUp',
    MOUSE_WHEEL: 'MouseWheel',
    PINCH_BEGIN: 'GesturePinchBegin',
    PINCH_END: 'GesturePinchEnd',
    PINCH_UPDATE: 'GesturePinchUpdate',
    SCROLL_BEGIN: 'GestureScrollBegin',
    SCROLL_END: 'GestureScrollEnd',
    SCROLL_UPDATE: 'GestureScrollUpdate',
    SCROLL_UPDATE_RENDERER: 'ScrollUpdate',
    SHOW_PRESS: 'GestureShowPress',
    TAP: 'GestureTap',
    TAP_CANCEL: 'GestureTapCancel',
    TAP_DOWN: 'GestureTapDown',
    TOUCH_CANCEL: 'TouchCancel',
    TOUCH_END: 'TouchEnd',
    TOUCH_MOVE: 'TouchMove',
    TOUCH_START: 'TouchStart',
    UNKNOWN: 'UNKNOWN'
  };

  function InputLatencyAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    this.associatedEvents_ = new EventSet();
    this.typeName_ = undefined;
    if (!this.isLegacyEvent) {
      this.determineModernTypeName_();
    }
  }

  InputLatencyAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    // Legacy InputLatencyAsyncSlices involve a top-level slice titled
    // "InputLatency" containing a subSlice whose title starts with
    // "InputLatency:". Modern InputLatencyAsyncSlices involve a single
    // top-level slice whose title starts with "InputLatency::".
    // Legacy subSlices are not available at construction time, so
    // determineLegacyTypeName_() must be called at get time.
    // So this returns false for the legacy subSlice events titled like
    // "InputLatency:Foo" even though they are technically legacy events.
    get isLegacyEvent() {
      return this.title === 'InputLatency';
    },

    get typeName() {
      if (!this.typeName_) {
        this.determineLegacyTypeName_();
      }
      return this.typeName_;
    },

    checkTypeName_() {
      if (!this.typeName_) {
        throw new Error('Unable to determine typeName');
      }
      let found = false;
      for (const typeName in INPUT_EVENT_TYPE_NAMES) {
        if (this.typeName === INPUT_EVENT_TYPE_NAMES[typeName]) {
          found = true;
          break;
        }
      }
      if (!found) {
        this.typeName_ = INPUT_EVENT_TYPE_NAMES.UNKNOWN;
      }
    },

    determineModernTypeName_() {
      // This method works both on modern events titled like
      // "InputLatency::Foo" and also on the legacy subSlices titled like
      // "InputLatency:Foo". Modern events' titles contain 2 colons, whereas the
      // legacy subSlices events contain 1 colon.

      const lastColonIndex = this.title.lastIndexOf(':');
      if (lastColonIndex < 0) return;

      const characterAfterLastColonIndex = lastColonIndex + 1;
      this.typeName_ = this.title.slice(characterAfterLastColonIndex);

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    determineLegacyTypeName_() {
      // Iterate over all descendent subSlices.
      for (const subSlice of this.enumerateAllDescendents()) {
        // If |subSlice| is not an InputLatencyAsyncSlice, then ignore it.
        const subSliceIsAInputLatencyAsyncSlice = (
            subSlice instanceof InputLatencyAsyncSlice);
        if (!subSliceIsAInputLatencyAsyncSlice) continue;

        // If |subSlice| does not have a typeName, then ignore it.
        if (!subSlice.typeName) continue;

        // If |this| already has a typeName and |subSlice| has a different
        // typeName, then explode!
        if (this.typeName_ && subSlice.typeName_) {
          const subSliceHasDifferentTypeName = (
              this.typeName_ !== subSlice.typeName_);
          if (subSliceHasDifferentTypeName) {
            throw new Error(
                'InputLatencyAsyncSlice.determineLegacyTypeName_() ' +
                ' found multiple typeNames');
          }
        }

        // The typeName of |this| top-level event is whatever the typeName of
        // |subSlice| is. Set |this.typeName_| to the subSlice's typeName.
        this.typeName_ = subSlice.typeName_;
      }

      // If typeName could not be determined, then explode!
      if (!this.typeName_) {
        throw new Error(
            'InputLatencyAsyncSlice.determineLegacyTypeName_() failed');
      }

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    getRendererHelper(sourceSlices) {
      const traceModel = this.startThread.parent.model;
      const modelHelper = traceModel.getOrCreateHelper(
          tr.model.helpers.ChromeModelHelper);
      if (!modelHelper) return undefined;

      let mainThread = undefined;
      let compositorThread = undefined;

      for (const i in sourceSlices) {
        if (sourceSlices[i].parentContainer.name ===
            MAIN_RENDERER_THREAD_NAME) {
          mainThread = sourceSlices[i].parentContainer;
        } else if (sourceSlices[i].parentContainer.name ===
            COMPOSITOR_THREAD_NAME) {
          compositorThread = sourceSlices[i].parentContainer;
        }

        if (mainThread && compositorThread) break;
      }

      const rendererHelpers = modelHelper.rendererHelpers;

      const pids = Object.keys(rendererHelpers);
      for (let i = 0; i < pids.length; i++) {
        const pid = pids[i];
        const rendererHelper = rendererHelpers[pid];
        if (rendererHelper.mainThread === mainThread ||
            rendererHelper.compositorThread === compositorThread) {
          return rendererHelper;
        }
      }

      return undefined;
    },

    addEntireSliceHierarchy(slice) {
      this.associatedEvents_.push(slice);
      slice.iterateAllSubsequentSlices(function(subsequentSlice) {
        this.associatedEvents_.push(subsequentSlice);
      }, this);
    },

    addDirectlyAssociatedEvents(flowEvents) {
      const slices = [];

      flowEvents.forEach(function(flowEvent) {
        this.associatedEvents_.push(flowEvent);
        const newSource = flowEvent.startSlice.mostTopLevelSlice;
        if (slices.indexOf(newSource) === -1) {
          slices.push(newSource);
        }
      }, this);

      const lastFlowEvent = flowEvents[flowEvents.length - 1];
      const lastSource = lastFlowEvent.endSlice.mostTopLevelSlice;
      if (slices.indexOf(lastSource) === -1) {
        slices.push(lastSource);
      }

      return slices;
    },

    // Find the Latency::ScrollUpdate slice that corresponds to the
    // InputLatency::GestureScrollUpdate slice.
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1178963003
    addScrollUpdateEvents(rendererHelper) {
      if (!rendererHelper || !rendererHelper.compositorThread) {
        return;
      }

      const compositorThread = rendererHelper.compositorThread;
      const gestureScrollUpdateStart = this.start;
      const gestureScrollUpdateEnd = this.end;

      const allCompositorAsyncSlices =
        compositorThread.asyncSliceGroup.slices;

      for (const i in allCompositorAsyncSlices) {
        const slice = allCompositorAsyncSlices[i];

        if (slice.title !== 'Latency::ScrollUpdate') continue;

        const parentId = slice.args.data.
            INPUT_EVENT_LATENCY_FORWARD_SCROLL_UPDATE_TO_MAIN_COMPONENT.
            sequence_number;

        if (parentId === undefined) {
          // Old trace, we can only rely on the timestamp to find the slice
          if (slice.start < gestureScrollUpdateStart ||
              slice.start >= gestureScrollUpdateEnd) {
            continue;
          }
        } else {
          // New trace, we can definitively find the latency slice by comparing
          // its sequence number with gesture id
          if (parseInt(parentId) !== parseInt(this.id)) {
            continue;
          }
        }

        slice.associatedEvents.forEach(function(event) {
          this.associatedEvents_.push(event);
        }, this);
        break;
      }
    },

    // Return true if the slice hierarchy is tracked by LatencyInfo of other
    // input latency events. If the slice hierarchy is tracked by both, this
    // function still returns true.
    belongToOtherInputs(slice, flowEvents) {
      let fromOtherInputs = false;

      slice.iterateEntireHierarchy(function(subsequentSlice) {
        if (fromOtherInputs) return;

        subsequentSlice.inFlowEvents.forEach(function(inflow) {
          if (fromOtherInputs) return;

          if (inflow.category.indexOf('input') > -1) {
            if (flowEvents.indexOf(inflow) === -1) {
              fromOtherInputs = true;
            }
          }
        }, this);
      }, this);

      return fromOtherInputs;
    },

    // Return true if |event| triggers slices of other inputs.
    triggerOtherInputs(event, flowEvents) {
      if (event.outFlowEvents === undefined ||
          event.outFlowEvents.length === 0) {
        return false;
      }

      // Once we fix the bug of flow event binding, there should exist one and
      // only one outgoing flow (PostTask) from ScheduleBeginImplFrameDeadline
      // and PostComposite.
      const flow = event.outFlowEvents[0];

      if (flow.category !== POSTTASK_FLOW_EVENT ||
          !flow.endSlice) {
        return false;
      }

      const endSlice = flow.endSlice;
      if (this.belongToOtherInputs(endSlice.mostTopLevelSlice, flowEvents)) {
        return true;
      }

      return false;
    },

    // Follow outgoing flow of subsequentSlices in the current hierarchy.
    // We also handle cases where different inputs interfere with each other.
    followSubsequentSlices(event, queue, visited, flowEvents) {
      let stopFollowing = false;
      let inputAck = false;

      event.iterateAllSubsequentSlices(function(slice) {
        if (stopFollowing) return;

        // Do not follow TaskQueueManager::RunTask because it causes
        // many false events to be included.
        if (slice.title === 'TaskQueueManager::RunTask') return;

        // Do not follow ScheduledActionSendBeginMainFrame because the real
        // main thread BeginMainFrame is already traced by LatencyInfo flow.
        if (slice.title === 'ThreadProxy::ScheduledActionSendBeginMainFrame') {
          return;
        }

        // Do not follow ScheduleBeginImplFrameDeadline that triggers an
        // OnBeginImplFrameDeadline that is tracked by another LatencyInfo.
        if (slice.title === 'Scheduler::ScheduleBeginImplFrameDeadline') {
          if (this.triggerOtherInputs(slice, flowEvents)) return;
        }

        // Do not follow PostComposite that triggers CompositeImmediately
        // that is tracked by another LatencyInfo.
        if (slice.title === 'CompositorImpl::PostComposite') {
          if (this.triggerOtherInputs(slice, flowEvents)) return;
        }

        // Stop following the rest of the current slice hierarchy if
        // FilterAndSendWebInputEvent occurs after ProcessInputEventAck.
        if (slice.title === 'InputRouterImpl::ProcessInputEventAck') {
          inputAck = true;
        }
        if (inputAck &&
            slice.title === 'InputRouterImpl::FilterAndSendWebInputEvent') {
          stopFollowing = true;
        }

        this.followCurrentSlice(slice, queue, visited);
      }, this);
    },

    // Follow outgoing flow events of the current slice.
    followCurrentSlice(event, queue, visited) {
      event.outFlowEvents.forEach(function(outflow) {
        if ((outflow.category === POSTTASK_FLOW_EVENT ||
            outflow.category === IPC_FLOW_EVENT) &&
            outflow.endSlice) {
          this.associatedEvents_.push(outflow);

          const nextEvent = outflow.endSlice.mostTopLevelSlice;
          if (!visited.contains(nextEvent)) {
            visited.push(nextEvent);
            queue.push(nextEvent);
          }
        }
      }, this);
    },

    backtraceFromDraw(beginImplFrame, visited) {
      const pendingEventQueue = [];
      pendingEventQueue.push(beginImplFrame.mostTopLevelSlice);

      while (pendingEventQueue.length !== 0) {
        const event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);

        // TODO(yuhao): For now, we backtrace all the way to the source input.
        // But is this really needed? I will have an entry in the design
        // doc to discuss this.
        event.inFlowEvents.forEach(function(inflow) {
          if (inflow.category === POSTTASK_FLOW_EVENT && inflow.startSlice) {
            const nextEvent = inflow.startSlice.mostTopLevelSlice;
            if (!visited.contains(nextEvent)) {
              visited.push(nextEvent);
              pendingEventQueue.push(nextEvent);
            }
          }
        }, this);
      }
    },

    sortRasterizerSlices(rasterWorkerThreads,
        sortedRasterizerSlices) {
      rasterWorkerThreads.forEach(function(rasterizer) {
        Array.prototype.push.apply(sortedRasterizerSlices,
            rasterizer.sliceGroup.slices);
      }, this);

      sortedRasterizerSlices.sort(function(a, b) {
        if (a.start !== b.start) {
          return a.start - b.start;
        }
        return a.guid - b.guid;
      });
    },

    // Find rasterization slices that have the source_prepare_tiles_id
    // same as the prepare_tiles_id of TileManager::PrepareTiles
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1208683002/
    addRasterizationEvents(prepareTiles, rendererHelper,
        visited, flowEvents, sortedRasterizerSlices) {
      if (!prepareTiles.args.prepare_tiles_id) return;

      if (!rendererHelper || !rendererHelper.rasterWorkerThreads) {
        return;
      }

      const rasterWorkerThreads = rendererHelper.rasterWorkerThreads;
      const prepareTileId = prepareTiles.args.prepare_tiles_id;
      const pendingEventQueue = [];

      // Collect all the rasterizer tasks. Return the cached copy if possible.
      if (sortedRasterizerSlices.length === 0) {
        this.sortRasterizerSlices(rasterWorkerThreads, sortedRasterizerSlices);
      }

      // TODO(yuhao): Once TaskSetFinishedTaskImpl also get the prepareTileId
      // we can simply track by checking id rather than counting.
      let numFinishedTasks = 0;
      const RASTER_TASK_TITLE = 'RasterizerTaskImpl::RunOnWorkerThread';
      const IMAGEDECODE_TASK_TITLE = 'ImageDecodeTaskImpl::RunOnWorkerThread';
      const FINISHED_TASK_TITLE = 'TaskSetFinishedTaskImpl::RunOnWorkerThread';

      for (let i = 0; i < sortedRasterizerSlices.length; i++) {
        const task = sortedRasterizerSlices[i];

        if (task.title === RASTER_TASK_TITLE ||
            task.title === IMAGEDECODE_TASK_TITLE) {
          if (task.args.source_prepare_tiles_id === prepareTileId) {
            this.addEntireSliceHierarchy(task.mostTopLevelSlice);
          }
        } else if (task.title === FINISHED_TASK_TITLE) {
          if (task.start > prepareTiles.start) {
            pendingEventQueue.push(task.mostTopLevelSlice);
            if (++numFinishedTasks === 3) break;
          }
        }
      }

      // Trace PostTask from rasterizer tasks.
      while (pendingEventQueue.length !== 0) {
        const event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);
        this.followSubsequentSlices(event, pendingEventQueue, visited,
            flowEvents);
      }
    },

    addOtherCausallyRelatedEvents(rendererHelper, sourceSlices,
        flowEvents, sortedRasterizerSlices) {
      const pendingEventQueue = [];
      // Keep track of visited nodes when traversing a DAG
      const visitedEvents = new EventSet();
      let beginImplFrame = undefined;
      let prepareTiles = undefined;
      sortedRasterizerSlices = [];

      sourceSlices.forEach(function(sourceSlice) {
        if (!visitedEvents.contains(sourceSlice)) {
          visitedEvents.push(sourceSlice);
          pendingEventQueue.push(sourceSlice);
        }
      }, this);

      while (pendingEventQueue.length !== 0) {
        const event = pendingEventQueue.pop();

        // Push the current event chunk into associatedEvents.
        this.addEntireSliceHierarchy(event);

        this.followCurrentSlice(event, pendingEventQueue, visitedEvents);

        this.followSubsequentSlices(event, pendingEventQueue, visitedEvents,
            flowEvents);

        // The rasterization work (CompositorTileWorker thread) and the
        // Compositor tile manager are connect by the prepare_tiles_id
        // instead of flow events.
        const COMPOSITOR_PREPARE_TILES = 'TileManager::PrepareTiles';
        prepareTiles = event.findDescendentSlice(COMPOSITOR_PREPARE_TILES);
        if (prepareTiles) {
          this.addRasterizationEvents(prepareTiles, rendererHelper,
              visitedEvents, flowEvents, sortedRasterizerSlices);
        }

        // OnBeginImplFrameDeadline could be triggered by other inputs.
        // For now, we backtrace from it.
        // TODO(yuhao): There are more such slices that we need to backtrace
        const COMPOSITOR_ON_BIFD = 'Scheduler::OnBeginImplFrameDeadline';
        beginImplFrame = event.findDescendentSlice(COMPOSITOR_ON_BIFD);
        if (beginImplFrame) {
          this.backtraceFromDraw(beginImplFrame, visitedEvents);
        }
      }

      // A separate pass on GestureScrollUpdate.
      // Scroll update doesn't go through the main thread, but the compositor
      // may go back to the main thread if there is an onscroll event handler.
      // This is captured by a different flow event, which does not have the
      // same ID as the Input Latency Event, but it is technically causally
      // related to the GestureScrollUpdate input. Add them manually for now.
      const INPUT_GSU = 'InputLatency::GestureScrollUpdate';
      if (this.title === INPUT_GSU) {
        this.addScrollUpdateEvents(rendererHelper);
      }
    },

    get associatedEvents() {
      if (this.associatedEvents_.length !== 0) {
        return this.associatedEvents_;
      }

      const modelIndices = this.startThread.parent.model.modelIndices;
      const flowEvents = modelIndices.getFlowEventsWithId(this.id);

      if (flowEvents.length === 0) {
        return this.associatedEvents_;
      }

      // Step 1: Get events that are directly connected by the LatencyInfo
      // flow events. This gives us a small set of events that are guaranteed
      // to be associated with the input, but are almost certain incomplete.
      // We call this set "source" event set.
      // This step returns the "source" event set (sourceSlices), which is then
      // used in the second step.
      const sourceSlices = this.addDirectlyAssociatedEvents(flowEvents);

      // Step 2: Start from the previously constructed "source" event set, we
      // follow the toplevel (i.e., PostTask) and IPC flow events. Any slices
      // that are reachable from the "source" event set via PostTasks or IPCs
      // are conservatively considered associated with the input event.
      // We then deal with specific cases where flow events either over include
      // or miss capturing slices.
      const rendererHelper = this.getRendererHelper(sourceSlices);
      this.addOtherCausallyRelatedEvents(rendererHelper, sourceSlices,
          flowEvents);

      return this.associatedEvents_;
    },

    get inputLatency() {
      if (!('data' in this.args)) return undefined;

      const data = this.args.data;
      if (!(END_COMP_NAME in data)) return undefined;

      let latency = 0;
      const endTime = data[END_COMP_NAME].time;
      if (ORIGINAL_COMP_NAME in data) {
        latency = endTime - data[ORIGINAL_COMP_NAME].time;
      } else if (UI_COMP_NAME in data) {
        latency = endTime - data[UI_COMP_NAME].time;
      } else if (BEGIN_COMP_NAME in data) {
        latency = endTime - data[BEGIN_COMP_NAME].time;
      } else {
        throw new Error('No valid begin latency component');
      }
      return latency;
    }
  };

  const eventTypeNames = [
    'Char',
    'ContextMenu',
    'GestureClick',
    'GestureFlingCancel',
    'GestureFlingStart',
    'GestureScrollBegin',
    'GestureScrollEnd',
    'GestureScrollUpdate',
    'GestureShowPress',
    'GestureTap',
    'GestureTapCancel',
    'GestureTapDown',
    'GesturePinchBegin',
    'GesturePinchEnd',
    'GesturePinchUpdate',
    'KeyDown',
    'KeyUp',
    'MouseDown',
    'MouseEnter',
    'MouseLeave',
    'MouseMove',
    'MouseUp',
    'MouseWheel',
    'RawKeyDown',
    'ScrollUpdate',
    'TouchCancel',
    'TouchEnd',
    'TouchMove',
    'TouchStart'
  ];
  const allTypeNames = ['InputLatency'];
  eventTypeNames.forEach(function(eventTypeName) {
    // Old style.
    allTypeNames.push('InputLatency:' + eventTypeName);

    // New style.
    allTypeNames.push('InputLatency::' + eventTypeName);
  });

  AsyncSlice.subTypes.register(
      InputLatencyAsyncSlice,
      {
        typeNames: allTypeNames,
        categoryParts: ['latencyInfo']
      });

  return {
    InputLatencyAsyncSlice,
    INPUT_EVENT_TYPE_NAMES,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  function AnimationExpectation(
      parentModel, initiatorTitle, start, duration) {
    tr.model.um.UserExpectation.call(
        this, parentModel, initiatorTitle, start, duration);
    this.frameEvents_ = undefined;
  }

  AnimationExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: AnimationExpectation,

    get frameEvents() {
      if (this.frameEvents_) {
        return this.frameEvents_;
      }

      this.frameEvents_ = new tr.model.EventSet();

      this.associatedEvents.forEach(function(event) {
        if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) {
          this.frameEvents_.push(event);
        }
      }, this);

      return this.frameEvents_;
    }
  };

  tr.model.um.UserExpectation.subTypes.register(AnimationExpectation, {
    stageTitle: 'Animation',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_animation')
  });

  return {
    AnimationExpectation,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  function ResponseExpectation(
      parentModel, initiatorTitle, start, duration, opt_isAnimationBegin) {
    tr.model.um.UserExpectation.call(
        this, parentModel, initiatorTitle, start, duration);
    this.isAnimationBegin = opt_isAnimationBegin || false;
  }

  ResponseExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: ResponseExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(ResponseExpectation, {
    stageTitle: 'Response',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_response')
  });

  return {
    ResponseExpectation,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  // This is an intermediate data format between InputLatencyAsyncSlices and
  // Responses and Animations.
  function ProtoExpectation(type, initiatorType) {
    this.type = type;
    this.initiatorType = initiatorType;
    this.start = Infinity;
    this.end = -Infinity;
    this.associatedEvents = new tr.model.EventSet();
    this.isAnimationBegin = false;
  }

  ProtoExpectation.RESPONSE_TYPE = 'r';
  ProtoExpectation.ANIMATION_TYPE = 'a';

  // Explicitly ignore some input events to allow
  // UserModelBuilder.checkAllInputEventsHandled() to determine which events
  // were unintentionally ignored due to a bug.
  ProtoExpectation.IGNORED_TYPE = 'ignored';

  /**
   * Combine initiator titles by selecting the initiator title first in a
   * hard-coded hierarchy. Higher up in the hierarchy are more "specific"
   * initiator titles (e.g. a scroll is higher than a touch, because a
   * touch could mean many different things, of which a scroll is one)
   */
  const INITIATOR_HIERARCHY = [
    tr.model.um.INITIATOR_TYPE.PINCH,
    tr.model.um.INITIATOR_TYPE.FLING,
    tr.model.um.INITIATOR_TYPE.MOUSE_WHEEL,
    tr.model.um.INITIATOR_TYPE.SCROLL,
    tr.model.um.INITIATOR_TYPE.VIDEO,
    tr.model.um.INITIATOR_TYPE.WEBGL,
    tr.model.um.INITIATOR_TYPE.CSS,
    tr.model.um.INITIATOR_TYPE.MOUSE,
    tr.model.um.INITIATOR_TYPE.KEYBOARD,
    tr.model.um.INITIATOR_TYPE.TAP,
    tr.model.um.INITIATOR_TYPE.TOUCH
  ];

  function combineInitiatorTypes(title1, title2) {
    for (const item of INITIATOR_HIERARCHY) {
      if (title1 === item || title2 === item) return item;
    }
    throw new Error('Invalid titles in combineInitiatorTypes');
  }

  ProtoExpectation.prototype = {
    get isValid() {
      return this.end > this.start;
    },

    // Return true if any associatedEvent's typeName is in typeNames.
    containsTypeNames(typeNames) {
      return this.associatedEvents.some(
          x => typeNames.indexOf(x.typeName) >= 0);
    },

    containsSliceTitle(title) {
      return this.associatedEvents.some(x => title === x.title);
    },

    createInteractionRecord(model) {
      if (this.type !== ProtoExpectation.IGNORED_TYPE && !this.isValid) {
        model.importWarning({
          type: 'ProtoExpectation',
          message: 'Please file a bug with this trace. ' + this.debug(),
          showToUser: true
        });
        return undefined;
      }

      const duration = this.end - this.start;

      let ir = undefined;
      switch (this.type) {
        case ProtoExpectation.RESPONSE_TYPE:
          ir = new tr.model.um.ResponseExpectation(
              model, this.initiatorType, this.start, duration,
              this.isAnimationBegin);
          break;
        case ProtoExpectation.ANIMATION_TYPE:
          ir = new tr.model.um.AnimationExpectation(
              model, this.initiatorType, this.start, duration);
          break;
      }
      if (!ir) return undefined;

      ir.sourceEvents.addEventSet(this.associatedEvents);

      function pushAssociatedEvents(event) {
        ir.associatedEvents.push(event);

        // |event| is either an InputLatencyAsyncSlice (which collects all of
        // its associated events transitively) or a CSS Animation (which doesn't
        // have any associated events). So this does not need to recurse.
        if (event.associatedEvents) {
          ir.associatedEvents.addEventSet(event.associatedEvents);
        }
      }

      this.associatedEvents.forEach(function(event) {
        pushAssociatedEvents(event);

        // Old-style InputLatencyAsyncSlices have subSlices.
        if (event.subSlices) {
          event.subSlices.forEach(pushAssociatedEvents);
        }
      });

      return ir;
    },

    // Merge the other ProtoExpectation into this one.
    // The types need not match: ignored ProtoExpectations might be merged
    // into overlapping ProtoExpectations, and Touch-only Animations are merged
    // into Tap Responses.
    merge(other) {
      this.initiatorType = combineInitiatorTypes(
          this.initiatorType, other.initiatorType);

      // Don't use pushEvent(), which would lose special start, end.
      this.associatedEvents.addEventSet(other.associatedEvents);
      this.start = Math.min(this.start, other.start);
      this.end = Math.max(this.end, other.end);
      if (other.isAnimationBegin) {
        this.isAnimationBegin = true;
      }
    },

    // Include |event| in this ProtoExpectation, expanding start/end to include
    // it.
    pushEvent(event) {
      // Usually, this method will be called while iterating over a list of
      // events sorted by start time, so this method won't usually change
      // this.start. However, this will sometimes be called for
      // ProtoExpectations created by previous handlers, in which case
      // event.start could possibly be before this.start.
      this.start = Math.min(this.start, event.start);
      this.end = Math.max(this.end, event.end);
      this.associatedEvents.push(event);
    },

    // Returns true if timestamp is contained in this ProtoExpectation.
    containsTimestampInclusive(timestamp) {
      return (this.start <= timestamp) && (timestamp <= this.end);
    },

    // Return true if the other event intersects this ProtoExpectation.
    intersects(other) {
      // http://stackoverflow.com/questions/325933
      return (other.start < this.end) && (other.end > this.start);
    },

    isNear(event, threshold) {
      return (this.end + threshold) > event.start;
    },

    // Return a string describing this ProtoExpectation for debugging.
    debug() {
      let debugString = this.type + '(';
      debugString += parseInt(this.start) + ' ';
      debugString += parseInt(this.end);
      this.associatedEvents.forEach(function(event) {
        debugString += ' ' + event.typeName;
      });
      return debugString + ')';
    }
  };

  return {
    ProtoExpectation,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  const ProtoExpectation = tr.importer.ProtoExpectation;
  const INITIATOR_TYPE = tr.model.um.INITIATOR_TYPE;
  const INPUT_TYPE = tr.e.cc.INPUT_EVENT_TYPE_NAMES;

  const KEYBOARD_TYPE_NAMES = [
    INPUT_TYPE.CHAR,
    INPUT_TYPE.KEY_DOWN_RAW,
    INPUT_TYPE.KEY_DOWN,
    INPUT_TYPE.KEY_UP
  ];
  const MOUSE_RESPONSE_TYPE_NAMES = [
    INPUT_TYPE.CLICK,
    INPUT_TYPE.CONTEXT_MENU
  ];
  const MOUSE_WHEEL_TYPE_NAMES = [
    INPUT_TYPE.MOUSE_WHEEL
  ];
  const MOUSE_DRAG_TYPE_NAMES = [
    INPUT_TYPE.MOUSE_DOWN,
    INPUT_TYPE.MOUSE_MOVE,
    INPUT_TYPE.MOUSE_UP
  ];
  const TAP_TYPE_NAMES = [
    INPUT_TYPE.TAP,
    INPUT_TYPE.TAP_CANCEL,
    INPUT_TYPE.TAP_DOWN
  ];
  const PINCH_TYPE_NAMES = [
    INPUT_TYPE.PINCH_BEGIN,
    INPUT_TYPE.PINCH_END,
    INPUT_TYPE.PINCH_UPDATE
  ];
  const FLING_TYPE_NAMES = [
    INPUT_TYPE.FLING_CANCEL,
    INPUT_TYPE.FLING_START
  ];
  const TOUCH_TYPE_NAMES = [
    INPUT_TYPE.TOUCH_END,
    INPUT_TYPE.TOUCH_MOVE,
    INPUT_TYPE.TOUCH_START
  ];
  const SCROLL_TYPE_NAMES = [
    INPUT_TYPE.SCROLL_BEGIN,
    INPUT_TYPE.SCROLL_END,
    INPUT_TYPE.SCROLL_UPDATE
  ];
  const ALL_HANDLED_TYPE_NAMES = [].concat(
      KEYBOARD_TYPE_NAMES,
      MOUSE_RESPONSE_TYPE_NAMES,
      MOUSE_WHEEL_TYPE_NAMES,
      MOUSE_DRAG_TYPE_NAMES,
      PINCH_TYPE_NAMES,
      TAP_TYPE_NAMES,
      FLING_TYPE_NAMES,
      TOUCH_TYPE_NAMES,
      SCROLL_TYPE_NAMES
  );

  const RENDERER_FLING_TITLE = 'InputHandlerProxy::HandleGestureFling::started';
  const PLAYBACK_EVENT_TITLE = 'VideoPlayback';

  const CSS_ANIMATION_TITLE = 'Animation';

  /**
   * If there's less than this much time between the end of one event and the
   * start of the next, then they might be merged.
   * There was not enough thought given to this value, so if you have any slight
   * reason to change it, then please do so. It might also be good to split this
   * into multiple values.
   */
  const INPUT_MERGE_THRESHOLD_MS = 200;
  const ANIMATION_MERGE_THRESHOLD_MS = 32;   // 2x 60FPS frames

  /**
   * If two MouseWheel events begin this close together, then they're an
   * Animation, not two responses.
   */
  const MOUSE_WHEEL_THRESHOLD_MS = 40;

  /**
   * If two MouseMoves are more than this far apart, then they're two Responses,
   * not Animation.
   */
  const MOUSE_MOVE_THRESHOLD_MS = 40;

  // TODO(#3813) Move this.
  function compareEvents(x, y) {
    if (x.start !== y.start) {
      return x.start - y.start;
    }
    if (x.end !== y.end) {
      return x.end - y.end;
    }
    if (x.guid && y.guid) {
      return x.guid - y.guid;
    }
    return 0;
  }

  function forEventTypesIn(events, typeNames, cb, opt_this) {
    events.forEach(function(event) {
      if (typeNames.indexOf(event.typeName) >= 0) {
        cb.call(opt_this, event);
      }
    });
  }

  function causedFrame(event) {
    return event.associatedEvents.some(
        x => x.title === tr.model.helpers.IMPL_RENDERING_STATS);
  }

  function getSortedFrameEventsByProcess(modelHelper) {
    const frameEventsByPid = {};
    for (const [pid, rendererHelper] of
        Object.entries(modelHelper.rendererHelpers)) {
      frameEventsByPid[pid] = rendererHelper.getFrameEventsInRange(
          tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds);
    }
    return frameEventsByPid;
  }

  function getSortedInputEvents(modelHelper) {
    const inputEvents = [];

    const browserProcess = modelHelper.browserHelper.process;
    const mainThread = browserProcess.findAtMostOneThreadNamed(
        'CrBrowserMain');
    for (const slice of mainThread.asyncSliceGroup.getDescendantEvents()) {
      if (!slice.isTopLevel) continue;

      if (!(slice instanceof tr.e.cc.InputLatencyAsyncSlice)) continue;

      if (isNaN(slice.start) ||
          isNaN(slice.duration) ||
          isNaN(slice.end)) {
        continue;
      }

      inputEvents.push(slice);
    }

    return inputEvents.sort(compareEvents);
  }

  function findProtoExpectations(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    // This order is not important. Handlers are independent.
    const handlers = [
      handleKeyboardEvents,
      handleMouseResponseEvents,
      handleMouseWheelEvents,
      handleMouseDragEvents,
      handleTapResponseEvents,
      handlePinchEvents,
      handleFlingEvents,
      handleTouchEvents,
      handleScrollEvents,
      handleCSSAnimations,
      handleWebGLAnimations,
      handleVideoAnimations
    ];
    handlers.forEach(function(handler) {
      protoExpectations.push.apply(protoExpectations, handler(
          modelHelper, sortedInputEvents, warn));
    });
    protoExpectations.sort(compareEvents);
    return protoExpectations;
  }

  /**
   * Every keyboard event is a Response.
   */
  function handleKeyboardEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    forEventTypesIn(sortedInputEvents, KEYBOARD_TYPE_NAMES, function(event) {
      const pe = new ProtoExpectation(
          ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.KEYBOARD);
      pe.pushEvent(event);
      protoExpectations.push(pe);
    });
    return protoExpectations;
  }

  /**
   * Some mouse events can be translated directly into Responses.
   */
  function handleMouseResponseEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    forEventTypesIn(
        sortedInputEvents, MOUSE_RESPONSE_TYPE_NAMES, function(event) {
          const pe = new ProtoExpectation(
          ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
          pe.pushEvent(event);
          protoExpectations.push(pe);
        });
    return protoExpectations;
  }
  /**
   * MouseWheel events are caused either by a physical wheel on a physical
   * mouse, or by a touch-drag gesture on a track-pad. The physical wheel
   * causes MouseWheel events that are much more spaced out, and have no
   * chance of hitting 60fps, so they are each turned into separate Response
   * UEs. The track-pad causes MouseWheel events that are much closer
   * together, and are expected to be 60fps, so the first event in a sequence
   * is turned into a Response, and the rest are merged into an Animation.
   * NB this threshold uses the two events' start times, unlike
   * ProtoExpectation.isNear, which compares the end time of the previous event
   * with the start time of the next.
   */
  function handleMouseWheelEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    let prevEvent_ = undefined;
    forEventTypesIn(
        sortedInputEvents, MOUSE_WHEEL_TYPE_NAMES, function(event) {
      // Switch prevEvent in one place so that we can early-return later.
          const prevEvent = prevEvent_;
          prevEvent_ = event;

          if (currentPE &&
          (prevEvent.start + MOUSE_WHEEL_THRESHOLD_MS) >= event.start) {
            if (currentPE.type === ProtoExpectation.ANIMATION_TYPE) {
              currentPE.pushEvent(event);
            } else {
              currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,
              INITIATOR_TYPE.MOUSE_WHEEL);
              currentPE.pushEvent(event);
              protoExpectations.push(currentPE);
            }
            return;
          }
          currentPE = new ProtoExpectation(
          ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE_WHEEL);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
        });
    return protoExpectations;
  }

  /**
   * Down events followed closely by Up events are click Responses, but the
   * Response doesn't start until the Up event.
   *
   *     RRR
   * DDD UUU
   *
   * If there are any Move events in between a Down and an Up, then the Down
   * and the first Move are a Response, then the rest of the Moves are an
   * Animation:
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * DDD MMM MMM MMM MMM MMM UUU
   */
  function handleMouseDragEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    let mouseDownEvent = undefined;
    forEventTypesIn(
        sortedInputEvents, MOUSE_DRAG_TYPE_NAMES, function(event) {
          switch (event.typeName) {
            case INPUT_TYPE.MOUSE_DOWN:
              if (causedFrame(event)) {
                const pe = new ProtoExpectation(
                    ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                pe.pushEvent(event);
                protoExpectations.push(pe);
              } else {
            // Responses typically don't start until the mouse up event.
            // Add this MouseDown to the Response that starts at the MouseUp.
                mouseDownEvent = event;
              }
              break;

          // There may be more than 100ms between the start of the mouse down
          // and the start of the mouse up. Chrome and the web don't start to
          // respond until the mouse up. Responses start deducting comfort
          // at 100ms duration. If more than that 100ms duration is burned
          // through while waiting for the user to release the
          // mouse button, then ResponseExpectation will unfairly start
          // deducting comfort before Chrome even has a mouse up to respond to.
          // It is technically possible for a site to afford one response on
          // mouse down and another on mouse up, but that is an edge case. The
          // vast majority of mouse downs are not responses.

            case INPUT_TYPE.MOUSE_MOVE:
              if (!causedFrame(event)) {
            // Ignore MouseMoves that do not affect the screen. They are not
            // part of an interaction record by definition.
                const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
                pe.pushEvent(event);
                protoExpectations.push(pe);
              } else if (!currentPE ||
                      !currentPE.isNear(event, MOUSE_MOVE_THRESHOLD_MS)) {
            // The first MouseMove after a MouseDown or after a while is a
            // Response.
                currentPE = new ProtoExpectation(
                ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                currentPE.pushEvent(event);
                if (mouseDownEvent) {
                  currentPE.associatedEvents.push(mouseDownEvent);
                  mouseDownEvent = undefined;
                }
                protoExpectations.push(currentPE);
              } else {
            // Merge this event into an Animation.
                if (currentPE.type === ProtoExpectation.ANIMATION_TYPE) {
                  currentPE.pushEvent(event);
                } else {
                  currentPE = new ProtoExpectation(
                  ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.MOUSE);
                  currentPE.pushEvent(event);
                  protoExpectations.push(currentPE);
                }
              }
              break;

            case INPUT_TYPE.MOUSE_UP:
              if (!mouseDownEvent) {
                const pe = new ProtoExpectation(
                    causedFrame(event) ? ProtoExpectation.RESPONSE_TYPE :
                    ProtoExpectation.IGNORED_TYPE,
                    INITIATOR_TYPE.MOUSE);
                pe.pushEvent(event);
                protoExpectations.push(pe);
                break;
              }

              if (currentPE) {
                currentPE.pushEvent(event);
              } else {
                currentPE = new ProtoExpectation(
                ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.MOUSE);
                if (mouseDownEvent) {
                  currentPE.associatedEvents.push(mouseDownEvent);
                }
                currentPE.pushEvent(event);
                protoExpectations.push(currentPE);
              }
              mouseDownEvent = undefined;
              currentPE = undefined;
              break;
          }
        });
    if (mouseDownEvent) {
      currentPE = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
      currentPE.pushEvent(mouseDownEvent);
      protoExpectations.push(currentPE);
    }
    return protoExpectations;
  }

  /**
   * Solitary Tap events are simple Responses:
   *
   * RRR
   * TTT
   *
   * TapDowns are part of Responses.
   *
   * RRRRRRR
   * DDD TTT
   *
   * TapCancels are part of Responses, which seems strange. They always go
   * with scrolls, so they'll probably be merged with scroll Responses.
   * TapCancels can take a significant amount of time and account for a
   * significant amount of work, which should be grouped with the scroll UEs
   * if possible.
   *
   * RRRRRRR
   * DDD CCC
   **/
  function handleTapResponseEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    forEventTypesIn(sortedInputEvents, TAP_TYPE_NAMES, function(event) {
      switch (event.typeName) {
        case INPUT_TYPE.TAP_DOWN:
          currentPE = new ProtoExpectation(
              ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
          break;

        case INPUT_TYPE.TAP:
          if (currentPE) {
            currentPE.pushEvent(event);
          } else {
            // Sometimes we get Tap events with no TapDown, sometimes we get
            // TapDown events. Handle both.
            currentPE = new ProtoExpectation(
                ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          currentPE = undefined;
          break;

        case INPUT_TYPE.TAP_CANCEL:
          if (!currentPE) {
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }

          if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(
                ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TAP);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * The PinchBegin and the first PinchUpdate comprise a Response, then the
   * rest of the PinchUpdates comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * BBB UUU UUU UUU UUU UUU EEE
   */
  function handlePinchEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    let sawFirstUpdate = false;
    const modelBounds = modelHelper.model.bounds;
    forEventTypesIn(sortedInputEvents, PINCH_TYPE_NAMES, function(event) {
      switch (event.typeName) {
        case INPUT_TYPE.PINCH_BEGIN:
          if (currentPE &&
              currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
            break;
          }
          currentPE = new ProtoExpectation(
              ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.PINCH);
          currentPE.pushEvent(event);
          currentPE.isAnimationBegin = true;
          protoExpectations.push(currentPE);
          sawFirstUpdate = false;
          break;

        case INPUT_TYPE.PINCH_UPDATE:
          // Like ScrollUpdates, the Begin and the first Update constitute a
          // Response, then the rest of the Updates constitute an Animation
          // that begins when the Response ends. If the user pauses in the
          // middle of an extended pinch gesture, then multiple Animations
          // will be created.
          if (!currentPE ||
              ((currentPE.type === ProtoExpectation.RESPONSE_TYPE) &&
                sawFirstUpdate) ||
              !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE = new ProtoExpectation(
                ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.PINCH);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          } else {
            currentPE.pushEvent(event);
            sawFirstUpdate = true;
          }
          break;

        case INPUT_TYPE.PINCH_END:
          if (currentPE) {
            currentPE.pushEvent(event);
          } else {
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * Flings are defined by 3 types of events: FlingStart, FlingCancel, and the
   * renderer fling event. Flings do not begin with a Response. Flings end
   * either at the beginning of a FlingCancel, or at the end of the renderer
   * fling event.
   *
   * AAAAAAAAAAAAAAAAAAAAAAAAAA
   * SSS
   *     RRRRRRRRRRRRRRRRRRRRRR
   *
   *
   * AAAAAAAAAAA
   * SSS        CCC
   */
  function handleFlingEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;

    function isRendererFling(event) {
      return event.title === RENDERER_FLING_TITLE;
    }
    const browserHelper = modelHelper.browserHelper;
    const flingEvents = browserHelper.getAllAsyncSlicesMatching(
        isRendererFling);

    forEventTypesIn(sortedInputEvents, FLING_TYPE_NAMES, function(event) {
      flingEvents.push(event);
    });
    flingEvents.sort(compareEvents);

    flingEvents.forEach(function(event) {
      if (event.title === RENDERER_FLING_TITLE) {
        if (currentPE) {
          currentPE.pushEvent(event);
        } else {
          currentPE = new ProtoExpectation(
              ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.FLING);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
        }
        return;
      }

      switch (event.typeName) {
        case INPUT_TYPE.FLING_START:
          if (currentPE) {
            warn({
              type: 'UserModelBuilder',
              message: 'Unexpected FlingStart',
              showToUser: false,
            });
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(
                ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.FLING);
            currentPE.pushEvent(event);
            // Set end to an invalid value so that it can be noticed and fixed
            // later.
            currentPE.end = 0;
            protoExpectations.push(currentPE);
          }
          break;

        case INPUT_TYPE.FLING_CANCEL:
          if (currentPE) {
            currentPE.pushEvent(event);
            // FlingCancel events start when TouchStart events start, which is
            // typically when a Response starts. FlingCancel events end when
            // chrome acknowledges them, not when they update the screen. So
            // there might be one more frame during the FlingCancel, after
            // this Animation ends. That won't affect the scoring algorithms,
            // and it will make the UEs look more correct if they don't
            // overlap unnecessarily.
            currentPE.end = event.start;
            currentPE = undefined;
          } else {
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          break;
      }
    });
    // If there was neither a FLING_CANCEL nor a renderer fling after the
    // FLING_START, then assume that it ends at the end of the model, so set
    // the end of currentPE to the end of the model.
    if (currentPE && !currentPE.end) {
      currentPE.end = modelHelper.model.bounds.max;
    }
    return protoExpectations;
  }

  /**
   * The TouchStart and the first TouchMove comprise a Response, then the
   * rest of the TouchMoves comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * SSS MMM MMM MMM MMM MMM EEE
   *
   * If there are no TouchMove events in between a TouchStart and a TouchEnd,
   * then it's just a Response.
   *
   * RRRRRRR
   * SSS EEE
   */
  function handleTouchEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    let sawFirstMove = false;
    forEventTypesIn(sortedInputEvents, TOUCH_TYPE_NAMES, function(event) {
      switch (event.typeName) {
        case INPUT_TYPE.TOUCH_START:
          if (currentPE) {
            // NB: currentPE will probably be merged with something from
            // handlePinchEvents(). Multiple TouchStart events without an
            // intervening TouchEnd logically implies that multiple fingers
            // are on the screen, so this is probably a pinch gesture.
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(
                ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.TOUCH);
            currentPE.pushEvent(event);
            currentPE.isAnimationBegin = true;
            protoExpectations.push(currentPE);
            sawFirstMove = false;
          }
          break;

        case INPUT_TYPE.TOUCH_MOVE:
          if (!currentPE) {
            currentPE = new ProtoExpectation(
                ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.TOUCH);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
            break;
          }

          // Like Scrolls and Pinches, the Response is defined to be the
          // TouchStart plus the first TouchMove, then the rest of the
          // TouchMoves constitute an Animation.
          if ((sawFirstMove &&
              (currentPE.type === ProtoExpectation.RESPONSE_TYPE)) ||
              !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            // If there's already a touchmove in the currentPE or it's not
            // near event, then finish it and start a new animation.
            const prevEnd = currentPE.end;
            currentPE = new ProtoExpectation(
                ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.TOUCH);
            currentPE.pushEvent(event);
            // It's possible for there to be a gap between TouchMoves, but
            // that doesn't mean that there should be an Idle UE there.
            currentPE.start = prevEnd;
            protoExpectations.push(currentPE);
          } else {
            currentPE.pushEvent(event);
            sawFirstMove = true;
          }
          break;

        case INPUT_TYPE.TOUCH_END:
          if (!currentPE) {
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }
          if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
          } else {
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * The first ScrollBegin and the first ScrollUpdate comprise a Response,
   * then the rest comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * BBB UUU UUU UUU UUU UUU EEE
   */
  function handleScrollEvents(modelHelper, sortedInputEvents, warn) {
    const protoExpectations = [];
    let currentPE = undefined;
    let sawFirstUpdate = false;
    forEventTypesIn(sortedInputEvents, SCROLL_TYPE_NAMES, function(event) {
      switch (event.typeName) {
        case INPUT_TYPE.SCROLL_BEGIN:
          // Always begin a new PE even if there already is one, unlike
          // PinchBegin.
          currentPE = new ProtoExpectation(
              ProtoExpectation.RESPONSE_TYPE, INITIATOR_TYPE.SCROLL);
          currentPE.pushEvent(event);
          currentPE.isAnimationBegin = true;
          protoExpectations.push(currentPE);
          sawFirstUpdate = false;
          break;

        case INPUT_TYPE.SCROLL_UPDATE:
          if (currentPE) {
            if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS) &&
                ((currentPE.type === ProtoExpectation.ANIMATION_TYPE) ||
                !sawFirstUpdate)) {
              currentPE.pushEvent(event);
              sawFirstUpdate = true;
            } else {
              currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE,
                  INITIATOR_TYPE.SCROLL);
              currentPE.pushEvent(event);
              protoExpectations.push(currentPE);
            }
          } else {
             // ScrollUpdate without ScrollBegin.
            currentPE = new ProtoExpectation(
                ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.SCROLL);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          break;

        case INPUT_TYPE.SCROLL_END:
          if (!currentPE) {
            warn({
              type: 'UserModelBuilder',
              message: 'Unexpected ScrollEnd',
              showToUser: false,
            });
            const pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }
          currentPE.pushEvent(event);
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * Returns proto expectations for video animation events.
   *
   * Video animations represent video playback, and are based on
   * VideoPlayback async events (going from the VideoFrameCompositor::Start
   * to VideoFrameCompositor::Stop calls)
   */
  function handleVideoAnimations(modelHelper, sortedInputEvents, warn) {
    const events = [];
    for (const pid in modelHelper.rendererHelpers) {
      for (const tid in modelHelper.rendererHelpers[pid].process.threads) {
        for (const asyncSlice of
            modelHelper.rendererHelpers[pid].process.threads[tid]
                .asyncSliceGroup.slices) {
          if (asyncSlice.title === PLAYBACK_EVENT_TITLE) {
            events.push(asyncSlice);
          }
        }
      }
    }

    events.sort(tr.importer.compareEvents);

    const protoExpectations = [];
    for (const event of events) {
      const currentPE = new ProtoExpectation(
          ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.VIDEO);
      currentPE.start = event.start;
      currentPE.end = event.end;
      currentPE.pushEvent(event);
      protoExpectations.push(currentPE);
    }

    return protoExpectations;
  }

  /**
   * CSS Animations are merged into AnimationExpectations when they intersect.
   */
  function handleCSSAnimations(modelHelper, sortedInputEvents, warn) {
    // First find all the top-level CSS Animation async events.
    const animationEvents = modelHelper.browserHelper.
        getAllAsyncSlicesMatching(function(event) {
          return ((event.title === CSS_ANIMATION_TITLE) &&
                  event.isTopLevel &&
                  (event.duration > 0));
        });


    // Time ranges where animations are actually running will be collected here.
    // Each element will contain {min, max, animation}.
    const animationRanges = [];

    // This helper function will be called when a time range is found
    // during which the animation is actually running.
    function pushAnimationRange(start, end, animation) {
      const range = tr.b.math.Range.fromExplicitRange(start, end);
      range.animation = animation;
      animationRanges.push(range);
    }

    animationEvents.forEach(function(animation) {
      if (animation.subSlices.length === 0) {
        pushAnimationRange(animation.start, animation.end, animation);
      } else {
        // Now run a state machine over the animation's subSlices, which
        // indicate the animations running/paused/finished states, in order to
        // find ranges where the animation was actually running.
        let start = undefined;
        animation.subSlices.forEach(function(sub) {
          if ((sub.args.data.state === 'running') &&
              (start === undefined)) {
            // It's possible for the state to alternate between running and
            // pending, but the animation is still running in that case,
            // so only set start if the state is changing from one of the halted
            // states.
            start = sub.start;
          } else if ((sub.args.data.state === 'paused') ||
                     (sub.args.data.state === 'idle') ||
                     (sub.args.data.state === 'finished')) {
            if (start === undefined) {
              // An animation was already running when the trace started.
              // (Actually, it's possible that the animation was in the 'idle'
              // state when tracing started, but that should be rare, and will
              // be fixed when async events are buffered.)
              // http: //crbug.com/565627
              start = modelHelper.model.bounds.min;
            }

            pushAnimationRange(start, sub.start, animation);
            start = undefined;
          }
        });

        // An animation was still running when the
        // top-level animation event ended.
        if (start !== undefined) {
          pushAnimationRange(start, animation.end, animation);
        }
      }
    });

    // Now we have a set of time ranges when css animations were actually
    // running.
    // Leave merging intersecting animations to mergeIntersectingAnimations(),
    // after findFrameEventsForAnimations removes frame-less animations.

    return animationRanges.map(function(range) {
      const protoExpectation = new ProtoExpectation(
          ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.CSS);
      protoExpectation.start = range.min;
      protoExpectation.end = range.max;
      protoExpectation.associatedEvents.push(range.animation);
      return protoExpectation;
    });
  }

  /**
   * Get all the events (prepareMailbox and serviceScriptedAnimations)
   * relevant to WebGL. Note that modelHelper is the helper object containing
   * the model, and mailboxEvents and animationEvents are arrays where the
   * events are being pushed into (DrawingBuffer::prepareMailbox events go
   * into mailboxEvents; PageAnimator::serviceScriptedAnimations events go
   * into animationEvents). The function does not return anything but
   * modifies mailboxEvents and animationEvents.
   */
  function findWebGLEvents(modelHelper, mailboxEvents, animationEvents) {
    for (const event of modelHelper.model.getDescendantEvents()) {
      if (event.title === 'DrawingBuffer::prepareMailbox') {
        mailboxEvents.push(event);
      } else if (event.title === 'PageAnimator::serviceScriptedAnimations') {
        animationEvents.push(event);
      }
    }
  }

  /**
   * Returns a list of events in mailboxEvents that have an event in
   * animationEvents close by (within ANIMATION_MERGE_THRESHOLD_MS).
   */
  function findMailboxEventsNearAnimationEvents(
      mailboxEvents, animationEvents) {
    if (animationEvents.length === 0) return [];

    mailboxEvents.sort(compareEvents);
    animationEvents.sort(compareEvents);
    const animationIterator = animationEvents[Symbol.iterator]();
    let animationEvent = animationIterator.next().value;

    const filteredEvents = [];

    // We iterate through the mailboxEvents. With each event, we check if
    // there is a animationEvent near it, and if so, add it to the result.
    for (const event of mailboxEvents) {
      // If the current animationEvent is too far before the mailboxEvent,
      // we advance until we get to the next animationEvent that is not too
      // far before the animationEvent.
      while (animationEvent &&
          (animationEvent.start < (
           event.start - ANIMATION_MERGE_THRESHOLD_MS))) {
        animationEvent = animationIterator.next().value;
      }

      // If there aren't any more animationEvents, then that means all the
      // remaining mailboxEvents are too far after the animationEvents, so
      // we can quit now.
      if (!animationEvent) break;

      // If there's a animationEvent close to the mailboxEvent, then we push
      // the current mailboxEvent onto the stack.
      if (animationEvent.start < (event.start + ANIMATION_MERGE_THRESHOLD_MS)) {
        filteredEvents.push(event);
      }
    }
    return filteredEvents;
  }

  /**
   * Merge consecutive mailbox events into a ProtoExpectation. Note: Only
   * the drawingBuffer::prepareMailbox events will end up in the
   * associatedEvents. The PageAnimator::serviceScriptedAnimations events
   * will not end up in the associatedEvents.
   */
  function createProtoExpectationsFromMailboxEvents(mailboxEvents) {
    const protoExpectations = [];
    let currentPE = undefined;
    for (const event of mailboxEvents) {
      if (currentPE === undefined || !currentPE.isNear(
          event, ANIMATION_MERGE_THRESHOLD_MS)) {
        currentPE = new ProtoExpectation(
            ProtoExpectation.ANIMATION_TYPE, INITIATOR_TYPE.WEBGL);
        currentPE.pushEvent(event);
        protoExpectations.push(currentPE);
      } else {
        currentPE.pushEvent(event);
      }
    }
    return protoExpectations;
  }

  // WebGL animations are identified by the DrawingBuffer::prepareMailbox
  // and PageAnimator::serviceScriptedAnimations events (one of each per frame)
  // and consecutive frames are merged into the same animation.
  function handleWebGLAnimations(modelHelper, sortedInputEvents, warn) {
    // Get the prepareMailbox and scriptedAnimation events.
    const prepareMailboxEvents = [];
    const scriptedAnimationEvents = [];

    findWebGLEvents(modelHelper, prepareMailboxEvents, scriptedAnimationEvents);
    const webGLMailboxEvents = findMailboxEventsNearAnimationEvents(
        prepareMailboxEvents, scriptedAnimationEvents);

    return createProtoExpectationsFromMailboxEvents(webGLMailboxEvents);
  }


  function postProcessProtoExpectations(modelHelper, protoExpectations) {
    // protoExpectations is input only. Returns a modified set of
    // ProtoExpectations.  The order is important.
    protoExpectations = findFrameEventsForAnimations(
        modelHelper, protoExpectations);
    protoExpectations = mergeIntersectingResponses(protoExpectations);
    protoExpectations = mergeIntersectingAnimations(protoExpectations);
    protoExpectations = fixResponseAnimationStarts(protoExpectations);
    protoExpectations = fixTapResponseTouchAnimations(protoExpectations);
    return protoExpectations;
  }

  /**
   * TouchStarts happen at the same time as ScrollBegins.
   * It's easier to let multiple handlers create multiple overlapping
   * Responses and then merge them, rather than make the handlers aware of the
   * other handlers' PEs.
   *
   * For example:
   * RR
   *  RRR  -> RRRRR
   *    RR
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function mergeIntersectingResponses(protoExpectations) {
    const newPEs = [];
    while (protoExpectations.length) {
      const pe = protoExpectations.shift();
      newPEs.push(pe);

      // Only consider Responses for now.
      if (pe.type !== ProtoExpectation.RESPONSE_TYPE) continue;

      for (let i = 0; i < protoExpectations.length; ++i) {
        const otherPE = protoExpectations[i];

        if (otherPE.type !== pe.type) continue;

        if (!otherPE.intersects(pe)) continue;

        // Don't merge together Responses of the same type.
        // If handleTouchEvents wanted two of its Responses to be merged, then
        // it would have made them that way to begin with.
        const typeNames = pe.associatedEvents.map(function(event) {
          return event.typeName;
        });
        if (otherPE.containsTypeNames(typeNames)) continue;

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);

        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  /**
   * An animation is simply an expectation of 60fps between start and end.
   * If two animations overlap, then merge them.
   *
   * For example:
   * AA
   *  AAA  -> AAAAA
   *    AA
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function mergeIntersectingAnimations(protoExpectations) {
    const newPEs = [];
    while (protoExpectations.length) {
      const pe = protoExpectations.shift();
      newPEs.push(pe);

      // Only consider Animations for now.
      if (pe.type !== ProtoExpectation.ANIMATION_TYPE) continue;

      const isCSS = pe.initiatorType === INITIATOR_TYPE.CSS;
      const isFling = pe.containsTypeNames([INPUT_TYPE.FLING_START]);
      const isVideo = pe.initiatorType === INITIATOR_TYPE.VIDEO;

      for (let i = 0; i < protoExpectations.length; ++i) {
        const otherPE = protoExpectations[i];

        if (otherPE.type !== pe.type) continue;

        // Don't merge some animation types with others.
        if ((isCSS && otherPE.initiatorType !== INITIATOR_TYPE.CSS) ||
            isFling !== otherPE.containsTypeNames([INPUT_TYPE.FLING_START]) ||
            isVideo && otherPE.initiatorType !== INITIATOR_TYPE.VIDEO) {
          continue;
        }

        if (isCSS) {
          if (!pe.isNear(otherPE, ANIMATION_MERGE_THRESHOLD_MS)) {
            continue;
          }
        } else if (!otherPE.intersects(pe)) {
          continue;
        }

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);
        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  /**
   * The ends of responses frequently overlap the starts of animations.
   * Fix the animations to reflect the fact that the user can only start to
   * expect 60fps after the response.
   *
   * For example:
   * RRR   -> RRRAA
   *  AAAA
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function fixResponseAnimationStarts(protoExpectations) {
    protoExpectations.forEach(function(ape) {
      // Only consider animations for now.
      if (ape.type !== ProtoExpectation.ANIMATION_TYPE) {
        return;
      }

      protoExpectations.forEach(function(rpe) {
        // Only consider responses for now.
        if (rpe.type !== ProtoExpectation.RESPONSE_TYPE) {
          return;
        }

        // Only consider responses that end during the animation.
        if (!ape.containsTimestampInclusive(rpe.end)) {
          return;
        }

        // Ignore Responses that are entirely contained by the animation.
        if (ape.containsTimestampInclusive(rpe.start)) {
          return;
        }

        // Move the animation start to the response end.
        ape.start = rpe.end;
      });
    });
    return protoExpectations;
  }

  /**
   * Merge Tap Responses that overlap Touch-only Animations.
   * https: *github.com/catapult-project/catapult/issues/1431
   */
  function fixTapResponseTouchAnimations(protoExpectations) {
    function isTapResponse(pe) {
      return (pe.type === ProtoExpectation.RESPONSE_TYPE) &&
              pe.containsTypeNames([INPUT_TYPE.TAP]);
    }
    function isTouchAnimation(pe) {
      return (pe.type === ProtoExpectation.ANIMATION_TYPE) &&
              pe.containsTypeNames([INPUT_TYPE.TOUCH_MOVE]) &&
              !pe.containsTypeNames([
                INPUT_TYPE.SCROLL_UPDATE, INPUT_TYPE.PINCH_UPDATE]);
    }
    const newPEs = [];
    while (protoExpectations.length) {
      const pe = protoExpectations.shift();
      newPEs.push(pe);

      // protoExpectations are sorted by start time, and we don't know whether
      // the Tap Response or the Touch Animation will be first
      const peIsTapResponse = isTapResponse(pe);
      const peIsTouchAnimation = isTouchAnimation(pe);
      if (!peIsTapResponse && !peIsTouchAnimation) {
        continue;
      }

      for (let i = 0; i < protoExpectations.length; ++i) {
        const otherPE = protoExpectations[i];

        if (!otherPE.intersects(pe)) continue;

        if (peIsTapResponse && !isTouchAnimation(otherPE)) continue;

        if (peIsTouchAnimation && !isTapResponse(otherPE)) continue;

        // pe might be the Touch Animation, but the merged ProtoExpectation
        // should be a Response.
        pe.type = ProtoExpectation.RESPONSE_TYPE;

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);
        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  function findFrameEventsForAnimations(modelHelper, protoExpectations) {
    const newPEs = [];
    const frameEventsByPid = getSortedFrameEventsByProcess(modelHelper);

    for (const pe of protoExpectations) {
      if (pe.type !== ProtoExpectation.ANIMATION_TYPE) {
        newPEs.push(pe);
        continue;
      }

      const frameEvents = [];
      for (const pid of Object.keys(modelHelper.rendererHelpers)) {
        const range = tr.b.math.Range.fromExplicitRange(pe.start, pe.end);
        frameEvents.push.apply(frameEvents,
            range.filterArray(frameEventsByPid[pid], e => e.start));
      }

      // If a tree falls in a forest...
      // If there were not actually any frames while the animation was
      // running, then it wasn't really an animation, now, was it?
      // Philosophy aside, the system_health Animation metrics fail hard if
      // there are no frames in an AnimationExpectation.
      // Since WebGL animations don't generate this type of frame event,
      // don't remove them if it's a WebGL animation.
      if (frameEvents.length === 0 &&
              !(pe.initiatorType === INITIATOR_TYPE.WEBGL)) {
        pe.type = ProtoExpectation.IGNORED_TYPE;
        newPEs.push(pe);
        continue;
      }

      pe.associatedEvents.addEventSet(frameEvents);
      newPEs.push(pe);
    }

    return newPEs;
  }

  /**
   * Check that none of the handlers accidentally ignored an input event.
   */
  function checkAllInputEventsHandled(
      modelHelper, sortedInputEvents, protoExpectations, warn) {
    const handledEvents = [];
    protoExpectations.forEach(function(protoExpectation) {
      protoExpectation.associatedEvents.forEach(function(event) {
        // Ignore CSS Animations that might have multiple active ranges.
        if ((event.title === CSS_ANIMATION_TITLE) &&
            (event.subSlices.length > 0)) {
          return;
        }

        if ((handledEvents.indexOf(event) >= 0) &&
            (event.title !== tr.model.helpers.IMPL_RENDERING_STATS)) {
          warn({
            type: 'UserModelBuilder',
            message: `double-handled event: ${event.typeName} @ ${event.start}`,
            showToUser: false,
          });
          return;
        }
        handledEvents.push(event);
      });
    });

    sortedInputEvents.forEach(function(event) {
      if (handledEvents.indexOf(event) < 0) {
        warn({
          type: 'UserModelBuilder',
          message: `double-handled event: ${event.typeName} @ ${event.start}`,
          showToUser: false,
        });
      }
    });
  }

  /**
   * Find ProtoExpectations, post-process them, convert them to real UEs.
   */
  function findInputExpectations(modelHelper) {
    // Prevent helper functions from producing too many import warnings.
    let warning;
    function warn(w) {
      // Keep only the first warning.
      if (warning) return;
      warning = w;
    }

    const sortedInputEvents = getSortedInputEvents(modelHelper);
    let protoExpectations = findProtoExpectations(
        modelHelper, sortedInputEvents, warn);
    protoExpectations = postProcessProtoExpectations(
        modelHelper, protoExpectations);
    checkAllInputEventsHandled(
        modelHelper, sortedInputEvents, protoExpectations, warn);

    if (warning) modelHelper.model.importWarning(warning);

    const expectations = [];
    protoExpectations.forEach(function(protoExpectation) {
      const ir = protoExpectation.createInteractionRecord(modelHelper.model);
      if (ir) {
        expectations.push(ir);
      }
    });
    return expectations;
  }

  return {
    findInputExpectations,
    compareEvents,
    CSS_ANIMATION_TITLE,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  // If the power series doesn't cover the entire Chrome trace, then
  // the results from Chrome tracing metrics will likely be inaccurate,
  // so we don't report them. However, we allow the power series bounds
  // to be up to 1 ms inside the Chrome trace and still count as
  // covering the Chrome trace. This is to allow for small deviations
  // due to clock sync latency and the finite sampling rate of the
  // BattOr.
  const CHROME_POWER_GRACE_PERIOD_MS = 1;

  /**
   * Creates an empty histogram to hold data for a given time interval.
   *
   * @returns {Object} An object of the form:
   *
   *   {
   *     perSecond {boolean}: Whether the data for this time interval is given
   *       as per second, If not, it's given as an integral over the
   *       whole interval.
   *     energy {tr.v.Histogram}: Histogram giving energy use (i.e. energy in J
   *       if perSecond = False, power in W if perSecond = True)
   *   }
   */
  function createEmptyHistogram_(interval, histograms) {
    if (interval.perSecond) {
      return {
        perSecond: true,
        energy: histograms.createHistogram(`${interval.name}:power`,
            tr.b.Unit.byName.powerInWatts_smallerIsBetter, [], {
              description:
                `Energy consumption rate for ${interval.description}`,
              summaryOptions: {
                avg: true,
                count: false,
                max: true,
                min: true,
                std: false,
                sum: false,
              },
            }),
      };
    }
    return {
      perSecond: false,
      energy: histograms.createHistogram(`${interval.name}:energy`,
          tr.b.Unit.byName.energyInJoules_smallerIsBetter, [], {
            description: `Energy consumed in ${interval.description}`,
            summaryOptions: {
              avg: false,
              count: false,
              max: true,
              min: true,
              std: false,
              sum: true,
            },
          }),
    };
  }

  function createHistograms_(data, interval, histograms) {
    if (data.histograms[interval.name] === undefined) {
      data.histograms[interval.name] = createEmptyHistogram_(interval,
          histograms);
    }
    if (data.histograms[interval.name].perSecond) {
      for (const sample of data.model.device.powerSeries.getSamplesWithinRange(
          interval.bounds.min, interval.bounds.max)) {
        data.histograms[interval.name].energy.addSample(sample.powerInW);
      }
    } else {
      const energyInJ = data.model.device.powerSeries.getEnergyConsumedInJ(
          interval.bounds.min, interval.bounds.max);
      data.histograms[interval.name].energy.addSample(energyInJ);
    }
  }

  /**
   * Returns the intervals of time between navigation event and time to
   * interactive.
   */
  function getNavigationTTIIntervals_(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const intervals = [];
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      const samples = tr.metrics.sh.collectLoadingMetricsForRenderer(
          rendererHelper).firstInteractiveSamples;
      for (const sample of samples) {
        const info = tr.b.getOnlyElement(
            sample.diagnostics['Navigation infos']);
        intervals.push(tr.b.math.Range.fromExplicitRange(
            info.start, info.interactive));
      }
    }
    return intervals.sort((x, y) => x.min - y.min);
  }

  /**
   * Generates the set of time intervals that metrics should be run over.
   * Time intervals include each UE (for UE-based metrics), the whole
   * story (for the full-story metric), etc. Each time interval is given
   * in the following form:
   *
   *   {
   *     bounds {tr.b.math.Range}: Boundaries of the time interval.
   *     name {string}: Name of this interval. Used to generate the
   *       metric names.
   *     description {string}: Human readable description of the interval.
   *       Used to generate the metric descriptions.
   *     perSecond {boolean}: Whether metrics over this interval should be
   *       reported as per-second values (e.g. power). If not, integrated values
   *       over the whole interval (e.g. energy) are reported.
   *   }
   *
   */
  function* computeTimeIntervals_(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    const powerSeries = model.device.powerSeries;
    if (powerSeries === undefined ||
        powerSeries.samples.length === 0) {
      return;
    }
    // Output the full story power metrics, which exists regardless of
    // the presence of a Chrome trace.
    yield {
      bounds: model.bounds,
      name: 'story',
      description: 'user story',
      perSecond: true
    };

    const chromeBounds = computeChromeBounds_(model);
    if (chromeBounds.isEmpty) return;

    const powerSeriesBoundsWithGracePeriod = tr.b.math.Range.fromExplicitRange(
        powerSeries.bounds.min - CHROME_POWER_GRACE_PERIOD_MS,
        powerSeries.bounds.max + CHROME_POWER_GRACE_PERIOD_MS);
    if (!powerSeriesBoundsWithGracePeriod.containsRangeExclusive(
        chromeBounds)) {
      return;
    }

    // If Chrome bounds are good and the power trace covers the Chrome bounds,
    // then output the Chrome specific metrics (loading and RAIL stages). Note
    // that only the part of the time interval that overlaps the Chrome bounds
    // should be included.
    for (const interval of getRailStageIntervals_(model)) {
      yield {
        bounds: interval.bounds.findIntersection(chromeBounds),
        name: interval.name,
        description: interval.description,
        perSecond: interval.perSecond
      };
    }

    for (const interval of getLoadingIntervals_(model, chromeBounds)) {
      yield {
        bounds: interval.bounds.findIntersection(chromeBounds),
        name: interval.name,
        description: interval.description,
        perSecond: interval.perSecond
      };
    }
  }

  /**
   * Gets a list of time intervals for the RAIL stages. Each RAIL stage
   * generates a time interval with the name equal to the name of the RAIL
   * stage except made into lower case and with spaces replaced bu underscores
   * e.g. "Scroll Animation" --> "scroll_animation". Each time interval is given
   * in the following form:
   *
   *   {
   *     bounds {tr.b.math.Range}: Boundaries of the time interval.
   *     name {string}: Name of this interval. Used to generate the
   *       metric names.
   *     description {string}: Human readable description of the interval.
   *       Used to generate the metric descriptions.
   *     perSecond {boolean}: Whether metrics over this interval should be
   *       reported as per-second values (e.g. power). If not, integrated values
   *       over the whole interval (e.g. energy) are reported.
   *   }
   *
   */
  function* getRailStageIntervals_(model) {
    for (const exp of model.userModel.expectations) {
      const histogramName = exp.title.toLowerCase().replace(' ', '_');
      const energyHist = undefined;
      if (histogramName.includes('response')) {
        yield {
          bounds: tr.b.math.Range.fromExplicitRange(exp.start, exp.end),
          name: histogramName,
          description: 'RAIL stage ' + histogramName,
          perSecond: false
        };
      } else if (histogramName.includes('animation') ||
          histogramName.includes('idle')) {
        yield {
          bounds: tr.b.math.Range.fromExplicitRange(exp.start, exp.end),
          name: histogramName,
          description: 'RAIL stage ' + histogramName,
          perSecond: true
        };
      }
    }
  }

  /**
   * Gets a list of time intervals for the RAIL stages. Each RAIL stage
   * generates a time interval with the name equal to the name of the RAIL
   * stage except made into lower case and with spaces replaced bu underscores
   * e.g. "Scroll Animation" --> "scroll_animation". Each time interval is given
   * in the following form:
   *
   *   {
   *     bounds {tr.b.math.Range}: Boundaries of the time interval.
   *     name {string}: Name of this interval. Used to generate the
   *       metric names.
   *     description {string}: Human readable description of the interval.
   *       Used to generate the metric descriptions.
   *     perSecond {boolean}: Whether metrics over this interval should be
   *       reported as per-second values (e.g. power). If not, integrated values
   *       over the whole interval (e.g. energy) are reported.
   *   }
   *
   */
  function* getLoadingIntervals_(model, chromeBounds) {
    const ttiIntervals = getNavigationTTIIntervals_(model);
    let lastLoadTime = undefined;
    for (const ttiInterval of ttiIntervals) {
      yield {
        bounds: ttiInterval,
        name: 'load',
        description: 'page loads',
        perSecond: false
      };
      lastLoadTime = lastLoadTime === undefined ? ttiInterval.max :
          Math.max(lastLoadTime, ttiInterval.max);
    }
    if (lastLoadTime !== undefined) {
      yield {
        bounds: tr.b.math.Range.fromExplicitRange(
            lastLoadTime, chromeBounds.max),
        name: 'after_load',
        description: 'period after load',
        perSecond: true
      };
    }
  }

  /**
   * @returns {tr.b.math.Range} The boundaries of the Chrome portion of the
   * trace.
   */
  function computeChromeBounds_(model) {
    const chromeBounds = new tr.b.math.Range();
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (chromeHelper === undefined) return chromeBounds;
    for (const helper of chromeHelper.browserHelpers) {
      if (helper.mainThread) {
        chromeBounds.addRange(helper.mainThread.bounds);
      }
    }
    for (const pid in chromeHelper.rendererHelpers) {
      if (chromeHelper.rendererHelpers[pid].mainThread) {
        chromeBounds.addRange(
            chromeHelper.rendererHelpers[pid].mainThread.bounds);
      }
    }
    return chromeBounds;
  }

  /**
   * Adds the power histograms to the histogram set.
   *
   * Each power histogram is based on a specific time interval, and is named as
   * follows:
   *
   * - [time_interval_name]:power, which contains a sample for each power
   *    sample data point during any time interval with the given type. Each
   *    sample represents the power draw during the period covered by that
   *    power sample.
   *
   * - [time_interval_name]:energy, which contains a sample for each time
   *    interval with the given type present in the trace. Each sample
   *    represents the total energy used over that time interval.
   *
   * The time intervals are as follows:
   *
   * - "story": The time interval covering the entire user story. There is
   *    always exactly one "story" interval.
   *
   * - "load" : The time interval covered by a page load, from navigationStart
   *    to timeToInteractive. There is one "load" interval for each page load
   *    in the trace.
   *
   * - "after_load": The time interval from the timeToInteractive of the last
   *    load event to the end of the trace.
   *
   * - "[user_expectation_type]" : Each Response, Animation, or Idle
   *    UE in the trace generates a time interval whose name is that of the UE,
   *    converted to lower case and with underscores in place of spaces.
   *    For instance, if there are three "Scroll Response" UEs in the trace,
   *    then there will be three "scroll_response" time intervals, so the
   *    histogram scroll_response:energy will contain three samples.
   *
   * Note that each time interval type only generates ONE of the "power" or
   * "energy" histograms. Power histograms are generated for time intervals
   * that represent events that occur over a period of time. This includes
   * the following intervals
   *
   * - "story"
   * - "after_load"
   * - Any Animation or Idle UE
   *
   * For instance, "the energy it takes to play a video"
   * does not have meaning because it depends on how long the video
   * is; thus a more meaningful metric is power. In contrast, energy histograms
   * are generated for time intervals that represent particular tasks
   * which must be completed. This includes the following intervals:
   *
   * - "load"
   * - Any Response UE
   *
   * For instance, if a change causes a response to take longer to process, then
   * we want to count that as taking the energy over a longer period of time.
   */
  function powerMetric(histograms, model) {
    const data = {
      model,
      histograms: {}
    };
    for (const interval of computeTimeIntervals_(model)) {
      createHistograms_(data, interval, histograms);
    }
  }

  tr.metrics.MetricRegistry.register(powerMetric);

  return {
    powerMetric
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  const LOAD_SUBTYPE_NAMES = {
    SUCCESSFUL: 'Successful',
    FAILED: 'Failed',
  };

  const DOES_LOAD_SUBTYPE_NAME_EXIST = {};
  for (const key in LOAD_SUBTYPE_NAMES) {
    DOES_LOAD_SUBTYPE_NAME_EXIST[LOAD_SUBTYPE_NAMES[key]] = true;
  }

  function LoadExpectation(parentModel, initiatorTitle, start, duration) {
    if (!DOES_LOAD_SUBTYPE_NAME_EXIST[initiatorTitle]) {
      throw new Error(initiatorTitle + ' is not in LOAD_SUBTYPE_NAMES');
    }

    tr.model.um.UserExpectation.call(
        this, parentModel, initiatorTitle, start, duration);

    // |renderProcess| is the renderer process that contains the loading
    // RenderFrame.
    this.renderProcess = undefined;

    // |renderMainThread| is the CrRendererMain thread in the |renderProcess|
    // that contains the loading RenderFrame.
    this.renderMainThread = undefined;

    // |routingId| identifies the loading RenderFrame within the renderer
    // process.
    this.routingId = undefined;

    // |parentRoutingId| identifies the RenderFrame that created and contains
    // the loading RenderFrame.
    this.parentRoutingId = undefined;

    // |loadFinishedEvent|, if present, signals that this is a main frame.
    this.loadFinishedEvent = undefined;

    // Startup LoadExpectations do not have renderProcess, routingId, or
    // parentRoutingId. Maybe RenderLoadExpectation should be a separate class?
  }

  LoadExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: LoadExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(LoadExpectation, {
    stageTitle: 'Load',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_load')
  });

  return {
    LOAD_SUBTYPE_NAMES,
    LoadExpectation,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  // In the case of Response, Load, and DiscreteAnimation UEs, Responsiveness is
  // derived from the time between when the user thinks they begin an interation
  // (expectedStart) and the time when the screen first changes to reflect the
  // interaction (actualEnd).  There may be a delay between expectedStart and
  // when chrome first starts processing the interaction (actualStart) if the
  // main thread is busy.  The user doesn't know when actualStart is, they only
  // know when expectedStart is. User responsiveness, by definition, considers
  // only what the user experiences, so "duration" is defined as actualEnd -
  // expectedStart.

  function computeAnimationThroughput(animationExpectation) {
    if (animationExpectation.frameEvents === undefined ||
        animationExpectation.frameEvents.length === 0) {
      throw new Error('Animation missing frameEvents ' +
                      animationExpectation.stableId);
    }

    const durationInS = tr.b.convertUnit(animationExpectation.duration,
        tr.b.UnitPrefixScale.METRIC.MILLI,
        tr.b.UnitPrefixScale.METRIC.NONE);
    return animationExpectation.frameEvents.length / durationInS;
  }

  function computeAnimationframeTimeDiscrepancy(animationExpectation) {
    if (animationExpectation.frameEvents === undefined ||
        animationExpectation.frameEvents.length === 0) {
      throw new Error('Animation missing frameEvents ' +
                      animationExpectation.stableId);
    }

    let frameTimestamps = animationExpectation.frameEvents;
    frameTimestamps = frameTimestamps.toArray().map(function(event) {
      return event.start;
    });

    const absolute = true;
    return tr.b.math.Statistics.timestampsDiscrepancy(
        frameTimestamps, absolute);
  }

  /**
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function responsivenessMetric(histograms, model, opt_options) {
    const responseNumeric = new tr.v.Histogram('response latency',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        tr.v.HistogramBinBoundaries.createLinear(100, 1e3, 50));
    const throughputNumeric = new tr.v.Histogram('animation throughput',
        tr.b.Unit.byName.unitlessNumber_biggerIsBetter,
        tr.v.HistogramBinBoundaries.createLinear(10, 60, 10));
    const frameTimeDiscrepancyNumeric = new tr.v.Histogram(
        'animation frameTimeDiscrepancy',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        tr.v.HistogramBinBoundaries.createLinear(0, 1e3, 50).
          addExponentialBins(1e4, 10));
    const latencyNumeric = new tr.v.Histogram('animation latency',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        tr.v.HistogramBinBoundaries.createLinear(0, 300, 60));

    model.userModel.expectations.forEach(function(ue) {
      if (opt_options && opt_options.rangeOfInterest &&
          !opt_options.rangeOfInterest.intersectsExplicitRangeInclusive(
              ue.start, ue.end)) {
        return;
      }

      const sampleDiagnosticMap = tr.v.d.DiagnosticMap.fromObject(
          {relatedEvents: new tr.v.d.RelatedEventSet([ue])});

      // Responsiveness is not defined for Idle or Startup expectations.
      if (ue instanceof tr.model.um.IdleExpectation) {
        return;
      } else if (ue instanceof tr.model.um.StartupExpectation) {
        return;
      } else if (ue instanceof tr.model.um.LoadExpectation) {
        // This is already covered by loadingMetric.
      } else if (ue instanceof tr.model.um.ResponseExpectation) {
        responseNumeric.addSample(ue.duration, sampleDiagnosticMap);
      } else if (ue instanceof tr.model.um.AnimationExpectation) {
        if (ue.frameEvents === undefined || ue.frameEvents.length === 0) {
          // Ignore animation stages that do not have associated frames:
          // https://github.com/catapult-project/catapult/issues/2446
          return;
        }
        const throughput = computeAnimationThroughput(ue);
        if (throughput === undefined) {
          throw new Error('Missing throughput for ' +
                          ue.stableId);
        }

        throughputNumeric.addSample(throughput, sampleDiagnosticMap);

        const frameTimeDiscrepancy = computeAnimationframeTimeDiscrepancy(ue);
        if (frameTimeDiscrepancy === undefined) {
          throw new Error('Missing frameTimeDiscrepancy for ' +
                          ue.stableId);
        }

        frameTimeDiscrepancyNumeric.addSample(
            frameTimeDiscrepancy, sampleDiagnosticMap);

        ue.associatedEvents.forEach(function(event) {
          if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice)) {
            return;
          }

          latencyNumeric.addSample(event.duration, sampleDiagnosticMap);
        });
      } else {
        throw new Error('Unrecognized stage for ' + ue.stableId);
      }
    });

    [
      responseNumeric, throughputNumeric, frameTimeDiscrepancyNumeric,
      latencyNumeric
    ].forEach(function(numeric) {
      numeric.customizeSummaryOptions({
        avg: true,
        max: true,
        min: true,
        std: true
      });
    });

    histograms.addHistogram(responseNumeric);
    histograms.addHistogram(throughputNumeric);
    histograms.addHistogram(frameTimeDiscrepancyNumeric);
    histograms.addHistogram(latencyNumeric);
  }

  tr.metrics.MetricRegistry.register(responsivenessMetric, {
    supportsRangeOfInterest: true
  });

  return {
    responsivenessMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.sh', function() {
  function webviewStartupMetric(histograms, model) {
    const startupWallHist = new tr.v.Histogram('webview_startup_wall_time',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    startupWallHist.description = 'WebView startup wall time';
    const startupCPUHist = new tr.v.Histogram('webview_startup_cpu_time',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    startupCPUHist.description = 'WebView startup CPU time';
    const loadWallHist = new tr.v.Histogram('webview_url_load_wall_time',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    loadWallHist.description = 'WebView blank URL load wall time';
    const loadCPUHist = new tr.v.Histogram('webview_url_load_cpu_time',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    loadCPUHist.description = 'WebView blank URL load CPU time';

    // TODO(alexandermont): Only iterate over the processes and threads that
    // could contain these events.
    for (const slice of model.getDescendantEvents()) {
      if (!(slice instanceof tr.model.ThreadSlice)) continue;

      // WebViewStartupInterval is the title of the section of code that is
      // entered (via android.os.Trace.beginSection) when WebView is started
      // up. This value is defined in TelemetryActivity.java.
      if (slice.title === 'WebViewStartupInterval') {
        startupWallHist.addSample(slice.duration);
        startupCPUHist.addSample(slice.cpuDuration);
      }

      // WebViewBlankUrlLoadInterval is the title of the section of code
      // that is entered (via android.os.Trace.beginSection) when WebView
      // is started up. This value is defined in TelemetryActivity.java.
      if (slice.title === 'WebViewBlankUrlLoadInterval') {
        loadWallHist.addSample(slice.duration);
        loadCPUHist.addSample(slice.cpuDuration);
      }
    }

    histograms.addHistogram(startupWallHist);
    histograms.addHistogram(startupCPUHist);
    histograms.addHistogram(loadWallHist);
    histograms.addHistogram(loadCPUHist);
  }

  tr.metrics.MetricRegistry.register(webviewStartupMetric);

  return {
    webviewStartupMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  const MEMORY_INFRA_TRACING_CATEGORY = 'disabled-by-default-memory-infra';

  const TIME_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(
      1e-3, 1e5, 30);

  const BYTE_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(
      1, 1e9, 30);

  const COUNT_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(
      1, 1e5, 30);

  // By default, we store a single value, so we only need one of the
  // statistics to keep track. We choose the average for that.
  const SUMMARY_OPTIONS = tr.v.Histogram.AVERAGE_ONLY_SUMMARY_OPTIONS;

  // Adds histograms specific to memory-infra dumps.
  function addMemoryInfraHistograms(
      histograms, model, categoryNamesToTotalEventSizes) {
    const memoryDumpCount = model.globalMemoryDumps.length;
    if (memoryDumpCount === 0) return;

    let totalOverhead = 0;
    let nonMemoryInfraThreadOverhead = 0;
    const overheadByProvider = {};
    for (const process of Object.values(model.processes)) {
      for (const thread of Object.values(process.threads)) {
        for (const slice of Object.values(thread.sliceGroup.slices)) {
          if (slice.category !== MEMORY_INFRA_TRACING_CATEGORY) continue;

          totalOverhead += slice.duration;
          if (thread.name !== 'MemoryInfra') {
            nonMemoryInfraThreadOverhead += slice.duration;
          }
          if (slice.args && slice.args['dump_provider.name']) {
            const providerName = slice.args['dump_provider.name'];
            let durationAndCount = overheadByProvider[providerName];
            if (durationAndCount === undefined) {
              overheadByProvider[providerName] = durationAndCount =
                  {duration: 0, count: 0};
            }
            durationAndCount.duration += slice.duration;
            durationAndCount.count++;
          }
        }
      }
    }

    histograms.createHistogram('memory_dump_cpu_overhead',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        totalOverhead / memoryDumpCount, {
          binBoundaries: TIME_BOUNDARIES,
          description:
            'Average CPU overhead on all threads per memory-infra dump',
          summaryOptions: SUMMARY_OPTIONS,
        });

    histograms.createHistogram('nonmemory_thread_memory_dump_cpu_overhead',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        nonMemoryInfraThreadOverhead / memoryDumpCount, {
          binBoundaries: TIME_BOUNDARIES,
          description: 'Average CPU overhead on non-memory-infra threads ' +
            'per memory-infra dump',
          summaryOptions: SUMMARY_OPTIONS,
        });

    for (const [providerName, overhead] of Object.entries(overheadByProvider)) {
      histograms.createHistogram(`${providerName}_memory_dump_cpu_overhead`,
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
          overhead.duration / overhead.count, {
            binBoundaries: TIME_BOUNDARIES,
            description:
              `Average CPU overhead of ${providerName} per OnMemoryDump call`,
            summaryOptions: SUMMARY_OPTIONS,
          });
    }

    const memoryInfraEventsSize =
        categoryNamesToTotalEventSizes.get(MEMORY_INFRA_TRACING_CATEGORY);
    const memoryInfraTraceBytesValue = new tr.v.Histogram(
        'total_memory_dump_size',
        tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
    memoryInfraTraceBytesValue.description =
        'Total trace size of memory-infra dumps in bytes';
    memoryInfraTraceBytesValue.customizeSummaryOptions(SUMMARY_OPTIONS);
    memoryInfraTraceBytesValue.addSample(memoryInfraEventsSize);
    histograms.addHistogram(memoryInfraTraceBytesValue);

    const traceBytesPerDumpValue = new tr.v.Histogram(
        'memory_dump_size',
        tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
    traceBytesPerDumpValue.description =
        'Average trace size of memory-infra dumps in bytes';
    traceBytesPerDumpValue.customizeSummaryOptions(SUMMARY_OPTIONS);
    traceBytesPerDumpValue.addSample(memoryInfraEventsSize / memoryDumpCount);
    histograms.addHistogram(traceBytesPerDumpValue);
  }

  // TODO(charliea): The metrics in this file should be renamed to have names
  // more consistent with those in the rest of the codebase
  // (e.g. 'trace_size_growth_per_second', not 'Max event size in bytes per
  // second').
  // https://github.com/catapult-project/catapult/issues/3233
  function tracingMetric(histograms, model) {
    histograms.createHistogram('trace_import_duration',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        model.stats.traceImportDurationMs, {
          binBoundaries: TIME_BOUNDARIES,
          description:
            'Duration that trace viewer required to import the trace',
          summaryOptions: SUMMARY_OPTIONS,
        });

    if (!model.stats.hasEventSizesinBytes) return;

    const eventStats = model.stats.allTraceEventStatsInTimeIntervals;
    eventStats.sort((a, b) => a.timeInterval - b.timeInterval);

    const totalTraceBytes = eventStats.reduce(
        (a, b) => a + b.totalEventSizeinBytes, 0);

    // We maintain a sliding window of records [start ... end-1] where end
    // increments each time through the loop, and we move start just far enough
    // to keep the window less than 1 second wide. Note that we need to compute
    // the number of time intervals (i.e. units that timeInterval is given in)
    // in one second to know how wide the sliding window should be.
    let maxEventCountPerSec = 0;
    let maxEventBytesPerSec = 0;
    const INTERVALS_PER_SEC = Math.floor(
        1000 / model.stats.TIME_INTERVAL_SIZE_IN_MS);

    let runningEventNumPerSec = 0;
    let runningEventBytesPerSec = 0;
    let start = 0;
    let end = 0;

    while (end < eventStats.length) {
      // Slide the end marker forward. Moving the end marker from N
      // to N+1 adds eventStats[N] to the sliding window.
      runningEventNumPerSec += eventStats[end].numEvents;
      runningEventBytesPerSec += eventStats[end].totalEventSizeinBytes;
      end++;

      // Slide the start marker forward so that the time interval covered
      // by the window is less than 1 second wide.
      while ((eventStats[end - 1].timeInterval -
              eventStats[start].timeInterval) >= INTERVALS_PER_SEC) {
        runningEventNumPerSec -= eventStats[start].numEvents;
        runningEventBytesPerSec -= eventStats[start].totalEventSizeinBytes;
        start++;
      }

      // Update maximum values.
      maxEventCountPerSec = Math.max(maxEventCountPerSec,
          runningEventNumPerSec);
      maxEventBytesPerSec = Math.max(maxEventBytesPerSec,
          runningEventBytesPerSec);
    }

    const stats = model.stats.allTraceEventStats;
    const categoryNamesToTotalEventSizes = (
        stats.reduce((map, stat) => (
            map.set(stat.category,
                   ((map.get(stat.category) || 0) +
                    stat.totalEventSizeinBytes))), new Map()));

    // Determine the category with the highest total event size.
    const maxCatNameAndBytes = Array.from(
        categoryNamesToTotalEventSizes.entries()).reduce(
        (a, b) => ((b[1] >= a[1]) ? b : a));
    const maxEventBytesPerCategory = maxCatNameAndBytes[1];
    const categoryWithMaxEventBytes = maxCatNameAndBytes[0];

    const maxEventCountPerSecValue = new tr.v.Histogram(
        'peak_event_rate', tr.b.Unit.byName.count_smallerIsBetter,
        COUNT_BOUNDARIES);
    maxEventCountPerSecValue.description = 'Max number of events per second';
    maxEventCountPerSecValue.customizeSummaryOptions(SUMMARY_OPTIONS);
    maxEventCountPerSecValue.addSample(maxEventCountPerSec);

    const maxEventBytesPerSecValue = new tr.v.Histogram(
        'peak_event_size_rate', tr.b.Unit.byName.sizeInBytes_smallerIsBetter,
        BYTE_BOUNDARIES);
    maxEventBytesPerSecValue.description = 'Max event size in bytes per second';
    maxEventBytesPerSecValue.customizeSummaryOptions(SUMMARY_OPTIONS);
    maxEventBytesPerSecValue.addSample(maxEventBytesPerSec);

    const totalTraceBytesValue = new tr.v.Histogram('trace_size',
        tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
    totalTraceBytesValue.customizeSummaryOptions(SUMMARY_OPTIONS);
    totalTraceBytesValue.addSample(totalTraceBytes);

    const biggestCategory = {
      name: categoryWithMaxEventBytes,
      size_in_bytes: maxEventBytesPerCategory
    };

    totalTraceBytesValue.diagnostics.set(
        'category_with_max_event_size',
        new tr.v.d.GenericSet([biggestCategory]));
    histograms.addHistogram(totalTraceBytesValue);

    maxEventCountPerSecValue.diagnostics.set(
        'category_with_max_event_size',
        new tr.v.d.GenericSet([biggestCategory]));
    histograms.addHistogram(maxEventCountPerSecValue);

    maxEventBytesPerSecValue.diagnostics.set(
        'category_with_max_event_size',
        new tr.v.d.GenericSet([biggestCategory]));
    histograms.addHistogram(maxEventBytesPerSecValue);

    addMemoryInfraHistograms(histograms, model, categoryNamesToTotalEventSizes);
  }

  tr.metrics.MetricRegistry.register(tracingMetric);

  return {
    tracingMetric,
    // For testing only:
    MEMORY_INFRA_TRACING_CATEGORY,
  };
});


'use strict';

tr.exportTo('tr.metrics.v8', function() {
  const CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(
      4, 200, 100);

  function computeExecuteMetrics(histograms, model) {
    const cpuTotalExecution = new tr.v.Histogram('v8_execution_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalExecution.description = 'cpu total time spent in script execution';
    const wallTotalExecution = new tr.v.Histogram('v8_execution_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalExecution.description =
      'wall total time spent in script execution';
    const cpuSelfExecution = new tr.v.Histogram('v8_execution_cpu_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfExecution.description = 'cpu self time spent in script execution';
    const wallSelfExecution = new tr.v.Histogram('v8_execution_wall_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfExecution.description = 'wall self time spent in script execution';

    for (const e of model.findTopmostSlicesNamed('V8.Execute')) {
      cpuTotalExecution.addSample(e.cpuDuration);
      wallTotalExecution.addSample(e.duration);
      cpuSelfExecution.addSample(e.cpuSelfTime);
      wallSelfExecution.addSample(e.selfTime);
    }

    histograms.addHistogram(cpuTotalExecution);
    histograms.addHistogram(wallTotalExecution);
    histograms.addHistogram(cpuSelfExecution);
    histograms.addHistogram(wallSelfExecution);
  }

  function computeParseLazyMetrics(histograms, model) {
    const cpuSelfParseLazy = new tr.v.Histogram('v8_parse_lazy_cpu_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfParseLazy.description =
      'cpu self time spent performing lazy parsing';
    const wallSelfParseLazy = new tr.v.Histogram('v8_parse_lazy_wall_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfParseLazy.description =
      'wall self time spent performing lazy parsing';

    for (const e of model.findTopmostSlicesNamed('V8.ParseLazyMicroSeconds')) {
      cpuSelfParseLazy.addSample(e.cpuSelfTime);
      wallSelfParseLazy.addSample(e.selfTime);
    }
    for (const e of model.findTopmostSlicesNamed('V8.ParseLazy')) {
      cpuSelfParseLazy.addSample(e.cpuSelfTime);
      wallSelfParseLazy.addSample(e.selfTime);
    }

    histograms.addHistogram(cpuSelfParseLazy);
    histograms.addHistogram(wallSelfParseLazy);
  }

  function computeCompileFullCodeMetrics(histograms, model) {
    const cpuSelfCompileFullCode = new tr.v.Histogram(
        'v8_compile_full_code_cpu_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfCompileFullCode.description =
      'cpu self time spent performing compiling full code';
    const wallSelfCompileFullCode = new tr.v.Histogram(
        'v8_compile_full_code_wall_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfCompileFullCode.description =
      'wall self time spent performing compiling full code';

    for (const e of model.findTopmostSlicesNamed('V8.CompileFullCode')) {
      cpuSelfCompileFullCode.addSample(e.cpuSelfTime);
      wallSelfCompileFullCode.addSample(e.selfTime);
    }

    histograms.addHistogram(cpuSelfCompileFullCode);
    histograms.addHistogram(wallSelfCompileFullCode);
  }

  function computeCompileIgnitionMetrics(histograms, model) {
    const cpuSelfCompileIgnition = new tr.v.Histogram(
        'v8_compile_ignition_cpu_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfCompileIgnition.description =
      'cpu self time spent in compile ignition';
    const wallSelfCompileIgnition = new tr.v.Histogram(
        'v8_compile_ignition_wall_self',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfCompileIgnition.description =
      'wall self time spent in compile ignition';

    for (const e of model.findTopmostSlicesNamed('V8.CompileIgnition')) {
      cpuSelfCompileIgnition.addSample(e.cpuSelfTime);
      wallSelfCompileIgnition.addSample(e.selfTime);
    }

    histograms.addHistogram(cpuSelfCompileIgnition);
    histograms.addHistogram(wallSelfCompileIgnition);
  }

  function computeRecompileMetrics(histograms, model) {
    const cpuTotalRecompileSynchronous = new tr.v.Histogram(
        'v8_recompile_synchronous_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileSynchronous.description =
      'cpu total time spent in synchronous recompilation';
    const wallTotalRecompileSynchronous = new tr.v.Histogram(
        'v8_recompile_synchronous_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileSynchronous.description =
      'wall total time spent in synchronous recompilation';
    const cpuTotalRecompileConcurrent = new tr.v.Histogram(
        'v8_recompile_concurrent_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileConcurrent.description =
      'cpu total time spent in concurrent recompilation';
    const wallTotalRecompileConcurrent = new tr.v.Histogram(
        'v8_recompile_concurrent_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileConcurrent.description =
      'wall total time spent in concurrent recompilation';
    // TODO(eakuefner): Stop computing overall histograms once dash v2 is ready.
    // https://github.com/catapult-project/catapult/issues/2180
    const cpuTotalRecompileOverall = new tr.v.Histogram(
        'v8_recompile_overall_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileOverall.description =
      'cpu total time spent in synchronous or concurrent recompilation';
    const wallTotalRecompileOverall = new tr.v.Histogram(
        'v8_recompile_overall_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileOverall.description =
      'wall total time spent in synchronous or concurrent recompilation';

    for (const e of model.findTopmostSlicesNamed('V8.RecompileSynchronous')) {
      cpuTotalRecompileSynchronous.addSample(e.cpuDuration);
      wallTotalRecompileSynchronous.addSample(e.duration);
      cpuTotalRecompileOverall.addSample(e.cpuDuration);
      wallTotalRecompileOverall.addSample(e.duration);
    }

    histograms.addHistogram(cpuTotalRecompileSynchronous);
    histograms.addHistogram(wallTotalRecompileSynchronous);

    for (const e of model.findTopmostSlicesNamed('V8.RecompileConcurrent')) {
      cpuTotalRecompileConcurrent.addSample(e.cpuDuration);
      wallTotalRecompileConcurrent.addSample(e.duration);
      cpuTotalRecompileOverall.addSample(e.cpuDuration);
      wallTotalRecompileOverall.addSample(e.duration);
    }

    histograms.addHistogram(cpuTotalRecompileConcurrent);
    histograms.addHistogram(wallTotalRecompileConcurrent);
    histograms.addHistogram(cpuTotalRecompileOverall);
    histograms.addHistogram(wallTotalRecompileOverall);
  }

  function computeOptimizeCodeMetrics(histograms, model) {
    const cpuTotalOptimizeCode = new tr.v.Histogram(
        'v8_optimize_code_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalOptimizeCode.description =
      'cpu total time spent in code optimization';
    const wallTotalOptimizeCode = new tr.v.Histogram(
        'v8_optimize_code_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalOptimizeCode.description =
      'wall total time spent in code optimization';

    for (const e of model.findTopmostSlicesNamed('V8.OptimizeCode')) {
      cpuTotalOptimizeCode.addSample(e.cpuDuration);
      wallTotalOptimizeCode.addSample(e.duration);
    }

    histograms.addHistogram(cpuTotalOptimizeCode);
    histograms.addHistogram(wallTotalOptimizeCode);
  }

  function computeDeoptimizeCodeMetrics(histograms, model) {
    const cpuTotalDeoptimizeCode = new tr.v.Histogram(
        'v8_deoptimize_code_cpu_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalDeoptimizeCode.description =
      'cpu total time spent in code deoptimization';
    const wallTotalDeoptimizeCode = new tr.v.Histogram(
        'v8_deoptimize_code_wall_total',
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalDeoptimizeCode.description =
      'wall total time spent in code deoptimization';

    for (const e of model.findTopmostSlicesNamed('V8.DeoptimizeCode')) {
      cpuTotalDeoptimizeCode.addSample(e.cpuDuration);
      wallTotalDeoptimizeCode.addSample(e.duration);
    }

    histograms.addHistogram(cpuTotalDeoptimizeCode);
    histograms.addHistogram(wallTotalDeoptimizeCode);
  }

  function executionMetric(histograms, model) {
    computeExecuteMetrics(histograms, model);
    computeParseLazyMetrics(histograms, model);
    computeCompileIgnitionMetrics(histograms, model);
    computeCompileFullCodeMetrics(histograms, model);
    computeRecompileMetrics(histograms, model);
    computeOptimizeCodeMetrics(histograms, model);
    computeDeoptimizeCodeMetrics(histograms, model);
  }

  tr.metrics.MetricRegistry.register(executionMetric);

  return {
    executionMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.v8', function() {
  // The time window size for mutator utilization computation.
  // It is equal to the duration of one frame corresponding to 60 FPS rendering.
  const TARGET_FPS = 60;
  const MS_PER_SECOND = 1000;
  const WINDOW_SIZE_MS = MS_PER_SECOND / TARGET_FPS;

  function gcMetric(histograms, model) {
    addDurationOfTopEvents(histograms, model);
    addTotalDurationOfTopEvents(histograms, model);
    addDurationOfSubEvents(histograms, model);
    addPercentageInV8ExecuteOfTopEvents(histograms, model);
    addTotalPercentageInV8Execute(histograms, model);
  }

  tr.metrics.MetricRegistry.register(gcMetric);

  const timeDurationInMs_smallerIsBetter =
      tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const percentage_biggerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;
  const percentage_smallerIsBetter =
      tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  const CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200)
    .addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90]});
    return n;
  }

  function createNumericForSubEventTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: false,
      percentile: [0.90]
    });
    return n;
  }

  function createNumericForIdleTime(name) {
    const n = new tr.v.Histogram(name,
        timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator, unit) {
    const hist = new tr.v.Histogram(name, unit);
    if (denominator === 0) {
      hist.addSample(0);
    } else {
      hist.addSample(numerator / denominator);
    }
    hist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: false,
      percentile: []
    });
    return hist;
  }

  function isNotForcedTopGarbageCollectionEvent(event) {
    // We exclude garbage collection events forced by benchmark runner,
    // because they cannot happen in real world.
    return tr.metrics.v8.utils.isTopGarbageCollectionEvent(event) &&
           !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event);
  }

  function isNotForcedSubGarbageCollectionEvent(event) {
    // We exclude garbage collection events forced by benchmark runner,
    // because they cannot happen in real world.
    return tr.metrics.v8.utils.isSubGarbageCollectionEvent(event) &&
           !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event);
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor.
   */
  function addDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-total
   */
  function addTotalDurationOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          const cpuDuration = createNumericForTopEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor-evacuate.
   */
  function addDurationOfSubEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isNotForcedSubGarbageCollectionEvent,
        tr.metrics.v8.utils.subGarbageCollectionEventName,
        function(name, events) {
          const cpuDuration = createNumericForSubEventTime(name);
          events.forEach(function(event) {
            cpuDuration.addSample(event.cpuDuration);
          });
          histograms.addHistogram(cpuDuration);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor_percentage_in_v8_execute.
   */
  function addPercentageInV8ExecuteOfTopEvents(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isNotForcedTopGarbageCollectionEvent,
        tr.metrics.v8.utils.topGarbageCollectionEventName,
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        }
    );
  }

  /**
   * Example output:
   * - v8-gc-total_percentage_in_v8_execute.
   */
  function addTotalPercentageInV8Execute(histograms, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model,
        isNotForcedTopGarbageCollectionEvent,
        event => 'v8-gc-total',
        function(name, events) {
          addPercentageInV8Execute(histograms, model, name, events);
        }
    );
  }

  function addPercentageInV8Execute(histograms, model, name, events) {
    let cpuDurationInV8Execute = 0;
    let cpuDurationTotal = 0;
    events.forEach(function(event) {
      const v8Execute = tr.metrics.v8.utils.findParent(
          event, tr.metrics.v8.utils.isV8ExecuteEvent);
      if (v8Execute) {
        cpuDurationInV8Execute += event.cpuDuration;
      }
      cpuDurationTotal += event.cpuDuration;
    });
    const percentage = createPercentage(
        name + '_percentage_in_v8_execute', cpuDurationInV8Execute,
        cpuDurationTotal, percentage_smallerIsBetter);
    histograms.addHistogram(percentage);
  }

  return {
    gcMetric,
    WINDOW_SIZE_MS,  // For testing purposes only.
  };
});


'use strict';

tr.exportTo('tr.e.v8', function() {
  const ThreadSlice = tr.model.ThreadSlice;

  function V8ThreadSlice() {
    ThreadSlice.apply(this, arguments);
    this.runtimeCallStats_ = undefined;
  }

  V8ThreadSlice.prototype = {
    __proto__: ThreadSlice.prototype,

    get runtimeCallStats() {
      if ('runtime-call-stats' in this.args) {
        this.runtimeCallStats_ = this.args['runtime-call-stats'];
        delete this.args['runtime-call-stats'];
      }
      return this.runtimeCallStats_;
    }
  };

  ThreadSlice.subTypes.register(
      V8ThreadSlice,
      {
        categoryParts: ['v8', 'disabled-by-default-v8.runtime_stats'],
        name: 'v8 slice',
        pluralName: 'v8 slices'
      }
  );

  return {
    V8ThreadSlice,
  };
});


'use strict';

tr.exportTo('tr.e.v8', function() {
  class RuntimeStatsEntry {
    /**
     * @param time is in microseconds.
     */
    constructor(name, count, time) {
      this.name_ = name;
      this.count_ = count;
      this.time_ = time;
    }

    get name() {
      return this.name_;
    }

    get count() {
      return this.count_;
    }

    get time() {
      return this.time_;
    }

    addSample(count, time) {
      this.count_ += count;
      this.time_ += time;
    }
  }

  class RuntimeStatsGroup extends RuntimeStatsEntry {
    constructor(name, matchRegex) {
      super(name, 0, 0);
      this.regex_ = matchRegex;
      this.entries_ = new Map();
    }

    match(name) {
      return this.regex_ && name.match(this.regex_);
    }

    add(entry) {
      const value = this.entries_.get(entry.name);
      if (value !== undefined) {
        value.addSample(entry.count, entry.time);
      } else {
        this.entries_.set(entry.name, entry);
      }
      this.count_ += entry.count;
      this.time_ += entry.time;
    }

    get values() {
      return Array.from(this.entries_.values());
    }
  }

  class RuntimeStatsGroupCollection {
    constructor() {
      this.blink_cpp_group_ =
        new RuntimeStatsGroup('Blink C++', /.*Callback.*/);
      this.api_group_ = new RuntimeStatsGroup('API', /.*API.*/);

      this.groups_ = [
        new RuntimeStatsGroup('Total'),
        new RuntimeStatsGroup('IC', /.*IC_.*/),
        new RuntimeStatsGroup('Optimize',
          /StackGuard|.*Optimize.*|.*Deoptimize.*|Recompile.*/),
        new RuntimeStatsGroup('Compile-Background',
          /(.*CompileBackground.*)/),
        new RuntimeStatsGroup('Compile', /(^Compile.*)|(.*_Compile.*)/),
        new RuntimeStatsGroup('Parse-Background', /.*ParseBackground.*/),
        new RuntimeStatsGroup('Parse', /.*Parse.*/),
        this.blink_cpp_group_,
        this.api_group_,
        new RuntimeStatsGroup('GC', /GC|AllocateInTargetSpace/),
        new RuntimeStatsGroup('JavaScript', /JS_Execution/),
        new RuntimeStatsGroup('V8 C++', /.*/)
      ];

      this.blink_group_collection_ = null;
    }

    addSlices(slices) {
      const blinkEntries = [];
      for (const slice of slices) {
        if (!(slice instanceof tr.e.v8.V8ThreadSlice)) return;
        let runtimeCallStats;
        try {
          runtimeCallStats = JSON.parse(slice.runtimeCallStats);
        } catch (e) {
          runtimeCallStats = slice.runtimeCallStats;
        }
        if (runtimeCallStats === undefined) continue;
        for (const [name, stat] of Object.entries(runtimeCallStats)) {
          // Blink RCS stats go to a separate table
          if (name.match(/Blink_.*/)) {
            // This counter is used to avoid counting time spent in V8 as time
            // spent doing Blink C++, and interferes with total and percentage
            // calculations, so we skip this counter.
            if (name === 'Blink_V8') continue;
            const entry = new RuntimeStatsEntry(name, stat[0], stat[1]);
            blinkEntries.push(entry);
            continue;
          }

          // Skip the 'Total' group
          for (let i = 1; i < this.groups_.length; ++i) {
            if (this.groups_[i].match(name)) {
              if (stat.length !== 2) break;
              const entry = new RuntimeStatsEntry(name, stat[0], stat[1]);
              this.groups_[0].addSample(stat[0], stat[1]);
              this.groups_[i].add(entry);
              break;
            }
          }
        }
      }

      this.blink_group_collection_ =
        new BlinkRuntimeStatsGroupCollection(blinkEntries);
    }

    get totalTime() {
      return this.groups_[0].time;
    }

    get totalCount() {
      return this.groups_[0].count;
    }

    get runtimeGroups() {
      return this.groups_;
    }

    get blinkRCSGroupCollection() {
      return this.blink_group_collection_;
    }

    get blinkCppTotalTime() {
      // Include API time because Blink RCS times also include V8 API times
      return this.blink_cpp_group_.time + this.api_group_.time;
    }
  }

  class BlinkRuntimeStatsGroupCollection {
    constructor(entries) {
      this.groups_ = [
        new RuntimeStatsGroup('Blink_Bindings', /^Blink_Bindings_(.*)/),
        new RuntimeStatsGroup('Blink_GC', /^Blink_GC_(.*)/),
        new RuntimeStatsGroup('Blink_Layout', /^Blink_Layout_(.*)/),
        new RuntimeStatsGroup('Blink_Parsing', /^Blink_Parsing_(.*)/),
        new RuntimeStatsGroup('Blink_Style', /^Blink_Style_(.*)/),
        new RuntimeStatsGroup('Blink_Callbacks', /^Blink_(.*)/)
      ];
      this.total_group_ = new RuntimeStatsGroup('Blink_Total', /.*/);

      for (const entry of entries) {
        for (const group of this.groups_) {
          if (group.match(entry.name)) {
            // Strip out category prefix
            const newEntry = new RuntimeStatsEntry(
              'Blink_' + group.match(entry.name)[1], entry.count, entry.time);
            group.add(newEntry);
            this.total_group_.addSample(entry.count, entry.time);
            break;
          }
        }
      }
    }

    get runtimeGroups() {
      return this.groups_.concat(this.total_group_);
    }

    get values() {
      return this.groups_.reduce(
          (values, group) => values.concat(group.values), []);
    }

    get totalTime() {
      return this.total_group_.time;
    }

    get totalCount() {
      return this.total_group_.count;
    }
  }

  return {
    BlinkRuntimeStatsGroupCollection,
    RuntimeStatsEntry,
    RuntimeStatsGroup,
    RuntimeStatsGroupCollection,
  };
});


'use strict';

tr.exportTo('tr.metrics.v8', function() {
  const COUNT_CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createExponential(1, 1000000, 50);
  const DURATION_CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries
      .createExponential(0.1, 10000, 50);
  const SUMMARY_OPTIONS = {
    std: false,
    count: false,
    sum: false,
    min: false,
    max: false,
  };

  function computeDomContentLoadedTime_(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let domContentLoadedTime = 0;

    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      for (const ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
        if (ev.title === 'domContentLoadedEventEnd' &&
            ev.start > domContentLoadedTime) {
          domContentLoadedTime = ev.start;
        }
      }
    }
    return domContentLoadedTime;
  }

  function computeInteractiveTime_(model) {
    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let interactiveTime = 0;
    for (const rendererHelper of Object.values(chromeHelper.rendererHelpers)) {
      const samples = tr.metrics.sh.collectLoadingMetricsForRenderer(
          rendererHelper).firstInteractiveSamples;
      // TODO(fmeawad): Support multiple navigations.
      if (samples.length === 0) continue;
      if (interactiveTime !== 0) throw new Error('Too many navigations');
      const diagnostics = tr.b.getOnlyElement(samples).diagnostics;
      const infos = diagnostics['Navigation infos'];
      interactiveTime = tr.b.getOnlyElement(infos).interactive;
    }
    return interactiveTime;
  }

  function convertMicroToMilli_(time) {
    return tr.b.convertUnit(time,
        tr.b.UnitPrefixScale.METRIC.MICRO, tr.b.UnitPrefixScale.METRIC.MILLI);
  }

  // TODO(crbug.com/688342): Remove this function when runtimeStatsMetric is
  // removed.
  function computeRuntimeStats(histograms, slices) {
    const runtimeGroupCollection = new tr.e.v8.RuntimeStatsGroupCollection();
    runtimeGroupCollection.addSlices(slices);

    function addHistogramsForRuntimeGroup(runtimeGroup) {
      const durationSamples = new tr.v.d.RelatedHistogramBreakdown();
      const countSamples = new tr.v.d.RelatedHistogramBreakdown();
      for (const entry of runtimeGroup.values) {
        const durationSampleHistogram = histograms.createHistogram(
            `${entry.name}:duration`,
            tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
            convertMicroToMilli_(entry.time), {
              binBoundaries: DURATION_CUSTOM_BOUNDARIES,
              summaryOptions: SUMMARY_OPTIONS,
            });
        durationSamples.set(
            durationSampleHistogram.name, durationSampleHistogram);

        const countSampleHistogram = histograms.createHistogram(
            `${entry.name}:count`,
            tr.b.Unit.byName.count_smallerIsBetter,
            entry.count, {
              binBoundaries: COUNT_CUSTOM_BOUNDARIES,
              summaryOptions: SUMMARY_OPTIONS,
            });
        countSamples.set(
            countSampleHistogram.name, countSampleHistogram);
      }

      histograms.createHistogram(
          `${runtimeGroup.name}:duration`,
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, {
            value: convertMicroToMilli_(runtimeGroup.time),
            diagnostics: {samples: durationSamples},
          }, {
            binBoundaries: DURATION_CUSTOM_BOUNDARIES,
            summaryOptions: SUMMARY_OPTIONS,
          });

      histograms.createHistogram(
          `${runtimeGroup.name}:count`,
          tr.b.Unit.byName.count_smallerIsBetter, {
            value: runtimeGroup.count,
            diagnostics: {samples: countSamples},
          }, {
            binBoundaries: COUNT_CUSTOM_BOUNDARIES,
            summaryOptions: SUMMARY_OPTIONS,
          });
    }

    for (const runtimeGroup of runtimeGroupCollection.runtimeGroups) {
      addHistogramsForRuntimeGroup(runtimeGroup);
    }

    const blinkGroupCollection = runtimeGroupCollection.blinkRCSGroupCollection;
    if (blinkGroupCollection.totalTime > 0) {
      blinkGroupCollection.runtimeGroups.forEach(addHistogramsForRuntimeGroup);
    }
  }

  // TODO(crbug.com/688342): Remove this metric and use runtimeStatsTotalMetric
  // instead when the runtimeStatsTotalMetric is stable.
  function runtimeStatsMetric(histograms, model) {
    const interactiveTime = computeInteractiveTime_(model);
    const domContentLoadedTime = computeDomContentLoadedTime_(model);
    const endTime = Math.max(interactiveTime, domContentLoadedTime);
    const slices = [...model.getDescendantEvents()].filter(event =>
          event instanceof tr.e.v8.V8ThreadSlice && event.start <= endTime);
    computeRuntimeStats(histograms, slices);
  }

  function addDurationHistogram(railStageName, runtimeGroupName, sampleValue,
      histograms, durationRelatedHistsByGroupName) {
    const durationHistogram = histograms.createHistogram(
        `${railStageName}_${runtimeGroupName}:duration`,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        convertMicroToMilli_(sampleValue), {
          binBoundaries: DURATION_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS,
        });

    // Record this histogram in RelatedHistogramMap.
    if (durationRelatedHistsByGroupName.get(runtimeGroupName) ===
      undefined) {
      const durationHistogramMap = new tr.v.d.RelatedHistogramMap();
      durationHistogramMap.set(railStageName, durationHistogram);
      durationRelatedHistsByGroupName.set(runtimeGroupName,
          durationHistogramMap);
    } else {
      durationRelatedHistsByGroupName.get(runtimeGroupName).set(railStageName,
          durationHistogram);
    }
  }

  function addCountHistogram(railStageName, runtimeGroupName, sampleValue,
      histograms, countRelatedHistsByGroupName) {
    const countHistogram = histograms.createHistogram(
        `${railStageName}_${runtimeGroupName}:count`,
        tr.b.Unit.byName.count_smallerIsBetter, sampleValue, {
          binBoundaries: COUNT_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS,
        });

    // Record this histogram in RelatedHistogramMap.
    if (countRelatedHistsByGroupName.get(runtimeGroupName) === undefined) {
      const countHistogramMap = new tr.v.d.RelatedHistogramMap();
      countHistogramMap.set(railStageName, countHistogram);
      countRelatedHistsByGroupName.set(runtimeGroupName,
          countHistogramMap);
    } else {
      countRelatedHistsByGroupName.get(runtimeGroupName).set(railStageName,
          countHistogram);
    }
  }

  function addTotalDurationHistogram(histogramName, time, histograms,
      durationRelatedHistsByGroupName) {
    const durationHistogram = histograms.createHistogram(
        `${histogramName}:duration`,
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter,
        convertMicroToMilli_(time), {
          binBoundaries: DURATION_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS,
        });

    // Add UE histograms as a diagnostic, so they can be hidden in the main
    // view, and the data across UE buckets can be grouped together.
    const durationRelatedHistogram = durationRelatedHistsByGroupName.get(
        histogramName);
    if (durationRelatedHistogram !== undefined) {
      durationHistogram.diagnostics.set('RAIL stages',
          durationRelatedHistogram);
    }
  }

  function addTotalCountHistogram(histogramName, count, histograms,
      countRelatedHistsByGroupName) {
    const countHistogram = histograms.createHistogram(
        `${histogramName}:count`,
        tr.b.Unit.byName.count_smallerIsBetter,
        count, {
          binBoundaries: COUNT_CUSTOM_BOUNDARIES,
          summaryOptions: SUMMARY_OPTIONS,
        });

    // Add UE histograms as a diagnostic, so they can be hidden in the main
    // view, and the data across UE buckets can be grouped together.
    const countRelatedHistogram = countRelatedHistsByGroupName.get(
        histogramName);
    if (countRelatedHistogram !== undefined) {
      countHistogram.diagnostics.set('RAIL stages', countRelatedHistogram);
    }
  }

  function computeRuntimeStatsBucketOnUE(histograms, slices,
      v8SlicesBucketOnUEMap) {
    const durationRelatedHistsByGroupName = new Map();
    const countRelatedHistsByGroupName = new Map();

    // Compute runtimeStats in each of the UE buckets. Also record the
    // histograms in RelatedHistogramMap. These histograms are added to the
    // corresponding histograms in the total bucket as a diagnostic. This keeps
    // the data grouped.
    for (const [name, slicesUE] of v8SlicesBucketOnUEMap) {
      const runtimeGroupCollection = new tr.e.v8.RuntimeStatsGroupCollection();
      runtimeGroupCollection.addSlices(slicesUE);

      let overallV8Time = runtimeGroupCollection.totalTime;
      let overallV8Count = runtimeGroupCollection.totalCount;
      for (const runtimeGroup of runtimeGroupCollection.runtimeGroups) {
        addDurationHistogram(name, runtimeGroup.name, runtimeGroup.time,
            histograms, durationRelatedHistsByGroupName);
        if (runtimeGroup.name === 'Blink C++') {
          overallV8Time -= runtimeGroup.time;
        }

        addCountHistogram(name, runtimeGroup.name, runtimeGroup.count,
            histograms, countRelatedHistsByGroupName);
        if (runtimeGroup.name === 'Blink C++') {
          overallV8Count -= runtimeGroup.count;
        }
      }

      if (runtimeGroupCollection.blinkRCSGroupCollection.totalTime > 0) {
        const blinkRCSGroupCollection =
            runtimeGroupCollection.blinkRCSGroupCollection;
        for (const group of blinkRCSGroupCollection.runtimeGroups) {
          addDurationHistogram(name, group.name, group.time,
              histograms, durationRelatedHistsByGroupName);
          addCountHistogram(name, group.name, group.count,
              histograms, countRelatedHistsByGroupName);
        }
      }

      // Add V8 only time that is Total - Blink C++ duration.
      addDurationHistogram(name, 'V8-Only', overallV8Time, histograms,
          durationRelatedHistsByGroupName);
      addCountHistogram(name, 'V8-Only', overallV8Count, histograms,
          countRelatedHistsByGroupName);
    }

    // Add the runtimeStats for all the samples. Please note, the values in
    // the UE buckets may not add upto the values computed here. Since UEs
    // can overlap, we count some of the samples in multiple UE buckets.
    const runtimeGroupCollection = new tr.e.v8.RuntimeStatsGroupCollection();
    runtimeGroupCollection.addSlices(slices);

    let overallV8Time = runtimeGroupCollection.totalTime;
    let overallV8Count = runtimeGroupCollection.totalCount;
    for (const runtimeGroup of runtimeGroupCollection.runtimeGroups) {
      addTotalDurationHistogram(runtimeGroup.name, runtimeGroup.time,
          histograms, durationRelatedHistsByGroupName);
      if (runtimeGroup.name === 'Blink C++') {
        overallV8Time -= runtimeGroup.time;
      }

      addTotalCountHistogram(runtimeGroup.name, runtimeGroup.count,
          histograms, countRelatedHistsByGroupName);
      if (runtimeGroup.name === 'Blink C++') {
        overallV8Count -= runtimeGroup.count;
      }
    }

    if (runtimeGroupCollection.blinkRCSGroupCollection.totalTime > 0) {
      const blinkRCSGroupCollection =
        runtimeGroupCollection.blinkRCSGroupCollection;
      for (const group of blinkRCSGroupCollection.runtimeGroups) {
        addTotalDurationHistogram(group.name, group.time,
            histograms, durationRelatedHistsByGroupName);
        addTotalCountHistogram(group.name, group.count,
            histograms, countRelatedHistsByGroupName);
      }
    }

    // Add V8 only time that is Total - Blink C++ duration.
    addTotalDurationHistogram('V8-Only', overallV8Time, histograms,
        durationRelatedHistsByGroupName);
    addTotalCountHistogram('V8-Only', overallV8Count, histograms,
        countRelatedHistsByGroupName);
  }

  function runtimeStatsTotalMetric(histograms, model) {
    const v8ThreadSlices = [...model.getDescendantEvents()].filter(event =>
          event instanceof tr.e.v8.V8ThreadSlice).sort((e1, e2) =>
          e1.start - e2.start);
    const v8SlicesBucketOnUEMap = new Map();
    // User expectations can sometime overlap. So, certain v8 slices can be
    // included in more than one expectation. We count such slices in each
    // of the expectations. This is done so as to minimize the noise due to
    // the differences in the extent of overlap between the runs.
    for (const expectation of model.userModel.expectations) {
      const slices = expectation.range.filterArray(v8ThreadSlices,
          event => event.start);
      if (slices.length === 0) continue;
      // filterArray filters the array that intersects the range inclusively.
      // Expectations are not inclusive i.e. expectations are like [0, 1),
      // [1, 2). v8ThreadSlices that start at 1 should be counted only in [1,2)
      // bucket. Filter out sample at the boundary so that they are not counted
      // twice.
      const lastSlice = slices[slices.length - 1];
      if (!expectation.range.intersectsRangeExclusive(lastSlice.range)) {
        slices.pop();
      }

      if (v8SlicesBucketOnUEMap.get(expectation.stageTitle) === undefined) {
        v8SlicesBucketOnUEMap.set(expectation.stageTitle, slices);
      } else {
        const totalSlices = v8SlicesBucketOnUEMap.get(expectation.stageTitle)
                                               .concat(slices);
        v8SlicesBucketOnUEMap.set(expectation.stageTitle, totalSlices);
      }
    }

    // Compute runtimeStats in each of the UE buckets and also compute
    // runtimeStats on all of the samples. The values in UE buckets do not add
    // up to the total of all samples, since we duplicate some of the samples in
    // multiple buckets when the UEs overlap.
    computeRuntimeStatsBucketOnUE(histograms, v8ThreadSlices,
        v8SlicesBucketOnUEMap);
  }

  tr.metrics.MetricRegistry.register(runtimeStatsTotalMetric);
  tr.metrics.MetricRegistry.register(runtimeStatsMetric);

  return {
    runtimeStatsMetric,
    runtimeStatsTotalMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.v8', function() {
  function v8AndMemoryMetrics(histograms, model) {
    tr.metrics.v8.executionMetric(histograms, model);
    tr.metrics.v8.gcMetric(histograms, model);
    tr.metrics.sh.memoryMetric(histograms, model,
        {rangeOfInterest: tr.metrics.v8.utils.rangeForMemoryDumps(model)});
  }

  tr.metrics.MetricRegistry.register(v8AndMemoryMetrics);

  return {
    v8AndMemoryMetrics,
  };
});


'use strict';

tr.exportTo('tr.metrics.vr', function() {
  function createHistograms(histograms, name, options) {
    return {
      wall: histograms.createHistogram(name + '_wall',
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, [], options),
      cpu: histograms.createHistogram(name + '_cpu',
          tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, [], options),
    };
  }

  function frameCycleDurationMetric(histograms, model) {
    const histogramsByEventTitle = new Map();
    histogramsByEventTitle.set('VrShellGl::DrawFrame',
        createHistograms(histograms, 'draw_frame',
          {description: 'Duration to render one frame'}));
    histogramsByEventTitle.set('VrShellGl::AcquireFrame',
        createHistograms(histograms, 'acquire_frame',
          {description: 'Duration acquire a frame from GVR'}));
    histogramsByEventTitle.set('VrShellGl::UpdateController',
        createHistograms(histograms, 'update_controller',
          {description: 'Duration to query input from the controller'}));
    histogramsByEventTitle.set('VrShellGl::DrawWorldElements',
        createHistograms(histograms, 'draw_world_elements',
          {description: 'Duration to draw world UI elements'}));
    histogramsByEventTitle.set('VrShellGl::DrawFrameSubmitWhenReady',
        createHistograms(histograms, 'submit_frame',
          {description: 'Duration to submit a frame to GVR'}));
    histogramsByEventTitle.set('VrShellGl::DrawUiView',
        createHistograms(histograms, 'draw_ui',
          {description: 'Duration to draw the UI'}));

    const chromeHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);

    for (const helper of chromeHelper.browserHelpers) {
      // The events are traced on the GL thread in the browser process.
      // Unfortunately, this thread has no name.
      // TODO(tiborg): Give GL thread a name and reference the thread by
      // the given name.
      const glThreads = helper.process.findAllThreadsMatching(
          thread => !thread.name);

      for (const glThread of glThreads) {
        for (const event of glThread.getDescendantEvents()) {
          if (!(histogramsByEventTitle.has(event.title))) {
            continue;
          }

          const {wall: wallHist, cpu: cpuHist} =
            histogramsByEventTitle.get(event.title);
          wallHist.addSample(event.duration);
          cpuHist.addSample(event.cpuDuration);
        }
      }
    }
  }

  tr.metrics.MetricRegistry.register(frameCycleDurationMetric);

  return {
    frameCycleDurationMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.vr', function() {
  function webvrMetric(histograms, model) {
    // Maps VR trace counters to histogram.
    const WEBVR_COUNTERS = new Map([
      ['gpu.WebVR FPS', new Map([
        ['name', 'webvr_fps'],
        ['unit', tr.b.Unit.byName.count_biggerIsBetter],
        ['options', new Map([
          ['description', 'WebVR frame per second'],
          ['binBoundaries',
            tr.v.HistogramBinBoundaries.createLinear(20, 120, 25)]
        ])]
      ])],
      ['gpu.WebVR frame time (ms)', new Map([
        ['name', 'webvr_frame_time'],
        ['unit', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter],
        ['options', new Map([
          ['description', 'WebVR frame time in ms'],
          ['binBoundaries',
            tr.v.HistogramBinBoundaries.createLinear(20, 120, 25)]
        ])]
      ])],
      ['gpu.WebVR pose prediction (ms)', new Map([
        ['name', 'webvr_pose_prediction'],
        ['unit', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter],
        ['options', new Map([
          ['description', 'WebVR pose prediction in ms'],
          ['binBoundaries',
            tr.v.HistogramBinBoundaries.createLinear(20, 120, 25)]
        ])]
      ])]
    ]);

    for (const counter of model.getAllCounters()) {
      if (!(WEBVR_COUNTERS.has(counter.id))) continue;

      const nameToSamples = new Map();
      for (const series of counter.series) {
        nameToSamples[series.name] = nameToSamples[series.name] || [];
        for (const sample of series.samples) {
          nameToSamples[series.name].push(sample.value);
        }
      }

      for (const [seriesName, samples] of Object.entries(nameToSamples)) {
        let name = WEBVR_COUNTERS.get(counter.id).get('name');
        if (seriesName !== 'value') {
          name = name + '_' + seriesName;
        }

        histograms.createHistogram(
            name, WEBVR_COUNTERS.get(counter.id).get('unit'), samples,
            WEBVR_COUNTERS.get(counter.id).get('options')
        );
      }
    }
  }

  tr.metrics.MetricRegistry.register(webvrMetric);

  return {
    webvrMetric,
  };
});


'use strict';

tr.exportTo('tr.metrics.webrtc', function() {
  const DISPLAY_HERTZ = 60.0;
  const VSYNC_DURATION_US = 1e6 / DISPLAY_HERTZ;
  // How much more severe is a 'Badly out of sync' render event compared to an
  // 'Out of sync' one when calculating the smoothness score.
  const SEVERITY = 3;
  // How many vsyncs a frame should be displayed to be considered frozen.
  const FROZEN_FRAME_VSYNC_COUNT_THRESHOLD = 6;

  const WEB_MEDIA_PLAYER_UPDATE_TITLE = 'UpdateCurrentFrame';
  // These four are args for WebMediaPlayerMS update events.
  const IDEAL_RENDER_INSTANT_NAME = 'Ideal Render Instant';
  const ACTUAL_RENDER_BEGIN_NAME = 'Actual Render Begin';
  const ACTUAL_RENDER_END_NAME = 'Actual Render End';
  // The events of interest have a 'Serial' argument which represents the
  // stream ID.
  const STREAM_ID_NAME = 'Serial';

  const REQUIRED_EVENT_ARGS_NAMES = [
    IDEAL_RENDER_INSTANT_NAME, ACTUAL_RENDER_BEGIN_NAME, ACTUAL_RENDER_END_NAME,
    STREAM_ID_NAME
  ];

  // By default, we store a single value, so we only need one of the
  // statistics to keep track. We choose the average for that.
  const SUMMARY_OPTIONS = tr.v.Histogram.AVERAGE_ONLY_SUMMARY_OPTIONS;

  const count_smallerIsBetter =
        tr.b.Unit.byName.count_smallerIsBetter;
  const percentage_biggerIsBetter =
        tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;
  const percentage_smallerIsBetter =
        tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
  const timeDurationInMs_smallerIsBetter =
        tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  const unitlessNumber_biggerIsBetter =
        tr.b.Unit.byName.unitlessNumber_biggerIsBetter;

  /*
   * Verify that the event is a valid event.
   *
   * An event is valid if it is a UpdateCurrentFrame event,
   * and has all of the mandatory arguments. See MANDATORY above.
   */
  function isValidEvent(event) {
    if (event.title !== WEB_MEDIA_PLAYER_UPDATE_TITLE || !event.args) {
      return false;
    }
    for (const parameter of REQUIRED_EVENT_ARGS_NAMES) {
      if (!(parameter in event.args)) {
        return false;
      }
    }
    return true;
  }

  function webrtcRenderingMetric(histograms, model) {
    const modelHelper = model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    let webMediaPlayerMSEvents = [];
    for (const rendererPid in modelHelper.rendererHelpers) {
      const rendererHelper = modelHelper.rendererHelpers[rendererPid];
      const compositorThread = rendererHelper.compositorThread;
      if (compositorThread !== undefined) {
        webMediaPlayerMSEvents = webMediaPlayerMSEvents.concat(
            compositorThread.sliceGroup.slices.filter(isValidEvent));
      }
    }
    const eventsByStreamName = tr.b.groupIntoMap(
        webMediaPlayerMSEvents,
        event => event.args[STREAM_ID_NAME]
    );
    for (const [streamName, events] of eventsByStreamName) {
      getTimeStats(histograms, streamName, events);
    }
  }

  tr.metrics.MetricRegistry.register(webrtcRenderingMetric);

  function getTimeStats(histograms, streamName, events) {
    const frameHist = getFrameDistribution(histograms, events);
    addFpsFromFrameDistribution(histograms, frameHist);
    addFreezingScore(histograms, frameHist);

    const driftTimeStats = getDriftStats(events);
    histograms.createHistogram('WebRTCRendering_drift_time',
        timeDurationInMs_smallerIsBetter, driftTimeStats.driftTime, {
          summaryOptions: {
            count: false,
            min: false,
            percentile: [0.75, 0.9],
          },
        });
    histograms.createHistogram('WebRTCRendering_rendering_length_error',
        percentage_smallerIsBetter,
        driftTimeStats.renderingLengthError, {
          summaryOptions: SUMMARY_OPTIONS,
        });

    const smoothnessStats = getSmoothnessStats(driftTimeStats.driftTime);
    histograms.createHistogram('WebRTCRendering_percent_badly_out_of_sync',
        percentage_smallerIsBetter, smoothnessStats.percentBadlyOutOfSync, {
          summaryOptions: SUMMARY_OPTIONS,
        });
    histograms.createHistogram('WebRTCRendering_percent_out_of_sync',
        percentage_smallerIsBetter, smoothnessStats.percentOutOfSync, {
          summaryOptions: SUMMARY_OPTIONS,
        });
    histograms.createHistogram('WebRTCRendering_smoothness_score',
        percentage_biggerIsBetter, smoothnessStats.smoothnessScore, {
          summaryOptions: SUMMARY_OPTIONS,
        });
    histograms.createHistogram('WebRTCRendering_frames_out_of_sync',
        count_smallerIsBetter, smoothnessStats.framesOutOfSync, {
          summaryOptions: SUMMARY_OPTIONS,
        });
    histograms.createHistogram('WebRTCRendering_frames_badly_out_of_sync',
        count_smallerIsBetter, smoothnessStats.framesSeverelyOutOfSync, {
          summaryOptions: SUMMARY_OPTIONS,
        });
  }

  const FRAME_DISTRIBUTION_BIN_BOUNDARIES =
    tr.v.HistogramBinBoundaries.createLinear(1, 50, 49);

  /**
   * Create the frame distribution.
   *
   * If the overall display distribution is A1:A2:..:An, this will tell how
   * many times a frame stays displayed during Ak*VSYNC_DURATION_US, also known
   * as 'source to output' distribution.
   *
   * In other terms, a distribution B where
   * B[k] = number of frames that are displayed k times.
   *
   * @param {tr.v.HistogramSet} histograms
   * @param {Array.<event>} events - An array of events.
   * @returns {tr.v.Histogram} frameHist - The frame distribution.
   */
  function getFrameDistribution(histograms, events) {
    const cadence = tr.b.runLengthEncoding(
        events.map(e => e.args[IDEAL_RENDER_INSTANT_NAME]));
    return histograms.createHistogram('WebRTCRendering_frame_distribution',
        count_smallerIsBetter, cadence.map(ticks => ticks.count), {
          binBoundaries: FRAME_DISTRIBUTION_BIN_BOUNDARIES,
          summaryOptions: {
            percentile: [0.75, 0.9],
          },
        });
  }

  /**
   * Calculate the apparent FPS from frame distribution.
   *
   * Knowing the display frequency and the frame distribution, it is possible to
   * calculate the video apparent frame rate as played by WebMediaPlayerMs
   * module.
   *
   * @param {tr.v.HistogramSet} histograms
   * @param {tr.v.Histogram} frameHist - The frame distribution. See
   * getFrameDistribution.
   */
  function addFpsFromFrameDistribution(histograms, frameHist) {
    let numberFrames = 0;
    let numberVsyncs = 0;
    for (let ticks = 1; ticks < frameHist.allBins.length; ++ticks) {
      const count = frameHist.allBins[ticks].count;
      numberFrames += count;
      numberVsyncs += ticks * count;
    }
    const meanRatio = numberVsyncs / numberFrames;
    histograms.createHistogram('WebRTCRendering_fps',
        unitlessNumber_biggerIsBetter, DISPLAY_HERTZ / meanRatio, {
          summaryOptions: SUMMARY_OPTIONS,
        });
  }

  /**
   * Returns the weighted penalty for a number of frozen frames.
   *
   * In a series of repeated frames of length > 5, all frames after the first
   * are considered frozen. Conversely, no frames in a series of repeated frames
   * of length <= 5 will be considered frozen.
   *
   * This means the weight for 0 to 4 frozen frames is 0.
   *
   * @param {Number} numberFrozenFrames - The number of frozen frames.
   * @returns {Number} - The weight penalty for the number of frozen frames.
   */
  function frozenPenaltyWeight(numberFrozenFrames) {
    const penalty = {
      5: 1,
      6: 5,
      7: 15,
      8: 25
    };
    return penalty[numberFrozenFrames] || (8 * (numberFrozenFrames - 4));
  }

  /**
   * Adds the freezing score.
   *
   * @param {tr.v.HistogramSet} histograms
   * @param {tr.v.Histogram} frameHist - The frame distribution.
   * See getFrameDistribution.
   */
  function addFreezingScore(histograms, frameHist) {
    let numberVsyncs = 0;
    let freezingScore = 0;
    let frozenFramesCount = 0;
    for (let ticks = 1; ticks < frameHist.allBins.length; ++ticks) {
      const count = frameHist.allBins[ticks].count;
      numberVsyncs += ticks * count;
      if (ticks >= FROZEN_FRAME_VSYNC_COUNT_THRESHOLD) {
        // The first frame of the series is not considered frozen.
        frozenFramesCount += count * (ticks - 1);
        freezingScore += count * frozenPenaltyWeight(ticks - 1);
      }
    }
    freezingScore = 1 - freezingScore / numberVsyncs;
    if (freezingScore < 0) {
      freezingScore = 0;
    }
    histograms.createHistogram('WebRTCRendering_frozen_frames_count',
        count_smallerIsBetter, frozenFramesCount, {
          summaryOptions: SUMMARY_OPTIONS,
        });
    histograms.createHistogram('WebRTCRendering_freezing_score',
        percentage_biggerIsBetter, freezingScore, {
          summaryOptions: SUMMARY_OPTIONS,
        });
  }

  /**
   * Get the drift time statistics.
   *
   * This method will calculate:
   * - Drift Time: The difference between the Actual Render Begin and the Ideal
   *     Render Instant for each event.
   * - Rendering Length Error: The alignment error of the Ideal Render
   *     Instants. The Ideal Render Instants should be equally spaced by
   *     intervals of length VSYNC_DURATION_US. The Rendering Length error
   *     measures how much they are misaligned.
   *
   * @param {Array.<event>} events - An array of events.
   * @returns {Object.<Array.<Number>, Number>} - The drift time and rendering
   * length error.
   */
  function getDriftStats(events) {
    const driftTime = [];
    const discrepancy = [];
    let oldIdealRender = 0;
    let expectedIdealRender = 0;

    for (const event of events) {
      const currentIdealRender = event.args[IDEAL_RENDER_INSTANT_NAME];
      // The expected time of the next 'Ideal Render' event begins as the
      // current 'Ideal Render' time and increases by VSYNC_DURATION_US on every
      // frame.
      expectedIdealRender += VSYNC_DURATION_US;
      if (currentIdealRender === oldIdealRender) {
        continue;
      }
      const actualRenderBegin = event.args[ACTUAL_RENDER_BEGIN_NAME];
      // When was the frame rendered vs. when it would've been ideal.
      driftTime.push(actualRenderBegin - currentIdealRender);
      // The discrepancy is the absolute difference between the current Ideal
      // Render and the expected Ideal Render.
      discrepancy.push(Math.abs(currentIdealRender - expectedIdealRender));
      expectedIdealRender = currentIdealRender;
      oldIdealRender = currentIdealRender;
    }

    const discrepancySum = tr.b.math.Statistics.sum(discrepancy) -
      discrepancy[0];
    const lastIdealRender =
        events[events.length - 1].args[IDEAL_RENDER_INSTANT_NAME];
    const firstIdealRender = events[0].args[IDEAL_RENDER_INSTANT_NAME];
    const idealRenderSpan = lastIdealRender - firstIdealRender;

    const renderingLengthError = discrepancySum / idealRenderSpan;

    return {driftTime, renderingLengthError};
  }

  /**
   * Get the smoothness stats from the normalized drift time.
   *
   * This method will calculate the smoothness score, along with the percentage
   * of frames badly out of sync and the percentage of frames out of sync.
   * To be considered badly out of sync, a frame has to have missed rendering by
   * at least 2 * VSYNC_DURATION_US.
   * To be considered out of sync, a frame has to have missed rendering by at
   * least one VSYNC_DURATION_US.
   * The smoothness score is a measure of how out of sync the frames are.
   *
   * @param {Array.<Number>} driftTimes - See getDriftStats.
   * @returns {Object.<Number, Number, Number>} - The percentBadlyOutOfSync,
   * percentOutOfSync and smoothnesScore calculated from the driftTimes array.
   */
  function getSmoothnessStats(driftTimes) {
    const meanDriftTime = tr.b.math.Statistics.mean(driftTimes);
    const normDriftTimes = driftTimes.map(driftTime =>
        Math.abs(driftTime - meanDriftTime));

    // How many times is a frame later/earlier than T=2*VSYNC_DURATION_US. Time
    // is in microseconds
    const framesSeverelyOutOfSync = normDriftTimes
      .filter(driftTime => driftTime > 2 * VSYNC_DURATION_US)
      .length;
    // How many times is a frame later/earlier than VSYNC_DURATION_US.
    const framesOutOfSync = normDriftTimes
      .filter(driftTime => driftTime > VSYNC_DURATION_US)
      .length;

    const percentBadlyOutOfSync = framesSeverelyOutOfSync /
      driftTimes.length;
    const percentOutOfSync = framesOutOfSync / driftTimes.length;

    const framesOutOfSyncOnlyOnce = framesOutOfSync - framesSeverelyOutOfSync;

    // Calculate smoothness metric. From the formula, we can see that smoothness
    // score can be negative.
    let smoothnessScore = 1 - (framesOutOfSyncOnlyOnce +
        SEVERITY * framesSeverelyOutOfSync) / driftTimes.length;

    // Minimum smoothness_score value allowed is zero.
    if (smoothnessScore < 0) {
      smoothnessScore = 0;
    }

    return {
      framesOutOfSync,
      framesSeverelyOutOfSync,
      percentBadlyOutOfSync,
      percentOutOfSync,
      smoothnessScore
    };
  }

  return {
    webrtcRenderingMetric,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    let elements;
    if (typeof source === 'string') {
      elements = Polymer.dom(tr.doc).querySelectorAll(source);
    } else {
      elements = [source];
    }

    for (let i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr)) {
        constr.decorate(el);
      }
    }
  }

  /**
   * Defines a tracing UI component, a function that can be called to construct
   * the component.
   *
   * tr class:
   * const List = tr.ui.b.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * Derived class:
   * const CustomList = tr.ui.b.define('custom-list', List);
   * CustomList.prototype = {
   *   __proto__: List.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * @param {string} className The className of the newly created subtype. If
   *     subclassing by passing in opt_parentConstructor, this is used for
   *     debugging. If not subclassing, then it is the tag name that will be
   *     created by the component.

   * @param {function=} opt_parentConstructor The parent class for this new
   *     element, if subclassing is desired. If provided, the parent class must
   *     be also a function created by tr.ui.b.define.
   *
   * @param {string=} opt_tagNS The namespace in which to create the base
   *     element. Has no meaning when opt_parentConstructor is passed and must
   *     either be undefined or the same namespace as the parent class.
   *
   * @return {function(Object=):Element} The newly created component
   *     constructor.
   */
  function define(className, opt_parentConstructor, opt_tagNS) {
    if (typeof className === 'function') {
      throw new Error('Passing functions as className is deprecated. Please ' +
                      'use (className, opt_parentConstructor) to subclass');
    }

    className = className.toLowerCase();
    if (opt_parentConstructor && !opt_parentConstructor.tagName) {
      throw new Error('opt_parentConstructor was not ' +
                      'created by tr.ui.b.define');
    }

    // Walk up the parent constructors until we can find the type of tag
    // to create.
    let tagName = className;
    let tagNS = undefined;
    if (opt_parentConstructor) {
      if (opt_tagNS) {
        throw new Error('Must not specify tagNS if parentConstructor is given');
      }
      let parent = opt_parentConstructor;
      while (parent && parent.tagName) {
        tagName = parent.tagName;
        tagNS = parent.tagNS;
        parent = parent.parentConstructor;
      }
    } else {
      tagNS = opt_tagNS;
    }

    /**
     * Creates a new UI element constructor.
     * Arguments passed to the constuctor are provided to the decorate method.
     * You will need to call the parent elements decorate method from within
     * your decorate method and pass any required parameters.
     * @constructor
     */
    function f() {
      if (opt_parentConstructor &&
          f.prototype.__proto__ !== opt_parentConstructor.prototype) {
        throw new Error(
            className + ' prototye\'s __proto__ field is messed up. ' +
            'It MUST be the prototype of ' + opt_parentConstructor.tagName);
      }

      let el;
      if (tagNS === undefined) {
        el = tr.doc.createElement(tagName);
      } else {
        el = tr.doc.createElementNS(tagNS, tagName);
      }
      f.decorate.call(this, el, arguments);
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate.apply(el, arguments[1]);
      el.constructor = f;
    };

    f.className = className;
    f.tagName = tagName;
    f.tagNS = tagNS;
    f.parentConstructor = (opt_parentConstructor ? opt_parentConstructor :
                                                   undefined);
    f.toString = function() {
      if (!f.parentConstructor) {
        return f.tagName;
      }
      return f.parentConstructor.toString() + '::' + f.className;
    };

    return f;
  }

  function elementIsChildOf(el, potentialParent) {
    if (el === potentialParent) return false;

    let cur = el;
    while (Polymer.dom(cur).parentNode) {
      if (cur === potentialParent) return true;
      cur = Polymer.dom(cur).parentNode;
    }
    return false;
  }

  return {
    decorate,
    define,
    elementIsChildOf,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * YComponent is a class that handles storing the stableId and the percentage
   * offset in the y direction of all tracks within a specific viewX and viewY
   * coordinate.
   * @constructor
   */
  function YComponent(stableId, yPercentOffset) {
    this.stableId = stableId;
    this.yPercentOffset = yPercentOffset;
  }

  YComponent.prototype = {
    toDict() {
      return {
        stableId: this.stableId,
        yPercentOffset: this.yPercentOffset
      };
    }
  };

  /**
   * Location is a class that represents a spatial location on the timeline
   * that is specified by percent offsets within tracks rather than specific
   * points.
   *
   * @constructor
   */
  function Location(xWorld, yComponents) {
    this.xWorld_ = xWorld;
    this.yComponents_ = yComponents;
  }

  /**
   * Returns a new Location given by x and y coordinates with respect to
   * the timeline's drawing canvas.
   */
  Location.fromViewCoordinates = function(viewport, viewX, viewY) {
    const dt = viewport.currentDisplayTransform;
    const xWorld = dt.xViewToWorld(viewX);
    const yComponents = [];

    // Since we're given coordinates within the timeline canvas, we need to
    // convert them to document coordinates to get the element.
    let elem = document.elementFromPoint(
        viewX + viewport.modelTrackContainer.canvas.offsetLeft,
        viewY + viewport.modelTrackContainer.canvas.offsetTop);
    // Build yComponents by calculating percentage offset with respect to
    // each parent track.
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        const boundRect = elem.getBoundingClientRect();
        const yPercentOffset = (viewY - boundRect.top) / boundRect.height;
        yComponents.push(
            new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length === 0) return;
    return new Location(xWorld, yComponents);
  };

  Location.fromStableIdAndTimestamp = function(viewport, stableId, ts) {
    const xWorld = ts;
    const yComponents = [];

    // The y components' percentage offsets will be calculated with respect to
    // the boundingRect's top of containing track.
    const containerToTrack = viewport.containerToTrackMap;
    let elem = containerToTrack.getTrackByStableId(stableId);
    if (!elem) return;

    const firstY = elem.getBoundingClientRect().top;
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        const boundRect = elem.getBoundingClientRect();
        const yPercentOffset = (firstY - boundRect.top) / boundRect.height;
        yComponents.push(
            new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length === 0) return;
    return new Location(xWorld, yComponents);
  };

  Location.prototype = {

    get xWorld() {
      return this.xWorld_;
    },

    /**
     * Returns the first valid containing track based on the
     * internal yComponents.
     */
    getContainingTrack(viewport) {
      const containerToTrack = viewport.containerToTrackMap;
      for (const i in this.yComponents_) {
        const yComponent = this.yComponents_[i];
        const track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined) return track;
      }
    },

    /**
     * Calculates and returns x and y coordinates of the current location with
     * respect to the timeline's canvas.
     */
    toViewCoordinates(viewport) {
      const dt = viewport.currentDisplayTransform;
      const containerToTrack = viewport.containerToTrackMap;
      const viewX = dt.xWorldToView(this.xWorld_);

      let viewY = -1;
      for (const index in this.yComponents_) {
        const yComponent = this.yComponents_[index];
        const track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined) {
          const boundRect = track.getBoundingClientRect();
          viewY = yComponent.yPercentOffset * boundRect.height + boundRect.top;
          break;
        }
      }

      return {
        viewX,
        viewY
      };
    },

    toDict() {
      return {
        xWorld: this.xWorld_,
        yComponents: this.yComponents_
      };
    }
  };

  return {
    Location,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const Location = tr.model.Location;

  /**
   * UIState is a class that represents the current state of the timeline by
   * the Location of the point of interest and the current scaleX of the
   * timeline.
   *
   * @constructor
   */
  function UIState(location, scaleX) {
    this.location_ = location;
    this.scaleX_ = scaleX;
  }

  /**
   * Accepts a UIState string in the format of (timestamp)@(stableID)x(scaleX)
   * Returns undefined if string is not in this format, or throws an Error if
   * variables in a syntactically-correct stateString does not produce a valid
   * UIState. Otherwise returns a constructed UIState instance.
   */
  UIState.fromUserFriendlyString = function(model, viewport, stateString) {
    const navByFinderPattern = /^(-?\d+(\.\d+)?)@(.+)x(\d+(\.\d+)?)$/g;
    const match = navByFinderPattern.exec(stateString);
    if (!match) return;

    const timestamp = parseFloat(match[1]);
    const stableId = match[3];
    const scaleX = parseFloat(match[4]);

    if (scaleX <= 0) {
      throw new Error('Invalid ScaleX value in UI State string.');
    }

    if (!viewport.containerToTrackMap.getTrackByStableId(stableId)) {
      throw new Error('Invalid StableID given in UI State String.');
    }

    const loc = tr.model.Location.fromStableIdAndTimestamp(
        viewport, stableId, timestamp);
    return new UIState(loc, scaleX);
  };

  UIState.prototype = {

    get location() {
      return this.location_;
    },

    get scaleX() {
      return this.scaleX_;
    },

    toUserFriendlyString(viewport) {
      const timestamp = this.location_.xWorld;
      const stableId =
          this.location_.getContainingTrack(viewport).eventContainer.stableId;
      const scaleX = this.scaleX_;
      return timestamp.toFixed(5) + '@' + stableId + 'x' + scaleX.toFixed(5);
    },

    toDict() {
      return {
        location: this.location_.toDict(),
        scaleX: this.scaleX_
      };
    }
  };

  return {
    UIState,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const EventSet = tr.model.EventSet;
  const SelectionState = tr.model.SelectionState;

  function BrushingState() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.selection_ = new EventSet();
    this.findMatches_ = new EventSet();
    this.analysisViewRelatedEvents_ = new EventSet();
    this.analysisLinkHoveredEvents_ = new EventSet();
    this.appliedToModel_ = undefined;
    this.viewSpecificBrushingStates_ = {};
  }
  BrushingState.prototype = {
    get guid() {
      return this.guid_;
    },

    clone() {
      const that = new BrushingState();
      that.selection_ = this.selection_;
      that.findMatches_ = this.findMatches_;
      that.analysisViewRelatedEvents_ = this.analysisViewRelatedEvents_;
      that.analysisLinkHoveredEvents_ = this.analysisLinkHoveredEvents_;
      that.viewSpecificBrushingStates_ = this.viewSpecificBrushingStates_;

      return that;
    },

    equals(that) {
      if (!this.selection_.equals(that.selection_)) {
        return false;
      }
      if (!this.findMatches_.equals(that.findMatches_)) {
        return false;
      }
      if (!this.analysisViewRelatedEvents_.equals(
          that.analysisViewRelatedEvents_)) {
        return false;
      }
      if (!this.analysisLinkHoveredEvents_.equals(
          that.analysisLinkHoveredEvents_)) {
        return false;
      }
      // We currently do not take the view-specific brushing states into
      // account. If we did, every change of the view-specific brushing state
      // of any view would cause a redraw of the whole UI (see the
      // BrushingStateController.currentBrushingState setter).
      return true;
    },

    get selectionOfInterest() {
      if (this.selection_.length) {
        return this.selection_;
      }

      if (this.highlight_.length) {
        return this.highlight_;
      }

      if (this.analysisViewRelatedEvents_.length) {
        return this.analysisViewRelatedEvents_;
      }

      if (this.analysisLinkHoveredEvents_.length) {
        return this.analysisLinkHoveredEvents_;
      }

      return this.selection_;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.appliedToModel_) {
        throw new Error('Cannot mutate this state right now');
      }
      if (selection === undefined) {
        selection = new EventSet();
      }
      this.selection_ = selection;
    },

    get findMatches() {
      return this.findMatches_;
    },

    set findMatches(findMatches) {
      if (this.appliedToModel_) {
        throw new Error('Cannot mutate this state right now');
      }
      if (findMatches === undefined) {
        findMatches = new EventSet();
      }
      this.findMatches_ = findMatches;
    },

    get analysisViewRelatedEvents() {
      return this.analysisViewRelatedEvents_;
    },

    set analysisViewRelatedEvents(analysisViewRelatedEvents) {
      if (this.appliedToModel_) {
        throw new Error('Cannot mutate this state right now');
      }
      if (analysisViewRelatedEvents === undefined) {
        analysisViewRelatedEvents = new EventSet();
      }
      this.analysisViewRelatedEvents_ = analysisViewRelatedEvents;
    },

    get analysisLinkHoveredEvents() {
      return this.analysisLinkHoveredEvents_;
    },

    set analysisLinkHoveredEvents(analysisLinkHoveredEvents) {
      if (this.appliedToModel_) {
        throw new Error('Cannot mutate this state right now');
      }
      if (analysisLinkHoveredEvents === undefined) {
        analysisLinkHoveredEvents = new EventSet();
      }
      this.analysisLinkHoveredEvents_ = analysisLinkHoveredEvents;
    },

    get isAppliedToModel() {
      return this.appliedToModel_ !== undefined;
    },

    get viewSpecificBrushingStates() {
      return this.viewSpecificBrushingStates_;
    },

    set viewSpecificBrushingStates(viewSpecificBrushingStates) {
      this.viewSpecificBrushingStates_ = viewSpecificBrushingStates;
    },

    get dimmedEvents_() {
      const dimmedEvents = new EventSet();
      dimmedEvents.addEventSet(this.findMatches);
      dimmedEvents.addEventSet(this.analysisViewRelatedEvents_);
      return dimmedEvents;
    },

    get brightenedEvents_() {
      const brightenedEvents = new EventSet();
      brightenedEvents.addEventSet(this.selection_);
      brightenedEvents.addEventSet(this.analysisLinkHoveredEvents_);
      return brightenedEvents;
    },

    /**
     * This function sets the SelectionStates according to these rules:
     *
     * - Events in ONE of findMatches or analysisViewRelatedEvents
     * are set to SelectionState.BRIGHTENED0.
     * - Events in BOTH of findMatches and analysisViewRelatedEvents
     * are set to SelectionState.BRIGHTENED1.
     * - Events in ONE of selection or analysisLinkHoveredEvents
     * are set to SelectionState.DIMMED1.
     * - Events in BOTH selection and analysisLinkHoveredEvents
     * are set to SelectionState.DIMMED2.
     * - Events not in any of the above are set to SelectionState.NONE
     * if there are no events in selection or analysisLinkHoveredEvents
     * (i.e. model is "default bright") or SelectionState.DIMMED0 (i.e.
     * model is "default dimmed").
     *
     * It is up to the caller to assure that all of the SelectionStates
     * are the same before calling this function. Normally,
     * this is done by calling unapplyFromModelSelectionState on the
     * old brushing state first.
     */
    applyToEventSelectionStates(model) {
      this.appliedToModel_ = model;

      const dimmedEvents = this.dimmedEvents_;

      // It's possible for this to get called with an undefined model pointer.
      // If so, skip adjusting the defaults.
      if (model) {
        const newDefaultState = (
            dimmedEvents.length ? SelectionState.DIMMED0 : SelectionState.NONE);

        // Since all the states are the same, we can get the current default
        // state by looking at the first element.
        const currentDefaultState = tr.b.getFirstElement(
            model.getDescendantEvents()).selectionState;

        // If the default state was changed, then we have to iterate through
        // and reset all the events to the new default state.
        if (currentDefaultState !== newDefaultState) {
          for (const e of model.getDescendantEvents()) {
            e.selectionState = newDefaultState;
          }
        }
      }

      // Now we apply the other rules above.
      let score;
      for (const e of dimmedEvents) {
        score = 0;
        if (this.findMatches_.contains(e)) {
          score++;
        }
        if (this.analysisViewRelatedEvents_.contains(e)) {
          score++;
        }
        e.selectionState = SelectionState.getFromDimmingLevel(score);
      }

      for (const e of this.brightenedEvents_) {
        score = 0;
        if (this.selection_.contains(e)) {
          score++;
        }
        if (this.analysisLinkHoveredEvents_.contains(e)) {
          score++;
        }
        e.selectionState = SelectionState.getFromBrighteningLevel(score);
      }
    },

    transferModelOwnershipToClone(that) {
      if (!this.appliedToModel_) {
        throw new Error('Not applied');
      }
      // Assumes this.equals(that).
      that.appliedToModel_ = this.appliedToModel_;
      this.appliedToModel_ = undefined;
    },

    /**
     * Unapplies this brushing state from the model selection state.
     * Resets all the SelectionStates to their default value (DIMMED0 or NONE)
     * and returns the default selection states. The caller should store this
     * value and pass it into applyFromModelSelectionStat when that is called.
     */
    unapplyFromEventSelectionStates() {
      if (!this.appliedToModel_) {
        throw new Error('Not applied');
      }
      const model = this.appliedToModel_;
      this.appliedToModel_ = undefined;

      const dimmedEvents = this.dimmedEvents_;
      const defaultState = (
          dimmedEvents.length ? SelectionState.DIMMED0 : SelectionState.NONE);

      for (const e of this.brightenedEvents_) {
        e.selectionState = defaultState;
      }
      for (const e of dimmedEvents) {
        e.selectionState = defaultState;
      }
      return defaultState;
    }
  };

  return {
    BrushingState,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  /**
   * Represents a procedural animation that can be run by an
   * tr.ui.b.AnimationController.
   *
   * @constructor
   */
  function Animation() {
  }

  Animation.prototype = {

    /**
     * Called when an animation has been queued after a running animation.
     *
     * @return {boolean} True if the animation can take on the responsibilities
     * of the running animation. If true, takeOverFor will be called on the
     * animation.
     *
     * This can be used to build animations that accelerate as pairs of them are
     * queued.
     */
    canTakeOverFor(existingAnimation) {
      throw new Error('Not implemented');
    },

    /**
     * Called to take over responsiblities of an existingAnimation.
     *
     * At this point, the existingAnimation has been ticked one last time, then
     * stopped. This animation will be started after this returns and has the
     * job of finishing(or transitioning away from) the effect the existing
     * animation was trying to accomplish.
     */
    takeOverFor(existingAnimation, newStartTimestamp, target) {
      throw new Error('Not implemented');
    },

    start(timestamp, target) {
      throw new Error('Not implemented');
    },

    /**
     * Called when an animation is stopped before it finishes. The animation can
     * do what it wants here, usually nothing.
     *
     * @param {Number} timestamp When the animation was stopped.
     * @param {Object} target The object being animated. May be undefined, take
     * care.
     * @param {boolean} willBeTakenOverByAnotherAnimation Whether this animation
     * is going to be handed to another animation's takeOverFor function.
     */
    didStopEarly(timestamp, target,
        willBeTakenOverByAnotherAnimation) {
    },

    /**
     * @return {boolean} true if the animation is finished.
     */
    tick(timestamp, target) {
      throw new Error('Not implemented');
    }
  };

  return {
    Animation,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  /**
   * Manages execution, queueing and blending of tr.ui.b.Animations against
   * a single target.
   *
   * Targets must have a cloneAnimationState() method that returns all the
   * animatable states of that target.
   *
   * @constructor
   * @extends {tr.b.EventTarget}
   */
  function AnimationController() {
    tr.b.EventTarget.call(this);

    this.target_ = undefined;

    this.activeAnimation_ = undefined;

    this.tickScheduled_ = false;
  }

  AnimationController.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    get target() {
      return this.target_;
    },

    set target(target) {
      if (this.activeAnimation_) {
        throw new Error('Cannot change target while animation is running.');
      }
      if (target.cloneAnimationState === undefined ||
          typeof target.cloneAnimationState !== 'function') {
        throw new Error('target must have a cloneAnimationState function');
      }

      this.target_ = target;
    },

    get activeAnimation() {
      return this.activeAnimation_;
    },

    get hasActiveAnimation() {
      return !!this.activeAnimation_;
    },

    queueAnimation(animation, opt_now) {
      if (this.target_ === undefined) {
        throw new Error('Cannot queue animations without a target');
      }

      let now;
      if (opt_now !== undefined) {
        now = opt_now;
      } else {
        now = window.performance.now();
      }

      if (this.activeAnimation_) {
        // Must tick the animation before stopping it case its about to stop,
        // and to update the target with its final sets of edits up to this
        // point.
        const done = this.activeAnimation_.tick(now, this.target_);
        if (done) {
          this.activeAnimation_ = undefined;
        }
      }

      if (this.activeAnimation_) {
        if (animation.canTakeOverFor(this.activeAnimation_)) {
          this.activeAnimation_.didStopEarly(now, this.target_, true);
          animation.takeOverFor(this.activeAnimation_, now, this.target_);
        } else {
          this.activeAnimation_.didStopEarly(now, this.target_, false);
        }
      }
      this.activeAnimation_ = animation;
      this.activeAnimation_.start(now, this.target_);

      if (this.tickScheduled_) return;
      this.tickScheduled_ = true;
      tr.b.requestAnimationFrame(this.tickActiveAnimation_, this);
    },

    cancelActiveAnimation(opt_now) {
      if (!this.activeAnimation_) return;
      let now;
      if (opt_now !== undefined) {
        now = opt_now;
      } else {
        now = window.performance.now();
      }
      this.activeAnimation_.didStopEarly(now, this.target_, false);
      this.activeAnimation_ = undefined;
    },

    tickActiveAnimation_(frameBeginTime) {
      this.tickScheduled_ = false;
      if (!this.activeAnimation_) return;

      if (this.target_ === undefined) {
        this.activeAnimation_.didStopEarly(frameBeginTime, this.target_, false);
        return;
      }

      const oldTargetState = this.target_.cloneAnimationState();

      const done = this.activeAnimation_.tick(frameBeginTime, this.target_);
      if (done) {
        this.activeAnimation_ = undefined;
      }

      if (this.activeAnimation_) {
        this.tickScheduled_ = true;
        tr.b.requestAnimationFrame(this.tickActiveAnimation_, this);
      }

      if (oldTargetState) {
        const e = new tr.b.Event('didtick');
        e.oldTargetState = oldTargetState;
        this.dispatchEvent(e, false, false);
      }
    }
  };

  return {
    AnimationController,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  function createSpan(opt_dictionary) {
    let ownerDocument = document;
    if (opt_dictionary && opt_dictionary.ownerDocument) {
      ownerDocument = opt_dictionary.ownerDocument;
    }
    const spanEl = ownerDocument.createElement('span');
    if (opt_dictionary) {
      if (opt_dictionary.className) {
        spanEl.className = opt_dictionary.className;
      }
      if (opt_dictionary.textContent) {
        Polymer.dom(spanEl).textContent =
            opt_dictionary.textContent;
      }
      if (opt_dictionary.tooltip) {
        spanEl.title = opt_dictionary.tooltip;
      }
      if (opt_dictionary.parent) {
        Polymer.dom(opt_dictionary.parent).appendChild(spanEl);
      }
      if (opt_dictionary.bold) {
        spanEl.style.fontWeight = 'bold';
      }
      if (opt_dictionary.italic) {
        spanEl.style.fontStyle = 'italic';
      }
      if (opt_dictionary.marginLeft) {
        spanEl.style.marginLeft = opt_dictionary.marginLeft;
      }
      if (opt_dictionary.marginRight) {
        spanEl.style.marginRight = opt_dictionary.marginRight;
      }
      if (opt_dictionary.backgroundColor) {
        spanEl.style.backgroundColor = opt_dictionary.backgroundColor;
      }
      if (opt_dictionary.color) {
        spanEl.style.color = opt_dictionary.color;
      }
    }
    return spanEl;
  }

  function createLink(opt_args) {
    let ownerDocument = document;
    if (opt_args && opt_args.ownerDocument) {
      ownerDocument = opt_args.ownerDocument;
    }
    const linkEl = ownerDocument.createElement('a');
    if (opt_args) {
      if (opt_args.href) linkEl.href = opt_args.href;
      if (opt_args.tooltip) linkEl.title = opt_args.tooltip;
      if (opt_args.color) linkEl.style.color = opt_args.color;
      if (opt_args.bold) linkEl.style.fontWeight = 'bold';
      if (opt_args.italic) linkEl.style.fontStyle = 'italic';
      if (opt_args.className) linkEl.className = opt_args.className;
      if (opt_args.parent) Polymer.dom(opt_args.parent).appendChild(linkEl);
      if (opt_args.marginLeft) linkEl.style.marginLeft = opt_args.marginLeft;
      if (opt_args.marginRight) linkEl.style.marginRight = opt_args.marginRight;
      if (opt_args.backgroundColor) {
        linkEl.style.backgroundColor = opt_args.backgroundColor;
      }
      if (opt_args.textContent) {
        Polymer.dom(linkEl).textContent = opt_args.textContent;
      }
    }
    return linkEl;
  }

  function createDiv(opt_dictionary) {
    const divEl = document.createElement('div');
    if (opt_dictionary) {
      if (opt_dictionary.className) {
        divEl.className = opt_dictionary.className;
      }
      if (opt_dictionary.parent) {
        Polymer.dom(opt_dictionary.parent).appendChild(divEl);
      }
      if (opt_dictionary.textContent) {
        Polymer.dom(divEl).textContent =
            opt_dictionary.textContent;
      }
      if (opt_dictionary.maxWidth) {
        divEl.style.maxWidth = opt_dictionary.maxWidth;
      }
    }
    return divEl;
  }

  function createScopedStyle(styleContent) {
    const styleEl = document.createElement('style');
    styleEl.scoped = true;
    Polymer.dom(styleEl).innerHTML = styleContent;
    return styleEl;
  }

  function valuesEqual(a, b) {
    if (a instanceof Array && b instanceof Array) {
      return a.length === b.length && JSON.stringify(a) === JSON.stringify(b);
    }
    return a === b;
  }

  function createSelector(
      targetEl, targetElProperty,
      settingsKey, defaultValue,
      items, opt_namespace) {
    let defaultValueIndex;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (valuesEqual(item.value, defaultValue)) {
        defaultValueIndex = i;
        break;
      }
    }
    if (defaultValueIndex === undefined) {
      throw new Error('defaultValue must be in the items list');
    }

    const selectorEl = document.createElement('select');
    selectorEl.addEventListener('change', onChange);
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const optionEl = document.createElement('option');
      Polymer.dom(optionEl).textContent = item.label;
      optionEl.targetPropertyValue = item.value;
      optionEl.item = item;
      Polymer.dom(selectorEl).appendChild(optionEl);
    }
    function onChange(e) {
      const value = selectorEl.selectedOptions[0].targetPropertyValue;
      tr.b.Settings.set(settingsKey, value, opt_namespace);
      targetEl[targetElProperty] = value;
    }
    const oldSetter = targetEl.__lookupSetter__('selectedIndex');
    selectorEl.__defineGetter__('selectedValue', function(v) {
      return selectorEl.children[selectorEl.selectedIndex].targetPropertyValue;
    });
    selectorEl.__defineGetter__('selectedItem', function(v) {
      return selectorEl.children[selectorEl.selectedIndex].item;
    });
    selectorEl.__defineSetter__('selectedValue', function(v) {
      for (let i = 0; i < selectorEl.children.length; i++) {
        const value = selectorEl.children[i].targetPropertyValue;
        if (valuesEqual(value, v)) {
          const changed = selectorEl.selectedIndex !== i;
          if (changed) {
            selectorEl.selectedIndex = i;
            onChange();
          }
          return;
        }
      }
      throw new Error('Not a valid value');
    });

    const initialValue = tr.b.Settings.get(
        settingsKey, defaultValue, opt_namespace);
    let didSet = false;
    for (let i = 0; i < selectorEl.children.length; i++) {
      if (valuesEqual(selectorEl.children[i].targetPropertyValue,
          initialValue)) {
        didSet = true;
        targetEl[targetElProperty] = initialValue;
        selectorEl.selectedIndex = i;
        break;
      }
    }
    if (!didSet) {
      selectorEl.selectedIndex = defaultValueIndex;
      targetEl[targetElProperty] = defaultValue;
    }

    return selectorEl;
  }

  function createEditCategorySpan(optionGroupEl, targetEl) {
    const spanEl = createSpan({className: 'edit-categories'});
    Polymer.dom(spanEl).textContent = 'Edit categories';
    Polymer.dom(spanEl).classList.add('labeled-option');

    spanEl.addEventListener('click', function() {
      targetEl.onClickEditCategories();
    });
    return spanEl;
  }

  function createOptionGroup(targetEl, targetElProperty,
      settingsKey, defaultValue,
      items) {
    function onChange() {
      let value = [];
      if (this.value.length) {
        value = this.value.split(',');
      }
      tr.b.Settings.set(settingsKey, value);
      targetEl[targetElProperty] = value;
    }

    const optionGroupEl = createSpan({className: 'labeled-option-group'});
    const initialValue = tr.b.Settings.get(settingsKey, defaultValue);
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      const id = 'category-preset-' + item.label.replace(/ /g, '-');

      const radioEl = document.createElement('input');
      radioEl.type = 'radio';
      Polymer.dom(radioEl).setAttribute('id', id);
      Polymer.dom(radioEl).setAttribute('name', 'category-presets-group');
      Polymer.dom(radioEl).setAttribute('value', item.value);
      radioEl.addEventListener('change', onChange.bind(radioEl, targetEl,
          targetElProperty,
          settingsKey));
      if (valuesEqual(initialValue, item.value)) {
        radioEl.checked = true;
      }

      const labelEl = document.createElement('label');
      Polymer.dom(labelEl).textContent = item.label;
      Polymer.dom(labelEl).setAttribute('for', id);

      const spanEl = createSpan({className: 'labeled-option'});
      Polymer.dom(spanEl).appendChild(radioEl);
      Polymer.dom(spanEl).appendChild(labelEl);

      spanEl.__defineSetter__('checked', function(opt_bool) {
        const changed = radioEl.checked !== (!!opt_bool);
        if (!changed) return;

        radioEl.checked = !!opt_bool;
        onChange();
      });
      spanEl.__defineGetter__('checked', function() {
        return radioEl.checked;
      });

      Polymer.dom(optionGroupEl).appendChild(spanEl);
    }
    Polymer.dom(optionGroupEl).appendChild(
        createEditCategorySpan(optionGroupEl, targetEl));
    // Since this option group element is not yet added to the tree,
    // querySelector will fail during updateEditCategoriesStatus_ call.
    // Hence, creating the element with the 'expanded' classlist category
    // added, if last selected value was 'Manual' selection.
    if (!initialValue.length) {
      Polymer.dom(optionGroupEl).classList.add('categories-expanded');
    }
    targetEl[targetElProperty] = initialValue;

    return optionGroupEl;
  }

  let nextCheckboxId = 1;
  function createCheckBox(targetEl, targetElProperty,
      settingsKey, defaultValue,
      label, opt_changeCb) {
    const buttonEl = document.createElement('input');
    buttonEl.type = 'checkbox';

    let initialValue = defaultValue;
    if (settingsKey !== undefined) {
      initialValue = tr.b.Settings.get(settingsKey, defaultValue);
      buttonEl.checked = !!initialValue;
    }
    if (targetEl) {
      targetEl[targetElProperty] = initialValue;
    }

    function onChange() {
      if (settingsKey !== undefined) {
        tr.b.Settings.set(settingsKey, buttonEl.checked);
      }
      if (targetEl) {
        targetEl[targetElProperty] = buttonEl.checked;
      }
      if (opt_changeCb) {
        opt_changeCb.call();
      }
    }

    buttonEl.addEventListener('change', onChange);

    const id = '#checkbox-' + nextCheckboxId++;

    const spanEl = createSpan({className: 'labeled-checkbox'});
    Polymer.dom(buttonEl).setAttribute('id', id);

    const labelEl = document.createElement('label');
    Polymer.dom(labelEl).textContent = label;
    Polymer.dom(labelEl).setAttribute('for', id);
    Polymer.dom(spanEl).appendChild(buttonEl);
    Polymer.dom(spanEl).appendChild(labelEl);

    spanEl.__defineSetter__('checked', function(opt_bool) {
      const changed = buttonEl.checked !== (!!opt_bool);
      if (!changed) return;

      buttonEl.checked = !!opt_bool;
      onChange();
    });
    spanEl.__defineGetter__('checked', function() {
      return buttonEl.checked;
    });

    return spanEl;
  }

  /**
   * @param {!string} label
   * @param {function()=} opt_callback
   * @param {*=} opt_this
   */
  function createButton(label, opt_callback, opt_this) {
    const buttonEl = document.createElement('input');
    buttonEl.type = 'button';
    buttonEl.value = label;

    function onClick() {
      opt_callback.call(opt_this || buttonEl);
    }

    if (opt_callback) {
      buttonEl.addEventListener('click', onClick);
    }

    return buttonEl;
  }

  function createTextInput(
      targetEl, targetElProperty, settingsKey, defaultValue) {
    const initialValue = tr.b.Settings.get(settingsKey, defaultValue);
    const el = document.createElement('input');
    el.type = 'text';
    function onChange(e) {
      tr.b.Settings.set(settingsKey, el.value);
      targetEl[targetElProperty] = el.value;
    }
    el.addEventListener('input', onChange);
    el.value = initialValue;
    targetEl[targetElProperty] = initialValue;

    return el;
  }

  function isElementAttachedToDocument(el) {
    let cur = el;
    while (Polymer.dom(cur).parentNode) {
      cur = Polymer.dom(cur).parentNode;
    }
    return (cur === el.ownerDocument || cur.nodeName === '#document-fragment');
  }

  function asHTMLOrTextNode(value, opt_ownerDocument) {
    if (value instanceof Node) {
      return value;
    }
    const ownerDocument = opt_ownerDocument || document;
    return ownerDocument.createTextNode(value);
  }

  return {
    createSpan,
    createLink,
    createDiv,
    createScopedStyle,
    createSelector,
    createOptionGroup,
    createCheckBox,
    createButton,
    createTextInput,
    isElementAttachedToDocument,
    asHTMLOrTextNode,
  };
});


'use strict';

/**
 * @fileoverview Provides a caching layer for elided text values.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * Cache for elided strings.
   * Moved from the ElidedTitleCache protoype to a "global" for speed
   * (variable reference is 100x faster).
   *   key: String we wish to elide.
   *   value: Another dict whose key is width
   *     and value is an ElidedStringWidthPair.
   */
  const elidedTitleCacheDict = new Map();
  const elidedTitleCache = new ElidedTitleCache();

  /**
   * A cache for elided strings.
   * @constructor
   */
  function ElidedTitleCache() {
    // TODO(jrg): possibly obsoleted with the elided string cache.
    // Consider removing.
    this.textWidthMap = new Map();
  }

  ElidedTitleCache.prototype = {
    /**
     * Return elided text.
     *
     * @param {ctx} Context The graphics context.
     * @param {pixWidth} Pixel width.
     * @param {title} Original title text.
     * @param {width} Drawn width in world coords.
     * @param {sliceDuration} Where the title must fit (in world coords).
     * @return {ElidedStringWidthPair} Elided string and width.
     */
    get(ctx, pixWidth, title, width, sliceDuration) {
      let elidedDict = elidedTitleCacheDict.get(title);
      if (!elidedDict) {
        elidedDict = new Map();
        elidedTitleCacheDict.set(title, elidedDict);
      }

      let elidedDictForPixWidth = elidedDict.get(pixWidth);
      if (!elidedDictForPixWidth) {
        elidedDict.set(pixWidth, new Map());
        elidedDictForPixWidth = elidedDict.get(pixWidth);
      }

      let stringWidthPair = elidedDictForPixWidth.get(sliceDuration);
      if (stringWidthPair === undefined) {
        let newtitle = title;
        let elided = false;
        while (this.labelWidthWorld(ctx, newtitle, pixWidth) > sliceDuration) {
          if (newtitle.length * 0.75 < 1) break;
          newtitle = newtitle.substring(0, newtitle.length * 0.75);
          elided = true;
        }

        if (elided && newtitle.length > 3) {
          newtitle = newtitle.substring(0, newtitle.length - 3) + '...';
        }

        stringWidthPair = new ElidedStringWidthPair(
            newtitle, this.labelWidth(ctx, newtitle));
        elidedDictForPixWidth.set(sliceDuration, stringWidthPair);
      }
      return stringWidthPair;
    },

    quickMeasureText_(ctx, text) {
      let w = this.textWidthMap.get(text);
      if (!w) {
        w = ctx.measureText(text).width;
        this.textWidthMap.set(text, w);
      }
      return w;
    },

    labelWidth(ctx, title) {
      return this.quickMeasureText_(ctx, title) + 2;
    },

    labelWidthWorld(ctx, title, pixWidth) {
      return this.labelWidth(ctx, title) * pixWidth;
    }
  };

  /**
   * A pair representing an elided string and world-coordinate width
   * to draw it.
   * @constructor
   */
  function ElidedStringWidthPair(string, width) {
    this.string = string;
    this.width = width;
  }

  return {
    ElidedTitleCache,
  };
});


'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
tr.exportTo('tr.ui.b', function() {
  const ColorScheme = tr.b.ColorScheme;

  const colors = ColorScheme.colors;
  const colorsAsStrings = ColorScheme.colorsAsStrings;

  const SelectionState = tr.model.SelectionState;

  /**
   * Provides methods to get view values for events.
   */
  const EventPresenter = {
    getSelectableItemColorAsString(item) {
      const offset = this.getColorIdOffset_(item);
      const colorId = ColorScheme.getVariantColorId(item.colorId, offset);
      return colorsAsStrings[colorId];
    },

    getColorIdOffset_(event) {
      return event.selectionState;
    },

    getTextColor(event) {
      if (event.selectionState === SelectionState.DIMMED) {
        return 'rgb(60,60,60)';
      }
      return 'rgb(0,0,0)';
    },

    getSliceColorId(slice) {
      const offset = this.getColorIdOffset_(slice);
      return ColorScheme.getVariantColorId(slice.colorId, offset);
    },

    getSliceAlpha(slice, async) {
      let alpha = 1;
      if (async) {
        alpha *= 0.3;
      }
      return alpha;
    },

    getInstantSliceColor(instant) {
      const offset = this.getColorIdOffset_(instant);
      const colorId = ColorScheme.getVariantColorId(instant.colorId, offset);
      return colors[colorId].toStringWithAlphaOverride(1.0);
    },

    getObjectInstanceColor(instance) {
      const offset = this.getColorIdOffset_(instance);
      const colorId = ColorScheme.getVariantColorId(instance.colorId, offset);
      return colors[colorId].toStringWithAlphaOverride(0.25);
    },

    getObjectSnapshotColor(snapshot) {
      const offset = this.getColorIdOffset_(snapshot);
      let colorId = snapshot.objectInstance.colorId;
      colorId = ColorScheme.getVariantColorId(colorId, offset);
      return colors[colorId];
    },

    getCounterSeriesColor(colorId, selectionState,
        opt_alphaMultiplier) {
      const event = {selectionState};
      const offset = this.getColorIdOffset_(event);
      const c = colors[ColorScheme.getVariantColorId(colorId, offset)];
      return c.toStringWithAlphaOverride(
          opt_alphaMultiplier !== undefined ? opt_alphaMultiplier : 1.0);
    },

    getBarSnapshotColor(snapshot, offset) {
      const snapshotOffset = this.getColorIdOffset_(snapshot);
      let colorId = snapshot.objectInstance.colorId;
      colorId = ColorScheme.getAnotherColorId(colorId, offset);
      colorId = ColorScheme.getVariantColorId(colorId, snapshotOffset);
      return colors[colorId].toStringWithAlphaOverride(1.0);
    }
  };

  return {
    EventPresenter,
  };
});


'use strict';

/**
 * @fileoverview Provides various helper methods for drawing to a provided
 * canvas.
 */
tr.exportTo('tr.ui.b', function() {
  const elidedTitleCache = new tr.ui.b.ElidedTitleCache();
  const ColorScheme = tr.b.ColorScheme;
  const colorsAsStrings = ColorScheme.colorsAsStrings;

  const EventPresenter = tr.ui.b.EventPresenter;
  const blackColorId = ColorScheme.getColorIdForReservedName('black');

  /**
   * This value is used to allow for consistent style UI elements.
   * Thread time visualisation uses a smaller rectangle that has this height.
   * @const
   */
  const THIN_SLICE_HEIGHT = 4;

  /**
   * This value is used to for performance considerations when drawing large
   * zoomed out traces that feature cpu time in the slices. If the waiting
   * width is less than the threshold, we only draw the rectangle as a solid.
   * @const
   */
  const SLICE_WAITING_WIDTH_DRAW_THRESHOLD = 3;

  /**
   * If the slice has mostly been waiting to be scheduled on the cpu, the
   * wall clock will be far greater than the cpu clock. Draw the slice
   * only as an idle slice, if the active width is not thicker than the
   * threshold.
   * @const
   */
  const SLICE_ACTIVE_WIDTH_DRAW_THRESHOLD = 1;

  /**
   * Should we elide text on trace labels?
   * Without eliding, text that is too wide isn't drawn at all.
   * Disable if you feel this causes a performance problem.
   * This is a default value that can be overridden in tracks for testing.
   * @const
   */
  const SHOULD_ELIDE_TEXT = true;

  /**
   * Draw the define line into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The start x position of the line.
   * @param {float} y1 The start y position of the line.
   * @param {float} x2 The end x position of the line.
   * @param {float} y2 The end y position of the line.
   */
  function drawLine(ctx, x1, y1, x2, y2) {
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
  }

  /**
   * Draw the defined triangle into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The first corner x.
   * @param {float} y1 The first corner y.
   * @param {float} x2 The second corner x.
   * @param {float} y2 The second corner y.
   * @param {float} x3 The third corner x.
   * @param {float} y3 The third corner y.
   */
  function drawTriangle(ctx, x1, y1, x2, y2, x3, y3) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
  }

  /**
   * Draw an arrow into |ctx|.
   *
   * @param {Context} ctx The context to draw into.
   * @param {float} x1 The shaft x.
   * @param {float} y1 The shaft y.
   * @param {float} x2 The head x.
   * @param {float} y2 The head y.
   * @param {float} arrowLength The length of the head.
   * @param {float} arrowWidth The width of the head.
   */
  function drawArrow(ctx, x1, y1, x2, y2, arrowLength, arrowWidth) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const perc = (len - arrowLength) / len;
    const bx = x1 + perc * dx;
    const by = y1 + perc * dy;
    const ux = dx / len;
    const uy = dy / len;
    const ax = uy * arrowWidth;
    const ay = -ux * arrowWidth;

    ctx.beginPath();
    drawLine(ctx, x1, y1, x2, y2);
    ctx.stroke();

    drawTriangle(ctx,
        bx + ax, by + ay,
        x2, y2,
        bx - ax, by - ay);
    ctx.fill();
  }

  /**
   * Draw the provided slices to the screen.
   *
   * Each of the elements in |slices| must provide the follow methods:
   *   * start
   *   * duration
   *   * colorId
   *   * selected
   *
   * @param {Context} ctx The canvas context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {float} viewHeight The height of the viewport.
   * @param {Array} slices The slices to draw.
   * @param {bool} async Whether the slices are drawn with async style.
   */
  function drawSlices(ctx, dt, viewLWorld, viewRWorld, viewHeight, slices,
      async) {
    const pixelRatio = window.devicePixelRatio || 1;
    const height = viewHeight * pixelRatio;
    const viewL = dt.xWorldToView(viewLWorld);
    const viewR = dt.xWorldToView(viewRWorld);

    let darkRectHeight = THIN_SLICE_HEIGHT * pixelRatio;

    // Not enough space for both colors, use light color only.
    if (height < darkRectHeight) {
      darkRectHeight = 0;
    }

    const lightRectHeight = height - darkRectHeight;

    ctx.save();
    const rect = new tr.ui.b.FastRectRenderer(
        ctx, viewL, viewR, 2, 2, colorsAsStrings);
    rect.setYandH(0, height);

    const lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start + slice.duration; },
        viewLWorld);

    let hadTopLevel = false;

    for (let i = lowSlice; i < slices.length; ++i) {
      const slice = slices[i];
      const x = slice.start;
      if (x > viewRWorld) break;

      const xView = dt.xWorldToView(x);
      let wView = 1;
      if (slice.duration > 0) {
        const w = Math.max(slice.duration, 0.000001);
        wView = Math.max(dt.xWorldVectorToView(w), 1);
      }

      const colorId = EventPresenter.getSliceColorId(slice);
      const alpha = EventPresenter.getSliceAlpha(slice, async);
      const lightAlpha = alpha * 0.70;

      if (async && slice.isTopLevel) {
        rect.setYandH(3, height - 3);
        hadTopLevel = true;
      } else {
        rect.setYandH(0, height);
      }

      // If cpuDuration is available, draw rectangles proportional to the
      // amount of cpu time taken.
      if (!slice.cpuDuration) {
        // No cpuDuration available, draw using only one alpha.
        rect.fillRect(xView, wView, colorId, alpha);
        continue;
      }

      let activeWidth = wView * (slice.cpuDuration / slice.duration);
      let waitingWidth = wView - activeWidth;

      // Check if we have enough screen space to draw the whole slice, with
      // both color tones.
      //
      // Truncate the activeWidth to 0 if it is less than 'threshold' pixels.
      if (activeWidth < SLICE_ACTIVE_WIDTH_DRAW_THRESHOLD) {
        activeWidth = 0;
        waitingWidth = wView;
      }

      // Truncate the waitingWidth to 0 if it is less than 'threshold' pixels.
      if (waitingWidth < SLICE_WAITING_WIDTH_DRAW_THRESHOLD) {
        activeWidth = wView;
        waitingWidth = 0;
      }

      // We now draw the two rectangles making up the event slice.
      // NOTE: The if statements are necessary for performance considerations.
      // We do not want to force draws, if the width of the rectangle is 0.
      //
      // First draw the solid color, representing the 'active' part.
      if (activeWidth > 0) {
        rect.fillRect(xView, activeWidth, colorId, alpha);
      }

      // Next draw the two toned 'idle' part.
      // NOTE: We subtract 1 from the left-hand edge and draw one extra pixel to
      // prevent drawing artifacts. Without this, the two parts of the slice
      // ('active' and 'idle') may appear split apart.
      if (waitingWidth > 0) {
        // First draw the light toned top part.
        rect.setYandH(0, lightRectHeight);
        rect.fillRect(xView + activeWidth - 1,
            waitingWidth + 1, colorId, lightAlpha);
        // Then the solid bottom half.
        rect.setYandH(lightRectHeight, darkRectHeight);
        rect.fillRect(xView + activeWidth - 1,
            waitingWidth + 1, colorId, alpha);
        // Reset for the next slice.
        rect.setYandH(0, height);
      }
    }
    rect.flush();

    if (async && hadTopLevel) {
      // Draw a top border over async slices in order to visually separate
      // them from events above it.
      // See https://github.com/google/trace-viewer/issues/725.
      rect.setYandH(2, 1);
      for (let i = lowSlice; i < slices.length; ++i) {
        const slice = slices[i];
        const x = slice.start;
        if (x > viewRWorld) break;

        if (!slice.isTopLevel) continue;

        const xView = dt.xWorldToView(x);
        let wView = 1;
        if (slice.duration > 0) {
          const w = Math.max(slice.duration, 0.000001);
          wView = Math.max(dt.xWorldVectorToView(w), 1);
        }

        rect.fillRect(xView, wView, blackColorId, 0.7);
      }
      rect.flush();
    }

    ctx.restore();
  }

  /**
   * Draw the provided instant slices as lines to the screen.
   *
   * Each of the elements in |slices| must provide the follow methods:
   *   * start
   *   * duration with value of 0.
   *   * colorId
   *   * selected
   *
   * @param {Context} ctx The canvas context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {float} viewHeight The height of the viewport.
   * @param {Array} slices The slices to draw.
   * @param {Numer} lineWidthInPixels The width of the lines.
   */
  function drawInstantSlicesAsLines(
      ctx, dt, viewLWorld, viewRWorld, viewHeight, slices, lineWidthInPixels) {
    const pixelRatio = window.devicePixelRatio || 1;
    const height = viewHeight * pixelRatio;

    ctx.save();
    ctx.lineWidth = lineWidthInPixels * pixelRatio;

    const lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start; },
        viewLWorld);

    for (let i = lowSlice; i < slices.length; ++i) {
      const slice = slices[i];
      const x = slice.start;
      if (x > viewRWorld) break;

      ctx.strokeStyle = EventPresenter.getInstantSliceColor(slice);

      const xView = dt.xWorldToView(x);

      ctx.beginPath();
      ctx.moveTo(xView, 0);
      ctx.lineTo(xView, height);
      ctx.stroke();
    }
    ctx.restore();
  }

  /**
   * Draws the labels for the given slices.
   *
   * The |slices| array must contain objects with the following API:
   *   * start
   *   * duration
   *   * title
   *   * didNotFinish (optional)
   *
   * @param {Context} ctx The graphics context.
   * @param {TimelineDrawTransform} dt The draw transform.
   * @param {float} viewLWorld The left most point of the world viewport.
   * @param {float} viewRWorld The right most point of the world viewport.
   * @param {Array} slices The slices to label.
   * @param {bool} async Whether the slice labels are drawn with async style.
   * @param {float} fontSize The font size.
   * @param {float} yOffset The font offset.
   */
  function drawLabels(ctx, dt, viewLWorld, viewRWorld, slices, async,
      fontSize, yOffset) {
    const pixelRatio = window.devicePixelRatio || 1;
    const pixWidth = dt.xViewVectorToWorld(1);

    ctx.save();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = (fontSize * pixelRatio) + 'px sans-serif';

    if (async) {
      ctx.font = 'italic ' + ctx.font;
    }

    const cY = yOffset * pixelRatio;

    const lowSlice = tr.b.findLowIndexInSortedArray(
        slices,
        function(slice) { return slice.start + slice.duration; },
        viewLWorld);

    // Don't render text until it is 20px wide
    const quickDiscardThreshold = pixWidth * 20;
    for (let i = lowSlice; i < slices.length; ++i) {
      const slice = slices[i];
      if (slice.start > viewRWorld) break;

      if (slice.duration <= quickDiscardThreshold) continue;

      // Clip slice boundaries to viewport.
      const xLeftClipped = Math.max(slice.start, viewLWorld);
      const xRightClipped = Math.min(slice.start + slice.duration, viewRWorld);
      const visibleWidth = xRightClipped - xLeftClipped;

      const title = slice.title +
          (slice.didNotFinish ? ' (Did Not Finish)' : '');

      let drawnTitle = title;
      let drawnWidth = elidedTitleCache.labelWidth(ctx, drawnTitle);
      const fullLabelWidth = elidedTitleCache.labelWidthWorld(
          ctx, drawnTitle, pixWidth);
      if (SHOULD_ELIDE_TEXT && fullLabelWidth > visibleWidth) {
        const elidedValues = elidedTitleCache.get(
            ctx, pixWidth,
            drawnTitle, drawnWidth,
            visibleWidth);
        drawnTitle = elidedValues.string;
        drawnWidth = elidedValues.width;
      }

      if (drawnWidth * pixWidth < visibleWidth) {
        ctx.fillStyle = EventPresenter.getTextColor(slice);
        const cX = dt.xWorldToView((xLeftClipped + xRightClipped) / 2);
        ctx.fillText(drawnTitle, cX, cY, drawnWidth);
      }
    }
    ctx.restore();
  }

  return {
    drawSlices,
    drawInstantSlicesAsLines,
    drawLabels,

    drawLine,
    drawTriangle,
    drawArrow,

    elidedTitleCache_: elidedTitleCache,

    THIN_SLICE_HEIGHT,
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  function TimelineDisplayTransform(opt_that) {
    if (opt_that) {
      this.set(opt_that);
      return;
    }
    this.scaleX = 1;
    this.panX = 0;
    this.panY = 0;
  }

  TimelineDisplayTransform.prototype = {
    set(that) {
      this.scaleX = that.scaleX;
      this.panX = that.panX;
      this.panY = that.panY;
    },

    clone() {
      return new TimelineDisplayTransform(this);
    },

    equals(that) {
      let eq = true;
      if (that === undefined || that === null) {
        return false;
      }
      eq &= this.panX === that.panX;
      eq &= this.panY === that.panY;
      eq &= this.scaleX === that.scaleX;
      return !!eq;
    },

    almostEquals(that) {
      let eq = true;
      if (that === undefined || that === null) {
        return false;
      }
      eq &= Math.abs(this.panX - that.panX) < 0.001;
      eq &= Math.abs(this.panY - that.panY) < 0.001;
      eq &= Math.abs(this.scaleX - that.scaleX) < 0.001;
      return !!eq;
    },

    incrementPanXInViewUnits(xDeltaView) {
      this.panX += this.xViewVectorToWorld(xDeltaView);
    },

    xPanWorldPosToViewPos(worldX, viewX, viewWidth) {
      if (typeof viewX === 'string') {
        if (viewX === 'left') {
          viewX = 0;
        } else if (viewX === 'center') {
          viewX = viewWidth / 2;
        } else if (viewX === 'right') {
          viewX = viewWidth - 1;
        } else {
          throw new Error('viewX must be left|center|right or number.');
        }
      }
      this.panX = (viewX / this.scaleX) - worldX;
    },

    xPanWorldBoundsIntoView(worldMin, worldMax, viewWidth) {
      if (this.xWorldToView(worldMin) < 0) {
        this.xPanWorldPosToViewPos(worldMin, 'left', viewWidth);
      } else if (this.xWorldToView(worldMax) > viewWidth) {
        this.xPanWorldPosToViewPos(worldMax, 'right', viewWidth);
      }
    },

    xSetWorldBounds(worldMin, worldMax, viewWidth) {
      const worldWidth = worldMax - worldMin;
      const scaleX = viewWidth / worldWidth;
      const panX = -worldMin;
      this.setPanAndScale(panX, scaleX);
    },

    setPanAndScale(p, s) {
      this.scaleX = s;
      this.panX = p;
    },

    xWorldToView(x) {
      return (x + this.panX) * this.scaleX;
    },

    xWorldVectorToView(x) {
      return x * this.scaleX;
    },

    xViewToWorld(x) {
      return (x / this.scaleX) - this.panX;
    },

    xViewVectorToWorld(x) {
      return x / this.scaleX;
    }
  };

  return {
    TimelineDisplayTransform,
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  /**
   * @constructor
   */
  function SnapIndicator(y, height) {
    this.y = y;
    this.height = height;
  }

  /**
   * The interesting part of the world.
   *
   * @constructor
   */
  function TimelineInterestRange(vp) {
    this.viewport_ = vp;

    this.range_ = new tr.b.math.Range();

    this.leftSelected_ = false;
    this.rightSelected_ = false;

    this.leftSnapIndicator_ = undefined;
    this.rightSnapIndicator_ = undefined;
  }

  TimelineInterestRange.prototype = {
    get isEmpty() {
      return this.range_.isEmpty;
    },

    reset() {
      this.range_.reset();
      this.leftSelected_ = false;
      this.rightSelected_ = false;
      this.leftSnapIndicator_ = undefined;
      this.rightSnapIndicator_ = undefined;
      this.viewport_.dispatchChangeEvent();
    },

    get min() {
      return this.range_.min;
    },

    set min(min) {
      this.range_.min = min;
      this.viewport_.dispatchChangeEvent();
    },

    get max() {
      return this.range_.max;
    },

    set max(max) {
      this.range_.max = max;
      this.viewport_.dispatchChangeEvent();
    },

    set(range) {
      this.range_.reset();
      this.range_.addRange(range);
      this.viewport_.dispatchChangeEvent();
    },

    setMinAndMax(min, max) {
      this.range_.min = min;
      this.range_.max = max;
      this.viewport_.dispatchChangeEvent();
    },

    get range() {
      return this.range_.range;
    },

    asRangeObject() {
      const range = new tr.b.math.Range();
      range.addRange(this.range_);
      return range;
    },

    get leftSelected() {
      return this.leftSelected_;
    },

    set leftSelected(leftSelected) {
      if (this.leftSelected_ === leftSelected) return;

      this.leftSelected_ = leftSelected;
      this.viewport_.dispatchChangeEvent();
    },

    get rightSelected() {
      return this.rightSelected_;
    },

    set rightSelected(rightSelected) {
      if (this.rightSelected_ === rightSelected) return;

      this.rightSelected_ = rightSelected;
      this.viewport_.dispatchChangeEvent();
    },

    get leftSnapIndicator() {
      return this.leftSnapIndicator_;
    },

    set leftSnapIndicator(leftSnapIndicator) {
      this.leftSnapIndicator_ = leftSnapIndicator;
      this.viewport_.dispatchChangeEvent();
    },

    get rightSnapIndicator() {
      return this.rightSnapIndicator_;
    },

    set rightSnapIndicator(rightSnapIndicator) {
      this.rightSnapIndicator_ = rightSnapIndicator;
      this.viewport_.dispatchChangeEvent();
    },

    draw(ctx, viewLWorld, viewRWorld) {
      if (this.range_.isEmpty) return;

      const dt = this.viewport_.currentDisplayTransform;

      const markerLWorld = this.min;
      const markerRWorld = this.max;

      const markerLView = Math.round(dt.xWorldToView(markerLWorld));
      const markerRView = Math.round(dt.xWorldToView(markerRWorld));

      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      if (markerLWorld > viewLWorld) {
        ctx.fillRect(dt.xWorldToView(viewLWorld), 0,
            markerLView, ctx.canvas.height);
      }

      if (markerRWorld < viewRWorld) {
        ctx.fillRect(markerRView, 0,
            dt.xWorldToView(viewRWorld), ctx.canvas.height);
      }

      const pixelRatio = window.devicePixelRatio || 1;
      ctx.lineWidth = Math.round(pixelRatio);
      if (this.range_.range > 0) {
        this.drawLine_(ctx, viewLWorld, viewRWorld,
            ctx.canvas.height, this.min, this.leftSelected_);
        this.drawLine_(ctx, viewLWorld, viewRWorld,
            ctx.canvas.height, this.max, this.rightSelected_);
      } else {
        this.drawLine_(ctx, viewLWorld, viewRWorld,
            ctx.canvas.height, this.min,
            this.leftSelected_ || this.rightSelected_);
      }
      ctx.lineWidth = 1;
    },

    drawLine_(ctx, viewLWorld, viewRWorld, height, ts, selected) {
      if (ts < viewLWorld || ts >= viewRWorld) return;

      const dt = this.viewport_.currentDisplayTransform;
      const viewX = Math.round(dt.xWorldToView(ts));

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      tr.ui.b.drawLine(ctx, viewX, 0, viewX, height);
      if (selected) {
        ctx.strokeStyle = 'rgb(255, 0, 0)';
      } else {
        ctx.strokeStyle = 'rgb(0, 0, 0)';
      }
      ctx.stroke();

      ctx.restore();
    },

    drawIndicators(ctx, viewLWorld, viewRWorld) {
      if (this.leftSnapIndicator_) {
        this.drawIndicator_(ctx, viewLWorld, viewRWorld,
            this.range_.min,
            this.leftSnapIndicator_,
            this.leftSelected_);
      }
      if (this.rightSnapIndicator_) {
        this.drawIndicator_(ctx, viewLWorld, viewRWorld,
            this.range_.max,
            this.rightSnapIndicator_,
            this.rightSelected_);
      }
    },

    drawIndicator_(ctx, viewLWorld, viewRWorld,
        xWorld, si, selected) {
      const dt = this.viewport_.currentDisplayTransform;

      const viewX = Math.round(dt.xWorldToView(xWorld));

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      const pixelRatio = window.devicePixelRatio || 1;
      const viewY = si.y * devicePixelRatio;
      const viewHeight = si.height * devicePixelRatio;
      const arrowSize = 4 * pixelRatio;

      if (selected) {
        ctx.fillStyle = 'rgb(255, 0, 0)';
      } else {
        ctx.fillStyle = 'rgb(0, 0, 0)';
      }
      tr.ui.b.drawTriangle(ctx,
          viewX - arrowSize * 0.75, viewY,
          viewX + arrowSize * 0.75, viewY,
          viewX, viewY + arrowSize);
      ctx.fill();
      tr.ui.b.drawTriangle(ctx,
          viewX - arrowSize * 0.75, viewY + viewHeight,
          viewX + arrowSize * 0.75, viewY + viewHeight,
          viewX, viewY + viewHeight - arrowSize);
      ctx.fill();

      ctx.restore();
    }
  };

  return {
    SnapIndicator,
    TimelineInterestRange,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * ContainerToTrackMap is a class to handle building and accessing a map
   * between an EventContainer's stableId and its handling track.
   *
   * @constructor
   */
  function ContainerToTrackMap() {
    this.stableIdToTrackMap_ = {};
  }

  ContainerToTrackMap.prototype = {
    addContainer(container, track) {
      if (!track) {
        throw new Error('Must provide a track.');
      }
      this.stableIdToTrackMap_[container.stableId] = track;
    },

    clear() {
      this.stableIdToTrackMap_ = {};
    },

    getTrackByStableId(stableId) {
      return this.stableIdToTrackMap_[stableId];
    }
  };

  return {
    ContainerToTrackMap,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * EventToTrackMap provides a mapping mechanism between events and the
   * tracks those events belong on.
   * @constructor
   */
  function EventToTrackMap() {}

  EventToTrackMap.prototype = {
    addEvent(event, track) {
      if (!track) {
        throw new Error('Must provide a track.');
      }
      this[event.guid] = track;
    }
  };

  return {
    EventToTrackMap,
  };
});


'use strict';

/**
 * @fileoverview Code for the viewport.
 */
tr.exportTo('tr.ui', function() {
  const TimelineDisplayTransform = tr.ui.TimelineDisplayTransform;
  const TimelineInterestRange = tr.ui.TimelineInterestRange;

  const IDEAL_MAJOR_MARK_DISTANCE_PX = 150;
  // Keep 5 digits of precision when rounding the major mark distances.
  const MAJOR_MARK_ROUNDING_FACTOR = 100000;

  class AnimationControllerProxy {
    constructor(target) {
      this.target_ = target;
    }

    get panX() {
      return this.target_.currentDisplayTransform_.panX;
    }

    set panX(panX) {
      this.target_.currentDisplayTransform_.panX = panX;
    }

    get panY() {
      return this.target_.currentDisplayTransform_.panY;
    }

    set panY(panY) {
      this.target_.currentDisplayTransform_.panY = panY;
    }

    get scaleX() {
      return this.target_.currentDisplayTransform_.scaleX;
    }

    set scaleX(scaleX) {
      this.target_.currentDisplayTransform_.scaleX = scaleX;
    }

    cloneAnimationState() {
      return this.target_.currentDisplayTransform_.clone();
    }

    xPanWorldPosToViewPos(xWorld, xView) {
      this.target_.currentDisplayTransform_.xPanWorldPosToViewPos(
          xWorld, xView, this.target_.modelTrackContainer_.canvas.clientWidth);
    }
  }

  /**
   * The TimelineViewport manages the transform used for navigating
   * within the timeline. It is a simple transform:
   *   x' = (x+pan) * scale
   *
   * The timeline code tries to avoid directly accessing this transform,
   * instead using this class to do conversion between world and viewspace,
   * as well as the math for centering the viewport in various interesting
   * ways.
   *
   * @constructor
   * @extends {tr.b.EventTarget}
   */
  function TimelineViewport(parentEl) {
    this.parentEl_ = parentEl;
    this.modelTrackContainer_ = undefined;
    this.currentDisplayTransform_ = new TimelineDisplayTransform();
    this.initAnimationController_();

    // Flow events
    this.showFlowEvents_ = false;

    // Highlights.
    this.highlightVSync_ = false;

    // High details.
    this.highDetails_ = false;

    // Grid system.
    this.gridTimebase_ = 0;
    this.gridStep_ = 1000 / 60;
    this.gridEnabled_ = false;

    // Init logic.
    this.hasCalledSetupFunction_ = false;

    this.onResize_ = this.onResize_.bind(this);
    this.onModelTrackControllerScroll_ =
        this.onModelTrackControllerScroll_.bind(this);

    this.timeMode_ = TimelineViewport.TimeMode.TIME_IN_MS;
    // Major mark positions are where the gridlines/ruler marks are placed along
    // the x-axis.
    this.majorMarkWorldPositions_ = [];
    this.majorMarkUnit_ = undefined;
    this.interestRange_ = new TimelineInterestRange(this);

    this.eventToTrackMap_ = new tr.ui.tracks.EventToTrackMap();
    this.containerToTrackMap = new tr.ui.tracks.ContainerToTrackMap();

    this.dispatchChangeEvent = this.dispatchChangeEvent.bind(this);
  }

  TimelineViewport.TimeMode = {
    TIME_IN_MS: 0,
    REVISIONS: 1
  };

  TimelineViewport.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    /**
     * @return {boolean} Whether the current timeline is attached to the
     * document.
     */
    get isAttachedToDocumentOrInTestMode() {
      // Allow not providing a parent element, used by tests.
      if (this.parentEl_ === undefined) return;
      return tr.ui.b.isElementAttachedToDocument(this.parentEl_);
    },

    onResize_() {
      this.dispatchChangeEvent();
    },

    /**
     * Fires the change event on this viewport. Used to notify listeners
     * to redraw when the underlying model has been mutated.
     */
    dispatchChangeEvent() {
      tr.b.dispatchSimpleEvent(this, 'change');
    },

    detach() {
      window.removeEventListener('resize', this.dispatchChangeEvent);
    },

    initAnimationController_() {
      this.dtAnimationController_ = new tr.ui.b.AnimationController();
      this.dtAnimationController_.addEventListener(
          'didtick', function(e) {
            this.onCurentDisplayTransformChange_(e.oldTargetState);
          }.bind(this));

      this.dtAnimationController_.target = new AnimationControllerProxy(this);
    },

    get currentDisplayTransform() {
      return this.currentDisplayTransform_;
    },

    setDisplayTransformImmediately(displayTransform) {
      this.dtAnimationController_.cancelActiveAnimation();

      const oldDisplayTransform =
          this.dtAnimationController_.target.cloneAnimationState();
      this.currentDisplayTransform_.set(displayTransform);
      this.onCurentDisplayTransformChange_(oldDisplayTransform);
    },

    queueDisplayTransformAnimation(animation) {
      if (!(animation instanceof tr.ui.b.Animation)) {
        throw new Error('animation must be instanceof tr.ui.b.Animation');
      }
      this.dtAnimationController_.queueAnimation(animation);
    },

    onCurentDisplayTransformChange_(oldDisplayTransform) {
      // Ensure panY stays clamped in the track container's scroll range.
      if (this.modelTrackContainer_) {
        this.currentDisplayTransform.panY = tr.b.math.clamp(
            this.currentDisplayTransform.panY,
            0,
            this.modelTrackContainer_.scrollHeight -
                this.modelTrackContainer_.clientHeight);
      }

      const changed = !this.currentDisplayTransform.equals(oldDisplayTransform);
      const yChanged = this.currentDisplayTransform.panY !==
          oldDisplayTransform.panY;
      if (yChanged) {
        this.modelTrackContainer_.scrollTop = this.currentDisplayTransform.panY;
      }
      if (changed) {
        this.dispatchChangeEvent();
      }
    },

    onModelTrackControllerScroll_(e) {
      if (this.dtAnimationController_.activeAnimation &&
          this.dtAnimationController_.activeAnimation.affectsPanY) {
        this.dtAnimationController_.cancelActiveAnimation();
      }
      const panY = this.modelTrackContainer_.scrollTop;
      this.currentDisplayTransform_.panY = panY;
    },

    get modelTrackContainer() {
      return this.modelTrackContainer_;
    },

    set modelTrackContainer(m) {
      if (this.modelTrackContainer_) {
        this.modelTrackContainer_.removeEventListener('scroll',
            this.onModelTrackControllerScroll_);
      }

      this.modelTrackContainer_ = m;
      this.modelTrackContainer_.addEventListener('scroll',
          this.onModelTrackControllerScroll_);
    },

    get showFlowEvents() {
      return this.showFlowEvents_;
    },

    set showFlowEvents(showFlowEvents) {
      this.showFlowEvents_ = showFlowEvents;
      this.dispatchChangeEvent();
    },

    get highlightVSync() {
      return this.highlightVSync_;
    },

    set highlightVSync(highlightVSync) {
      this.highlightVSync_ = highlightVSync;
      this.dispatchChangeEvent();
    },

    get highDetails() {
      return this.highDetails_;
    },

    set highDetails(highDetails) {
      this.highDetails_ = highDetails;
      this.dispatchChangeEvent();
    },

    get gridEnabled() {
      return this.gridEnabled_;
    },

    set gridEnabled(enabled) {
      if (this.gridEnabled_ === enabled) return;

      this.gridEnabled_ = enabled && true;
      this.dispatchChangeEvent();
    },

    get gridTimebase() {
      return this.gridTimebase_;
    },

    set gridTimebase(timebase) {
      if (this.gridTimebase_ === timebase) return;

      this.gridTimebase_ = timebase;
      this.dispatchChangeEvent();
    },

    get gridStep() {
      return this.gridStep_;
    },

    get interestRange() {
      return this.interestRange_;
    },

    get majorMarkWorldPositions() {
      return this.majorMarkWorldPositions_;
    },

    get majorMarkUnit() {
      switch (this.timeMode_) {
        case TimelineViewport.TimeMode.TIME_IN_MS:
          return tr.b.Unit.byName.timeInMsAutoFormat;
        case TimelineViewport.TimeMode.REVISIONS:
          return tr.b.Unit.byName.count;
        default:
          throw new Error(
              'Cannot get Unit for unsupported time mode ' + this.timeMode_);
      }
    },

    get timeMode() {
      return this.timeMode_;
    },

    set timeMode(mode) {
      this.timeMode_ = mode;
      this.dispatchChangeEvent();
    },

    updateMajorMarkData(viewLWorld, viewRWorld) {
      const pixelRatio = window.devicePixelRatio || 1;
      const dt = this.currentDisplayTransform;

      const idealMajorMarkDistancePix =
          IDEAL_MAJOR_MARK_DISTANCE_PX * pixelRatio;
      const idealMajorMarkDistanceWorld =
          dt.xViewVectorToWorld(idealMajorMarkDistancePix);

      const majorMarkDistanceWorld = tr.b.math.preferredNumberLargerThanMin(
          idealMajorMarkDistanceWorld);

      const firstMajorMark = Math.floor(
          viewLWorld / majorMarkDistanceWorld) * majorMarkDistanceWorld;

      this.majorMarkWorldPositions_ = [];
      for (let curX = firstMajorMark;
           curX < viewRWorld;
           curX += majorMarkDistanceWorld) {
        this.majorMarkWorldPositions_.push(
            Math.floor(MAJOR_MARK_ROUNDING_FACTOR * curX) /
            MAJOR_MARK_ROUNDING_FACTOR);
      }
    },

    drawMajorMarkLines(ctx) {
      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      for (const majorMark of this.majorMarkWorldPositions_) {
        const x = this.currentDisplayTransform.xWorldToView(majorMark);
        tr.ui.b.drawLine(ctx, x, 0, x, ctx.canvas.height);
      }
      ctx.strokeStyle = '#ddd';
      ctx.stroke();

      ctx.restore();
    },

    drawGridLines(ctx, viewLWorld, viewRWorld) {
      if (!this.gridEnabled) return;

      const dt = this.currentDisplayTransform;
      let x = this.gridTimebase;

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      ctx.save();
      ctx.translate((Math.round(ctx.lineWidth) % 2) / 2, 0);

      ctx.beginPath();
      while (x < viewRWorld) {
        if (x >= viewLWorld) {
          // Do conversion to viewspace here rather than on
          // x to avoid precision issues.
          const vx = Math.floor(dt.xWorldToView(x));
          tr.ui.b.drawLine(ctx, vx, 0, vx, ctx.canvas.height);
        }

        x += this.gridStep;
      }
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
      ctx.stroke();

      ctx.restore();
    },

    /**
     * Helper for selection previous or next.
     * @param {boolean} offset If positive, select one forward (next).
     *   Else, select previous.
     *
     * @return {boolean} true if current selection changed.
     */
    getShiftedSelection(selection, offset) {
      const newSelection = new tr.model.EventSet();
      for (const event of selection) {
        // If this is a flow event, then move to its slice based on the
        // offset direction.
        if (event instanceof tr.model.FlowEvent) {
          if (offset > 0) {
            newSelection.push(event.endSlice);
          } else if (offset < 0) {
            newSelection.push(event.startSlice);
          } else {
            /* Do nothing. Zero offsets don't do anything. */
          }
          continue;
        }

        const track = this.trackForEvent(event);
        track.addEventNearToProvidedEventToSelection(
            event, offset, newSelection);
      }

      if (newSelection.length === 0) return undefined;

      return newSelection;
    },

    rebuildEventToTrackMap() {
      // TODO(charliea): Make the event to track map have a similar interface
      // to the container to track map so that we can just clear() here.
      this.eventToTrackMap_ = new tr.ui.tracks.EventToTrackMap();
      this.modelTrackContainer_.addEventsToTrackMap(this.eventToTrackMap_);
    },

    rebuildContainerToTrackMap() {
      this.containerToTrackMap.clear();
      this.modelTrackContainer_.addContainersToTrackMap(
          this.containerToTrackMap);
    },

    trackForEvent(event) {
      return this.eventToTrackMap_[event.guid];
    }
  };

  return {
    TimelineViewport,
  };
});


'use strict';

tr.exportTo('tr.c', function() {
  const BrushingState = tr.ui.b.BrushingState;
  const EventSet = tr.model.EventSet;
  const SelectionState = tr.model.SelectionState;
  const Viewport = tr.ui.TimelineViewport;

  function BrushingStateController(timelineView) {
    tr.b.EventTarget.call(this);

    this.timelineView_ = timelineView;
    this.currentBrushingState_ = new BrushingState();

    this.onPopState_ = this.onPopState_.bind(this);
    this.historyEnabled_ = false;
    this.selections_ = {};
  }

  BrushingStateController.prototype = {
    __proto__: tr.b.EventTarget.prototype,

    dispatchChangeEvent_() {
      const e = new tr.b.Event('change', false, false);
      this.dispatchEvent(e);
    },

    get model() {
      if (!this.timelineView_) {
        return undefined;
      }
      return this.timelineView_.model;
    },

    get trackView() {
      if (!this.timelineView_) {
        return undefined;
      }
      return this.timelineView_.trackView;
    },

    get viewport() {
      if (!this.timelineView_) {
        return undefined;
      }
      if (!this.timelineView_.trackView) {
        return undefined;
      }
      return this.timelineView_.trackView.viewport;
    },

    /* History system */
    get historyEnabled() {
      return this.historyEnabled_;
    },

    set historyEnabled(historyEnabled) {
      this.historyEnabled_ = !!historyEnabled;
      if (historyEnabled) {
        window.addEventListener('popstate', this.onPopState_);
      } else {
        window.removeEventListener('popstate', this.onPopState_);
      }
    },

    modelWillChange() {
      if (this.currentBrushingState_.isAppliedToModel) {
        this.currentBrushingState_.unapplyFromEventSelectionStates();
      }
    },

    modelDidChange() {
      this.selections_ = {};

      this.currentBrushingState_ = new BrushingState();
      this.currentBrushingState_.applyToEventSelectionStates(this.model);

      const e = new tr.b.Event('model-changed', false, false);
      this.dispatchEvent(e);

      this.dispatchChangeEvent_();
    },

    onUserInitiatedSelectionChange_() {
      const selection = this.selection;
      if (this.historyEnabled) {
        // Save the selection so that when back button is pressed,
        // it could be retrieved.
        this.selections_[selection.guid] = selection;
        const state = {
          selection_guid: selection.guid
        };

        window.history.pushState(state, document.title);
      }
    },

    onPopState_(e) {
      if (e.state === null) return;

      const selection = this.selections_[e.state.selection_guid];
      if (selection) {
        const newState = this.currentBrushingState_.clone();
        newState.selection = selection;
        this.currentBrushingState = newState;
      }
      e.stopPropagation();
    },

    get selection() {
      return this.currentBrushingState_.selection;
    },
    get findMatches() {
      return this.currentBrushingState_.findMatches;
    },

    get selectionOfInterest() {
      return this.currentBrushingState_.selectionOfInterest;
    },

    get currentBrushingState() {
      return this.currentBrushingState_;
    },

    set currentBrushingState(newBrushingState) {
      if (newBrushingState.isAppliedToModel) {
        throw new Error('Cannot apply this state, it is applied');
      }

      // This function uses value-equality on the states so that state can
      // changed to a clone of itself without causing a change event, while
      // still having the actual state object change to the new clone.
      const hasValueChanged = !this.currentBrushingState_.equals(
          newBrushingState);

      if (newBrushingState !== this.currentBrushingState_ && !hasValueChanged) {
        if (this.currentBrushingState_.isAppliedToModel) {
          this.currentBrushingState_.transferModelOwnershipToClone(
              newBrushingState);
        }
        this.currentBrushingState_ = newBrushingState;
        return;
      }

      if (this.currentBrushingState_.isAppliedToModel) {
        this.currentBrushingState_.unapplyFromEventSelectionStates();
      }

      this.currentBrushingState_ = newBrushingState;

      this.currentBrushingState_.applyToEventSelectionStates(this.model);

      this.dispatchChangeEvent_();
    },

    /**
     * @param {Filter} filter The filter to use for finding matches.
     * @param {Selection} selection The selection to add matches to.
     * @return {Task} which performs the filtering.
     */
    addAllEventsMatchingFilterToSelectionAsTask(filter, selection) {
      const timelineView = this.timelineView_.trackView;
      if (!timelineView) {
        return new tr.b.Task();
      }
      return timelineView.addAllEventsMatchingFilterToSelectionAsTask(
          filter, selection);
    },

    findTextChangedTo(allPossibleMatches) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.findMatches = allPossibleMatches;
      this.currentBrushingState = newBrushingState;
    },

    findFocusChangedTo(currentFocus) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = currentFocus;
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    findTextCleared() {
      if (this.xNavStringMarker_ !== undefined) {
        this.model.removeAnnotation(this.xNavStringMarker_);
        this.xNavStringMarker_ = undefined;
      }

      if (this.guideLineAnnotation_ !== undefined) {
        this.model.removeAnnotation(this.guideLineAnnotation_);
        this.guideLineAnnotation_ = undefined;
      }

      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = new EventSet();
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    uiStateFromString(string) {
      return tr.ui.b.UIState.fromUserFriendlyString(
          this.model, this.viewport, string);
    },

    navToPosition(uiState, showNavLine) {
      this.trackView.navToPosition(uiState, showNavLine);
    },

    changeSelectionFromTimeline(selection) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    showScriptControlSelection(selection) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;
    },

    changeSelectionFromRequestSelectionChangeEvent(selection) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.selection = selection;
      newBrushingState.findMatches = new EventSet();
      this.currentBrushingState = newBrushingState;

      this.onUserInitiatedSelectionChange_();
    },

    changeAnalysisViewRelatedEvents(eventSet) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.analysisViewRelatedEvents = eventSet;
      this.currentBrushingState = newBrushingState;
    },

    changeAnalysisLinkHoveredEvents(eventSet) {
      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.analysisLinkHoveredEvents = eventSet;
      this.currentBrushingState = newBrushingState;
    },

    getViewSpecificBrushingState(viewId) {
      return this.currentBrushingState.viewSpecificBrushingStates[viewId];
    },

    changeViewSpecificBrushingState(viewId, newState) {
      const oldStates = this.currentBrushingState_.viewSpecificBrushingStates;
      const newStates = {};
      for (const id in oldStates) {
        newStates[id] = oldStates[id];
      }
      if (newState === undefined) {
        delete newStates[viewId];
      } else {
        newStates[viewId] = newState;
      }

      const newBrushingState = this.currentBrushingState_.clone();
      newBrushingState.viewSpecificBrushingStates = newStates;
      this.currentBrushingState = newBrushingState;
    }
  };

  BrushingStateController.getControllerForElement = function(element) {
    if (tr.isHeadless) {
      throw new Error('Unsupported');
    }
    let currentElement = element;
    while (currentElement) {
      if (currentElement.brushingStateController) {
        return currentElement.brushingStateController;
      }

      // Walk up the DOM.
      if (currentElement.parentElement) {
        currentElement = currentElement.parentElement;
        continue;
      }

      // Possibly inside a shadow DOM.
      let currentNode = currentElement;
      while (Polymer.dom(currentNode).parentNode) {
        currentNode = Polymer.dom(currentNode).parentNode;
      }
      currentElement = currentNode.host;
    }
    return undefined;
  };

  return {
    BrushingStateController,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-a-analysis-link',

  properties: {
    href: {
      type: String
    }
  },

  listeners: {
    'click': 'onClicked_',
    'mouseenter': 'onMouseEnter_',
    'mouseleave': 'onMouseLeave_'
  },

  ready() {
    this.selection_ = undefined;
  },

  attached() {
    // Save an instance of the controller since it's going to be used in
    // detached() where it can no longer be obtained.
    this.controller_ =
        tr.c.BrushingStateController.getControllerForElement(this);
  },

  detached() {
    // Reset highlights.
    this.clearHighlight_();
    this.controller_ = undefined;
  },

  set color(c) {
    this.style.color = c;
  },

  /**
   * @return {*|function():*}
   */
  get selection() {
    return this.selection_;
  },

  /**
   * |selection| can be anything except a function, or else a function that
   * can return anything.
   *
   * In the context of trace_viewer, |selection| is typically an EventSet,
   * whose events will be highlighted by trace_viewer when this link is
   * clicked or mouse-entered.
   *
   * If |selection| is not a function, then it will be dispatched to this
   * link's embedder via a RequestSelectionChangeEvent when this link is
   * clicked or mouse-entered.
   *
   * If |selection| is a function, then it will be called when this link is
   * clicked or mouse-entered, and its result will be dispatched to this
   * link's embedder via a RequestSelectionChangeEvent.
   *
   * @param {*|function():*} selection
   */
  set selection(selection) {
    this.selection_ = selection;
    Polymer.dom(this).textContent = selection.userFriendlyName;
  },

  setSelectionAndContent(selection, opt_textContent) {
    this.selection_ = selection;
    if (opt_textContent) {
      Polymer.dom(this).textContent = opt_textContent;
    }
  },

  /**
   * If |selection| is a function, call it and return the result.
   * Otherwise return |selection| directly.
   *
   * @return {*}
   */
  getCurrentSelection_() {
    // Gets the current selection, invoking the selection function if needed.
    if (typeof this.selection_ === 'function') {
      return this.selection_();
    }
    return this.selection_;
  },

  setHighlight_(opt_eventSet) {
    if (this.controller_) {
      this.controller_.changeAnalysisLinkHoveredEvents(opt_eventSet);
    }
  },

  clearHighlight_(opt_eventSet) {
    this.setHighlight_();
  },

  onClicked_(clickEvent) {
    if (!this.selection_) return;

    clickEvent.stopPropagation();

    const event = new tr.model.RequestSelectionChangeEvent();
    event.selection = this.getCurrentSelection_();
    this.dispatchEvent(event);
  },

  onMouseEnter_() {
    this.setHighlight_(this.getCurrentSelection_());
  },

  onMouseLeave_() {
    this.clearHighlight_();
  }
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const AnalysisSubView = {
    set tabLabel(label) {
      Polymer.dom(this).setAttribute('tab-label', label);
    },

    get tabLabel() {
      return this.getAttribute('tab-label');
    },

    get requiresTallView() {
      return false;
    },

    get relatedEventsToHighlight() {
      return undefined;
    },

    /**
     * Each element extending this one must implement
     * a 'selection' property.
     */
    set selection(selection) {
      throw new Error('Not implemented!');
    },

    get selection() {
      throw new Error('Not implemented!');
    }
  };

  // Basic registry.
  const allTypeInfosByEventProto = new Map();
  let onlyRootTypeInfosByEventProto = undefined;
  let eventProtoToRootTypeInfoMap = undefined;

  function AnalysisSubViewTypeInfo(eventConstructor, options) {
    if (options.multi === undefined) {
      throw new Error('missing field: multi');
    }
    if (options.title === undefined) {
      throw new Error('missing field: title');
    }
    this.eventConstructor = eventConstructor;

    this.singleTagName = undefined;
    this.singleTitle = undefined;

    this.multiTagName = undefined;
    this.multiTitle = undefined;

    // This is computed by rebuildRootSubViewTypeInfos, so don't muck with it!
    this.childrenTypeInfos_ = undefined;
  }

  AnalysisSubViewTypeInfo.prototype = {
    get childrenTypeInfos() {
      return this.childrenTypeInfos_;
    },

    resetchildrenTypeInfos() {
      this.childrenTypeInfos_ = [];
    }
  };

  AnalysisSubView.register = function(tagName, eventConstructor, options) {
    let typeInfo = allTypeInfosByEventProto.get(eventConstructor.prototype);
    if (typeInfo === undefined) {
      typeInfo = new AnalysisSubViewTypeInfo(eventConstructor, options);
      allTypeInfosByEventProto.set(typeInfo.eventConstructor.prototype,
          typeInfo);

      onlyRootTypeInfosByEventProto = undefined;
    }

    if (!options.multi) {
      if (typeInfo.singleTagName !== undefined) {
        throw new Error('SingleTagName already set');
      }
      typeInfo.singleTagName = tagName;
      typeInfo.singleTitle = options.title;
    } else {
      if (typeInfo.multiTagName !== undefined) {
        throw new Error('MultiTagName already set');
      }
      typeInfo.multiTagName = tagName;
      typeInfo.multiTitle = options.title;
    }
    return typeInfo;
  };

  function rebuildRootSubViewTypeInfos() {
    onlyRootTypeInfosByEventProto = new Map();
    allTypeInfosByEventProto.forEach(function(typeInfo) {
      typeInfo.resetchildrenTypeInfos();
    });

    // Find all root typeInfos.
    allTypeInfosByEventProto.forEach(function(typeInfo, eventProto) {
      const eventPrototype = typeInfo.eventConstructor.prototype;

      let lastEventProto = eventPrototype;
      let curEventProto = eventPrototype.__proto__;
      while (true) {
        if (!allTypeInfosByEventProto.has(curEventProto)) {
          const rootTypeInfo = allTypeInfosByEventProto.get(lastEventProto);
          const rootEventProto = lastEventProto;

          const isNew = onlyRootTypeInfosByEventProto.has(rootEventProto);
          onlyRootTypeInfosByEventProto.set(rootEventProto,
              rootTypeInfo);
          break;
        }

        lastEventProto = curEventProto;
        curEventProto = curEventProto.__proto__;
      }
    });

    // Build the childrenTypeInfos array.
    allTypeInfosByEventProto.forEach(function(typeInfo, eventProto) {
      const eventPrototype = typeInfo.eventConstructor.prototype;
      const parentEventProto = eventPrototype.__proto__;
      const parentTypeInfo = allTypeInfosByEventProto.get(parentEventProto);
      if (!parentTypeInfo) return;
      parentTypeInfo.childrenTypeInfos.push(typeInfo);
    });

    // Build the eventProto to rootTypeInfo map.
    eventProtoToRootTypeInfoMap = new Map();
    allTypeInfosByEventProto.forEach(function(typeInfo, eventProto) {
      const eventPrototype = typeInfo.eventConstructor.prototype;

      let curEventProto = eventPrototype;
      while (true) {
        if (onlyRootTypeInfosByEventProto.has(curEventProto)) {
          const rootTypeInfo = onlyRootTypeInfosByEventProto.get(
              curEventProto);
          eventProtoToRootTypeInfoMap.set(eventPrototype,
              rootTypeInfo);
          break;
        }
        curEventProto = curEventProto.__proto__;
      }
    });
  }

  function findLowestTypeInfoForEvents(thisTypeInfo, events) {
    if (events.length === 0) return thisTypeInfo;
    const event0 = tr.b.getFirstElement(events);

    let candidateSubTypeInfo;
    for (let i = 0; i < thisTypeInfo.childrenTypeInfos.length; i++) {
      const childTypeInfo = thisTypeInfo.childrenTypeInfos[i];
      if (event0 instanceof childTypeInfo.eventConstructor) {
        candidateSubTypeInfo = childTypeInfo;
        break;
      }
    }
    if (!candidateSubTypeInfo) return thisTypeInfo;

    // Validate that all the other events are instances of the candidate type.
    let allMatch = true;
    for (const event of events) {
      if (event instanceof candidateSubTypeInfo.eventConstructor) continue;
      allMatch = false;
      break;
    }

    if (!allMatch) {
      return thisTypeInfo;
    }

    return findLowestTypeInfoForEvents(candidateSubTypeInfo, events);
  }

  const primaryEventProtoToTypeInfoMap = new Map();
  function getRootTypeInfoForEvent(event) {
    const curProto = event.__proto__;
    const typeInfo = primaryEventProtoToTypeInfoMap.get(curProto);
    if (typeInfo) return typeInfo;
    return getRootTypeInfoForEventSlow(event);
  }

  function getRootTypeInfoForEventSlow(event) {
    let typeInfo;
    let curProto = event.__proto__;
    while (true) {
      if (curProto === Object.prototype) {
        throw new Error('No view registered for ' + event.toString());
      }
      typeInfo = onlyRootTypeInfosByEventProto.get(curProto);
      if (typeInfo) {
        primaryEventProtoToTypeInfoMap.set(event.__proto__, typeInfo);
        return typeInfo;
      }
      curProto = curProto.__proto__;
    }
  }

  AnalysisSubView.getEventsOrganizedByTypeInfo = function(selection) {
    if (onlyRootTypeInfosByEventProto === undefined) {
      rebuildRootSubViewTypeInfos();
    }

    // Base grouping.
    const eventsByRootTypeInfo = tr.b.groupIntoMap(
        selection,
        function(event) {
          return getRootTypeInfoForEvent(event);
        },
        this, tr.model.EventSet);

    // Now, try to lower the typeinfo to the most specific type that still
    // encompasses the event group.
    //
    // For instance,  if we have 3 ThreadSlices, and all three are V8 slices,
    // then we can convert this to use the V8Slices's typeinfos. But, if one
    // of those slices was not a V8Slice, then we must still use
    // ThreadSlice.
    //
    // The reason for this is for the confusion that might arise from the
    // alternative. Suppose you click on a set of mixed slices, we want to show
    // you the most correct information, and let you navigate to . If we instead
    // showed you a V8 slices tab, and a Slices tab, we present the user with an
    // ambiguity: is the V8 slice also in the Slices tab? Or is it not? Better,
    // we think, to just only ever show an event in one place at a time, and
    // avoid the possible confusion.
    const eventsByLowestTypeInfo = new Map();
    eventsByRootTypeInfo.forEach(function(events, typeInfo) {
      const lowestTypeInfo = findLowestTypeInfoForEvents(typeInfo, events);
      eventsByLowestTypeInfo.set(lowestTypeInfo, events);
    });

    return eventsByLowestTypeInfo;
  };

  return {
    AnalysisSubView,
    AnalysisSubViewTypeInfo,
  };
});

// Dummy element for testing
Polymer({
  is: 'tr-ui-a-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView]
});


'use strict';

tr.exportTo('tr.b.math', function() {
  /**
   * Tracks a 2D bounding box.
   * @constructor
   */
  function Rect() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }

  Rect.fromXYWH = function(x, y, w, h) {
    const rect = new Rect();
    rect.x = x;
    rect.y = y;
    rect.width = w;
    rect.height = h;
    return rect;
  };

  Rect.fromArray = function(ary) {
    if (ary.length !== 4) {
      throw new Error('ary.length must be 4');
    }
    const rect = new Rect();
    rect.x = ary[0];
    rect.y = ary[1];
    rect.width = ary[2];
    rect.height = ary[3];
    return rect;
  };

  Rect.prototype = {
    __proto__: Object.prototype,

    get left() {
      return this.x;
    },

    get top() {
      return this.y;
    },

    get right() {
      return this.x + this.width;
    },

    get bottom() {
      return this.y + this.height;
    },

    toString() {
      return 'Rect(' + this.x + ', ' + this.y + ', ' +
          this.width + ', ' + this.height + ')';
    },

    toArray() {
      return [this.x, this.y, this.width, this.height];
    },

    clone() {
      const rect = new Rect();
      rect.x = this.x;
      rect.y = this.y;
      rect.width = this.width;
      rect.height = this.height;
      return rect;
    },

    enlarge(pad) {
      const rect = new Rect();
      this.enlargeFast(rect, pad);
      return rect;
    },

    enlargeFast(out, pad) {
      out.x = this.x - pad;
      out.y = this.y - pad;
      out.width = this.width + 2 * pad;
      out.height = this.height + 2 * pad;
      return out;
    },

    size() {
      return {width: this.width, height: this.height};
    },

    scale(s) {
      const rect = new Rect();
      this.scaleFast(rect, s);
      return rect;
    },

    scaleSize(s) {
      return Rect.fromXYWH(this.x, this.y, this.width * s, this.height * s);
    },

    scaleFast(out, s) {
      out.x = this.x * s;
      out.y = this.y * s;
      out.width = this.width * s;
      out.height = this.height * s;
      return out;
    },

    translate(v) {
      const rect = new Rect();
      this.translateFast(rect, v);
      return rect;
    },

    translateFast(out, v) {
      out.x = this.x + v[0];
      out.y = this.x + v[1];
      out.width = this.width;
      out.height = this.height;
      return out;
    },

    asUVRectInside(containingRect) {
      const rect = new Rect();
      rect.x = (this.x - containingRect.x) / containingRect.width;
      rect.y = (this.y - containingRect.y) / containingRect.height;
      rect.width = this.width / containingRect.width;
      rect.height = this.height / containingRect.height;
      return rect;
    },

    intersects(that) {
      let ok = true;
      ok &= this.x < that.right;
      ok &= this.right > that.x;
      ok &= this.y < that.bottom;
      ok &= this.bottom > that.y;
      return ok;
    },

    equalTo(rect) {
      return rect &&
             (this.x === rect.x) &&
             (this.y === rect.y) &&
             (this.width === rect.width) &&
             (this.height === rect.height);
    }
  };

  return {
    Rect,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  function instantiateTemplate(selector, doc) {
    doc = doc || document;
    const el = Polymer.dom(doc).querySelector(selector);
    if (!el) {
      throw new Error('Element not found');
    }
    return doc.importNode(el.content, true);
//    return el.createInstance();
  }

  function windowRectForElement(element) {
    const position = [element.offsetLeft, element.offsetTop];
    const size = [element.offsetWidth, element.offsetHeight];
    let node = element.offsetParent;
    while (node) {
      position[0] += node.offsetLeft;
      position[1] += node.offsetTop;
      node = node.offsetParent;
    }
    return tr.b.math.Rect.fromXYWH(position[0], position[1], size[0], size[1]);
  }

  function scrollIntoViewIfNeeded(el) {
    const pr = el.parentElement.getBoundingClientRect();
    const cr = el.getBoundingClientRect();
    if (cr.top < pr.top) {
      el.scrollIntoView(true);
    } else if (cr.bottom > pr.bottom) {
      el.scrollIntoView(false);
    }
  }

  function extractUrlString(url) {
    let extracted = url.replace(/url\((.*)\)/, '$1');

    // In newer versions of chrome, the contents of url() will be quoted. Remove
    // these quotes as well. If quotes are not present, match will fail and this
    // becomes a no-op.
    extracted = extracted.replace(/\"(.*)\"/, '$1');

    return extracted;
  }

  function toThreeDigitLocaleString(value) {
    return value.toLocaleString(
        undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3});
  }

  /**
   * Returns true if |name| is the name of an unknown HTML element.  Registered
   * polymer elements are known, so this returns false.  Typos of registered
   * polymer element names are unknown, so this returns true for typos.
   *
   * @return {boolean}
   */
  function isUnknownElementName(name) {
    return document.createElement(name) instanceof HTMLUnknownElement;
  }

  return {
    isUnknownElementName,
    toThreeDigitLocaleString,
    instantiateTemplate,
    windowRectForElement,
    scrollIntoViewIfNeeded,
    extractUrlString,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const TableFormat = {};

  TableFormat.SelectionMode = {
    // Selection disabled.
    // Default highlight: none.
    NONE: 0,

    // Row selection mode.
    // Default highlight: dark row.
    ROW: 1,

    // Cell selection mode.
    // Default highlight: dark cell and light row.
    CELL: 2
  };

  TableFormat.HighlightStyle = {
    // Highlight depends on the current selection mode.
    DEFAULT: 0,

    // No highlight.
    NONE: 1,

    // Light highlight.
    LIGHT: 2,

    // Dark highlight.
    DARK: 3
  };

  TableFormat.ColumnAlignment = {
    LEFT: 0 /* default */,
    RIGHT: 1
  };

  return {
    TableFormat,
  };
});


'use strict';
(function() {
  const RIGHT_ARROW = String.fromCharCode(0x25b6);
  const UNSORTED_ARROW = String.fromCharCode(0x25BF);
  const ASCENDING_ARROW = String.fromCharCode(0x25B4);
  const DESCENDING_ARROW = String.fromCharCode(0x25BE);

  const SelectionMode = tr.ui.b.TableFormat.SelectionMode;
  const SelectionModeValues = new Set(Object.values(SelectionMode));
  const HighlightStyle = tr.ui.b.TableFormat.HighlightStyle;
  const HighlightStyleValues = new Set(Object.values(HighlightStyle));
  const ColumnAlignment = tr.ui.b.TableFormat.ColumnAlignment;
  const ColumnAlignmentValues = new Set(Object.values(ColumnAlignment));

  Polymer({
    is: 'tr-ui-b-table',

    created() {
      this.selectionMode_ = SelectionMode.NONE;
      this.rowHighlightStyle_ = HighlightStyle.DEFAULT;
      this.cellHighlightStyle_ = HighlightStyle.DEFAULT;
      this.selectedTableRowInfo_ = undefined;
      this.selectedColumnIndex_ = undefined;

      this.tableColumns_ = [];
      this.tableRows_ = [];
      this.tableRowsInfo_ = new WeakMap();
      this.tableFooterRows_ = [];
      this.tableFooterRowsInfo_ = new WeakMap();
      this.sortColumnIndex_ = undefined;
      this.sortDescending_ = false;
      this.columnsWithExpandButtons_ = [];
      this.headerCells_ = [];
      this.showHeader_ = true;
      this.emptyValue_ = undefined;
      this.subRowsPropertyName_ = 'subRows';
      this.customizeTableRowCallback_ = undefined;
      this.defaultExpansionStateCallback_ = undefined;
      this.userCanModifySortOrder_ = true;
      this.computedFontSizePx_ = undefined;
    },

    ready() {
      this.$.body.addEventListener(
          'keydown', this.onKeyDown_.bind(this), true);
      this.$.body.addEventListener(
          'focus', this.onFocus_.bind(this), true);
    },

    clear() {
      this.selectionMode_ = SelectionMode.NONE;
      this.rowHighlightStyle_ = HighlightStyle.DEFAULT;
      this.cellHighlightStyle_ = HighlightStyle.DEFAULT;
      this.selectedTableRowInfo_ = undefined;
      this.selectedColumnIndex_ = undefined;

      Polymer.dom(this).textContent = '';
      this.tableColumns_ = [];
      this.tableRows_ = [];
      this.tableRowsInfo_ = new WeakMap();
      this.tableFooterRows_ = [];
      this.tableFooterRowsInfo_ = new WeakMap();
      this.sortColumnIndex_ = undefined;
      this.sortDescending_ = false;
      this.columnsWithExpandButtons_ = [];
      this.headerCells_ = [];
      this.showHeader_ = true;
      this.emptyValue_ = undefined;
      this.subRowsPropertyName_ = 'subRows';
      this.defaultExpansionStateCallback_ = undefined;
      this.userCanModifySortOrder_ = true;
    },

    set zebra(zebra) {
      if (zebra) {
        this.setAttribute('zebra', true);
      } else {
        this.removeAttribute('zebra');
      }
    },

    get zebra() {
      return this.getAttribute('zebra');
    },

    get showHeader() {
      return this.showHeader_;
    },

    set showHeader(showHeader) {
      this.showHeader_ = showHeader;
      this.scheduleRebuildHeaders_();
    },

    set subRowsPropertyName(name) {
      this.subRowsPropertyName_ = name;
    },

    /**
     * This callback will be called whenever a body row is built
     * for a userRow that has subRows and does not have an explicit
     * isExpanded field.
     * The callback should return true if the row should be expanded,
     * or false if the row should be collapsed.
     * @param {function(userRow, parentUserRow): boolean} cb The callback.
     */
    set defaultExpansionStateCallback(cb) {
      this.defaultExpansionStateCallback_ = cb;
      this.scheduleRebuildBody_();
    },

    /**
     * This callback will be called whenever a body row is built.
     * The callback's return value is ignored.
     * @param {function(userRow, trElement)} cb The callback.
     */
    set customizeTableRowCallback(cb) {
      this.customizeTableRowCallback_ = cb;
      this.scheduleRebuildBody_();
    },

    get emptyValue() {
      return this.emptyValue_;
    },

    set emptyValue(emptyValue) {
      const previousEmptyValue = this.emptyValue_;
      this.emptyValue_ = emptyValue;
      if (this.tableRows_.length === 0 && emptyValue !== previousEmptyValue) {
        this.scheduleRebuildBody_();
      }
    },

    /**
     * Data objects should have the following fields:
     *   mandatory: title, value
     *   optional: width {string}, cmp {function}, colSpan {number},
     *             showExpandButtons {boolean},
     *             align {tr.ui.b.TableFormat.ColumnAlignment}
     *
     * @param {Array} columns An array of data objects.
     */
    set tableColumns(columns) {
      // Figure out the columns with expand buttons...
      let columnsWithExpandButtons = [];
      for (let i = 0; i < columns.length; i++) {
        if (columns[i].showExpandButtons) {
          columnsWithExpandButtons.push(i);
        }
      }
      if (columnsWithExpandButtons.length === 0) {
        // First column if none have specified.
        columnsWithExpandButtons = [0];
      }

      // Sanity check columns.
      for (let i = 0; i < columns.length; i++) {
        const colInfo = columns[i];
        if (colInfo.width === undefined) continue;

        const hasExpandButton = columnsWithExpandButtons.includes(i);

        const w = colInfo.width;
        if (w) {
          if (/\d+px/.test(w)) {
            continue;
          } else if (/\d+%/.test(w)) {
            if (hasExpandButton) {
              throw new Error('Columns cannot be %-sized and host ' +
                              ' an expand button');
            }
          } else {
            throw new Error('Unrecognized width string');
          }
        }
      }

      // Try to preserve the user's sort choice.
      // This is a 'best-effort' attempt, for example we compare columns by
      // thier titles which can be HTML nodes in which case we might consider
      // them different even if they look the same to the user.
      let sortIndex = undefined;
      const currentSortColumn = this.tableColumns[this.sortColumnIndex_];
      if (currentSortColumn) {
        for (const [i, column] of columns.entries()) {
          if (currentSortColumn.title === column.title) {
            sortIndex = i;
            break;
          }
        }
      }

      // Commit the change.
      this.tableColumns_ = columns;
      this.headerCells_ = [];
      this.columnsWithExpandButtons_ = columnsWithExpandButtons;
      this.scheduleRebuildHeaders_();
      this.sortColumnIndex = sortIndex;

      // Blow away the table rows, too.
      this.tableRows = this.tableRows_;
    },

    get tableColumns() {
      return this.tableColumns_;
    },

    /**
     * @param {Array} rows An array of 'row' objects with the following
     * fields:
     *   optional: subRows An array of objects that have the same 'row'
     *                     structure. Set subRowsPropertyName to use an
     *                     alternative field name.
     */
    set tableRows(rows) {
      this.selectedTableRowInfo_ = undefined;
      this.selectedColumnIndex_ = undefined;
      this.tableRows_ = rows;
      this.tableRowsInfo_ = new WeakMap();
      this.scheduleRebuildBody_();
    },

    get tableRows() {
      return this.tableRows_;
    },

    set footerRows(rows) {
      this.tableFooterRows_ = rows;
      this.tableFooterRowsInfo_ = new WeakMap();
      this.scheduleRebuildFooter_();
    },

    get footerRows() {
      return this.tableFooterRows_;
    },

    get userCanModifySortOrder() {
      return this.userCanModifySortOrder_;
    },

    set userCanModifySortOrder(userCanModifySortOrder) {
      const newUserCanModifySortOrder = !!userCanModifySortOrder;
      if (newUserCanModifySortOrder === this.userCanModifySortOrder_) {
        return;
      }

      this.userCanModifySortOrder_ = newUserCanModifySortOrder;
      this.scheduleRebuildHeaders_();
    },

    set sortColumnIndex(number) {
      if (number === this.sortColumnIndex_) return;

      if (number !== undefined) {
        if (this.tableColumns_.length <= number) {
          throw new Error('Column number ' + number + ' is out of bounds.');
        }
        if (!this.tableColumns_[number].cmp) {
          throw new Error('Column ' + number + ' does not have a comparator.');
        }
      }

      this.sortColumnIndex_ = number;
      this.updateHeaderArrows_();
      this.scheduleRebuildBody_();
      this.dispatchSortingChangedEvent_();
    },

    get sortColumnIndex() {
      return this.sortColumnIndex_;
    },

    set sortDescending(value) {
      const newValue = !!value;

      if (newValue !== this.sortDescending_) {
        this.sortDescending_ = newValue;
        this.updateHeaderArrows_();
        this.scheduleRebuildBody_();
        this.dispatchSortingChangedEvent_();
      }
    },

    get sortDescending() {
      return this.sortDescending_;
    },

    updateHeaderArrows_() {
      for (let i = 0; i < this.headerCells_.length; i++) {
        const headerCell = this.headerCells_[i];
        const isColumnCurrentlySorted = i === this.sortColumnIndex_;
        if (!this.tableColumns_[i].cmp ||
            (!this.userCanModifySortOrder_ && !isColumnCurrentlySorted)) {
          headerCell.sideContent = '';
          continue;
        }
        if (!isColumnCurrentlySorted) {
          headerCell.sideContent = UNSORTED_ARROW;
          headerCell.sideContentDisabled = false;
          continue;
        }
        headerCell.sideContent = this.sortDescending_ ?
            DESCENDING_ARROW : ASCENDING_ARROW;
        headerCell.sideContentDisabled = !this.userCanModifySortOrder_;
      }
    },

    generateHeaderColumns_() {
      const selectedTableColumnIndex = this.selectedTableColumnIndex;
      Polymer.dom(this.$.cols).textContent = '';
      for (let i = 0; i < this.tableColumns_.length; ++i) {
        const colElement = document.createElement('col');
        if (i === selectedTableColumnIndex) {
          colElement.setAttribute('selected', true);
        }
        Polymer.dom(this.$.cols).appendChild(colElement);
      }

      this.headerCells_ = [];
      Polymer.dom(this.$.head).textContent = '';
      if (!this.showHeader_) return;

      const tr = this.appendNewElement_(this.$.head, 'tr');
      for (let i = 0; i < this.tableColumns_.length; i++) {
        const td = this.appendNewElement_(tr, 'td');

        const headerCell = document.createElement('tr-ui-b-table-header-cell');
        headerCell.column = this.tableColumns_[i];

        // If the table can be sorted by this column and the user can modify
        // the sort order, attach a tap callback to the column.
        if (this.tableColumns_[i].cmp) {
          const isColumnCurrentlySorted = i === this.sortColumnIndex_;
          if (isColumnCurrentlySorted) {
            headerCell.sideContent = this.sortDescending_ ?
                DESCENDING_ARROW : ASCENDING_ARROW;
            if (!this.userCanModifySortOrder_) {
              headerCell.sideContentDisabled = true;
            }
          }
          if (this.userCanModifySortOrder_) {
            Polymer.dom(td).classList.add('sensitive');
            if (!isColumnCurrentlySorted) {
              headerCell.sideContent = UNSORTED_ARROW;
            }
            headerCell.tapCallback = this.createSortCallback_(i);
          }
        }

        Polymer.dom(td).appendChild(headerCell);
        this.headerCells_.push(headerCell);
      }
    },

    applySizes_() {
      if (this.tableRows_.length === 0 && !this.showHeader) return;

      let rowToRemoveSizing;
      let rowToSize;
      if (this.showHeader) {
        rowToSize = Polymer.dom(this.$.head).children[0];
        rowToRemoveSizing = Polymer.dom(this.$.body).children[0];
      } else {
        rowToSize = Polymer.dom(this.$.body).children[0];
        rowToRemoveSizing = Polymer.dom(this.$.head).children[0];
      }
      for (let i = 0; i < this.tableColumns_.length; i++) {
        if (rowToRemoveSizing && Polymer.dom(rowToRemoveSizing).children[i]) {
          const tdToRemoveSizing = Polymer.dom(rowToRemoveSizing).children[i];
          tdToRemoveSizing.style.minWidth = '';
          tdToRemoveSizing.style.width = '';
        }

        // Apply sizing.
        const td = Polymer.dom(rowToSize).children[i];

        let delta;
        if (this.columnsWithExpandButtons_.includes(i)) {
          td.style.paddingLeft = this.basicIndentation_ + 'px';
          delta = this.basicIndentation_ + 'px';
        } else {
          delta = undefined;
        }

        function calc(base, delta) {
          if (delta) {
            return 'calc(' + base + ' - ' + delta + ')';
          }
          return base;
        }

        const w = this.tableColumns_[i].width;
        if (w) {
          if (/\d+px/.test(w)) {
            td.style.minWidth = calc(w, delta);
          } else if (/\d+%/.test(w)) {
            td.style.width = w;
          } else {
            throw new Error('Unrecognized width string: ' + w);
          }
        }
      }
    },

    createSortCallback_(columnNumber) {
      return function() {
        if (!this.userCanModifySortOrder_) return;

        const previousIndex = this.sortColumnIndex;
        this.sortColumnIndex = columnNumber;
        if (previousIndex !== columnNumber) {
          this.sortDescending = false;
        } else {
          this.sortDescending = !this.sortDescending;
        }
      }.bind(this);
    },

    generateTableRowNodes_(tableSection, userRows, rowInfoMap,
        indentation, lastAddedRow,
        parentRowInfo) {
      if (this.sortColumnIndex_ !== undefined &&
          tableSection === this.$.body) {
        userRows = userRows.slice(); // Don't mess with the input data.
        userRows.sort(function(rowA, rowB) {
          let c = this.tableColumns_[this.sortColumnIndex_].cmp(
              rowA, rowB);
          if (this.sortDescending_) {
            c = -c;
          }
          return c;
        }.bind(this));
      }

      for (let i = 0; i < userRows.length; i++) {
        const userRow = userRows[i];
        const rowInfo = this.getOrCreateRowInfoFor_(rowInfoMap, userRow,
            parentRowInfo);
        const htmlNode = this.getHTMLNodeForRowInfo_(
            tableSection, rowInfo, rowInfoMap, indentation);

        if (lastAddedRow === undefined) {
          // Put first into the table.
          Polymer.dom(tableSection).insertBefore(
              htmlNode, Polymer.dom(tableSection).firstChild);
        } else {
          // This is shorthand for insertAfter(htmlNode, lastAdded).
          const nextSiblingOfLastAdded = Polymer.dom(lastAddedRow).nextSibling;
          Polymer.dom(tableSection).insertBefore(
              htmlNode, nextSiblingOfLastAdded);
        }

        lastAddedRow = htmlNode;
        if (!rowInfo.isExpanded) continue;

        // Append subrows now.
        lastAddedRow = this.generateTableRowNodes_(
            tableSection, userRow[this.subRowsPropertyName_], rowInfoMap,
            indentation + 1, lastAddedRow, rowInfo);
      }
      return lastAddedRow;
    },

    getOrCreateRowInfoFor_(rowInfoMap, userRow, parentRowInfo) {
      let rowInfo = undefined;

      if (rowInfoMap.has(userRow)) {
        rowInfo = rowInfoMap.get(userRow);
      } else {
        rowInfo = {
          userRow,
          htmlNode: undefined,
          parentRowInfo
        };
        rowInfoMap.set(userRow, rowInfo);
      }

      // Recompute isExpanded in case defaultExpansionStateCallback_ has
      // changed.
      rowInfo.isExpanded = this.getExpandedForUserRow_(userRow);

      return rowInfo;
    },

    customizeTableRow_(userRow, trElement) {
      if (!this.customizeTableRowCallback_) return;
      this.customizeTableRowCallback_(userRow, trElement);
    },

    get basicIndentation_() {
      if (this.computedFontSizePx_ === undefined) {
        this.computedFontSizePx_ = parseInt(
            getComputedStyle(this).fontSize) || 16;
      }
      return this.computedFontSizePx_ - 2;
    },

    getHTMLNodeForRowInfo_(tableSection, rowInfo,
        rowInfoMap, indentation) {
      if (rowInfo.htmlNode) {
        this.customizeTableRow_(rowInfo.userRow, rowInfo.htmlNode);
        return rowInfo.htmlNode;
      }

      const INDENT_SPACE = indentation * 16;
      const INDENT_SPACE_NO_BUTTON = indentation * 16 + this.basicIndentation_;
      const trElement = this.ownerDocument.createElement('tr');
      rowInfo.htmlNode = trElement;
      rowInfo.indentation = indentation;
      trElement.rowInfo = rowInfo;
      this.customizeTableRow_(rowInfo.userRow, trElement);

      const isBodyRow = tableSection === this.$.body;
      const isExpandableRow = rowInfo.userRow[this.subRowsPropertyName_] &&
          rowInfo.userRow[this.subRowsPropertyName_].length;

      for (let i = 0; i < this.tableColumns_.length;) {
        const td = this.appendNewElement_(trElement, 'td');
        td.columnIndex = i;

        const column = this.tableColumns_[i];
        const value = column.value(rowInfo.userRow);
        const colSpan = column.colSpan ? column.colSpan : 1;
        td.style.colSpan = colSpan;

        switch (column.align) {
          case undefined:
          case ColumnAlignment.LEFT:
            break;

          case ColumnAlignment.RIGHT:
            td.style.textAlign = 'right';
            break;

          default:
            throw new Error('Invalid alignment of column at index=' + i +
                ': ' + column.align);
        }

        if (this.doesColumnIndexSupportSelection(i)) {
          Polymer.dom(td).classList.add('supports-selection');
        }

        if (this.columnsWithExpandButtons_.includes(i)) {
          if (rowInfo.userRow[this.subRowsPropertyName_] &&
              rowInfo.userRow[this.subRowsPropertyName_].length > 0) {
            td.style.paddingLeft = INDENT_SPACE + 'px';
            td.style.display = 'flex';
            const expandButton = this.appendNewElement_(td, 'expand-button');
            Polymer.dom(expandButton).textContent = RIGHT_ARROW;
            if (rowInfo.isExpanded) {
              Polymer.dom(expandButton).classList.add('button-expanded');
            }
          } else {
            td.style.paddingLeft = INDENT_SPACE_NO_BUTTON + 'px';
          }
        }

        if (value !== undefined) {
          Polymer.dom(td).appendChild(
              tr.ui.b.asHTMLOrTextNode(value, this.ownerDocument));
        }

        td.addEventListener('click', function(i, clickEvent) {
          // Prevent automatically focusing on the table upon clicking on the
          // table. Explicitly focus on it when appropriate (upon clicking on a
          // selectable row/cell) instead.
          clickEvent.preventDefault();

          if (!isBodyRow && !isExpandableRow) return;

          clickEvent.stopPropagation();

          if (clickEvent.target.tagName === 'EXPAND-BUTTON') {
            this.setExpandedForUserRow_(
                tableSection, rowInfoMap,
                rowInfo.userRow, !rowInfo.isExpanded);
            return;
          }

          // If the row/cell can be selected and it's not selected yet,
          // select it.
          if (isBodyRow && this.selectionMode_ !== SelectionMode.NONE) {
            let shouldSelect = false;
            let shouldFocus = false;
            switch (this.selectionMode_) {
              case SelectionMode.ROW:
                shouldSelect = this.selectedTableRowInfo_ !== rowInfo;
                shouldFocus = true;
                break;
              case SelectionMode.CELL:
                if (this.doesColumnIndexSupportSelection(i)) {
                  shouldSelect = this.selectedTableRowInfo_ !== rowInfo ||
                      this.selectedColumnIndex_ !== i;
                  shouldFocus = true;
                }
                break;
              default:
                throw new Error('Invalid selection mode ' +
                    this.selectionMode_);
            }
            if (shouldFocus) {
              this.focus();
            }
            if (shouldSelect) {
              this.didTableRowInfoGetClicked_(rowInfo, i);
              return;
            }
          }

          // Otherwise, if the row is expandable, expand/collapse it.
          if (isExpandableRow) {
            this.setExpandedForUserRow_(tableSection, rowInfoMap,
                rowInfo.userRow, !rowInfo.isExpanded);
          }
        }.bind(this, i));

        // Add a double-click handler for stepping into a row/cell (if
        // applicable).
        if (isBodyRow) {
          td.addEventListener('dblclick', function(i, e) {
            e.stopPropagation();
            this.dispatchStepIntoEvent_(rowInfo, i);
          }.bind(this, i));
        }

        i += colSpan;
      }

      return rowInfo.htmlNode;
    },

    removeSubNodes_(tableSection, rowInfo, rowInfoMap) {
      if (rowInfo.userRow[this.subRowsPropertyName_] === undefined) return;

      for (let i = 0;
           i < rowInfo.userRow[this.subRowsPropertyName_].length; i++) {
        const subRow = rowInfo.userRow[this.subRowsPropertyName_][i];
        const subRowInfo = rowInfoMap.get(subRow);
        if (!subRowInfo) continue;

        const subNode = subRowInfo.htmlNode;
        if (subNode && Polymer.dom(subNode).parentNode === tableSection) {
          Polymer.dom(tableSection).removeChild(subNode);
          this.removeSubNodes_(tableSection, subRowInfo, rowInfoMap);
        }
      }
    },

    scheduleRebuildHeaders_() {
      this.headerDirty_ = true;
      this.scheduleRebuild_();
    },

    scheduleRebuildBody_() {
      this.bodyDirty_ = true;
      this.scheduleRebuild_();
    },

    scheduleRebuildFooter_() {
      this.footerDirty_ = true;
      this.scheduleRebuild_();
    },

    scheduleRebuild_() {
      if (this.rebuildPending_) return;

      this.rebuildPending_ = true;
      setTimeout(function() {
        this.rebuildPending_ = false;
        this.rebuild();
      }.bind(this), 0);
    },

    rebuildIfNeeded_() {
      this.rebuild();
    },

    rebuild() {
      const wasBodyOrHeaderDirty = this.headerDirty_ || this.bodyDirty_;

      if (this.headerDirty_) {
        this.generateHeaderColumns_();
        this.headerDirty_ = false;
      }
      if (this.bodyDirty_) {
        Polymer.dom(this.$.body).textContent = '';
        this.generateTableRowNodes_(
            this.$.body,
            this.tableRows_, this.tableRowsInfo_, 0,
            undefined, undefined);
        if (this.tableRows_.length === 0 && this.emptyValue_ !== undefined) {
          const trElement = this.ownerDocument.createElement('tr');
          Polymer.dom(this.$.body).appendChild(trElement);
          Polymer.dom(trElement).classList.add('empty-row');
          const td = this.ownerDocument.createElement('td');
          Polymer.dom(trElement).appendChild(td);
          td.colSpan = this.tableColumns_.length;
          const emptyValue = this.emptyValue_;
          Polymer.dom(td).appendChild(
              tr.ui.b.asHTMLOrTextNode(emptyValue, this.ownerDocument));
        }
        this.bodyDirty_ = false;
      }

      if (wasBodyOrHeaderDirty) this.applySizes_();

      if (this.footerDirty_) {
        Polymer.dom(this.$.foot).textContent = '';
        this.generateTableRowNodes_(
            this.$.foot,
            this.tableFooterRows_, this.tableFooterRowsInfo_, 0,
            undefined, undefined);
        if (this.tableFooterRowsInfo_.length) {
          Polymer.dom(this.$.body).classList.add('has-footer');
        } else {
          Polymer.dom(this.$.body).classList.remove('has-footer');
        }
        this.footerDirty_ = false;
      }
    },

    appendNewElement_(parent, tagName) {
      const element = parent.ownerDocument.createElement(tagName);
      Polymer.dom(parent).appendChild(element);
      return element;
    },

    getExpandedForTableRow(userRow) {
      this.rebuildIfNeeded_();
      const rowInfo = this.tableRowsInfo_.get(userRow);
      if (rowInfo === undefined) {
        throw new Error('Row has not been seen, must expand its parents');
      }
      return rowInfo.isExpanded;
    },

    getExpandedForUserRow_(userRow) {
      if (userRow[this.subRowsPropertyName_] === undefined) {
        return false;
      }
      if (userRow[this.subRowsPropertyName_].length === 0) {
        return false;
      }
      if (userRow.isExpanded) {
        return true;
      }
      if ((userRow.isExpanded !== undefined) &&
          (userRow.isExpanded === false)) {
        return false;
      }

      const rowInfo = this.tableRowsInfo_.get(userRow);
      if (rowInfo && rowInfo.isExpanded) {
        return true;
      }

      if (this.defaultExpansionStateCallback_ === undefined) {
        return false;
      }

      let parentUserRow = undefined;
      if (rowInfo && rowInfo.parentRowInfo) {
        parentUserRow = rowInfo.parentRowInfo.userRow;
      }

      return this.defaultExpansionStateCallback_(
          userRow, parentUserRow);
    },

    setExpandedForTableRow(userRow, expanded) {
      this.rebuildIfNeeded_();
      const rowInfo = this.tableRowsInfo_.get(userRow);
      if (rowInfo === undefined) {
        throw new Error('Row has not been seen, must expand its parents');
      }
      return this.setExpandedForUserRow_(this.$.body, this.tableRowsInfo_,
          userRow, expanded);
    },

    setExpandedForUserRow_(tableSection, rowInfoMap,
        userRow, expanded) {
      this.rebuildIfNeeded_();

      const rowInfo = rowInfoMap.get(userRow);
      if (rowInfo === undefined) {
        throw new Error('Row has not been seen, must expand its parents');
      }

      const wasExpanded = rowInfo.isExpanded;

      rowInfo.isExpanded = !!expanded;
      // If no node, then nothing further needs doing.
      if (rowInfo.htmlNode === undefined) return;

      // If its detached, then nothing needs doing.
      if (rowInfo.htmlNode.parentElement !== tableSection) {
        return;
      }

      // Otherwise, rebuild.
      const expandButton =
          Polymer.dom(rowInfo.htmlNode).querySelector('expand-button');
      if (rowInfo.isExpanded) {
        Polymer.dom(expandButton).classList.add('button-expanded');
        const lastAddedRow = rowInfo.htmlNode;
        if (rowInfo.userRow[this.subRowsPropertyName_]) {
          this.generateTableRowNodes_(
              tableSection,
              rowInfo.userRow[this.subRowsPropertyName_], rowInfoMap,
              rowInfo.indentation + 1,
              lastAddedRow, rowInfo);
        }
      } else {
        Polymer.dom(expandButton).classList.remove('button-expanded');
        this.removeSubNodes_(tableSection, rowInfo, rowInfoMap);
      }

      if (wasExpanded !== rowInfo.isExpanded) {
        const e = new tr.b.Event('row-expanded-changed');
        e.row = rowInfo.userRow;
        this.dispatchEvent(e);
      }

      this.maybeUpdateSelectedRow_();
    },

    get selectionMode() {
      return this.selectionMode_;
    },

    set selectionMode(selectionMode) {
      if (!SelectionModeValues.has(selectionMode)) {
        throw new Error('Invalid selection mode ' + selectionMode);
      }
      this.rebuildIfNeeded_();
      this.selectionMode_ = selectionMode;
      this.didSelectionStateChange_();
    },

    get rowHighlightStyle() {
      return this.rowHighlightStyle_;
    },

    set rowHighlightStyle(rowHighlightStyle) {
      if (!HighlightStyleValues.has(rowHighlightStyle)) {
        throw new Error('Invalid row highlight style ' + rowHighlightStyle);
      }
      this.rebuildIfNeeded_();
      this.rowHighlightStyle_ = rowHighlightStyle;
      this.didSelectionStateChange_();
    },

    get resolvedRowHighlightStyle() {
      if (this.rowHighlightStyle_ !== HighlightStyle.DEFAULT) {
        return this.rowHighlightStyle_;
      }
      switch (this.selectionMode_) {
        case SelectionMode.NONE:
          return HighlightStyle.NONE;
        case SelectionMode.ROW:
          return HighlightStyle.DARK;
        case SelectionMode.CELL:
          return HighlightStyle.LIGHT;
        default:
          throw new Error('Invalid selection mode ' + selectionMode);
      }
    },

    get cellHighlightStyle() {
      return this.cellHighlightStyle_;
    },

    set cellHighlightStyle(cellHighlightStyle) {
      if (!HighlightStyleValues.has(cellHighlightStyle)) {
        throw new Error('Invalid cell highlight style ' + cellHighlightStyle);
      }
      this.rebuildIfNeeded_();
      this.cellHighlightStyle_ = cellHighlightStyle;
      this.didSelectionStateChange_();
    },

    get resolvedCellHighlightStyle() {
      if (this.cellHighlightStyle_ !== HighlightStyle.DEFAULT) {
        return this.cellHighlightStyle_;
      }
      switch (this.selectionMode_) {
        case SelectionMode.NONE:
        case SelectionMode.ROW:
          return HighlightStyle.NONE;
        case SelectionMode.CELL:
          return HighlightStyle.DARK;
        default:
          throw new Error('Invalid selection mode ' + selectionMode);
      }
    },

    setHighlightStyle_(highlightAttribute, resolvedHighlightStyle) {
      switch (resolvedHighlightStyle) {
        case HighlightStyle.NONE:
          Polymer.dom(this.$.body).removeAttribute(highlightAttribute);
          break;
        case HighlightStyle.LIGHT:
          Polymer.dom(this.$.body).setAttribute(highlightAttribute, 'light');
          break;
        case HighlightStyle.DARK:
          Polymer.dom(this.$.body).setAttribute(highlightAttribute, 'dark');
          break;
        default:
          throw new Error('Invalid resolved highlight style ' +
              resolvedHighlightStyle);
      }
    },

    didSelectionStateChange_() {
      this.setHighlightStyle_('row-highlight-style',
          this.resolvedRowHighlightStyle);
      this.setHighlightStyle_('cell-highlight-style',
          this.resolvedCellHighlightStyle);

      this.removeSelectedState_();

      switch (this.selectionMode_) {
        case SelectionMode.ROW:
          // TODO: Replace this.selectionMode_ with a proper Polymer attribute.
          Polymer.dom(this.$.body).setAttribute('selection-mode', 'row');
          Polymer.dom(this.$.body).setAttribute('tabindex', 0);
          this.selectedColumnIndex_ = undefined;
          break;
        case SelectionMode.CELL:
          Polymer.dom(this.$.body).setAttribute('selection-mode', 'cell');
          Polymer.dom(this.$.body).setAttribute('tabindex', 0);
          if (this.selectedTableRowInfo_ &&
              this.selectedColumnIndex_ === undefined) {
            const i = this.getFirstSelectableColumnIndex_();
            if (i === -1) {
              // No column is selectable.
              this.selectedTableRowInfo_ = undefined;
            } else {
              this.selectedColumnIndex_ = i;
            }
          }
          break;
        case SelectionMode.NONE:
          Polymer.dom(this.$.body).removeAttribute('selection-mode');
          Polymer.dom(this.$.body).removeAttribute('tabindex');
          this.$.body.blur();  // Remove focus (if applicable).
          this.selectedTableRowInfo_ = undefined;
          this.selectedColumnIndex_ = undefined;
          break;
        default:
          throw new Error('Invalid selection mode ' + this.selectionMode_);
      }

      this.maybeUpdateSelectedRow_();
    },

    maybeUpdateSelectedRow_() {
      if (this.selectedTableRowInfo_ === undefined) return;

      // selectedUserRow may not be visible
      function isVisible(rowInfo) {
        if (!rowInfo.htmlNode) return false;
        return !!rowInfo.htmlNode.parentElement;
      }
      if (isVisible(this.selectedTableRowInfo_)) {
        this.updateSelectedState_();
        return;
      }

      this.removeSelectedState_();
      let curRowInfo = this.selectedTableRowInfo_;
      while (curRowInfo && !isVisible(curRowInfo)) {
        curRowInfo = curRowInfo.parentRowInfo;
      }

      this.selectedTableRowInfo_ = curRowInfo;
      if (this.selectedTableRowInfo_) {
        this.updateSelectedState_();
      } else {
        this.selectedColumnIndex_ = undefined;
      }
    },

    didTableRowInfoGetClicked_(rowInfo, columnIndex) {
      switch (this.selectionMode_) {
        case SelectionMode.NONE:
          return;

        case SelectionMode.CELL:
          if (!this.doesColumnIndexSupportSelection(columnIndex)) {
            return;
          }
          if (this.selectedColumnIndex !== columnIndex) {
            this.selectedColumnIndex = columnIndex;
          }
          // Fall through.

        case SelectionMode.ROW:
          if (this.selectedTableRowInfo_ !== rowInfo) {
            this.selectedTableRow = rowInfo.userRow;
          }
      }
    },

    dispatchStepIntoEvent_(rowInfo, columnIndex) {
      const e = new tr.b.Event('step-into');
      e.tableRow = rowInfo.userRow;
      e.tableColumn = this.tableColumns_[columnIndex];
      e.columnIndex = columnIndex;
      this.dispatchEvent(e);
    },

    /**
     * If the selectionMode is CELL and a cell is selected,
     * return an object containing the row, column, and value of the selected
     * cell.
     *
     * @return {undefined|!Object}
     */
    get selectedCell() {
      const row = this.selectedTableRow;
      const columnIndex = this.selectedColumnIndex;
      if (row === undefined || columnIndex === undefined ||
          this.tableColumns_.length <= columnIndex) {
        return undefined;
      }
      const column = this.tableColumns_[columnIndex];
      return {
        row,
        column,
        value: column.value(row)
      };
    },

    /**
     * If a column is selected, return the object describing the selected
     * column.
     *
     * Columns can be selected independently of rows and cells. So it is
     * possible to select column 0 and cell [0,0], or column 1 and cell [0,0],
     * for example. See |selectedCell| for how to access the selected cell when
     * the selectionMode is CELL.
     *
     * |selectedTableColumn| is entirely independent of |selectedColumnIndex|.
     * When the table selectionMode is CELL, use |selectedTableRow| and
     * |selectedColumnIndex| to find the selected cell.
     * When one or more columns have |selectable:true|, then use
     * |selectedTableColumn| to find the selected column, which may be either
     * the same as or different from |selectedColumnIndex|, if a cell is also
     * selected.
     *
     * @return {number|undefined}
     */
    get selectedTableColumnIndex() {
      const cols = Polymer.dom(this.$.cols).children;
      for (let i = 0; i < cols.length; ++i) {
        if (cols[i].getAttribute('selected')) {
          return i;
        }
      }
      return undefined;
    },

    /**
     * @param {number|undefined} index
     */
    set selectedTableColumnIndex(selectedIndex) {
      const cols = Polymer.dom(this.$.cols).children;
      for (let i = 0; i < cols.length; ++i) {
        if (i === selectedIndex) {
          cols[i].setAttribute('selected', true);
        } else {
          cols[i].removeAttribute('selected');
        }
      }
    },

    get selectedTableRow() {
      if (!this.selectedTableRowInfo_) return undefined;
      return this.selectedTableRowInfo_.userRow;
    },

    set selectedTableRow(userRow) {
      this.rebuildIfNeeded_();
      if (this.selectionMode_ === SelectionMode.NONE) {
        throw new Error('Selection is off.');
      }

      let rowInfo;
      if (userRow === undefined) {
        rowInfo = undefined;
      } else {
        rowInfo = this.tableRowsInfo_.get(userRow);
        if (!rowInfo) {
          throw new Error('Row has not been seen, must expand its parents.');
        }
      }

      const e = this.prepareToChangeSelection_();

      if (!rowInfo) {
        this.selectedColumnIndex_ = undefined;
      } else {
        switch (this.selectionMode_) {
          case SelectionMode.ROW:
            this.selectedColumnIndex_ = undefined;
            break;

          case SelectionMode.CELL:
            if (this.selectedColumnIndex_ === undefined) {
              const i = this.getFirstSelectableColumnIndex_();
              if (i === -1) {
                throw new Error('Cannot find a selectable column.');
              }
              this.selectedColumnIndex_ = i;
            }
            break;

          default:
            throw new Error('Invalid selection mode ' + this.selectionMode_);
        }
      }

      this.selectedTableRowInfo_ = rowInfo;
      this.updateSelectedState_();
      this.dispatchEvent(e);
    },

    prepareToChangeSelection_() {
      const e = new tr.b.Event('selection-changed');
      const previousSelectedRowInfo = this.selectedTableRowInfo_;
      if (previousSelectedRowInfo) {
        e.previousSelectedTableRow = previousSelectedRowInfo.userRow;
      } else {
        e.previousSelectedTableRow = undefined;
      }

      this.removeSelectedState_();

      return e;
    },

    removeSelectedState_() {
      this.setSelectedState_(false);
    },

    updateSelectedState_() {
      this.setSelectedState_(true);
    },

    setSelectedState_(select) {
      if (this.selectedTableRowInfo_ === undefined) return;

      // Row selection.
      const rowNode = this.selectedTableRowInfo_.htmlNode;
      if (select) {
        Polymer.dom(rowNode).setAttribute('selected', true);
      } else {
        Polymer.dom(rowNode).removeAttribute('selected');
      }

      // Cell selection (if applicable).
      const cellNode = Polymer.dom(rowNode).children[this.selectedColumnIndex_];
      if (!cellNode) return;
      if (select) {
        Polymer.dom(cellNode).setAttribute('selected', true);
      } else {
        Polymer.dom(cellNode).removeAttribute('selected');
      }
    },

    doesColumnIndexSupportSelection(columnIndex) {
      const columnInfo = this.tableColumns_[columnIndex];
      const scs = columnInfo.supportsCellSelection;
      if (scs === false) return false;
      return true;
    },

    getFirstSelectableColumnIndex_() {
      for (let i = 0; i < this.tableColumns_.length; i++) {
        if (this.doesColumnIndexSupportSelection(i)) {
          return i;
        }
      }
      return -1;
    },

    getSelectableNodeGivenTableRowNode_(htmlNode) {
      switch (this.selectionMode_) {
        case SelectionMode.ROW:
          return htmlNode;

        case SelectionMode.CELL:
          return Polymer.dom(htmlNode).children[this.selectedColumnIndex_];

        default:
          throw new Error('Invalid selection mode ' + this.selectionMode_);
      }
    },

    get selectedColumnIndex() {
      if (this.selectionMode_ !== SelectionMode.CELL) {
        return undefined;
      }
      return this.selectedColumnIndex_;
    },

    set selectedColumnIndex(selectedColumnIndex) {
      this.rebuildIfNeeded_();
      if (this.selectionMode_ === SelectionMode.NONE) {
        throw new Error('Selection is off.');
      }
      if (selectedColumnIndex < 0 ||
          selectedColumnIndex >= this.tableColumns_.length) {
        throw new Error('Invalid index');
      }
      if (!this.doesColumnIndexSupportSelection(selectedColumnIndex)) {
        throw new Error('Selection is not supported on this column');
      }

      const e = this.prepareToChangeSelection_();
      if (this.selectedColumnIndex_ === undefined) {
        this.selectedTableRowInfo_ = undefined;
      } else if (!this.selectedTableRowInfo_) {
        if (this.tableRows_.length === 0) {
          throw new Error('No available row to be selected');
        }
        this.selectedTableRowInfo_ =
            this.tableRowsInfo_.get(this.tableRows_[0]);
      }
      this.selectedColumnIndex_ = selectedColumnIndex;
      this.updateSelectedState_();
      this.dispatchEvent(e);
    },

    onKeyDown_(e) {
      if (this.selectionMode_ === SelectionMode.NONE) return;

      const CODE_TO_COMMAND_NAMES = {
        13: 'ENTER',
        32: 'SPACE',
        37: 'ARROW_LEFT',
        38: 'ARROW_UP',
        39: 'ARROW_RIGHT',
        40: 'ARROW_DOWN'
      };
      const cmdName = CODE_TO_COMMAND_NAMES[e.keyCode];
      if (cmdName === undefined) return;

      e.stopPropagation();
      e.preventDefault();
      this.performKeyCommand_(cmdName);
    },

    onFocus_(e) {
      // This method should be idempotent. If it can't be, then focus() must be
      // updated.
      if (this.selectionMode_ === SelectionMode.NONE ||
          this.selectedTableRow ||
          this.tableRows_.length === 0) {
        return;
      }

      if (this.selectionMode_ === SelectionMode.CELL &&
          this.getFirstSelectableColumnIndex_() === -1) {
        // If there are no selectable columns in cell selection mode, don't do
        // anything.
        return;
      }

      this.selectedTableRow = this.tableRows_[0];
    },

    focus() {
      this.$.body.focus();

      // Need to manually call onFocus_ here: if the table is invisible for any
      // reason, then the focus event will not fire, but the table may become
      // visible later, and should reflect the focus accurately.
      // If the table is already visible, then this will cause onFocus_ to be
      // called multiple times. That shouldn't be a problem since onFocus_ is
      // idempotent.
      this.onFocus_();
    },

    blur() {
      this.$.body.blur();
    },

    get isFocused() {
      return this.root.activeElement === this.$.body;
    },

    performKeyCommand_(cmdName) {
      this.rebuildIfNeeded_();

      switch (cmdName) {
        case 'ARROW_UP':
          this.selectPreviousOrFirstRowIfPossible_();
          return;

        case 'ARROW_DOWN':
          this.selectNextOrFirstRowIfPossible_();
          return;

        case 'ARROW_RIGHT':
          switch (this.selectionMode_) {
            case SelectionMode.NONE:
              return;  // No action.
            case SelectionMode.ROW:
              this.expandRowAndSelectChildRowIfPossible_();
              return;
            case SelectionMode.CELL:
              this.selectNextSelectableCellToTheRightIfPossible_();
              return;
            default:
              throw new Error('Invalid selection mode ' + this.selectionMode_);
          }

        case 'ARROW_LEFT':
          switch (this.selectionMode_) {
            case SelectionMode.NONE:
              return;  // No action.
            case SelectionMode.ROW:
              this.collapseRowOrSelectParentRowIfPossible_();
              return;
            case SelectionMode.CELL:
              this.selectNextSelectableCellToTheLeftIfPossible_();
              return;
            default:
              throw new Error('Invalid selection mode ' + this.selectionMode_);
          }

        case 'SPACE':
          this.toggleRowExpansionStateIfPossible_();
          return;

        case 'ENTER':
          this.stepIntoSelectionIfPossible_();
          return;

        default:
          throw new Error('Unrecognized command ' + cmdName);
      }
    },

    selectPreviousOrFirstRowIfPossible_() {
      const prev = this.selectedTableRowInfo_ ?
          this.selectedTableRowInfo_.htmlNode.previousElementSibling :
          this.$.body.firstChild;
      if (!prev) return;

      if (this.selectionMode_ === SelectionMode.CELL &&
          this.getFirstSelectableColumnIndex_() === -1) {
        // If there are no selectable columns in cell selection mode, don't do
        // anything.
        return;
      }
      tr.ui.b.scrollIntoViewIfNeeded(prev);
      this.selectedTableRow = prev.rowInfo.userRow;
    },

    selectNextOrFirstRowIfPossible_() {
      this.getFirstSelectableColumnIndex_;
      const next = this.selectedTableRowInfo_ ?
          this.selectedTableRowInfo_.htmlNode.nextElementSibling :
          this.$.body.firstChild;
      if (!next) return;

      if (this.selectionMode_ === SelectionMode.CELL &&
          this.getFirstSelectableColumnIndex_() === -1) {
        // If there are no selectable columns in cell selection mode, don't do
        // anything.
        return;
      }
      tr.ui.b.scrollIntoViewIfNeeded(next);
      this.selectedTableRow = next.rowInfo.userRow;
    },

    expandRowAndSelectChildRowIfPossible_() {
      const selectedRowInfo = this.selectedTableRowInfo_;
      if (!selectedRowInfo ||
          selectedRowInfo.userRow[this.subRowsPropertyName_] === undefined ||
          selectedRowInfo.userRow[this.subRowsPropertyName_].length === 0) {
        return;
      }
      if (!selectedRowInfo.isExpanded) {
        this.setExpandedForTableRow(selectedRowInfo.userRow, true);
      }
      this.selectedTableRow =
          selectedRowInfo.htmlNode.nextElementSibling.rowInfo.userRow;
    },

    collapseRowOrSelectParentRowIfPossible_() {
      const selectedRowInfo = this.selectedTableRowInfo_;
      if (!selectedRowInfo) return;

      if (selectedRowInfo.isExpanded) {
        // If the node is expanded, collapse it.
        this.setExpandedForTableRow(selectedRowInfo.userRow, false);
      } else {
        // If the node is not expanded, select its parent.
        const parentRowInfo = selectedRowInfo.parentRowInfo;
        if (parentRowInfo) {
          this.selectedTableRow = parentRowInfo.userRow;
        }
      }
    },

    selectNextSelectableCellToTheRightIfPossible_() {
      if (!this.selectedTableRowInfo_ ||
          this.selectedColumnIndex_ === undefined) {
        return;
      }
      for (let i = this.selectedColumnIndex_ + 1; i < this.tableColumns_.length;
           i++) {
        if (this.doesColumnIndexSupportSelection(i)) {
          this.selectedColumnIndex = i;
          return;
        }
      }
    },

    selectNextSelectableCellToTheLeftIfPossible_() {
      if (!this.selectedTableRowInfo_ ||
          this.selectedColumnIndex_ === undefined) {
        return;
      }
      for (let i = this.selectedColumnIndex_ - 1; i >= 0; i--) {
        if (this.doesColumnIndexSupportSelection(i)) {
          this.selectedColumnIndex = i;
          return;
        }
      }
    },

    toggleRowExpansionStateIfPossible_() {
      const selectedRowInfo = this.selectedTableRowInfo_;
      if (!selectedRowInfo ||
          selectedRowInfo.userRow[this.subRowsPropertyName_] === undefined ||
          selectedRowInfo.userRow[this.subRowsPropertyName_].length === 0) {
        return;
      }
      this.setExpandedForTableRow(selectedRowInfo.userRow,
          !selectedRowInfo.isExpanded);
    },

    stepIntoSelectionIfPossible_() {
      if (!this.selectedTableRowInfo_) return;
      this.dispatchStepIntoEvent_(this.selectedTableRowInfo_,
          this.selectedColumnIndex_);
    },

    dispatchSortingChangedEvent_() {
      const e = new tr.b.Event('sort-column-changed');
      e.sortColumnIndex = this.sortColumnIndex_;
      e.sortDescending = this.sortDescending_;
      this.dispatchEvent(e);
    }
  });
})();


'use strict';

const ColumnAlignment = tr.ui.b.TableFormat.ColumnAlignment;

Polymer({
  is: 'tr-ui-b-table-header-cell',

  created() {
    this.tapCallback_ = undefined;
    this.cellTitle_ = '';
    this.align_ = undefined;
    this.selectable_ = false;
    this.column_ = undefined;
  },

  ready() {
    this.addEventListener('click', this.onTap_.bind(this));
  },

  set column(column) {
    this.column_ = column;
    this.align = column.align;
    this.cellTitle = column.title;
  },

  get column() {
    return this.column_;
  },

  set cellTitle(value) {
    this.cellTitle_ = value;

    const titleNode = tr.ui.b.asHTMLOrTextNode(
        this.cellTitle_, this.ownerDocument);

    this.$.title.innerText = '';

    Polymer.dom(this.$.title).appendChild(titleNode);
  },

  get cellTitle() {
    return this.cellTitle_;
  },

  set align(align) {
    switch (align) {
      case undefined:
      case ColumnAlignment.LEFT:
        this.style.justifyContent = '';
        break;

      case ColumnAlignment.RIGHT:
        this.style.justifyContent = 'flex-end';
        break;

      default:
        throw new Error('Invalid alignment of column (title=\'' +
            this.cellTitle_ + '\'): ' + align);
    }
    this.align_ = align;
  },

  get align() {
    return this.align_;
  },

  clearSideContent() {
    Polymer.dom(this.$.side).textContent = '';
  },

  set sideContent(content) {
    Polymer.dom(this.$.side).textContent = content;
    this.$.side.style.display = content ? 'inline' : 'none';
  },

  get sideContent() {
    return Polymer.dom(this.$.side).textContent;
  },

  set sideContentDisabled(sideContentDisabled) {
    this.$.side.classList.toggle('disabled', sideContentDisabled);
  },

  get sideContentDisabled() {
    return this.$.side.classList.contains('disabled');
  },

  set tapCallback(callback) {
    this.style.cursor = 'pointer';
    this.tapCallback_ = callback;
  },

  get tapCallback() {
    return this.tapCallback_;
  },

  onTap_() {
    if (this.tapCallback_) {
      this.tapCallback_();
    }
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-alert-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.currentSelection_ = undefined;
    this.$.table.tableColumns = [
      {
        title: 'Label',
        value(row) { return row.name; },
        width: '150px'
      },
      {
        title: 'Value',
        width: '100%',
        value(row) { return row.value; }
      }
    ];
    this.$.table.showHeader = false;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.updateContents_();
  },

  getRowsForSingleAlert_(alert) {
    const rows = [];

    // Arguments
    for (const argName in alert.args) {
      const argView =
          document.createElement('tr-ui-a-generic-object-view');
      argView.object = alert.args[argName];
      rows.push({ name: argName, value: argView });
    }

    // Associated events
    if (alert.associatedEvents.length) {
      alert.associatedEvents.forEach(function(event, i) {
        const linkEl = document.createElement('tr-ui-a-analysis-link');
        linkEl.setSelectionAndContent(
            new tr.model.EventSet(event), event.title);

        let valueString = '';
        if (event instanceof tr.model.TimedEvent) {
          valueString = 'took ' + event.duration.toFixed(2) + 'ms';
        }

        rows.push({
          name: linkEl,
          value: valueString
        });
      });
    }

    // Description
    const descriptionEl = tr.ui.b.createDiv({
      textContent: alert.info.description,
      maxWidth: '300px'
    });
    rows.push({
      name: 'Description',
      value: descriptionEl
    });

    // Additional Reading Links
    if (alert.info.docLinks) {
      alert.info.docLinks.forEach(function(linkObject) {
        const linkEl = document.createElement('a');
        linkEl.target = '_blank';
        linkEl.href = linkObject.href;
        Polymer.dom(linkEl).textContent = Polymer.dom(linkObject).textContent;
        rows.push({
          name: linkObject.label,
          value: linkEl
        });
      });
    }
    return rows;
  },

  getRowsForAlerts_(alerts) {
    if (alerts.length === 1) {
      const rows = [{
        name: 'Alert',
        value: tr.b.getOnlyElement(alerts).title
      }];
      const detailRows = this.getRowsForSingleAlert_(tr.b.getOnlyElement(
          alerts));
      rows.push.apply(rows, detailRows);
      return rows;
    }
    return alerts.map(function(alert) {
      return {
        name: 'Alert',
        value: alert.title,
        isExpanded: alerts.size < 10, // This is somewhat arbitrary for now.
        subRows: this.getRowsForSingleAlert_(alert)
      };
    }, this);
  },

  updateContents_() {
    if (this.currentSelection_ === undefined) {
      this.$.table.rows = [];
      this.$.table.rebuild();
      return;
    }

    const alerts = this.currentSelection_;
    this.$.table.tableRows = this.getRowsForAlerts_(alerts);
    this.$.table.rebuild();
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;
    const result = new tr.model.EventSet();
    for (const event of this.currentSelection_) {
      result.addEventSet(event.associatedEvents);
    }
    return result;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-alert-sub-view',
    tr.model.Alert,
    {
      multi: false,
      title: 'Alert',
    });

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-alert-sub-view',
    tr.model.Alert,
    {
      multi: true,
      title: 'Alerts',
    });


'use strict';

tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-scalar-context-controller',

    created() {
      this.host_ = undefined;
      this.groupToContext_ = new Map();
      this.dirtyGroups_ = new Set();
    },

    attached() {
      if (this.host_) {
        throw new Error(
            'Scalar context controller is already attached to a host');
      }

      const host = findParentOrHost(this);
      if (host.__scalarContextController) {
        throw new Error(
            'Multiple scalar context controllers attached to this host');
      }

      host.__scalarContextController = this;
      this.host_ = host;
    },

    detached() {
      if (!this.host_) {
        throw new Error('Scalar context controller is not attached to a host');
      }
      if (this.host_.__scalarContextController !== this) {
        throw new Error(
            'Scalar context controller is not attached to its host');
      }

      delete this.host_.__scalarContextController;
      this.host_ = undefined;
    },

    getContext(group) {
      return this.groupToContext_.get(group);
    },

    onScalarSpanAdded(group, span) {
      let context = this.groupToContext_.get(group);
      if (context === undefined) {
        context = {
          spans: new Set(),
          range: new tr.b.math.Range()
        };
        this.groupToContext_.set(group, context);
      }
      if (context.spans.has(span)) {
        throw new Error('Scalar span already registered with group: ' + group);
      }
      context.spans.add(span);
      this.markGroupDirtyAndScheduleUpdate_(group);
    },

    onScalarSpanRemoved(group, span) {
      const context = this.groupToContext_.get(group);
      if (!context.spans.has(span)) {
        throw new Error('Scalar span not registered with group: ' + group);
      }
      context.spans.delete(span);
      this.markGroupDirtyAndScheduleUpdate_(group);
    },

    onScalarSpanUpdated(group, span) {
      const context = this.groupToContext_.get(group);
      if (!context.spans.has(span)) {
        throw new Error('Scalar span not registered with group: ' + group);
      }
      this.markGroupDirtyAndScheduleUpdate_(group);
    },

    markGroupDirtyAndScheduleUpdate_(group) {
      const alreadyDirty = this.dirtyGroups_.size > 0;
      this.dirtyGroups_.add(group);
      if (!alreadyDirty) {
        tr.b.requestAnimationFrameInThisFrameIfPossible(
            this.updateContext, this);
      }
    },

    updateContext() {
      const groups = this.dirtyGroups_;
      if (groups.size === 0) return;
      this.dirtyGroups_ = new Set();

      for (const group of groups) {
        this.updateGroup_(group);
      }

      const event = new tr.b.Event('context-updated');
      event.groups = groups;
      this.dispatchEvent(event);
    },

    updateGroup_(group) {
      const context = this.groupToContext_.get(group);
      if (context.spans.size === 0) {
        this.groupToContext_.delete(group);
        return;
      }
      context.range.reset();
      for (const span of context.spans) {
        context.range.addValue(span.value);
      }
    }
  });

  function getScalarContextControllerForElement(element) {
    while (element) {
      if (element.__scalarContextController) {
        return element.__scalarContextController;
      }
      element = findParentOrHost(element);
    }
    return undefined;
  }

  function findParentOrHost(node) {
    if (node.parentElement) {
      return node.parentElement;
    }
    while (Polymer.dom(node).parentNode) {
      node = Polymer.dom(node).parentNode;
    }
    return node.host;
  }

  return {
    getScalarContextControllerForElement,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  /**
   * One common simple way to use this function is
   * createScalarSpan(number, {unit: tr.b.Unit.byName.whatever})
   *
   * This function can also take a Scalar, undefined, or a Histogram plus
   * significance, contextGroup, customContextRange, leftAlign and/or inline.
   *
   * @param {undefined|tr.b.Scalar|tr.v.Histogram} value
   * @param {Object=} opt_config
   * @param {!tr.b.math.Range=} opt_config.customContextRange
   * @param {boolean=} opt_config.leftAlign
   * @param {boolean=} opt_config.inline
   * @param {!tr.b.Unit=} opt_config.unit
   * @param {tr.b.math.Statistics.Significance=} opt_config.significance
   * @param {string=} opt_config.contextGroup
   * @return {(string|!HTMLElement)}
   */
  function createScalarSpan(value, opt_config) {
    if (value === undefined) return '';

    const config = opt_config || {};
    const ownerDocument = config.ownerDocument || document;

    const span = ownerDocument.createElement('tr-v-ui-scalar-span');

    let numericValue;
    if (value instanceof tr.b.Scalar) {
      span.value = value;
      numericValue = value.value;
    } else if (value instanceof tr.v.Histogram) {
      numericValue = value.average;
      if (numericValue === undefined) return '';
      span.setValueAndUnit(numericValue, value.unit);
    } else {
      const unit = config.unit;
      if (unit === undefined) {
        throw new Error(
            'Unit must be provided in config when value is a number');
      }
      span.setValueAndUnit(value, unit);
      numericValue = value;
    }

    if (config.context) {
      span.context = config.context;
    }

    if (config.customContextRange) {
      span.customContextRange = config.customContextRange;
    }

    if (config.leftAlign) {
      span.leftAlign = true;
    }

    if (config.inline) {
      span.inline = true;
    }

    if (config.significance !== undefined) {
      span.significance = config.significance;
    }

    if (config.contextGroup !== undefined) {
      span.contextGroup = config.contextGroup;
    }

    return span;
  }

  return {
    createScalarSpan,
  };
});


'use strict';

Polymer({
  is: 'tr-v-ui-scalar-span',

  properties: {
    /**
     * String identifier for grouping scalar spans with common context (e.g.
     * all scalar spans in a single table column would typically share a common
     * context and, thus, have the same context group identifier). If falsy,
     * the scalar span will NOT be associated with any context.
     */
    contextGroup: {
      type: String,
      reflectToAttribute: true,
      observer: 'contextGroupChanged_'
    }
  },

  created() {
    this.value_ = undefined;
    this.unit_ = undefined;

    // TODO(petrcermak): Merge this into the context controller.
    this.context_ = undefined;

    this.warning_ = undefined;
    this.significance_ = tr.b.math.Statistics.Significance.DONT_CARE;

    // To avoid unnecessary DOM traversal, search for the context controller
    // only when necessary (when the span is attached and has a context group).
    this.shouldSearchForContextController_ = false;
    this.lazyContextController_ = undefined;
    this.onContextUpdated_ = this.onContextUpdated_.bind(this);
    this.updateContents_ = this.updateContents_.bind(this);

    // The span can specify a custom context range, which will override the
    // values from the context controller.
    this.customContextRange_ = undefined;
  },

  get significance() {
    return this.significance_;
  },

  set significance(s) {
    this.significance_ = s;
    this.updateContents_();
  },

  set contentTextDecoration(deco) {
    this.$.content.style.textDecoration = deco;
  },

  get value() {
    return this.value_;
  },

  set value(value) {
    if (value instanceof tr.b.Scalar) {
      this.value_ = value.value;
      this.unit_ = value.unit;
    } else {
      this.value_ = value;
    }
    this.updateContents_();
    if (this.hasContext_(this.contextGroup)) {
      this.contextController_.onScalarSpanUpdated(this.contextGroup, this);
    } else {
      this.updateSparkline_();
    }
  },

  get contextController_() {
    if (this.shouldSearchForContextController_) {
      this.lazyContextController_ =
          tr.v.ui.getScalarContextControllerForElement(this);
      this.shouldSearchForContextController_ = false;
    }
    return this.lazyContextController_;
  },

  hasContext_(contextGroup) {
    // The ordering here is important. It ensures that we avoid a DOM traversal
    // when the span doesn't have a context group.
    return !!(contextGroup && this.contextController_);
  },

  contextGroupChanged_(newContextGroup, oldContextGroup) {
    this.detachFromContextControllerIfPossible_(oldContextGroup);
    if (!this.attachToContextControllerIfPossible_(newContextGroup)) {
      // If the span failed to attach to a controller, it won't receive a
      // context-updated event, so we trigger it manually.
      this.onContextUpdated_();
    }
  },

  attachToContextControllerIfPossible_(contextGroup) {
    if (!this.hasContext_(contextGroup)) return false;

    this.contextController_.addEventListener(
        'context-updated', this.onContextUpdated_);
    this.contextController_.onScalarSpanAdded(contextGroup, this);
    return true;
  },

  detachFromContextControllerIfPossible_(contextGroup) {
    if (!this.hasContext_(contextGroup)) return;

    this.contextController_.removeEventListener(
        'context-updated', this.onContextUpdated_);
    this.contextController_.onScalarSpanRemoved(contextGroup, this);
  },

  attached() {
    tr.b.Unit.addEventListener(
        'display-mode-changed', this.updateContents_);
    this.shouldSearchForContextController_ = true;
    this.attachToContextControllerIfPossible_(this.contextGroup);
  },

  detached() {
    tr.b.Unit.removeEventListener(
        'display-mode-changed', this.updateContents_);
    this.detachFromContextControllerIfPossible_(this.contextGroup);
    this.shouldSearchForContextController_ = false;
    this.lazyContextController_ = undefined;
  },

  onContextUpdated_() {
    this.updateSparkline_();
  },

  get context() {
    return this.context_;
  },

  set context(context) {
    this.context_ = context;
    this.updateContents_();
  },

  get unit() {
    return this.unit_;
  },

  set unit(unit) {
    this.unit_ = unit;
    this.updateContents_();
    this.updateSparkline_();
  },

  setValueAndUnit(value, unit) {
    this.value_ = value;
    this.unit_ = unit;
    this.updateContents_();
  },

  get customContextRange() {
    return this.customContextRange_;
  },

  set customContextRange(customContextRange) {
    this.customContextRange_ = customContextRange;
    this.updateSparkline_();
  },

  get inline() {
    return Polymer.dom(this).classList.contains('inline');
  },

  set inline(inline) {
    if (inline) {
      Polymer.dom(this).classList.add('inline');
    } else {
      Polymer.dom(this).classList.remove('inline');
    }
  },

  get leftAlign() {
    return Polymer.dom(this).classList.contains('left-align');
  },

  set leftAlign(leftAlign) {
    if (leftAlign) {
      Polymer.dom(this).classList.add('left-align');
    } else {
      Polymer.dom(this).classList.remove('left-align');
    }
  },

  updateSparkline_() {
    Polymer.dom(this.$.sparkline).classList.remove('positive');
    Polymer.dom(this.$.sparkline).classList.remove('better');
    Polymer.dom(this.$.sparkline).classList.remove('worse');
    Polymer.dom(this.$.sparkline).classList.remove('same');
    this.$.sparkline.style.display = 'none';
    this.$.sparkline.style.left = '0';
    this.$.sparkline.style.width = '0';

    // Custom context range takes precedence over controller context range.
    let range = this.customContextRange_;
    if (!range && this.hasContext_(this.contextGroup)) {
      const context = this.contextController_.getContext(this.contextGroup);
      if (context) {
        range = context.range;
      }
    }
    if (!range || range.isEmpty) return;

    const leftPoint = Math.min(range.min, 0);
    const rightPoint = Math.max(range.max, 0);
    const pointDistance = rightPoint - leftPoint;
    if (pointDistance === 0) {
      // This can happen, for example, when all spans within the context have
      // zero values (so |range| is [0, 0]).
      return;
    }

    // Draw the sparkline.
    this.$.sparkline.style.display = 'block';
    let left;
    let width;
    if (this.value > 0) {
      width = Math.min(this.value, rightPoint);
      left = -leftPoint;
      Polymer.dom(this.$.sparkline).classList.add('positive');
    } else if (this.value <= 0) {
      width = -Math.max(this.value, leftPoint);
      left = (-leftPoint) - width;
    }
    this.$.sparkline.style.left = this.buildSparklineStyle_(
        left / pointDistance, false);
    this.$.sparkline.style.width = this.buildSparklineStyle_(
        width / pointDistance, true);

    // Set the sparkline color (if applicable).
    const changeClass = this.changeClassName_;
    if (changeClass) {
      Polymer.dom(this.$.sparkline).classList.add(changeClass);
    }
  },

  buildSparklineStyle_(ratio, isWidth) {
    // To avoid visual glitches around the zero value bar, we subtract 1 pixel
    // from the width of the element and multiply the remainder (100% - 1px) by
    // |ratio|. The extra pixel is used for the sparkline border. This allows
    // us to align zero sparklines with both positive and negative values:
    //
    //                          ::::::::::|  +10 MiB
    //                          :::::|        +5 MiB
    //                          |              0 MiB
    //                     |:::::             -5 MiB
    //                |::::::::::            -10 MiB
    //
    let position = 'calc(' + ratio + ' * (100% - 1px)';
    if (isWidth) {
      position += ' + 1px';  // Extra pixel for sparkline border.
    }
    position += ')';
    return position;
  },

  updateContents_() {
    Polymer.dom(this.$.content).textContent = '';
    Polymer.dom(this.$.content).classList.remove('better');
    Polymer.dom(this.$.content).classList.remove('worse');
    Polymer.dom(this.$.content).classList.remove('same');
    this.$.insignificant.style.display = '';
    this.$.significantly_better.style.display = '';
    this.$.significantly_worse.style.display = '';

    if (this.unit_ === undefined) return;

    this.$.content.title = '';
    Polymer.dom(this.$.content).textContent =
        this.unit_.format(this.value, this.context);
    this.updateDelta_();
  },

  updateDelta_() {
    let changeClass = this.changeClassName_;
    if (!changeClass) {
      this.$.significance.style.display = 'none';
      return;  // Not a delta or we don't care.
    }

    this.$.significance.style.display = 'inline';

    let title;
    switch (changeClass) {
      case 'better':
        title = 'improvement';
        break;

      case 'worse':
        title = 'regression';
        break;

      case 'same':
        title = 'no change';
        break;

      default:
        throw new Error('Unknown change class: ' + changeClass);
    }

    // Set the content class separately from the significance class so that
    // the Neutral face is always a neutral color.
    Polymer.dom(this.$.content).classList.add(changeClass);

    switch (this.significance) {
      case tr.b.math.Statistics.Significance.DONT_CARE:
        break;

      case tr.b.math.Statistics.Significance.INSIGNIFICANT:
        if (changeClass !== 'same') title = 'insignificant ' + title;
        this.$.insignificant.style.display = 'inline';
        changeClass = 'same';
        break;

      case tr.b.math.Statistics.Significance.SIGNIFICANT:
        if (changeClass === 'same') {
          throw new Error('How can no change be significant?');
        }
        this.$['significantly_' + changeClass].style.display = 'inline';
        title = 'significant ' + title;
        break;

      default:
        throw new Error('Unknown significance ' + this.significance);
    }

    this.$.significance.title = title;
    this.$.content.title = title;
  },

  get changeClassName_() {
    if (!this.unit_ || !this.unit_.isDelta) return undefined;

    switch (this.unit_.improvementDirection) {
      case tr.b.ImprovementDirection.DONT_CARE:
        return undefined;

      case tr.b.ImprovementDirection.BIGGER_IS_BETTER:
        if (this.value === 0) return 'same';
        return this.value > 0 ? 'better' : 'worse';

      case tr.b.ImprovementDirection.SMALLER_IS_BETTER:
        if (this.value === 0) return 'same';
        return this.value < 0 ? 'better' : 'worse';

      default:
        throw new Error('Unknown improvement direction: ' +
            this.unit_.improvementDirection);
    }
  },

  get warning() {
    return this.warning_;
  },

  set warning(warning) {
    this.warning_ = warning;
    const warningEl = this.$.warning;
    if (this.warning_) {
      warningEl.title = warning;
      warningEl.style.display = 'inline';
    } else {
      warningEl.title = '';
      warningEl.style.display = '';
    }
  },

  // tr-v-ui-time-stamp-span property
  get timestamp() {
    return this.value;
  },

  set timestamp(timestamp) {
    if (timestamp instanceof tr.b.u.TimeStamp) {
      this.value = timestamp;
      return;
    }
    this.setValueAndUnit(timestamp, tr.b.u.Units.timeStampInMs);
  },

  // tr-v-ui-time-duration-span property
  get duration() {
    return this.value;
  },

  set duration(duration) {
    if (duration instanceof tr.b.u.TimeDuration) {
      this.value = duration;
      return;
    }
    this.setValueAndUnit(duration, tr.b.u.Units.timeDurationInMs);
  }
});


'use strict';

/**
 * @fileoverview Helper code for memory dump sub-views.
 */
tr.exportTo('tr.ui.analysis', function() {
  const NO_BREAK_SPACE = String.fromCharCode(160);
  const RIGHTWARDS_ARROW = String.fromCharCode(8594);

  const COLLATOR = new Intl.Collator(undefined, {numeric: true});

  /**
   * A table column for displaying memory dump row titles.
   *
   * @constructor
   */
  function TitleColumn(title) {
    this.title = title;
  }

  TitleColumn.prototype = {
    supportsCellSelection: false,

    /**
     * Get the title associated with a given row.
     *
     * This method will decorate the title with color and '+++'/'---' prefix if
     * appropriate (as determined by the optional row.contexts field).
     * Examples:
     *
     *   +----------------------+-----------------+--------+--------+
     *   | Contexts provided at | Interpretation  | Prefix | Color  |
     *   +----------------------+-----------------+--------+--------+
     *   | 1111111111           | always present  |        |        |
     *   | 0000111111           | added           | +++    | red    |
     *   | 1111111000           | deleted         | ---    | green  |
     *   | 1100111111*          | flaky           |        | purple |
     *   | 0001001111           | added + flaky   | +++    | purple |
     *   | 1111100010           | deleted + flaky | ---    | purple |
     *   +----------------------+-----------------+--------+--------+
     *
     *   *) This means that, given a selection of 10 memory dumps, a particular
     *      row (e.g. a process) was present in the first 2 and last 6 of them
     *      (but not in the third and fourth dump).
     *
     * This method should therefore NOT be overriden by subclasses. The
     * formatTitle method should be overriden instead when necessary.
     */
    value(row) {
      const formattedTitle = this.formatTitle(row);

      const contexts = row.contexts;
      if (contexts === undefined || contexts.length === 0) {
        return formattedTitle;
      }

      // Determine if the row was provided in the first and last row and how
      // many times it changed between being provided and not provided.
      const firstContext = contexts[0];
      const lastContext = contexts[contexts.length - 1];
      let changeDefinedContextCount = 0;
      for (let i = 1; i < contexts.length; i++) {
        if ((contexts[i] === undefined) !== (contexts[i - 1] === undefined)) {
          changeDefinedContextCount++;
        }
      }

      // Determine the color and prefix of the title.
      let color = undefined;
      let prefix = undefined;
      if (!firstContext && lastContext) {
        // The row was added.
        color = 'red';
        prefix = '+++';
      } else if (firstContext && !lastContext) {
        // The row was removed.
        color = 'green';
        prefix = '---';
      }
      if (changeDefinedContextCount > 1) {
        // The row was flaky (added/removed more than once).
        color = 'purple';
      }

      if (color === undefined && prefix === undefined) {
        return formattedTitle;
      }

      const titleEl = document.createElement('span');
      if (prefix !== undefined) {
        const prefixEl = tr.ui.b.createSpan({textContent: prefix});
        // Enforce same width of '+++' and '---'.
        prefixEl.style.fontFamily = 'monospace';
        Polymer.dom(titleEl).appendChild(prefixEl);
        Polymer.dom(titleEl).appendChild(
            tr.ui.b.asHTMLOrTextNode(NO_BREAK_SPACE));
      }
      if (color !== undefined) {
        titleEl.style.color = color;
      }
      Polymer.dom(titleEl).appendChild(
          tr.ui.b.asHTMLOrTextNode(formattedTitle));
      return titleEl;
    },

    /**
     * Format the title associated with a given row. This method is intended to
     * be overriden by subclasses.
     */
    formatTitle(row) {
      return row.title;
    },

    cmp(rowA, rowB) {
      return COLLATOR.compare(rowA.title, rowB.title);
    }
  };

  /**
   * Abstract table column for displaying memory dump data.
   *
   * @constructor
   */
  function MemoryColumn(name, cellPath, aggregationMode) {
    this.name = name;
    this.cellPath = cellPath;
    this.shouldSetContextGroup = false;

    // See MemoryColumn.AggregationMode enum in this file.
    this.aggregationMode = aggregationMode;
  }

  /**
   * Construct columns from cells in a hierarchy of rows and a list of rules.
   *
   * The list of rules contains objects with three fields:
   *
   *   condition: Optional string or regular expression matched against the
   *       name of a cell. If omitted, the rule will match any cell.
   *   importance: Mandatory number which determines the final order of the
   *       columns. The column with the highest importance will be first in the
   *       returned array.
   *   columnConstructor: Mandatory memory column constructor.
   *
   * Example:
   *
   *   const importanceRules = [
   *     {
   *       condition: 'page_size',
   *       columnConstructor: NumericMemoryColumn,
   *       importance: 8
   *     },
   *     {
   *       condition: /size/,
   *       columnConstructor: CustomNumericMemoryColumn,
   *       importance: 10
   *     },
   *     {
   *       // No condition: matches all columns.
   *       columnConstructor: NumericMemoryColumn,
   *       importance: 9
   *     }
   *   ];
   *
   * Given a name of a cell, the corresponding column constructor and
   * importance are determined by the first rule whose condition matches the
   * column's name. For example, given a cell with name 'inner_size', the
   * corresponding column will be constructed using CustomNumericMemoryColumn
   * and its importance (for sorting purposes) will be 10 (second rule).
   *
   * After columns are constructed for all cell names, they are sorted in
   * descending order of importance and the resulting list is returned. In the
   * example above, the constructed columns will be sorted into three groups as
   * follows:
   *
   *      [most important, left in the resulting table]
   *   1. columns whose name contains 'size' excluding 'page_size' because it
   *      would have already matched the first rule (Note that string matches
   *      must be exact so a column named 'page_size2' would not match the
   *      first rule and would therefore belong to this group).
   *   2. columns whose name does not contain 'size'.
   *   3. columns whose name is 'page_size'.
   *      [least important, right in the resulting table]
   *
   * where columns will be sorted alphabetically within each group.
   *
   * @param {!Array.<!Object>} rows
   * @param {!Object} config
   * @param {string} config.cellKey
   * @param {!MemoryColumn.AggregationMode=} config.aggregationMode
   * @param {!Array.<!{
   *            condition: (string|!RegExp)=,
   *            importance: number,
   *            columnConstructor: !function(new: MemoryColumn, ...)=,
   *            shouldSetContextGroup: boolean=
   *        }>} config.rules
   */
  MemoryColumn.fromRows = function(rows, config) {
    // Recursively find the names of all cells of the rows (and their sub-rows).
    const cellNames = new Set();
    function gatherCellNames(rows) {
      rows.forEach(function(row) {
        if (row === undefined) return;
        const fieldCells = row[config.cellKey];
        if (fieldCells !== undefined) {
          for (const [fieldName, fieldCell] of Object.entries(fieldCells)) {
            if (fieldCell === undefined || fieldCell.fields === undefined) {
              continue;
            }
            cellNames.add(fieldName);
          }
        }
        const subRows = row.subRows;
        if (subRows !== undefined) {
          gatherCellNames(subRows);
        }
      });
    }
    gatherCellNames(rows);

    // Based on the provided list of rules, construct the columns and calculate
    // their importance.
    const positions = [];
    cellNames.forEach(function(cellName) {
      const cellPath = [config.cellKey, cellName];
      const matchingRule = MemoryColumn.findMatchingRule(
          cellName, config.rules);
      const constructor = matchingRule.columnConstructor;
      const column = new constructor(
          cellName, cellPath, config.aggregationMode);
      column.shouldSetContextGroup = !!config.shouldSetContextGroup;
      positions.push({
        importance: matchingRule.importance,
        column
      });
    });

    positions.sort(function(a, b) {
      // Sort columns with the same importance alphabetically.
      if (a.importance === b.importance) {
        return COLLATOR.compare(a.column.name, b.column.name);
      }

      // Sort columns in descending order of importance.
      return b.importance - a.importance;
    });

    return positions.map(function(position) { return position.column; });
  };

  MemoryColumn.spaceEqually = function(columns) {
    const columnWidth = (100 / columns.length).toFixed(3) + '%';
    columns.forEach(function(column) {
      column.width = columnWidth;
    });
  };

  MemoryColumn.findMatchingRule = function(name, rules) {
    for (let i = 0; i < rules.length; i++) {
      const rule = rules[i];
      if (MemoryColumn.nameMatchesCondition(name, rule.condition)) {
        return rule;
      }
    }
    return undefined;
  };

  MemoryColumn.nameMatchesCondition = function(name, condition) {
    // Rules without conditions match all columns.
    if (condition === undefined) return true;

    // String conditions must match the column name exactly.
    if (typeof(condition) === 'string') return name === condition;

    // If the condition is not a string, assume it is a RegExp.
    return condition.test(name);
  };

  /** @enum */
  MemoryColumn.AggregationMode = {
    DIFF: 0,
    MAX: 1
  };

  MemoryColumn.SOME_TIMESTAMPS_INFO_QUANTIFIER = 'at some selected timestamps';

  MemoryColumn.prototype = {
    get title() {
      return this.name;
    },

    cell(row) {
      let cell = row;
      const cellPath = this.cellPath;
      for (let i = 0; i < cellPath.length; i++) {
        if (cell === undefined) return undefined;
        cell = cell[cellPath[i]];
      }
      return cell;
    },

    aggregateCells(row, subRows) {
      // No generic aggregation.
    },

    fields(row) {
      const cell = this.cell(row);
      if (cell === undefined) return undefined;
      return cell.fields;
    },

    /**
     * Format a cell associated with this column from the given row. This
     * method is not intended to be overriden.
     */
    value(row) {
      const fields = this.fields(row);
      if (this.hasAllRelevantFieldsUndefined(fields)) return '';

      // Determine the color and infos of the resulting element.
      const contexts = row.contexts;
      const color = this.color(fields, contexts);
      const infos = [];
      this.addInfos(fields, contexts, infos);

      // Format the actual fields.
      const formattedFields = this.formatFields(fields);

      // If no color is specified and there are no infos, there is no need to
      // wrap the value in a span element.#
      if ((color === undefined || formattedFields === '') &&
          infos.length === 0) {
        return formattedFields;
      }

      const fieldEl = document.createElement('span');
      fieldEl.style.display = 'flex';
      fieldEl.style.alignItems = 'center';
      fieldEl.style.justifyContent = 'flex-end';
      Polymer.dom(fieldEl).appendChild(
          tr.ui.b.asHTMLOrTextNode(formattedFields));

      // Add info icons with tooltips.
      infos.forEach(function(info) {
        const infoEl = document.createElement('span');
        infoEl.style.paddingLeft = '4px';
        infoEl.style.cursor = 'help';
        infoEl.style.fontWeight = 'bold';
        Polymer.dom(infoEl).textContent = info.icon;
        if (info.color !== undefined) {
          infoEl.style.color = info.color;
        }
        infoEl.title = info.message;
        Polymer.dom(fieldEl).appendChild(infoEl);
      }, this);

      // Set the color of the element.
      if (color !== undefined) {
        fieldEl.style.color = color;
      }

      return fieldEl;
    },

    /**
     * Returns true iff all fields of a row which are relevant for the current
     * aggregation mode (e.g. first and last field for diff mode) are undefined.
     */
    hasAllRelevantFieldsUndefined(fields) {
      if (fields === undefined) return true;

      switch (this.aggregationMode) {
        case MemoryColumn.AggregationMode.DIFF:
          // Only the first and last field are relevant.
          return fields[0] === undefined &&
              fields[fields.length - 1] === undefined;

        case MemoryColumn.AggregationMode.MAX:
        default:
          // All fields are relevant.
          return fields.every(function(field) { return field === undefined; });
      }
    },

    /**
     * Get the color of the given fields formatted by this column. At least one
     * field relevant for the current aggregation mode is guaranteed to be
     * defined.
     */
    color(fields, contexts) {
      return undefined;
    },

    /**
     * Format an arbitrary number of fields. At least one field relevant for
     * the current aggregation mode is guaranteed to be defined.
     */
    formatFields(fields) {
      if (fields.length === 1) {
        return this.formatSingleField(fields[0]);
      }
      return this.formatMultipleFields(fields);
    },

    /**
     * Format a single defined field.
     *
     * This method is intended to be overriden by field type specific columns
     * (e.g. show '1.0 KiB' instead of '1024' for Scalar(s) representing
     * bytes).
     */
    formatSingleField(field) {
      throw new Error('Not implemented');
    },

    /**
     * Format multiple fields. At least one field relevant for the current
     * aggregation mode is guaranteed to be defined.
     *
     * The aggregation mode specializations of this method (e.g.
     * formatMultipleFieldsDiff) are intended to be overriden by field type
     * specific columns.
     */
    formatMultipleFields(fields) {
      switch (this.aggregationMode) {
        case MemoryColumn.AggregationMode.DIFF:
          return this.formatMultipleFieldsDiff(
              fields[0], fields[fields.length - 1]);

        case MemoryColumn.AggregationMode.MAX:
          return this.formatMultipleFieldsMax(fields);

        default:
          return tr.ui.b.createSpan({
            textContent: '(unsupported aggregation mode)',
            italic: true
          });
      }
    },

    formatMultipleFieldsDiff(firstField, lastField) {
      throw new Error('Not implemented');
    },

    formatMultipleFieldsMax(fields) {
      return this.formatSingleField(this.getMaxField(fields));
    },

    cmp(rowA, rowB) {
      const fieldsA = this.fields(rowA);
      const fieldsB = this.fields(rowB);

      // Sanity check.
      if (fieldsA !== undefined && fieldsB !== undefined &&
          fieldsA.length !== fieldsB.length) {
        throw new Error('Different number of fields');
      }

      // Handle empty fields.
      const undefinedA = this.hasAllRelevantFieldsUndefined(fieldsA);
      const undefinedB = this.hasAllRelevantFieldsUndefined(fieldsB);
      if (undefinedA && undefinedB) return 0;
      if (undefinedA) return -1;
      if (undefinedB) return 1;

      return this.compareFields(fieldsA, fieldsB);
    },

    /**
     * Compare a pair of single or multiple fields. At least one field relevant
     * for the current aggregation mode is guaranteed to be defined in each of
     * the two lists.
     */
    compareFields(fieldsA, fieldsB) {
      if (fieldsA.length === 1) {
        return this.compareSingleFields(fieldsA[0], fieldsB[0]);
      }
      return this.compareMultipleFields(fieldsA, fieldsB);
    },

    /**
     * Compare a pair of single defined fields.
     *
     * This method is intended to be overriden by field type specific columns.
     */
    compareSingleFields(fieldA, fieldB) {
      throw new Error('Not implemented');
    },

    /**
     * Compare a pair of multiple fields. At least one field relevant for the
     * current aggregation mode is guaranteed to be defined in each of the two
     * lists.
     *
     * The aggregation mode specializations of this method (e.g.
     * compareMultipleFieldsDiff) are intended to be overriden by field type
     * specific columns.
     */
    compareMultipleFields(fieldsA, fieldsB) {
      switch (this.aggregationMode) {
        case MemoryColumn.AggregationMode.DIFF:
          return this.compareMultipleFieldsDiff(
              fieldsA[0], fieldsA[fieldsA.length - 1],
              fieldsB[0], fieldsB[fieldsB.length - 1]);

        case MemoryColumn.AggregationMode.MAX:
          return this.compareMultipleFieldsMax(fieldsA, fieldsB);

        default:
          return 0;
      }
    },

    compareMultipleFieldsDiff(firstFieldA, lastFieldA, firstFieldB,
        lastFieldB) {
      throw new Error('Not implemented');
    },

    compareMultipleFieldsMax(fieldsA, fieldsB) {
      return this.compareSingleFields(
          this.getMaxField(fieldsA), this.getMaxField(fieldsB));
    },

    getMaxField(fields) {
      return fields.reduce(function(accumulator, field) {
        if (field === undefined) {
          return accumulator;
        }
        if (accumulator === undefined ||
            this.compareSingleFields(field, accumulator) > 0) {
          return field;
        }
        return accumulator;
      }.bind(this), undefined);
    },

    addInfos(fields, contexts, infos) {
      // No generic infos.
    },

    getImportance(importanceRules) {
      if (importanceRules.length === 0) return 0;

      // Find the first matching rule.
      const matchingRule =
          MemoryColumn.findMatchingRule(this.name, importanceRules);
      if (matchingRule !== undefined) {
        return matchingRule.importance;
      }

      // No matching rule. Return lower importance than all rules.
      let minImportance = importanceRules[0].importance;
      for (let i = 1; i < importanceRules.length; i++) {
        minImportance = Math.min(minImportance, importanceRules[i].importance);
      }
      return minImportance - 1;
    }
  };

  /**
   * @constructor
   */
  function StringMemoryColumn(name, cellPath, aggregationMode) {
    MemoryColumn.call(this, name, cellPath, aggregationMode);
  }

  StringMemoryColumn.prototype = {
    __proto__: MemoryColumn.prototype,

    formatSingleField(string) {
      return string;
    },

    formatMultipleFieldsDiff(firstString, lastString) {
      if (firstString === undefined) {
        // String was added ("+NEW_VALUE" in red).
        const spanEl = tr.ui.b.createSpan({color: 'red'});
        Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode('+'));
        Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode(
            this.formatSingleField(lastString)));
        return spanEl;
      } else if (lastString === undefined) {
        // String was removed ("-OLD_VALUE" in green).
        const spanEl = tr.ui.b.createSpan({color: 'green'});
        Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode('-'));
        Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode(
            this.formatSingleField(firstString)));
        return spanEl;
      } else if (firstString === lastString) {
        // String didn't change ("VALUE" with unchanged color).
        return this.formatSingleField(firstString);
      }
      // String changed ("OLD_VALUE -> NEW_VALUE" in orange).
      const spanEl = tr.ui.b.createSpan({color: 'DarkOrange'});
      Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode(
          this.formatSingleField(firstString)));
      Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode(
          ' ' + RIGHTWARDS_ARROW + ' '));
      Polymer.dom(spanEl).appendChild(tr.ui.b.asHTMLOrTextNode(
          this.formatSingleField(lastString)));
      return spanEl;
    },

    compareSingleFields(stringA, stringB) {
      return COLLATOR.compare(stringA, stringB);
    },

    compareMultipleFieldsDiff(firstStringA, lastStringA, firstStringB,
        lastStringB) {
      // If one of the strings was added (and the other one wasn't), mark the
      // corresponding diff as greater.
      if (firstStringA === undefined && firstStringB !== undefined) {
        return 1;
      }
      if (firstStringA !== undefined && firstStringB === undefined) {
        return -1;
      }

      // If both strings were added, compare the last values (greater last
      // value implies greater diff).
      if (firstStringA === undefined && firstStringB === undefined) {
        return this.compareSingleFields(lastStringA, lastStringB);
      }

      // If one of the strings was removed (and the other one wasn't), mark the
      // corresponding diff as lower.
      if (lastStringA === undefined && lastStringB !== undefined) {
        return -1;
      }
      if (lastStringA !== undefined && lastStringB === undefined) {
        return 1;
      }

      // If both strings were removed, compare the first values (greater first
      // value implies smaller (!) diff).
      if (lastStringA === undefined && lastStringB === undefined) {
        return this.compareSingleFields(firstStringB, firstStringA);
      }

      const areStringsAEqual = firstStringA === lastStringA;
      const areStringsBEqual = firstStringB === lastStringB;

      // Consider diffs of strings that did not change to be smaller than diffs
      // of strings that did change.
      if (areStringsAEqual && areStringsBEqual) return 0;
      if (areStringsAEqual) return -1;
      if (areStringsBEqual) return 1;

      // Both strings changed. We are unable to determine the ordering of the
      // diffs.
      return 0;
    }
  };

  /**
   * @constructor
   */
  function NumericMemoryColumn(name, cellPath, aggregationMode) {
    MemoryColumn.call(this, name, cellPath, aggregationMode);
  }

  // Avoid tiny positive/negative diffs (displayed in the UI as '+0.0 B' and
  // '-0.0 B') due to imprecise floating-point arithmetic by treating all diffs
  // within the (-DIFF_EPSILON, DIFF_EPSILON) range as zeros.
  NumericMemoryColumn.DIFF_EPSILON = 0.0001;

  NumericMemoryColumn.prototype = {
    __proto__: MemoryColumn.prototype,

    align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,

    aggregateCells(row, subRows) {
      const subRowCells = subRows.map(this.cell, this);

      // Determine if there is at least one defined numeric in the sub-row
      // cells and the timestamp count.
      let hasDefinedSubRowNumeric = false;
      let timestampCount = undefined;
      subRowCells.forEach(function(subRowCell) {
        if (subRowCell === undefined) return;

        const subRowNumerics = subRowCell.fields;
        if (subRowNumerics === undefined) return;

        if (timestampCount === undefined) {
          timestampCount = subRowNumerics.length;
        } else if (timestampCount !== subRowNumerics.length) {
          throw new Error('Sub-rows have different numbers of timestamps');
        }

        if (hasDefinedSubRowNumeric) {
          return;  // Avoid unnecessary traversals of the numerics.
        }
        hasDefinedSubRowNumeric = subRowNumerics.some(function(numeric) {
          return numeric !== undefined;
        });
      });
      if (!hasDefinedSubRowNumeric) {
        return;  // No numeric to aggregate.
      }

      // Get or create the row cell.
      const cellPath = this.cellPath;
      let rowCell = row;
      for (let i = 0; i < cellPath.length; i++) {
        const nextStepName = cellPath[i];
        let nextStep = rowCell[nextStepName];
        if (nextStep === undefined) {
          if (i < cellPath.length - 1) {
            nextStep = {};
          } else {
            nextStep = new MemoryCell(undefined);
          }
          rowCell[nextStepName] = nextStep;
        }
        rowCell = nextStep;
      }
      if (rowCell.fields === undefined) {
        rowCell.fields = new Array(timestampCount);
      } else if (rowCell.fields.length !== timestampCount) {
        throw new Error(
            'Row has a different number of timestamps than sub-rows');
      }

      for (let i = 0; i < timestampCount; i++) {
        if (rowCell.fields[i] !== undefined) continue;
        rowCell.fields[i] = tr.model.MemoryAllocatorDump.aggregateNumerics(
            subRowCells.map(function(subRowCell) {
              if (subRowCell === undefined || subRowCell.fields === undefined) {
                return undefined;
              }
              return subRowCell.fields[i];
            }));
      }
    },

    formatSingleField(numeric) {
      return tr.v.ui.createScalarSpan(numeric, {
        context: this.getFormattingContext(numeric.unit),
        contextGroup: this.shouldSetContextGroup ? this.name : undefined,
        inline: true,
      });
    },

    getFormattingContext(unit) {
      return undefined;
    },

    formatMultipleFieldsDiff(firstNumeric, lastNumeric) {
      return this.formatSingleField(
          this.getDiffField_(firstNumeric, lastNumeric));
    },

    compareSingleFields(numericA, numericB) {
      return numericA.value - numericB.value;
    },

    compareMultipleFieldsDiff(firstNumericA, lastNumericA,
        firstNumericB, lastNumericB) {
      return this.getDiffFieldValue_(firstNumericA, lastNumericA) -
          this.getDiffFieldValue_(firstNumericB, lastNumericB);
    },

    getDiffField_(firstNumeric, lastNumeric) {
      const definedNumeric = firstNumeric || lastNumeric;
      return new tr.b.Scalar(definedNumeric.unit.correspondingDeltaUnit,
          this.getDiffFieldValue_(firstNumeric, lastNumeric));
    },

    getDiffFieldValue_(firstNumeric, lastNumeric) {
      const firstValue = firstNumeric === undefined ? 0 : firstNumeric.value;
      const lastValue = lastNumeric === undefined ? 0 : lastNumeric.value;
      const diff = lastValue - firstValue;
      return Math.abs(diff) < NumericMemoryColumn.DIFF_EPSILON ? 0 : diff;
    }
  };

  /**
   * @constructor
   */
  function MemoryCell(fields) {
    this.fields = fields;
  }

  MemoryCell.extractFields = function(cell) {
    if (cell === undefined) return undefined;
    return cell.fields;
  };

  /** Limit for the number of sub-rows for recursive table row expansion. */
  const RECURSIVE_EXPANSION_MAX_VISIBLE_ROW_COUNT = 10;

  function expandTableRowsRecursively(table) {
    let currentLevelRows = table.tableRows;
    let totalVisibleRowCount = currentLevelRows.length;

    while (currentLevelRows.length > 0) {
      // Calculate the total number of sub-rows on the current level.
      let nextLevelRowCount = 0;
      currentLevelRows.forEach(function(currentLevelRow) {
        const subRows = currentLevelRow.subRows;
        if (subRows === undefined || subRows.length === 0) return;
        nextLevelRowCount += subRows.length;
      });

      // Determine whether expanding all rows on the current level would cause
      // the total number of visible rows go over the limit.
      if (totalVisibleRowCount + nextLevelRowCount >
          RECURSIVE_EXPANSION_MAX_VISIBLE_ROW_COUNT) {
        break;
      }

      // Expand all rows on the current level and gather their sub-rows.
      const nextLevelRows = new Array(nextLevelRowCount);
      let nextLevelRowIndex = 0;
      currentLevelRows.forEach(function(currentLevelRow) {
        const subRows = currentLevelRow.subRows;
        if (subRows === undefined || subRows.length === 0) return;
        table.setExpandedForTableRow(currentLevelRow, true);
        subRows.forEach(function(subRow) {
          nextLevelRows[nextLevelRowIndex++] = subRow;
        });
      });

      // Update the total number of visible rows and progress to the next level.
      totalVisibleRowCount += nextLevelRowCount;
      currentLevelRows = nextLevelRows;
    }
  }

  function aggregateTableRowCellsRecursively(row, columns, opt_predicate) {
    const subRows = row.subRows;
    if (subRows === undefined || subRows.length === 0) return;

    subRows.forEach(function(subRow) {
      aggregateTableRowCellsRecursively(subRow, columns, opt_predicate);
    });

    if (opt_predicate === undefined || opt_predicate(row.contexts)) {
      aggregateTableRowCells(row, subRows, columns);
    }
  }

  function aggregateTableRowCells(row, subRows, columns) {
    columns.forEach(function(column) {
      if (!(column instanceof MemoryColumn)) return;
      column.aggregateCells(row, subRows);
    });
  }

  function createCells(timeToValues, valueFieldsGetter, opt_this) {
    opt_this = opt_this || this;
    const fieldNameToFields = tr.b.invertArrayOfDicts(
        timeToValues, valueFieldsGetter, opt_this);
    const result = {};
    for (const [fieldName, fields] of Object.entries(fieldNameToFields)) {
      result[fieldName] = new tr.ui.analysis.MemoryCell(fields);
    }
    return result;
  }

  function createWarningInfo(message) {
    return {
      message,
      icon: String.fromCharCode(9888),
      color: 'red'
    };
  }

  // TODO(petrcermak): Use a context manager instead
  // (https://github.com/catapult-project/catapult/issues/2420).
  function DetailsNumericMemoryColumn(name, cellPath, aggregationMode) {
    NumericMemoryColumn.call(this, name, cellPath, aggregationMode);
  }

  DetailsNumericMemoryColumn.prototype = {
    __proto__: NumericMemoryColumn.prototype,

    getFormattingContext(unit) {
      if (unit.baseUnit === tr.b.Unit.byName.sizeInBytes) {
        return { unitPrefix: tr.b.UnitPrefixScale.BINARY.KIBI };
      }
      return undefined;
    }
  };

  return {
    TitleColumn,
    MemoryColumn,
    StringMemoryColumn,
    NumericMemoryColumn,
    MemoryCell,
    expandTableRowsRecursively,
    aggregateTableRowCellsRecursively,
    aggregateTableRowCells,
    createCells,
    createWarningInfo,
    DetailsNumericMemoryColumn,
  };
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const LATIN_SMALL_LETTER_F_WITH_HOOK = String.fromCharCode(0x0192);
  const CIRCLED_LATIN_CAPITAL_LETTER_T = String.fromCharCode(0x24C9);

  /** @{enum} */
  const HeapDetailsRowDimension = {
    ROOT: {},
    STACK_FRAME: {
      label: 'Stack frame',
      symbol: LATIN_SMALL_LETTER_F_WITH_HOOK,
      color: 'heap_dump_stack_frame'
    },
    OBJECT_TYPE: {
      label: 'Object type',
      symbol: CIRCLED_LATIN_CAPITAL_LETTER_T,
      color: 'heap_dump_object_type'
    }
  };

  /** @{constructor} */
  function HeapDetailsTitleColumn(title) {
    tr.ui.analysis.TitleColumn.call(this, title);
  }

  HeapDetailsTitleColumn.prototype = {
    __proto__: tr.ui.analysis.TitleColumn.prototype,

    formatTitle(row) {
      if (row.dimension === HeapDetailsRowDimension.ROOT) {
        return row.title;
      }

      const symbolEl = document.createElement('span');
      Polymer.dom(symbolEl).textContent = row.dimension.symbol;
      symbolEl.title = row.dimension.label;
      symbolEl.style.color = tr.b.ColorScheme.getColorForReservedNameAsString(
          row.dimension.color);
      symbolEl.style.paddingRight = '4px';
      symbolEl.style.cursor = 'help';
      symbolEl.style.fontWeight = 'bold';

      const titleEl = document.createElement('span');
      Polymer.dom(titleEl).appendChild(symbolEl);
      Polymer.dom(titleEl).appendChild(document.createTextNode(row.title));

      return titleEl;
    }
  };

  /** @constructor */
  function AllocationCountColumn(name, cellPath, aggregationMode) {
    tr.ui.analysis.DetailsNumericMemoryColumn.call(
        this, name, cellPath, aggregationMode);
  }

  AllocationCountColumn.prototype = {
    __proto__: tr.ui.analysis.DetailsNumericMemoryColumn.prototype,

    getFormattingContext(unit) {
      return { minimumFractionDigits: 0 };
    }
  };

  const HEAP_DETAILS_COLUMN_RULES = [
    {
      condition: 'Size',
      importance: 2,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Count',
      importance: 1,
      columnConstructor: AllocationCountColumn
    },
    {
      importance: 0,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    }
  ];

  return {
    HeapDetailsRowDimension,
    HeapDetailsTitleColumn,
    AllocationCountColumn,
    HEAP_DETAILS_COLUMN_RULES,
  };
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const RebuildableBehavior = {
    rebuild() {
      /**
       * Rebuild the pane if necessary.
       *
       * This method is not intended to be overriden by subclasses. Please
       * override scheduleRebuild_() instead.
       */
      if (!this.paneDirty_) {
        // Avoid rebuilding unnecessarily as it breaks things like table
        // selection.
        return;
      }

      this.paneDirty_ = false;
      this.onRebuild_();
    },

    /**
     * Mark the UI state of the pane as dirty and schedule a rebuild.
     *
     * This method is intended to be called by subclasses.
     */
    scheduleRebuild_() {
      if (this.paneDirty_) return;
      this.paneDirty_ = true;
      tr.b.requestAnimationFrame(this.rebuild.bind(this));
    },

    /**
     * Called when the pane is dirty and a rebuild is triggered.
     *
     * This method is intended to be overriden by subclasses (instead of
     * directly overriding rebuild()).
     */
    onRebuild_() {
    }
  };

  return {
    RebuildableBehavior,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-b-tab-view',

  properties: {
    label_: {
      type: String,
      value: () => ''
    },
    selectedSubView_: Object,
    subViews_: {
      type: Array,
      value: () => []
    },
    tabsHidden: {
      type: Boolean,
      value: false,
      observer: 'tabsHiddenChanged_'
    }
  },

  ready() {
    this.$.tabs.addEventListener('keydown', this.onKeyDown_.bind(this), true);
    this.updateFocusability_();
  },

  set label(newLabel) {
    this.set('label_', newLabel);
  },

  get tabs() {
    return this.get('subViews_');
  },

  get selectedSubView() {
    return this.selectedSubView_;
  },

  set selectedSubView(subView) {
    if (subView === this.selectedSubView_) return;

    if (this.selectedSubView_) {
      Polymer.dom(this.$.subView).removeChild(this.selectedSubView_);
      const oldInput = this.root.getElementById(this.computeRadioId_(
          this.selectedSubView_));
      if (oldInput) {
        oldInput.checked = false;
      }
    }

    this.set('selectedSubView_', subView);

    if (subView) {
      Polymer.dom(this.$.subView).appendChild(subView);
      const newInput = this.root.getElementById(this.computeRadioId_(subView));
      if (newInput) {
        newInput.checked = true;
      }
    }

    this.fire('selected-tab-change');
  },

  clearSubViews() {
    this.splice('subViews_', 0, this.subViews_.length);
    this.selectedSubView = undefined;
    this.updateFocusability_();
  },

  addSubView(subView) {
    this.push('subViews_', subView);
    if (!this.selectedSubView_) this.selectedSubView = subView;

    this.updateFocusability_();
  },

  get subViews() {
    return this.subViews_;
  },

  resetSubViews(subViews) {
    this.splice('subViews_', 0, this.subViews_.length);
    if (subViews.length) {
      for (const subView of subViews) {
        this.push('subViews_', subView);
      }
      this.selectedSubView = subViews[0];
    } else {
      this.selectedSubView = undefined;
    }
    this.updateFocusability_();
  },

  onTabChanged_(event) {
    this.selectedSubView = event.model.item;
  },

  isChecked_(subView) {
    return this.selectedSubView_ === subView;
  },

  tabsHiddenChanged_() {
    this.updateFocusability_();
  },

  onKeyDown_(e) {
    if (this.tabsHidden) return;

    let keyHandled = false;
    switch (e.keyCode) {
      // Arrow left.
      case 37:
        keyHandled = this.selectPreviousTabIfPossible();
        break;

      // Arrow right.
      case 39:
        keyHandled = this.selectNextTabIfPossible();
        break;
    }

    if (!keyHandled) return;
    e.stopPropagation();
    e.preventDefault();
  },

  selectNextTabIfPossible() {
    return this.selectTabByOffsetIfPossible_(1);
  },

  selectPreviousTabIfPossible() {
    return this.selectTabByOffsetIfPossible_(-1);
  },

  selectTabByOffsetIfPossible_(offset) {
    if (!this.selectedSubView_) return false;
    const currentIndex = this.subViews_.indexOf(this.selectedSubView_);
    const newSubView = this.tabs[currentIndex + offset];
    if (!newSubView) return false;
    this.selectedSubView = newSubView;
    return true;
  },

  shouldBeFocusable_() {
    return !this.tabsHidden && this.subViews_.length > 0;
  },

  updateFocusability_() {
    if (this.shouldBeFocusable_()) {
      Polymer.dom(this.$.tabs).setAttribute('tabindex', 0);
    } else {
      Polymer.dom(this.$.tabs).removeAttribute('tabindex');
    }
  },

  computeRadioId_(subView) {
    // We can't just use the tagName as the radio's ID because there are
    // instances where a single subview type can handle multiple event types,
    // and thus might be present multiple times in a single tab view. In order
    // to avoid the case where we might have two tabs with the same ID, we
    // uniquify this ID by appending the tab's label with all spaces replaced
    // by dashes (because spaces aren't allowed in HTML IDs).
    return subView.tagName + '-' + subView.tabLabel.replace(/ /g, '-');
  }
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const RESONABLE_NUMBER_OF_ROWS = 200;

  const TabUiState = {
    NO_LONG_TAIL: 0,
    HIDING_LONG_TAIL: 1,
    SHOWING_LONG_TAIL: 2,
  };

  /** @constructor */
  function EmptyFillerColumn() {}

  EmptyFillerColumn.prototype = {
    title: '',

    value() {
      return '';
    },
  };

  Polymer({
    is: 'tr-ui-a-memory-dump-heap-details-breakdown-view',
    behaviors: [tr.ui.analysis.RebuildableBehavior],

    created() {
      this.displayedNode_ = undefined;
      this.dimensionToTab_ = new Map();
    },

    ready() {
      this.scheduleRebuild_();
      this.root.addEventListener('keydown', this.onKeyDown_.bind(this), true);
    },

    get displayedNode() {
      return this.displayedNode_;
    },

    set displayedNode(node) {
      this.displayedNode_ = node;
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      for (const tab of this.$.tabs.tabs) {
        tab.aggregationMode = aggregationMode;
      }
    },

    onRebuild_() {
      const previouslySelectedTab = this.$.tabs.selectedSubView;
      let previouslySelectedTabFocused = false;
      let previouslySelectedDimension = undefined;
      if (previouslySelectedTab) {
        previouslySelectedTabFocused = previouslySelectedTab.isFocused;
        previouslySelectedDimension = previouslySelectedTab.dimension;
      }

      for (const tab of this.$.tabs.tabs) {
        tab.nodes = undefined;
      }
      this.$.tabs.clearSubViews();

      if (this.displayedNode_ === undefined) {
        this.$.tabs.label = 'No heap node provided.';
        return;
      }

      for (const [dimension, children] of this.displayedNode_.childNodes) {
        if (!this.dimensionToTab_.has(dimension)) {
          this.dimensionToTab_.set(dimension, document.createElement(
              'tr-ui-a-memory-dump-heap-details-breakdown-view-tab'));
        }
        const tab = this.dimensionToTab_.get(dimension);
        tab.aggregationMode = this.aggregationMode_;
        tab.dimension = dimension;
        tab.nodes = children;
        this.$.tabs.addSubView(tab);
        tab.rebuild();
        if (dimension === previouslySelectedDimension) {
          this.$.tabs.selectedSubView = tab;
          if (previouslySelectedTabFocused) {
            tab.focus();
          }
        }
      }

      if (this.$.tabs.tabs.length > 0) {
        this.$.tabs.label = 'Break selected node further by:';
      } else {
        this.$.tabs.label = 'Selected node cannot be broken down any further.';
      }
    },

    onKeyDown_(keyEvent) {
      if (!this.displayedNode_) return;

      let keyHandled = false;
      switch (keyEvent.keyCode) {
        case 8: {
          // Backspace.
          if (!this.displayedNode_.parentNode) break;

          // Enter the parent node upon pressing backspace.
          const viewEvent = new tr.b.Event('enter-node');
          viewEvent.node = this.displayedNode_.parentNode;
          this.dispatchEvent(viewEvent);
          keyHandled = true;
          break;
        }

        case 37:  // Left arrow.
        case 39:  // Right arrow.
          {
            const wasFocused = this.$.tabs.selectedSubView.isFocused;
            keyHandled = keyEvent.keyCode === 37 ?
                this.$.tabs.selectPreviousTabIfPossible() :
                this.$.tabs.selectNextTabIfPossible();
            if (wasFocused && keyHandled) {
              this.$.tabs.selectedSubView.focus();  // Restore focus to new tab.
            }
          }
      }

      if (!keyHandled) return;
      keyEvent.stopPropagation();
      keyEvent.preventDefault();
    }
  });

  Polymer({
    is: 'tr-ui-a-memory-dump-heap-details-breakdown-view-tab',
    behaviors: [tr.ui.analysis.RebuildableBehavior],

    created() {
      this.dimension_ = undefined;
      this.nodes_ = undefined;
      this.aggregationMode_ = undefined;
      this.displayLongTail_ = false;
    },

    ready() {
      this.$.table.addEventListener('step-into', function(tableEvent) {
        const viewEvent = new tr.b.Event('enter-node');
        viewEvent.node = tableEvent.tableRow;
        this.dispatchEvent(viewEvent);
      }.bind(this));
    },

    get displayLongTail() {
      return this.displayLongTail_;
    },

    set displayLongTail(newValue) {
      if (this.displayLongTail === newValue) return;
      this.displayLongTail_ = newValue;
      this.scheduleRebuild_();
    },

    get dimension() {
      return this.dimension_;
    },

    set dimension(dimension) {
      this.dimension_ = dimension;
      this.scheduleRebuild_();
    },

    get nodes() {
      return this.nodes_;
    },

    set nodes(nodes) {
      this.nodes_ = nodes;
      this.scheduleRebuild_();
    },

    get nodes() {
      return this.nodes_ || [];
    },

    get dimensionLabel_() {
      if (this.dimension_ === undefined) return '(undefined)';
      return this.dimension_.label;
    },

    get tabLabel() {
      let nodeCount = 0;
      if (this.nodes_) {
        nodeCount = this.nodes_.length;
      }
      return this.dimensionLabel_ + ' (' + nodeCount + ')';
    },

    get tabIcon() {
      if (this.dimension_ === undefined ||
          this.dimension_ === tr.ui.analysis.HeapDetailsRowDimension.ROOT) {
        return undefined;
      }
      return {
        text: this.dimension_.symbol,
        style: 'color: ' + tr.b.ColorScheme.getColorForReservedNameAsString(
            this.dimension_.color) + ';'
      };
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    focus() {
      this.$.table.focus();
    },

    blur() {
      this.$.table.blur();
    },

    get isFocused() {
      return this.$.table.isFocused;
    },

    onRebuild_() {
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
      this.$.table.emptyValue = 'Cannot break down by ' +
          this.dimensionLabel_.toLowerCase() + ' any further.';
      const [state, rows] = this.getRows_();
      const total = this.nodes.length;
      const displayed = rows.length;
      const hidden = total - displayed;
      this.updateInfoBar_(state, [total, displayed, hidden]);
      this.$.table.tableRows = rows;
      this.$.table.tableColumns = this.createColumns_(rows);
      if (this.$.table.sortColumnIndex === undefined) {
        this.$.table.sortColumnIndex = 0;
        this.$.table.sortDescending = false;
      }
      this.$.table.rebuild();
    },

    createColumns_(rows) {
      const titleColumn = new tr.ui.analysis.HeapDetailsTitleColumn(
          this.dimensionLabel_);
      titleColumn.width = '400px';

      const numericColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'cells',
        aggregationMode: this.aggregationMode_,
        rules: tr.ui.analysis.HEAP_DETAILS_COLUMN_RULES,
        shouldSetContextGroup: true
      });
      if (numericColumns.length === 0) {
        numericColumns.push(new EmptyFillerColumn());
      }
      tr.ui.analysis.MemoryColumn.spaceEqually(numericColumns);

      const columns = [titleColumn].concat(numericColumns);
      return columns;
    },

    getRows_() {
      let rows = this.nodes;
      if (rows.length <= RESONABLE_NUMBER_OF_ROWS) {
        return [TabUiState.NO_LONG_TAIL, rows];
      } else if (this.displayLongTail) {
        return [TabUiState.SHOWING_LONG_TAIL, rows];
      }
      const absSize = row => Math.max(row.cells.Size.fields[0].value);
      rows.sort((a, b) => absSize(b) - absSize(a));
      rows = rows.slice(0, RESONABLE_NUMBER_OF_ROWS);
      return [TabUiState.HIDING_LONG_TAIL, rows];
    },

    updateInfoBar_(state, rowStats) {
      if (state === TabUiState.SHOWING_LONG_TAIL) {
        this.longTailVisibleInfoBar_(rowStats);
      } else if (state === TabUiState.HIDING_LONG_TAIL) {
        this.longTailHiddenInfoBar_(rowStats);
      } else {
        this.hideInfoBar_();
      }
    },

    longTailVisibleInfoBar_(rowStats) {
      const [total, visible, hidden] = rowStats;
      const couldHide = total - RESONABLE_NUMBER_OF_ROWS;
      this.$.info.message = 'Showing ' + total + ' rows. This may be slow.';
      this.$.info.removeAllButtons();
      const buttonText = 'Hide ' + couldHide + ' rows.';
      this.$.info.addButton(buttonText, () => this.displayLongTail = false);
      this.$.info.visible = true;
    },

    longTailHiddenInfoBar_(rowStats) {
      const [total, visible, hidden] = rowStats;
      this.$.info.message = 'Hiding the smallest ' + hidden + ' rows.';
      this.$.info.removeAllButtons();
      this.$.info.addButton('Show all.', () => this.displayLongTail = true);
      this.$.info.visible = true;
    },

    hideInfoBar_() {
      this.$.info.visible = false;
    },

  });

  return {};
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const DOWNWARDS_ARROW_WITH_TIP_RIGHTWARDS = String.fromCharCode(0x21B3);

  function HeapDetailsPathColumn(title) {
    tr.ui.analysis.HeapDetailsTitleColumn.call(this, title);
  }

  HeapDetailsPathColumn.prototype = {
    __proto__: tr.ui.analysis.HeapDetailsTitleColumn.prototype,

    formatTitle(row) {
      const title = tr.ui.analysis.HeapDetailsTitleColumn.prototype.
          formatTitle.call(this, row);
      if (row.dimension === tr.ui.analysis.HeapDetailsRowDimension.ROOT) {
        return title;
      }

      const arrowEl = document.createElement('span');
      Polymer.dom(arrowEl).textContent = DOWNWARDS_ARROW_WITH_TIP_RIGHTWARDS;
      arrowEl.style.paddingRight = '2px';
      arrowEl.style.fontWeight = 'bold';
      arrowEl.style.color = tr.b.ColorScheme.getColorForReservedNameAsString(
          'heap_dump_child_node_arrow');

      const rowEl = document.createElement('span');
      Polymer.dom(rowEl).appendChild(arrowEl);
      Polymer.dom(rowEl).appendChild(tr.ui.b.asHTMLOrTextNode(title));
      return rowEl;
    }
  };

  Polymer({
    is: 'tr-ui-a-memory-dump-heap-details-path-view',
    behaviors: [tr.ui.analysis.RebuildableBehavior],

    created() {
      this.selectedNode_ = undefined;
      this.aggregationMode_ = undefined;
    },

    ready() {
      this.$.table.addEventListener('selection-changed', function(event) {
        this.selectedNode_ = this.$.table.selectedTableRow;
        this.didSelectedNodeChange_();
      }.bind(this));
    },

    didSelectedNodeChange_() {
      this.dispatchEvent(new tr.b.Event('selected-node-changed'));
    },

    get selectedNode() {
      return this.selectedNode_;
    },

    set selectedNode(node) {
      this.selectedNode_ = node;
      this.didSelectedNodeChange_();
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    onRebuild_() {
      if (this.selectedNode_ === undefined) {
        this.$.table.clear();
        return;
      }

      if (this.$.table.tableRows.includes(this.selectedNode_)) {
        this.$.table.selectedTableRow = this.selectedNode_;
        return;
      }

      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
      this.$.table.userCanModifySortOrder = false;
      const rows = this.createRows_(this.selectedNode_);
      this.$.table.tableRows = rows;
      this.$.table.tableColumns = this.createColumns_(rows);
      this.$.table.selectedTableRow = rows[rows.length - 1];
    },

    createRows_(node) {
      const rows = [];
      while (node) {
        rows.push(node);
        node = node.parentNode;
      }
      rows.reverse();
      return rows;
    },

    createColumns_(rows) {
      const titleColumn = new HeapDetailsPathColumn('Current path');
      titleColumn.width = '200px';

      const numericColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'cells',
        aggregationMode: this.aggregationMode_,
        rules: tr.ui.analysis.HEAP_DETAILS_COLUMN_RULES,
        shouldSetContextGroup: true
      });
      tr.ui.analysis.MemoryColumn.spaceEqually(numericColumns);

      return [titleColumn].concat(numericColumns);
    }
  });

  return {};
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const StackedPaneImpl = {
    /**
     * Request changing the child pane of this pane in the associated stacked
     * pane view. If the assigned builder is undefined, request removing the
     * current child pane.
     *
     * Note that setting this property before appended() is called will have no
     * effect (as there will be no listener attached to the pane).
     *
     * This method is intended to be called by subclasses.
     */
    set childPaneBuilder(childPaneBuilder) {
      this.childPaneBuilder_ = childPaneBuilder;
      this.dispatchEvent(new tr.b.Event('request-child-pane-change'));
    },

    get childPaneBuilder() {
      return this.childPaneBuilder_;
    },

    /**
     * Called right after the pane is appended to a pane view.
     *
     * This method triggers an immediate rebuild by default. Subclasses are
     * free to change this behavior (e.g. if a pane has lots of data to display,
     * it might decide to defer rebuilding in order not to cause jank).
     */
    appended() {
      this.rebuild();
    }
  };

  const StackedPane = [tr.ui.analysis.RebuildableBehavior, StackedPaneImpl];

  return {
    StackedPane,
  };
});

Polymer({
  is: 'tr-ui-a-stacked-pane',
  behaviors: [tr.ui.analysis.StackedPane]
});


'use strict';

Polymer({
  is: 'tr-ui-b-drag-handle',

  created() {
    this.lastMousePos_ = 0;
    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.onMouseUp_ = this.onMouseUp_.bind(this);
    this.addEventListener('mousedown', this.onMouseDown_);
    this.target_ = undefined;
    this.horizontal = true;
    this.observer_ = new WebKitMutationObserver(
        this.didTargetMutate_.bind(this));
    this.targetSizesByModeKey_ = {};
  },

  get modeKey_() {
    return this.target_.className === '' ? '.' : this.target_.className;
  },

  get target() {
    return this.target_;
  },

  set target(target) {
    this.observer_.disconnect();
    this.target_ = target;
    if (!this.target_) return;
    this.observer_.observe(this.target_, {
      attributes: true,
      attributeFilter: ['class']
    });
  },

  get horizontal() {
    return this.horizontal_;
  },

  set horizontal(h) {
    this.horizontal_ = h;
    if (this.horizontal_) {
      this.className = 'horizontal-drag-handle';
    } else {
      this.className = 'vertical-drag-handle';
    }
  },

  get vertical() {
    return !this.horizontal_;
  },

  set vertical(v) {
    this.horizontal = !v;
  },

  forceMutationObserverFlush_() {
    const records = this.observer_.takeRecords();
    if (records.length) {
      this.didTargetMutate_(records);
    }
  },

  didTargetMutate_(e) {
    const modeSize = this.targetSizesByModeKey_[this.modeKey_];
    if (modeSize !== undefined) {
      this.setTargetSize_(modeSize);
      return;
    }

    // If we hadn't previously sized the target, then just remove any manual
    // sizing that we applied.
    this.target_.style[this.targetStyleKey_] = '';
  },

  get targetStyleKey_() {
    return this.horizontal_ ? 'height' : 'width';
  },

  getTargetSize_() {
    // If style is not set, start off with computed height.
    const targetStyleKey = this.targetStyleKey_;
    if (!this.target_.style[targetStyleKey]) {
      this.target_.style[targetStyleKey] =
          window.getComputedStyle(this.target_)[targetStyleKey];
    }
    const size = parseInt(this.target_.style[targetStyleKey]);
    this.targetSizesByModeKey_[this.modeKey_] = size;
    return size;
  },

  setTargetSize_(s) {
    this.target_.style[this.targetStyleKey_] = s + 'px';
    this.targetSizesByModeKey_[this.modeKey_] = s;
    tr.b.dispatchSimpleEvent(this, 'drag-handle-resize', true, false);
  },

  applyDelta_(delta) {
    // Apply new size to the container.
    const curSize = this.getTargetSize_();
    let newSize;
    if (this.target_ === this.nextElementSibling) {
      newSize = curSize + delta;
    } else {
      newSize = curSize - delta;
    }
    this.setTargetSize_(newSize);
  },

  onMouseMove_(e) {
    // Compute the difference in height position.
    const curMousePos = this.horizontal_ ? e.clientY : e.clientX;
    const delta = this.lastMousePos_ - curMousePos;

    this.applyDelta_(delta);

    this.lastMousePos_ = curMousePos;
    e.preventDefault();
    return true;
  },

  onMouseDown_(e) {
    if (!this.target_) return;
    this.forceMutationObserverFlush_();
    this.lastMousePos_ = this.horizontal_ ? e.clientY : e.clientX;
    document.addEventListener('mousemove', this.onMouseMove_);
    document.addEventListener('mouseup', this.onMouseUp_);
    e.preventDefault();
    return true;
  },

  onMouseUp_(e) {
    document.removeEventListener('mousemove', this.onMouseMove_);
    document.removeEventListener('mouseup', this.onMouseUp_);
    e.preventDefault();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-b-info-bar',

  ready() {
    this.messageEl_ = this.$.message;
    this.buttonsEl_ = this.$.buttons;

    this.message = '';
  },

  get message() {
    return Polymer.dom(this.messageEl_).textContent;
  },

  set message(message) {
    Polymer.dom(this.messageEl_).textContent = message;
  },

  get visible() {
    return !this.hidden;
  },

  set visible(visible) {
    this.hidden = !visible;
  },

  removeAllButtons() {
    Polymer.dom(this.buttonsEl_).textContent = '';
  },

  addButton(text, clickCallback) {
    const button = document.createElement('button');
    Polymer.dom(button).textContent = text;
    button.addEventListener('click', event => clickCallback(event, this));
    Polymer.dom(this.buttonsEl_).appendChild(button);
    return button;
  }
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const Scalar = tr.b.Scalar;
  const sizeInBytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;
  const count_smallerIsBetter = tr.b.Unit.byName.count_smallerIsBetter;
  const MultiDimensionalViewBuilder = tr.b.MultiDimensionalViewBuilder;
  const TotalState = tr.b.MultiDimensionalViewNode.TotalState;

  /** @{constructor} */
  function HeapDumpTreeNode(
      stackFrameNodes, dimension, title, heavyView, parentNode) {
    this.dimension = dimension;
    this.title = title;
    this.parentNode = parentNode;

    this.heavyView_ = heavyView;
    this.stackFrameNodes_ = stackFrameNodes;
    this.lazyCells_ = undefined;
    this.lazyChildNodes_ = undefined;
  }

  HeapDumpTreeNode.prototype = {
    get minDisplayedTotalState_() {
      if (this.heavyView_) {
        // Show lower-bound and exact values in heavy views.
        return TotalState.LOWER_BOUND;
      }
      // Show only exact values in tree view.
      return TotalState.EXACT;
    },

    get childNodes() {
      if (!this.lazyChildNodes_) {
        this.lazyChildNodes_ = new Map();
        this.addDimensionChildNodes_(
            tr.ui.analysis.HeapDetailsRowDimension.STACK_FRAME, 0);
        this.addDimensionChildNodes_(
            tr.ui.analysis.HeapDetailsRowDimension.OBJECT_TYPE, 1);
        this.releaseStackFrameNodesIfPossible_();
      }
      return this.lazyChildNodes_;
    },

    get cells() {
      if (!this.lazyCells_) {
        this.addCells_();
        this.releaseStackFrameNodesIfPossible_();
      }
      return this.lazyCells_;
    },

    releaseStackFrameNodesIfPossible_() {
      if (this.lazyCells_ && this.lazyChildNodes_) {
        // Don't unnecessarily hold a reference to the stack frame nodes when
        // we don't need them anymore.
        this.stackFrameNodes_ = undefined;
      }
    },

    addDimensionChildNodes_(dimension, dimensionIndex) {
      // Child title -> Timestamp (list index) -> Child
      // MultiDimensionalViewNode.
      const dimensionChildTitleToStackFrameNodes = tr.b.invertArrayOfDicts(
          this.stackFrameNodes_,
          node => this.convertStackFrameNodeDimensionToChildDict_(
              node, dimensionIndex));

      // Child title (list index) -> Child HeapDumpTreeNode.
      const dimensionChildNodes = [];
      for (const [childTitle, childStackFrameNodes] of
          Object.entries(dimensionChildTitleToStackFrameNodes)) {
        dimensionChildNodes.push(new HeapDumpTreeNode(childStackFrameNodes,
            dimension, childTitle, this.heavyView_, this));
      }
      this.lazyChildNodes_.set(dimension, dimensionChildNodes);
    },

    convertStackFrameNodeDimensionToChildDict_(
        stackFrameNode, dimensionIndex) {
      const childDict = {};
      let displayedChildrenTotalSize = 0;
      let displayedChildrenTotalCount = 0;
      let hasDisplayedChildren = false;
      let allDisplayedChildrenHaveDisplayedCounts = true;
      for (const child of stackFrameNode.children[dimensionIndex].values()) {
        if (child.values[0].totalState < this.minDisplayedTotalState_) {
          continue;
        }
        if (child.values[1].totalState < this.minDisplayedTotalState_) {
          allDisplayedChildrenHaveDisplayedCounts = false;
        }
        childDict[child.title[dimensionIndex]] = child;
        displayedChildrenTotalSize += child.values[0].total;
        displayedChildrenTotalCount += child.values[1].total;
        hasDisplayedChildren = true;
      }

      const nodeTotalSize = stackFrameNode.values[0].total;
      const nodeTotalCount = stackFrameNode.values[1].total;

      // Add '<other>' node if necessary in tree-view.
      const hasUnclassifiedSizeOrCount =
          displayedChildrenTotalSize < nodeTotalSize ||
          displayedChildrenTotalCount < nodeTotalCount;
      if (!this.heavyView_ && hasUnclassifiedSizeOrCount &&
          hasDisplayedChildren) {
        const otherTitle = stackFrameNode.title.slice();
        otherTitle[dimensionIndex] = '<other>';
        const otherNode = new tr.b.MultiDimensionalViewNode(otherTitle, 2);
        childDict[otherTitle[dimensionIndex]] = otherNode;

        // '<other>' node size.
        otherNode.values[0].total = nodeTotalSize - displayedChildrenTotalSize;
        otherNode.values[0].totalState = this.minDisplayedTotalState_;

        // '<other>' node allocation count.
        otherNode.values[1].total =
            nodeTotalCount - displayedChildrenTotalCount;
        // Don't show allocation count of the '<other>' node if there is a
        // displayed child node that did NOT display allocation count.
        otherNode.values[1].totalState =
            allDisplayedChildrenHaveDisplayedCounts ?
                this.minDisplayedTotalState_ : TotalState.NOT_PROVIDED;
      }

      return childDict;
    },

    addCells_() {
      // Transform a chronological list of heap stack frame tree nodes into a
      // dictionary of cells (where each cell contains a chronological list
      // of the values of its numeric).
      this.lazyCells_ = tr.ui.analysis.createCells(this.stackFrameNodes_,
          function(stackFrameNode) {
            const size = stackFrameNode.values[0].total;
            const numerics = {
              'Size': new Scalar(sizeInBytes_smallerIsBetter, size)
            };
            const countValue = stackFrameNode.values[1];
            if (countValue.totalState >= this.minDisplayedTotalState_) {
              const count = countValue.total;
              numerics.Count = new Scalar(
                  count_smallerIsBetter, count);
            }
            return numerics;
          }, this);
    }
  };

  Polymer({
    is: 'tr-ui-a-memory-dump-heap-details-pane',
    behaviors: [tr.ui.analysis.StackedPane],

    created() {
      this.heapDumps_ = undefined;
      this.viewMode_ = undefined;
      this.aggregationMode_ = undefined;
      this.cachedBuilders_ = new Map();
    },

    ready() {
      this.$.info_bar.message = 'Note: Values displayed in the heavy view ' +
          'are lower bounds (except for the root).';

      Polymer.dom(this.$.view_mode_container).appendChild(
          tr.ui.b.createSelector(
              this, 'viewMode', 'memoryDumpHeapDetailsPane.viewMode',
              MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW,
              [
                {
                  label: 'Top-down (Tree)',
                  value: MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW
                },
                {
                  label: 'Top-down (Heavy)',
                  value:
                      MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW
                },
                {
                  label: 'Bottom-up (Heavy)',
                  value:
                      MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW
                }
              ]));

      this.$.drag_handle.target = this.$.path_view;
      this.$.drag_handle.horizontal = false;

      // If the user selects a node in the path view, show its children in the
      // breakdown view.
      this.$.path_view.addEventListener('selected-node-changed', (function(e) {
        this.$.breakdown_view.displayedNode = this.$.path_view.selectedNode;
      }).bind(this));

      // If the user double-clicks on a node in the breakdown view, select the
      // node in the path view.
      this.$.breakdown_view.addEventListener('enter-node', (function(e) {
        this.$.path_view.selectedNode = e.node;
      }).bind(this));
    },

    /**
     * Sets the heap dumps and schedules rebuilding the pane.
     *
     * The provided value should be a chronological list of heap dumps. All
     * dumps are assumed to belong to the same process and belong to the same
     * allocator. Example:
     *
     *   [
     *     tr.model.HeapDump {},  // Heap dump at timestamp 1.
     *     undefined,  // Heap dump not provided at timestamp 2.
     *     tr.model.HeapDump {},  // Heap dump at timestamp 3.
     *   ]
     */
    set heapDumps(heapDumps) {
      this.heapDumps_ = heapDumps;
      this.scheduleRebuild_();
    },

    get heapDumps() {
      return this.heapDumps_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.$.path_view.aggregationMode = aggregationMode;
      this.$.breakdown_view.aggregationMode = aggregationMode;
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    set viewMode(viewMode) {
      this.viewMode_ = viewMode;
      this.scheduleRebuild_();
    },

    get viewMode() {
      return this.viewMode_;
    },

    get heavyView() {
      switch (this.viewMode) {
        case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW:
        case MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW:
          return true;
        default:
          return false;
      }
    },

    onRebuild_() {
      if (this.heapDumps_ === undefined ||
          this.heapDumps_.length === 0) {
        // Show the info text (hide the table and the view mode selector).
        this.$.info_text.style.display = 'block';
        this.$.split_view.style.display = 'none';
        this.$.view_mode_container.style.display = 'none';
        this.$.info_bar.hidden = true;
        this.$.path_view.selectedNode = undefined;
        return;
      }

      // Show the table and the view mode selector (hide the info text).
      this.$.info_text.style.display = 'none';
      this.$.split_view.style.display = 'flex';
      this.$.view_mode_container.style.display = 'block';

      // Show the info bar if in heavy view mode.
      this.$.info_bar.hidden = !this.heavyView;

      this.$.path_view.selectedNode = this.createHeapTree_();
      this.$.path_view.rebuild();
      this.$.breakdown_view.rebuild();
    },

    createHeapTree_() {
      const definedHeapDump = this.heapDumps_.find(x => x);
      if (definedHeapDump === undefined) return undefined;

      // The title of the root node is the name of the allocator.
      const rootRowTitle = definedHeapDump.allocatorName;

      const stackFrameTrees = this.createStackFrameTrees_(this.heapDumps_);

      return new HeapDumpTreeNode(stackFrameTrees,
          tr.ui.analysis.HeapDetailsRowDimension.ROOT, rootRowTitle,
          this.heavyView);
    },

    createStackFrameTrees_(heapDumps) {
      const builders = heapDumps.map(heapDump => this.createBuilder_(heapDump));
      const views = builders.map(builder => {
        if (builder === undefined) return undefined;
        return builder.buildView(this.viewMode);
      });
      return views;
    },

    createBuilder_(heapDump) {
      if (heapDump === undefined) return undefined;

      if (this.cachedBuilders_.has(heapDump)) {
        return this.cachedBuilders_.get(heapDump);
      }

      const dimensions = 2; // stack frames, object type
      const valueCount = 2; // size, count
      const builder = new MultiDimensionalViewBuilder(dimensions, valueCount);

      // Build the heap tree.
      for (const entry of heapDump.entries) {
        const leafStackFrame = entry.leafStackFrame;
        const stackTracePath = leafStackFrame === undefined ?
            [] : leafStackFrame.getUserFriendlyStackTrace().reverse();

        const objectTypeName = entry.objectTypeName;
        const objectTypeNamePath = objectTypeName === undefined ?
            [] : [objectTypeName];

        const valueKind = entry.valuesAreTotals ?
            MultiDimensionalViewBuilder.ValueKind.TOTAL :
            MultiDimensionalViewBuilder.ValueKind.SELF;

        builder.addPath([stackTracePath, objectTypeNamePath],
            [entry.size, entry.count],
            valueKind);
      }

      builder.complete = heapDump.isComplete;
      this.cachedBuilders_.set(heapDump, builder);
      return builder;
    },
  });

  return {};
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  // Link to docs.
  const URL_TO_SIZE_VS_EFFECTIVE_SIZE = 'https://chromium.googlesource.com/chromium/src/+/master/docs/memory-infra/README.md#effective_size-vs_size';

  // Constant representing the context in suballocation rows.
  const SUBALLOCATION_CONTEXT = true;

  // Size numeric info types.
  const MemoryAllocatorDumpInfoType = tr.model.MemoryAllocatorDumpInfoType;
  const PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN =
      MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN;
  const PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER =
      MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER;

  // Unicode symbols used for memory cell info icons and messages.
  const LEFTWARDS_OPEN_HEADED_ARROW = String.fromCharCode(0x21FD);
  const RIGHTWARDS_OPEN_HEADED_ARROW = String.fromCharCode(0x21FE);
  const EN_DASH = String.fromCharCode(0x2013);
  const CIRCLED_LATIN_SMALL_LETTER_I = String.fromCharCode(0x24D8);

  /** @constructor */
  function AllocatorDumpNameColumn() {
    tr.ui.analysis.TitleColumn.call(this, 'Component');
  }

  AllocatorDumpNameColumn.prototype = {
    __proto__: tr.ui.analysis.TitleColumn.prototype,

    formatTitle(row) {
      if (!row.suballocation) {
        return row.title;
      }
      return tr.ui.b.createSpan({
        textContent: row.title,
        italic: true,
        tooltip: row.fullNames === undefined ?
            undefined : row.fullNames.join(', ')
      });
    }
  };

  /**
   * Retrieve the entry associated with a given name from a map and increment
   * its count.
   *
   * If there is no entry associated with the name, a new entry is created, the
   * creation callback is called, the entry's count is incremented (from 0 to
   * 1) and the newly created entry is returned.
   */
  function getAndUpdateEntry(map, name, createdCallback) {
    let entry = map.get(name);
    if (entry === undefined) {
      entry = {count: 0};
      createdCallback(entry);
      map.set(name, entry);
    }
    entry.count++;
    return entry;
  }

  /**
   * Helper class for building size and effective size column info messages.
   *
   * @constructor
   */
  function SizeInfoMessageBuilder() {
    this.parts_ = [];
    this.indent_ = 0;
  }

  SizeInfoMessageBuilder.prototype = {
    append(/* arguments */) {
      this.parts_.push.apply(
          this.parts_, Array.prototype.slice.apply(arguments));
    },

    /**
     * Append the entries of a map to the message according to the following
     * rules:
     *
     *   1. If the map is empty, append emptyText to the message (if provided).
     *      Examples:
     *
     *                       emptyText=undefined
     *        Hello, World! ====================> Hello, World!
     *
     *                        emptyText='empty'
     *        The bottle is ====================> The bottle is empty
     *
     *   2. If the map contains a single entry, append a space and call
     *      itemCallback on the entry (which is in turn expected to append a
     *      message for the entry). Example:
     *
     *        Please do not ====================> Please do not [item-message]
     *
     *   3. If the map contains multiple entries, append them as a list
     *      with itemCallback called on each entry. If hasPluralSuffix is true,
     *      's' will be appended to the message before the list. Examples:
     *
     *                      hasPluralSuffix=false
     *        I need to buy ====================> I need to buy:
     *                                             - [item1-message]
     *                                             - [item2-message]
     *                                             [...]
     *                                             - [itemN-message]
     *
     *                      hasPluralSuffix=true
     *        Suspected CL  ====================> Suspected CLs:
     *                                             - [item1-message]
     *                                             - [item2-message]
     *                                             [...]
     *                                             - [itemN-message]
     */
    appendMap(
        map, hasPluralSuffix, emptyText, itemCallback, opt_this) {
      opt_this = opt_this || this;
      if (map.size === 0) {
        if (emptyText) {
          this.append(emptyText);
        }
      } else if (map.size === 1) {
        this.parts_.push(' ');
        const key = map.keys().next().value;
        itemCallback.call(opt_this, key, map.get(key));
      } else {
        if (hasPluralSuffix) {
          this.parts_.push('s');
        }
        this.parts_.push(':');
        this.indent_++;
        for (const key of map.keys()) {
          this.parts_.push('\n', ' '.repeat(3 * (this.indent_ - 1)), ' - ');
          itemCallback.call(opt_this, key, map.get(key));
        }
        this.indent_--;
      }
    },

    appendImportanceRange(range) {
      this.append(' (importance: ');
      if (range.min === range.max) {
        this.append(range.min);
      } else {
        this.append(range.min, EN_DASH, range.max);
      }
      this.append(')');
    },

    appendSizeIfDefined(size) {
      if (size !== undefined) {
        this.append(' (', tr.b.Unit.byName.sizeInBytes.format(size), ')');
      }
    },

    appendSomeTimestampsQuantifier() {
      this.append(
          ' ', tr.ui.analysis.MemoryColumn.SOME_TIMESTAMPS_INFO_QUANTIFIER);
    },

    build() {
      return this.parts_.join('');
    }
  };

  /** @constructor */
  function EffectiveSizeColumn(name, cellPath, aggregationMode) {
    tr.ui.analysis.DetailsNumericMemoryColumn.call(
        this, name, cellPath, aggregationMode);
  }

  EffectiveSizeColumn.prototype = {
    __proto__: tr.ui.analysis.DetailsNumericMemoryColumn.prototype,

    get title() {
      return tr.ui.b.createLink({
        textContent: this.name,
        tooltip: 'Memory used by this component',
        href: URL_TO_SIZE_VS_EFFECTIVE_SIZE
      });
    },

    addInfos(numerics, memoryAllocatorDumps, infos) {
      if (memoryAllocatorDumps === undefined) return;

      // Quantified name of an owner dump (of the given dump) -> {count,
      // importanceRange}.
      const ownerNameToEntry = new Map();

      // Quantified name of an owned dump (by the given dump) -> {count,
      // importanceRange, sharerNameToEntry}, where sharerNameToEntry is a map
      // from quantified names of other owners of the owned dump to {count,
      // importanceRange}.
      const ownedNameToEntry = new Map();

      for (let i = 0; i < numerics.length; i++) {
        if (numerics[i] === undefined) continue;

        const dump = memoryAllocatorDumps[i];
        if (dump === SUBALLOCATION_CONTEXT) {
          return;  // No ownership of suballocation internal rows.
        }

        // Gather owners of this dump.
        dump.ownedBy.forEach(function(ownerLink) {
          const ownerDump = ownerLink.source;
          this.getAndUpdateOwnershipEntry_(
              ownerNameToEntry, ownerDump, ownerLink);
        }, this);

        // Gather dumps owned by this dump and other owner dumps sharing them
        // (with this dump).
        const ownedLink = dump.owns;
        if (ownedLink !== undefined) {
          const ownedDump = ownedLink.target;
          const ownedEntry = this.getAndUpdateOwnershipEntry_(ownedNameToEntry,
              ownedDump, ownedLink, true /* opt_withSharerNameToEntry */);
          const sharerNameToEntry = ownedEntry.sharerNameToEntry;
          ownedDump.ownedBy.forEach(function(sharerLink) {
            const sharerDump = sharerLink.source;
            if (sharerDump === dump) return;
            this.getAndUpdateOwnershipEntry_(
                sharerNameToEntry, sharerDump, sharerLink);
          }, this);
        }
      }

      // Emit a single info listing all owners of this dump.
      if (ownerNameToEntry.size > 0) {
        const messageBuilder = new SizeInfoMessageBuilder();
        messageBuilder.append('shared by');
        messageBuilder.appendMap(
            ownerNameToEntry,
            false /* hasPluralSuffix */,
            undefined /* emptyText */,
            function(ownerName, ownerEntry) {
              messageBuilder.append(ownerName);
              if (ownerEntry.count < numerics.length) {
                messageBuilder.appendSomeTimestampsQuantifier();
              }
              messageBuilder.appendImportanceRange(ownerEntry.importanceRange);
            }, this);
        infos.push({
          message: messageBuilder.build(),
          icon: LEFTWARDS_OPEN_HEADED_ARROW,
          color: 'green'
        });
      }

      // Emit a single info listing all dumps owned by this dump together
      // with list(s) of other owner dumps sharing them with this dump.
      if (ownedNameToEntry.size > 0) {
        const messageBuilder = new SizeInfoMessageBuilder();
        messageBuilder.append('shares');
        messageBuilder.appendMap(
            ownedNameToEntry,
            false /* hasPluralSuffix */,
            undefined /* emptyText */,
            function(ownedName, ownedEntry) {
              messageBuilder.append(ownedName);
              const ownedCount = ownedEntry.count;
              if (ownedCount < numerics.length) {
                messageBuilder.appendSomeTimestampsQuantifier();
              }
              messageBuilder.appendImportanceRange(ownedEntry.importanceRange);
              messageBuilder.append(' with');
              messageBuilder.appendMap(
                  ownedEntry.sharerNameToEntry,
                  false /* hasPluralSuffix */,
                  ' no other dumps',
                  function(sharerName, sharerEntry) {
                    messageBuilder.append(sharerName);
                    if (sharerEntry.count < ownedCount) {
                      messageBuilder.appendSomeTimestampsQuantifier();
                    }
                    messageBuilder.appendImportanceRange(
                        sharerEntry.importanceRange);
                  }, this);
            }, this);
        infos.push({
          message: messageBuilder.build(),
          icon: RIGHTWARDS_OPEN_HEADED_ARROW,
          color: 'green'
        });
      }
    },

    getAndUpdateOwnershipEntry_(
        map, dump, link, opt_withSharerNameToEntry) {
      const entry = getAndUpdateEntry(map, dump.quantifiedName,
          function(newEntry) {
            newEntry.importanceRange = new tr.b.math.Range();
            if (opt_withSharerNameToEntry) {
              newEntry.sharerNameToEntry = new Map();
            }
          });
      entry.importanceRange.addValue(link.importance || 0);
      return entry;
    }
  };

  /** @constructor */
  function SizeColumn(name, cellPath, aggregationMode) {
    tr.ui.analysis.DetailsNumericMemoryColumn.call(
        this, name, cellPath, aggregationMode);
  }

  SizeColumn.prototype = {
    __proto__: tr.ui.analysis.DetailsNumericMemoryColumn.prototype,

    get title() {
      return tr.ui.b.createLink({
        textContent: this.name,
        tooltip: 'Memory requested by this component',
        href: URL_TO_SIZE_VS_EFFECTIVE_SIZE
      });
    },

    addInfos(numerics, memoryAllocatorDumps, infos) {
      if (memoryAllocatorDumps === undefined) return;
      this.addOverlapInfo_(numerics, memoryAllocatorDumps, infos);
      this.addProvidedSizeWarningInfos_(numerics, memoryAllocatorDumps, infos);
    },

    addOverlapInfo_(numerics, memoryAllocatorDumps, infos) {
      // Sibling allocator dump name -> {count, size}. The latter field (size)
      // is omitted in multi-selection mode.
      const siblingNameToEntry = new Map();
      for (let i = 0; i < numerics.length; i++) {
        if (numerics[i] === undefined) continue;
        const dump = memoryAllocatorDumps[i];
        if (dump === SUBALLOCATION_CONTEXT) {
          return;  // No ownership of suballocation internal rows.
        }
        const ownedBySiblingSizes = dump.ownedBySiblingSizes;
        for (const siblingDump of ownedBySiblingSizes.keys()) {
          const siblingName = siblingDump.name;
          getAndUpdateEntry(siblingNameToEntry, siblingName,
              function(newEntry) {
                if (numerics.length === 1 /* single-selection mode */) {
                  newEntry.size = ownedBySiblingSizes.get(siblingDump);
                }
              });
        }
      }

      // Emit a single info describing all overlaps with siblings (if
      // applicable).
      if (siblingNameToEntry.size > 0) {
        const messageBuilder = new SizeInfoMessageBuilder();
        messageBuilder.append('overlaps with its sibling');
        messageBuilder.appendMap(
            siblingNameToEntry,
            true /* hasPluralSuffix */,
            undefined /* emptyText */,
            function(siblingName, siblingEntry) {
              messageBuilder.append('\'', siblingName, '\'');
              messageBuilder.appendSizeIfDefined(siblingEntry.size);
              if (siblingEntry.count < numerics.length) {
                messageBuilder.appendSomeTimestampsQuantifier();
              }
            }, this);
        infos.push({
          message: messageBuilder.build(),
          icon: CIRCLED_LATIN_SMALL_LETTER_I,
          color: 'blue'
        });
      }
    },

    addProvidedSizeWarningInfos_(numerics, memoryAllocatorDumps,
        infos) {
      // Info type (see MemoryAllocatorDumpInfoType) -> {count, providedSize,
      // dependencySize}. The latter two fields (providedSize and
      // dependencySize) are omitted in multi-selection mode.
      const infoTypeToEntry = new Map();
      for (let i = 0; i < numerics.length; i++) {
        if (numerics[i] === undefined) continue;
        const dump = memoryAllocatorDumps[i];
        if (dump === SUBALLOCATION_CONTEXT) {
          return;  // Suballocation internal rows have no provided size.
        }
        dump.infos.forEach(function(dumpInfo) {
          getAndUpdateEntry(infoTypeToEntry, dumpInfo.type, function(newEntry) {
            if (numerics.length === 1 /* single-selection mode */) {
              newEntry.providedSize = dumpInfo.providedSize;
              newEntry.dependencySize = dumpInfo.dependencySize;
            }
          });
        });
      }

      // Emit a warning info for every info type.
      for (const infoType of infoTypeToEntry.keys()) {
        const entry = infoTypeToEntry.get(infoType);
        const messageBuilder = new SizeInfoMessageBuilder();
        messageBuilder.append('provided size');
        messageBuilder.appendSizeIfDefined(entry.providedSize);
        let dependencyName;
        switch (infoType) {
          case PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN:
            dependencyName = 'the aggregated size of the children';
            break;
          case PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER:
            dependencyName = 'the size of the largest owner';
            break;
          default:
            dependencyName = 'an unknown dependency';
            break;
        }
        messageBuilder.append(' was less than ', dependencyName);
        messageBuilder.appendSizeIfDefined(entry.dependencySize);
        if (entry.count < numerics.length) {
          messageBuilder.appendSomeTimestampsQuantifier();
        }
        infos.push(tr.ui.analysis.createWarningInfo(messageBuilder.build()));
      }
    }
  };

  const NUMERIC_COLUMN_RULES = [
    {
      condition: tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME,
      importance: 10,
      columnConstructor: EffectiveSizeColumn
    },
    {
      condition: tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME,
      importance: 9,
      columnConstructor: SizeColumn
    },
    {
      condition: 'page_size',
      importance: 0,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: /size/,
      importance: 5,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      // All other columns.
      importance: 0,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    }
  ];

  const DIAGNOSTIC_COLUMN_RULES = [
    {
      importance: 0,
      columnConstructor: tr.ui.analysis.StringMemoryColumn
    }
  ];

  Polymer({
    is: 'tr-ui-a-memory-dump-allocator-details-pane',
    behaviors: [tr.ui.analysis.StackedPane],

    created() {
      this.memoryAllocatorDumps_ = undefined;
      this.heapDumps_ = undefined;
      this.aggregationMode_ = undefined;
    },

    ready() {
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
    },

    /**
     * Sets the memory allocator dumps and schedules rebuilding the pane.
     *
     * The provided value should be a chronological list of memory allocator
     * dumps. All dumps are assumed to belong to the same process and have
     * the same full name. Example:
     *
     *   [
     *     tr.model.MemoryAllocatorDump {},  // MAD at timestamp 1.
     *     undefined,  // MAD not provided at timestamp 2.
     *     tr.model.MemoryAllocatorDump {},  // MAD at timestamp 3.
     *   ]
     */
    set memoryAllocatorDumps(memoryAllocatorDumps) {
      this.memoryAllocatorDumps_ = memoryAllocatorDumps;
      this.scheduleRebuild_();
    },

    get memoryAllocatorDumps() {
      return this.memoryAllocatorDumps_;
    },

    // TODO(petrcermak): Don't plumb the heap dumps through the allocator
    // details pane. Maybe add support for multiple child panes to stacked pane
    // (view) instead.
    set heapDumps(heapDumps) {
      this.heapDumps_ = heapDumps;
      this.scheduleRebuild_();
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    onRebuild_() {
      if (this.memoryAllocatorDumps_ === undefined ||
          this.memoryAllocatorDumps_.length === 0) {
        // Show the info text (hide the table).
        this.$.info_text.style.display = 'block';
        this.$.table.style.display = 'none';

        this.$.table.clear();
        this.$.table.rebuild();

        // Hide the heap details pane (if applicable).
        this.childPaneBuilder = undefined;
        return;
      }

      // Show the table (hide the info text).
      this.$.info_text.style.display = 'none';
      this.$.table.style.display = 'block';

      const rows = this.createRows_();
      const columns = this.createColumns_(rows);
      rows.forEach(function(rootRow) {
        tr.ui.analysis.aggregateTableRowCellsRecursively(rootRow, columns,
            function(contexts) {
              // Only aggregate suballocation rows (numerics of regular rows
              // corresponding to MADs have already been aggregated by the
              // model in MemoryAllocatorDump.aggregateNumericsRecursively).
              return contexts !== undefined && contexts.some(function(context) {
                return context === SUBALLOCATION_CONTEXT;
              });
            });
      });

      this.$.table.tableRows = rows;
      this.$.table.tableColumns = columns;
      this.$.table.rebuild();
      tr.ui.analysis.expandTableRowsRecursively(this.$.table);

      // Show/hide the heap details pane.
      if (this.heapDumps_ === undefined) {
        this.childPaneBuilder = undefined;
      } else {
        this.childPaneBuilder = function() {
          const pane =
              document.createElement('tr-ui-a-memory-dump-heap-details-pane');
          pane.heapDumps = this.heapDumps_;
          pane.aggregationMode = this.aggregationMode_;
          return pane;
        }.bind(this);
      }
    },

    createRows_() {
      return [
        this.createAllocatorRowRecursively_(this.memoryAllocatorDumps_)
      ];
    },

    createAllocatorRowRecursively_(dumps) {
      // Get the name of the memory allocator dumps. We can use any defined
      // dump in dumps since they all have the same name.
      const definedDump = dumps.find(x => x);
      const title = definedDump.name;
      const fullName = definedDump.fullName;

      // Transform a chronological list of memory allocator dumps into two
      // dictionaries of cells (where each cell contains a chronological list
      // of the values of one of its numerics or diagnostics).
      const numericCells = tr.ui.analysis.createCells(dumps, function(dump) {
        return dump.numerics;
      });
      const diagnosticCells = tr.ui.analysis.createCells(dumps, function(dump) {
        return dump.diagnostics;
      });

      // Determine whether the memory allocator dump is a suballocation. A
      // dump is assumed to be a suballocation if (1) its name starts with
      // two underscores, (2) it has an owner from within the same process at
      // some timestamp, and (3) it is undefined, has no owners, or has the
      // same owner (and no other owners) at all other timestamps.
      let suballocatedBy = undefined;
      if (title.startsWith('__')) {
        for (let i = 0; i < dumps.length; i++) {
          const dump = dumps[i];
          if (dump === undefined || dump.ownedBy.length === 0) {
            // Ignore timestamps where the dump is undefined or doesn't
            // have any owner.
            continue;
          }
          const ownerDump = dump.ownedBy[0].source;
          if (dump.ownedBy.length > 1 ||
              dump.children.length > 0 ||
              ownerDump.containerMemoryDump !== dump.containerMemoryDump) {
            // If the dump has (1) any children, (2) multiple owners, or
            // (3) its owner is in a different process (otherwise, the
            // modified title would be ambiguous), then it's not considered
            // to be a suballocation.
            suballocatedBy = undefined;
            break;
          }
          if (suballocatedBy === undefined) {
            suballocatedBy = ownerDump.fullName;
          } else if (suballocatedBy !== ownerDump.fullName) {
            // The full name of the owner dump changed over time, so this
            // dump is not a suballocation.
            suballocatedBy = undefined;
            break;
          }
        }
      }

      const row = {
        title,
        fullNames: [fullName],
        contexts: dumps,
        numericCells,
        diagnosticCells,
        suballocatedBy
      };

      // Child memory dump name (dict key) -> Timestamp (list index) ->
      // Child dump.
      const childDumpNameToDumps = tr.b.invertArrayOfDicts(dumps,
          function(dump) {
            const results = {};
            for (const child of dump.children) {
              results[child.name] = child;
            }
            return results;
          });

      // Recursively create sub-rows for children (if applicable).
      const subRows = [];
      let suballocationClassificationRootNode = undefined;
      for (const childDumps of Object.values(childDumpNameToDumps)) {
        const childRow = this.createAllocatorRowRecursively_(childDumps);
        if (childRow.suballocatedBy === undefined) {
          // Not a suballocation row: just append it.
          subRows.push(childRow);
        } else {
          // Suballocation row: classify it in a tree of suballocations.
          suballocationClassificationRootNode =
              this.classifySuballocationRow_(
                  childRow, suballocationClassificationRootNode);
        }
      }

      // Build the tree of suballocations (if applicable).
      if (suballocationClassificationRootNode !== undefined) {
        const suballocationRow = this.createSuballocationRowRecursively_(
            'suballocations', suballocationClassificationRootNode);
        subRows.push(suballocationRow);
      }

      if (subRows.length > 0) {
        row.subRows = subRows;
      }

      return row;
    },

    classifySuballocationRow_(suballocationRow, rootNode) {
      if (rootNode === undefined) {
        rootNode = {
          children: {},
          row: undefined
        };
      }

      const suballocationLevels = suballocationRow.suballocatedBy.split('/');
      let currentNode = rootNode;
      for (let i = 0; i < suballocationLevels.length; i++) {
        const suballocationLevel = suballocationLevels[i];
        let nextNode = currentNode.children[suballocationLevel];
        if (nextNode === undefined) {
          currentNode.children[suballocationLevel] = nextNode = {
            children: {},
            row: undefined
          };
        }
        currentNode = nextNode;
      }

      const existingRow = currentNode.row;
      if (existingRow !== undefined) {
        // On rare occasions it can happen that one dump (e.g. sqlite) owns
        // different suballocations at different timestamps (e.g.
        // malloc/allocated_objects/_7d35 and malloc/allocated_objects/_511e).
        // When this happens, we merge the two suballocations into a single row
        // (malloc/allocated_objects/suballocations/sqlite).
        for (let i = 0; i < suballocationRow.contexts.length; i++) {
          const newContext = suballocationRow.contexts[i];
          if (newContext === undefined) continue;

          if (existingRow.contexts[i] !== undefined) {
            throw new Error('Multiple suballocations with the same owner name');
          }

          existingRow.contexts[i] = newContext;
          ['numericCells', 'diagnosticCells'].forEach(function(cellKey) {
            const suballocationCells = suballocationRow[cellKey];
            if (suballocationCells === undefined) return;
            for (const [cellName, cell] of Object.entries(suballocationCells)) {
              if (cell === undefined) continue;
              const fields = cell.fields;
              if (fields === undefined) continue;
              const field = fields[i];
              if (field === undefined) continue;
              let existingCells = existingRow[cellKey];
              if (existingCells === undefined) {
                existingCells = {};
                existingRow[cellKey] = existingCells;
              }
              let existingCell = existingCells[cellName];
              if (existingCell === undefined) {
                existingCell = new tr.ui.analysis.MemoryCell(
                    new Array(fields.length));
                existingCells[cellName] = existingCell;
              }
              existingCell.fields[i] = field;
            }
          });
        }
        existingRow.fullNames.push.apply(
            existingRow.fullNames, suballocationRow.fullNames);
      } else {
        currentNode.row = suballocationRow;
      }

      return rootNode;
    },

    createSuballocationRowRecursively_(name, node) {
      const childCount = Object.keys(node.children).length;
      if (childCount === 0) {
        if (node.row === undefined) {
          throw new Error('Suballocation node must have a row or children');
        }
        // Leaf row of the suballocation tree: Change the row's title from
        // '__MEANINGLESSHASH' to the name of the suballocation owner.
        const row = node.row;
        row.title = name;
        row.suballocation = true;
        return row;
      }

      // Internal row of the suballocation tree: Recursively create its
      // sub-rows.
      const subRows = [];
      for (const [subName, subNode] of Object.entries(node.children)) {
        subRows.push(this.createSuballocationRowRecursively_(subName, subNode));
      }

      if (node.row !== undefined) {
        // Very unlikely case: Both an ancestor (e.g. 'skia') and one of its
        // descendants (e.g. 'skia/sk_glyph_cache') both suballocate from the
        // same MemoryAllocatorDump (e.g. 'malloc/allocated_objects'). In
        // this case, the suballocation from the ancestor must be mapped to
        // 'malloc/allocated_objects/suballocations/skia/<unspecified>' so
        // that 'malloc/allocated_objects/suballocations/skia' could
        // aggregate the numerics of the two suballocations properly.
        const row = node.row;
        row.title = '<unspecified>';
        row.suballocation = true;
        subRows.unshift(row);
      }

      // An internal row of the suballocation tree is assumed to be defined
      // at a given timestamp if at least one of its sub-rows is defined at
      // the timestamp.
      const contexts = new Array(subRows[0].contexts.length);
      for (let i = 0; i < subRows.length; i++) {
        subRows[i].contexts.forEach(function(subContext, index) {
          if (subContext !== undefined) {
            contexts[index] = SUBALLOCATION_CONTEXT;
          }
        });
      }

      return {
        title: name,
        suballocation: true,
        contexts,
        subRows
      };
    },

    createColumns_(rows) {
      const titleColumn = new AllocatorDumpNameColumn();
      titleColumn.width = '200px';

      const numericColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'numericCells',
        aggregationMode: this.aggregationMode_,
        rules: NUMERIC_COLUMN_RULES
      });
      const diagnosticColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'diagnosticCells',
        aggregationMode: this.aggregationMode_,
        rules: DIAGNOSTIC_COLUMN_RULES
      });
      const fieldColumns = numericColumns.concat(diagnosticColumns);
      tr.ui.analysis.MemoryColumn.spaceEqually(fieldColumns);

      const columns = [titleColumn].concat(fieldColumns);
      return columns;
    }
  });

  return {
    // All exports are for testing only.
    SUBALLOCATION_CONTEXT,
    AllocatorDumpNameColumn,
    EffectiveSizeColumn,
    SizeColumn,
  };
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const Scalar = tr.b.Scalar;
  const sizeInBytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;

  const CONSTANT_COLUMN_RULES = [
    {
      condition: 'Start address',
      importance: 0,
      columnConstructor: tr.ui.analysis.StringMemoryColumn
    }
  ];

  const VARIABLE_COLUMN_RULES = [
    {
      condition: 'Virtual size',
      importance: 7,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Protection flags',
      importance: 6,
      columnConstructor: tr.ui.analysis.StringMemoryColumn
    },
    {
      condition: 'PSS',
      importance: 5,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Private dirty',
      importance: 4,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Private clean',
      importance: 3,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Shared dirty',
      importance: 2,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Shared clean',
      importance: 1,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    },
    {
      condition: 'Swapped',
      importance: 0,
      columnConstructor: tr.ui.analysis.DetailsNumericMemoryColumn
    }
  ];

  const BYTE_STAT_COLUMN_MAP = {
    'proportionalResident': 'PSS',
    'privateDirtyResident': 'Private dirty',
    'privateCleanResident': 'Private clean',
    'sharedDirtyResident': 'Shared dirty',
    'sharedCleanResident': 'Shared clean',
    'swapped': 'Swapped'
  };

  function hexString(address, is64BitAddress) {
    if (address === undefined) return undefined;
    const hexPadding = is64BitAddress ? '0000000000000000' : '00000000';
    return (hexPadding + address.toString(16)).substr(-hexPadding.length);
  }

  function pruneEmptyRuleRows(row) {
    if (row.subRows === undefined || row.subRows.length === 0) return;

    // Either all sub-rows are rule rows, or all sub-rows are VM region rows.
    if (row.subRows[0].rule === undefined) {
      // VM region rows: Early out to avoid filtering a large array for
      // performance reasons (no sub-rows would be removed, but the whole array
      // would be unnecessarily copied to a new array).
      return;
    }

    row.subRows.forEach(pruneEmptyRuleRows);
    row.subRows = row.subRows.filter(function(subRow) {
      return subRow.subRows.length > 0;
    });
  }

  Polymer({
    is: 'tr-ui-a-memory-dump-vm-regions-details-pane',
    behaviors: [tr.ui.analysis.StackedPane],

    created() {
      this.vmRegions_ = undefined;
      this.aggregationMode_ = undefined;
    },

    ready() {
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
    },

    /**
     * Sets the VM regions and schedules rebuilding the pane.
     *
     * The provided value should be a chronological list of lists of VM
     * regions. All VM regions are assumed to belong to the same process.
     * Example:
     *
     *   [
     *     [
     *       // VM regions at timestamp 1.
     *       tr.model.VMRegion {},
     *       tr.model.VMRegion {},
     *       tr.model.VMRegion {}
     *     ],
     *     undefined,  // No VM regions provided at timestamp 2.
     *     [
     *       // VM regions at timestamp 3.
     *       tr.model.VMRegion {},
     *       tr.model.VMRegion {}
     *     ]
     *   ]
     */
    set vmRegions(vmRegions) {
      this.vmRegions_ = vmRegions;
      this.scheduleRebuild_();
    },

    get vmRegions() {
      return this.vmRegions_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    onRebuild_() {
      if (this.vmRegions_ === undefined || this.vmRegions_.length === 0) {
        // Show the info text (hide the table).
        this.$.info_text.style.display = 'block';
        this.$.table.style.display = 'none';

        this.$.table.clear();
        this.$.table.rebuild();
        return;
      }

      // Show the table (hide the info text).
      this.$.info_text.style.display = 'none';
      this.$.table.style.display = 'block';

      const rows = this.createRows_(this.vmRegions_);
      const columns = this.createColumns_(rows);

      // Note: There is no need to aggregate fields of the VM regions because
      // the classification tree already takes care of that.

      this.$.table.tableRows = rows;
      this.$.table.tableColumns = columns;

      // TODO(petrcermak): This can be quite slow. Consider doing this somehow
      // asynchronously.
      this.$.table.rebuild();

      tr.ui.analysis.expandTableRowsRecursively(this.$.table);
    },

    createRows_(timeToVmRegionTree) {
      // Determine if any start address is outside the 32-bit range.
      const is64BitAddress = timeToVmRegionTree.some(function(vmRegionTree) {
        if (vmRegionTree === undefined) return false;
        return vmRegionTree.someRegion(function(region) {
          if (region.startAddress === undefined) return false;
          return region.startAddress >= 4294967296; /* 2^32 */
        });
      });

      return [
        this.createClassificationNodeRow(timeToVmRegionTree, is64BitAddress)
      ];
    },

    createClassificationNodeRow(timeToNode, is64BitAddress) {
      // Get any defined classification node so that we can extract the
      // properties which don't change over time.
      const definedNode = timeToNode.find(x => x);

      // Child node ID (list index) -> Timestamp (list index) ->
      // VM region classification node.
      const childNodeIdToTimeToNode = Object.values(
          tr.b.invertArrayOfDicts(timeToNode, function(node) {
            const children = node.children;
            if (children === undefined) return undefined;
            const childMap = {};
            children.forEach(function(childNode) {
              if (!childNode.hasRegions) return;
              childMap[childNode.title] = childNode;
            });
            return childMap;
          }));
      const childNodeSubRows = childNodeIdToTimeToNode.map(
          function(timeToChildNode) {
            return this.createClassificationNodeRow(
                timeToChildNode, is64BitAddress);
          }, this);

      // Region ID (list index) -> Timestamp (list index) -> VM region.
      const regionIdToTimeToRegion = Object.values(
          tr.b.invertArrayOfDicts(timeToNode, function(node) {
            const regions = node.regions;
            if (regions === undefined) return undefined;

            const results = {};
            for (const region of regions) {
              results[region.uniqueIdWithinProcess] = region;
            }
            return results;
          }));
      const regionSubRows = regionIdToTimeToRegion.map(function(timeToRegion) {
        return this.createRegionRow_(timeToRegion, is64BitAddress);
      }, this);

      const subRows = childNodeSubRows.concat(regionSubRows);

      return {
        title: definedNode.title,
        contexts: timeToNode,
        variableCells: this.createVariableCells_(timeToNode),
        subRows
      };
    },

    createRegionRow_(timeToRegion, is64BitAddress) {
      // Get any defined VM region so that we can extract the properties which
      // don't change over time.
      const definedRegion = timeToRegion.find(x => x);

      return {
        title: definedRegion.mappedFile,
        contexts: timeToRegion,
        constantCells: this.createConstantCells_(definedRegion, is64BitAddress),
        variableCells: this.createVariableCells_(timeToRegion)
      };
    },

    /**
     * Create cells for VM region properties which DON'T change over time.
     *
     * Note that there are currently no such properties of classification nodes.
     */
    createConstantCells_(definedRegion, is64BitAddress) {
      return tr.ui.analysis.createCells([definedRegion], function(region) {
        const startAddress = region.startAddress;
        if (startAddress === undefined) return undefined;
        return { 'Start address': hexString(startAddress, is64BitAddress) };
      });
    },

    /**
     * Create cells for VM region (classification node) properties which DO
     * change over time.
     */
    createVariableCells_(timeToRegion) {
      return tr.ui.analysis.createCells(timeToRegion, function(region) {
        const fields = {};

        const sizeInBytes = region.sizeInBytes;
        if (sizeInBytes !== undefined) {
          fields['Virtual size'] = new Scalar(
                sizeInBytes_smallerIsBetter, sizeInBytes);
        }
        const protectionFlags = region.protectionFlagsToString;
        if (protectionFlags !== undefined) {
          fields['Protection flags'] = protectionFlags;
        }

        for (const [byteStatName, columnName] of
            Object.entries(BYTE_STAT_COLUMN_MAP)) {
          const byteStat = region.byteStats[byteStatName];
          if (byteStat === undefined) continue;
          fields[columnName] = new Scalar(
              sizeInBytes_smallerIsBetter, byteStat);
        }

        return fields;
      });
    },

    createColumns_(rows) {
      const titleColumn = new tr.ui.analysis.TitleColumn('Mapped file');
      titleColumn.width = '200px';

      const constantColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'constantCells',
        aggregationMode: undefined,
        rules: CONSTANT_COLUMN_RULES
      });
      const variableColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'variableCells',
        aggregationMode: this.aggregationMode_,
        rules: VARIABLE_COLUMN_RULES
      });
      const fieldColumns = constantColumns.concat(variableColumns);
      tr.ui.analysis.MemoryColumn.spaceEqually(fieldColumns);

      const columns = [titleColumn].concat(fieldColumns);
      return columns;
    }
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-b-color-legend',

  ready() {
    const blackSquareCharCode = 9632;
    this.$.square.innerText = String.fromCharCode(blackSquareCharCode);
    this.label_ = undefined;

    this.compoundEventSelectionState_ =
        tr.model.CompoundEventSelectionState.NOT_SELECTED;
  },

  set compoundEventSelectionState(compoundEventSelectionState) {
    this.compoundEventSelectionState_ = compoundEventSelectionState;
    // TODO(nduca): Adjust appearance based on associated state.
  },

  get label() {
    return this.label_;
  },

  set label(label) {
    if (label === undefined) {
      this.setLabelAndColorId(undefined, undefined);
      return;
    }

    const colorId = tr.b.ColorScheme.getColorIdForGeneralPurposeString(
        label);
    this.setLabelAndColorId(label, colorId);
  },

  setLabelAndColorId(label, colorId) {
    this.label_ = label;

    Polymer.dom(this.$.label).textContent = '';
    Polymer.dom(this.$.label).appendChild(tr.ui.b.asHTMLOrTextNode(label));

    if (colorId === undefined) {
      this.$.square.style.color = 'initial';
    } else {
      this.$.square.style.color = tr.b.ColorScheme.colorsAsStrings[colorId];
    }
  }
});


'use strict';

Polymer({
  is: 'tr-ui-b-view-specific-brushing-state',

  /** Compulsory unique identifier of the associated view. */
  get viewId() {
    return this.getAttribute('view-id');
  },

  set viewId(viewId) {
    Polymer.dom(this).setAttribute('view-id', viewId);
  },

  /**
   * Retrieve the persisted state of the associated view. The returned object
   * (or any of its fields) must not be modified by the caller (unless the
   * object/field is treated as a reference).
   *
   * If no state has been persisted yet or there is no ancestor element with
   * a brushingStateController field, this method returns undefined.
   */
  get() {
    const viewId = this.viewId;
    if (!viewId) {
      throw new Error('Element must have a view-id attribute!');
    }

    const brushingStateController =
        tr.c.BrushingStateController.getControllerForElement(this);
    if (!brushingStateController) return undefined;

    return brushingStateController.getViewSpecificBrushingState(viewId);
  },

  /**
   * Persist the provided state of the associated view. The provided object
   * (or any of its fields) must not be modified afterwards (unless the
   * object/field is treated as a reference).
   *
   * If there is no ancestor element with a brushingStateController field,
   * this method does nothing.
   */
  set(state) {
    const viewId = this.viewId;
    if (!viewId) {
      throw new Error('Element must have a view-id attribute!');
    }

    const brushingStateController =
        tr.c.BrushingStateController.getControllerForElement(this);
    if (!brushingStateController) return;

    brushingStateController.changeViewSpecificBrushingState(viewId, state);
  }
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const MemoryColumnColorScheme = tr.b.MemoryColumnColorScheme;
  const Scalar = tr.b.Scalar;
  const sizeInBytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;

  const PLATFORM_SPECIFIC_TOTAL_NAME_SUFFIX = '_bytes';

  const DISPLAYED_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;
  const SOME_TIMESTAMPS_INFO_QUANTIFIER =
      tr.ui.analysis.MemoryColumn.SOME_TIMESTAMPS_INFO_QUANTIFIER;

  // Unicode symbols used for memory cell info icons and messages.
  const RIGHTWARDS_ARROW_WITH_HOOK = String.fromCharCode(0x21AA);
  const RIGHTWARDS_ARROW_FROM_BAR = String.fromCharCode(0x21A6);
  const GREATER_THAN_OR_EQUAL_TO = String.fromCharCode(0x2265);
  const UNMARRIED_PARTNERSHIP_SYMBOL = String.fromCharCode(0x26AF);
  const TRIGRAM_FOR_HEAVEN = String.fromCharCode(0x2630);

  function lazyMap(list, fn, opt_this) {
    opt_this = opt_this || this;
    let result = undefined;
    list.forEach(function(item, index) {
      const value = fn.call(opt_this, item, index);
      if (value === undefined) return;
      if (result === undefined) {
        result = new Array(list.length);
      }
      result[index] = value;
    });
    return result;
  }

  /** @constructor */
  function ProcessNameColumn() {
    tr.ui.analysis.TitleColumn.call(this, 'Process');
  }

  ProcessNameColumn.prototype = {
    __proto__: tr.ui.analysis.TitleColumn.prototype,

    formatTitle(row) {
      if (row.contexts === undefined) {
        return row.title;  // Total row.
      }
      const titleEl = document.createElement('tr-ui-b-color-legend');
      titleEl.label = row.title;
      return titleEl;
    }
  };

  /** @constructor */
  function UsedMemoryColumn(name, cellPath, aggregationMode) {
    tr.ui.analysis.NumericMemoryColumn.call(
        this, name, cellPath, aggregationMode);
  }

  UsedMemoryColumn.COLOR =
      MemoryColumnColorScheme.getColor('used_memory_column').toString();
  UsedMemoryColumn.OLDER_COLOR =
      MemoryColumnColorScheme.getColor('older_used_memory_column').toString();

  UsedMemoryColumn.prototype = {
    __proto__: tr.ui.analysis.NumericMemoryColumn.prototype,

    get title() {
      return tr.ui.b.createSpan({
        textContent: this.name,
        color: UsedMemoryColumn.COLOR
      });
    },

    getFormattingContext(unit) {
      return { unitPrefix: tr.b.UnitPrefixScale.BINARY.MEBI };
    },

    color(numerics, processMemoryDumps) {
      return UsedMemoryColumn.COLOR;
    },

    getChildPaneBuilder(processMemoryDumps) {
      if (processMemoryDumps === undefined) return undefined;

      const vmRegions = lazyMap(processMemoryDumps, function(pmd) {
        if (pmd === undefined) return undefined;
        return pmd.mostRecentVmRegions;
      });
      if (vmRegions === undefined) return undefined;

      return function() {
        const pane = document.createElement(
            'tr-ui-a-memory-dump-vm-regions-details-pane');
        pane.vmRegions = vmRegions;
        pane.aggregationMode = this.aggregationMode;
        return pane;
      }.bind(this);
    }
  };

  /** @constructor */
  function PeakMemoryColumn(name, cellPath, aggregationMode) {
    UsedMemoryColumn.call(this, name, cellPath, aggregationMode);
  }

  PeakMemoryColumn.prototype = {
    __proto__: UsedMemoryColumn.prototype,

    addInfos(numerics, processMemoryDumps, infos) {
      if (processMemoryDumps === undefined) return;  // Total row.

      let resettableValueCount = 0;
      let nonResettableValueCount = 0;
      for (let i = 0; i < numerics.length; i++) {
        if (numerics[i] === undefined) continue;
        if (processMemoryDumps[i].arePeakResidentBytesResettable) {
          resettableValueCount++;
        } else {
          nonResettableValueCount++;
        }
      }

      if (resettableValueCount > 0 && nonResettableValueCount > 0) {
        infos.push(tr.ui.analysis.createWarningInfo('Both resettable and ' +
            'non-resettable peak RSS values were provided by the process'));
      } else if (resettableValueCount > 0) {
        infos.push({
          icon: RIGHTWARDS_ARROW_WITH_HOOK,
          message: 'Peak RSS since previous memory dump.'
        });
      } else {
        infos.push({
          icon: RIGHTWARDS_ARROW_FROM_BAR,
          message: 'Peak RSS since process startup. Finer grained ' +
              'peaks require a Linux kernel version ' +
              GREATER_THAN_OR_EQUAL_TO + ' 4.0.'
        });
      }
    }
  };

  /** @constructor */
  function ByteStatColumn(name, cellPath, aggregationMode) {
    UsedMemoryColumn.call(this, name, cellPath, aggregationMode);
  }

  ByteStatColumn.prototype = {
    __proto__: UsedMemoryColumn.prototype,

    color(numerics, processMemoryDumps) {
      if (processMemoryDumps === undefined) {
        return UsedMemoryColumn.COLOR;  // Total row.
      }

      const allOlderValues = processMemoryDumps.every(
          function(processMemoryDump) {
            if (processMemoryDump === undefined) return true;
            return !processMemoryDump.hasOwnVmRegions;
          });

      // Show the cell in lighter blue if all values were older (i.e. none of
      // the defined process memory dumps had own VM regions).
      if (allOlderValues) {
        return UsedMemoryColumn.OLDER_COLOR;
      }
      return UsedMemoryColumn.COLOR;
    },

    addInfos(numerics, processMemoryDumps, infos) {
      if (processMemoryDumps === undefined) return;  // Total row.

      let olderValueCount = 0;
      for (let i = 0; i < numerics.length; i++) {
        const processMemoryDump = processMemoryDumps[i];
        if (processMemoryDump !== undefined &&
            !processMemoryDump.hasOwnVmRegions) {
          olderValueCount++;
        }
      }

      if (olderValueCount === 0) {
        return;  // There are no older values.
      }

      const infoQuantifier = olderValueCount < numerics.length ?
          ' ' + SOME_TIMESTAMPS_INFO_QUANTIFIER : /* some values are older */
          ''; /* all values are older */

      // Emit an info if there was at least one older value (i.e. at least one
      // defined process memory dump did not have own VM regions).
      infos.push({
        message: 'Older value' + infoQuantifier +
            ' (only heavy (purple) memory dumps contain memory maps).',
        icon: UNMARRIED_PARTNERSHIP_SYMBOL
      });
    }
  };

  // Rules for constructing and sorting used memory columns.
  UsedMemoryColumn.RULES = [
    {
      condition: 'Total resident',
      importance: 10,
      columnConstructor: UsedMemoryColumn
    },
    {
      condition: 'Peak total resident',
      importance: 9,
      columnConstructor: PeakMemoryColumn
    },
    {
      condition: 'PSS',
      importance: 8,
      columnConstructor: ByteStatColumn
    },
    {
      condition: 'Private dirty',
      importance: 7,
      columnConstructor: ByteStatColumn
    },
    {
      condition: 'Swapped',
      importance: 6,
      columnConstructor: ByteStatColumn
    },
    {
      // All other columns.
      importance: 0,
      columnConstructor: UsedMemoryColumn
    }
  ];

  // Map from ProcessMemoryDump totals fields to column names.
  UsedMemoryColumn.TOTALS_MAP = {
    'residentBytes': 'Total resident',
    'peakResidentBytes': 'Peak total resident'
  };

  // Map from ProcessMemoryDump platform-specific totals fields to column names.
  UsedMemoryColumn.PLATFORM_SPECIFIC_TOTALS_MAP = {
    'vm': 'Total virtual',
    'swp': 'Swapped',
    'pc': 'Private clean',
    'pd': 'Private dirty',
    'sc': 'Shared clean',
    'sd': 'Shared dirty',
    'gpu_egl': 'GPU EGL',
    'gpu_egl_pss': 'GPU EGL PSS',
    'gpu_gl': 'GPU GL',
    'gpu_gl_pss': 'GPU GL PSS',
    'gpu_etc': 'GPU Other',
    'gpu_etc_pss': 'GPU Other PSS',
  };

  // Map from VMRegionByteStats field names to column names.
  UsedMemoryColumn.BYTE_STAT_MAP = {
    'proportionalResident': 'PSS',
    'privateDirtyResident': 'Private dirty',
    'swapped': 'Swapped'
  };

  /** @constructor */
  function AllocatorColumn(name, cellPath, aggregationMode) {
    tr.ui.analysis.NumericMemoryColumn.call(
        this, name, cellPath, aggregationMode);
  }

  AllocatorColumn.prototype = {
    __proto__: tr.ui.analysis.NumericMemoryColumn.prototype,

    get title() {
      const titleEl = document.createElement('tr-ui-b-color-legend');
      titleEl.label = this.name;
      return titleEl;
    },

    getFormattingContext(unit) {
      return { unitPrefix: tr.b.UnitPrefixScale.BINARY.MEBI };
    },

    addInfos(numerics, processMemoryDumps, infos) {
      if (processMemoryDumps === undefined) return;

      let heapDumpCount = 0;
      let missingSizeCount = 0;

      for (let i = 0; i < processMemoryDumps.length; i++) {
        const processMemoryDump = processMemoryDumps[i];
        if (processMemoryDump === undefined) continue;

        const heapDumps = processMemoryDump.heapDumps;
        if (heapDumps !== undefined && heapDumps[this.name] !== undefined) {
          heapDumpCount++;
        }
        const allocatorDump =
            processMemoryDump.getMemoryAllocatorDumpByFullName(this.name);

        if (allocatorDump !== undefined &&
            allocatorDump.numerics[DISPLAYED_SIZE_NUMERIC_NAME] === undefined) {
          missingSizeCount++;
        }
      }

      // Emit a heap dump info if at least one of the process memory dumps has
      // a heap dump associated with this allocator.
      if (heapDumpCount > 0) {
        const infoQuantifier = heapDumpCount < numerics.length ?
            ' ' + SOME_TIMESTAMPS_INFO_QUANTIFIER : '';
        infos.push({
          message: 'Heap dump provided' + infoQuantifier + '.',
          icon: TRIGRAM_FOR_HEAVEN
        });
      }

      // Emit a warning if this allocator did not provide size in at least one
      // of the process memory dumps.
      if (missingSizeCount > 0) {
        const infoQuantifier = missingSizeCount < numerics.length ?
            ' ' + SOME_TIMESTAMPS_INFO_QUANTIFIER : '';
        infos.push(tr.ui.analysis.createWarningInfo(
            'Size was not provided' + infoQuantifier + '.'));
      }
    },

    getChildPaneBuilder(processMemoryDumps) {
      if (processMemoryDumps === undefined) return undefined;

      const memoryAllocatorDumps = lazyMap(processMemoryDumps, function(pmd) {
        if (pmd === undefined) return undefined;
        return pmd.getMemoryAllocatorDumpByFullName(this.name);
      }, this);
      if (memoryAllocatorDumps === undefined) return undefined;

      const heapDumps = lazyMap(processMemoryDumps, function(pmd) {
        if (pmd === undefined || pmd.heapDumps === undefined) return undefined;
        return pmd.heapDumps[this.name];
      }, this);

      return function() {
        const pane = document.createElement(
            'tr-ui-a-memory-dump-allocator-details-pane');
        pane.memoryAllocatorDumps = memoryAllocatorDumps;
        pane.heapDumps = heapDumps;
        pane.aggregationMode = this.aggregationMode;
        return pane;
      }.bind(this);
    }
  };

  /** @constructor */
  function TracingColumn(name, cellPath, aggregationMode) {
    AllocatorColumn.call(this, name, cellPath, aggregationMode);
  }

  TracingColumn.COLOR =
      MemoryColumnColorScheme.getColor('tracing_memory_column').toString();

  TracingColumn.prototype = {
    __proto__: AllocatorColumn.prototype,

    get title() {
      return tr.ui.b.createSpan({
        textContent: this.name,
        color: TracingColumn.COLOR
      });
    },

    color(numerics, processMemoryDumps) {
      return TracingColumn.COLOR;
    }
  };

  // Rules for constructing and sorting allocator columns.
  AllocatorColumn.RULES = [
    {
      condition: 'tracing',
      importance: 0,
      columnConstructor: TracingColumn
    },
    {
      // All other columns.
      importance: 1,
      columnConstructor: AllocatorColumn
    }
  ];

  Polymer({
    is: 'tr-ui-a-memory-dump-overview-pane',
    behaviors: [tr.ui.analysis.StackedPane],

    created() {
      this.processMemoryDumps_ = undefined;
      this.aggregationMode_ = undefined;
    },

    ready() {
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.CELL;
      this.$.table.addEventListener('selection-changed',
          function(tableEvent) {
            tableEvent.stopPropagation();
            this.changeChildPane_();
          }.bind(this));
    },

    /**
     * Sets the process memory dumps and schedules rebuilding the pane.
     *
     * The provided value should be a chronological list of dictionaries
     * mapping process IDs to process memory dumps. Example:
     *
     *   [
     *     {
     *       // PMDs at timestamp 1.
     *       42: tr.model.ProcessMemoryDump {}
     *     },
     *     {
     *       // PMDs at timestamp 2.
     *       42: tr.model.ProcessMemoryDump {},
     *       89: tr.model.ProcessMemoryDump {}
     *     }
     *   ]
     */
    set processMemoryDumps(processMemoryDumps) {
      this.processMemoryDumps_ = processMemoryDumps;
      this.scheduleRebuild_();
    },

    get processMemoryDumps() {
      return this.processMemoryDumps_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    get selectedMemoryCell() {
      if (this.processMemoryDumps_ === undefined ||
          this.processMemoryDumps_.length === 0) {
        return undefined;
      }

      const selectedTableRow = this.$.table.selectedTableRow;
      if (!selectedTableRow) return undefined;

      const selectedColumnIndex = this.$.table.selectedColumnIndex;
      if (selectedColumnIndex === undefined) return undefined;

      const selectedColumn = this.$.table.tableColumns[selectedColumnIndex];
      const selectedMemoryCell = selectedColumn.cell(selectedTableRow);
      return selectedMemoryCell;
    },

    changeChildPane_() {
      this.storeSelection_();
      this.childPaneBuilder = this.determineChildPaneBuilderFromSelection_();
    },

    determineChildPaneBuilderFromSelection_() {
      if (this.processMemoryDumps_ === undefined ||
          this.processMemoryDumps_.length === 0) {
        return undefined;
      }

      const selectedTableRow = this.$.table.selectedTableRow;
      if (!selectedTableRow) return undefined;

      const selectedColumnIndex = this.$.table.selectedColumnIndex;
      if (selectedColumnIndex === undefined) return undefined;
      const selectedColumn = this.$.table.tableColumns[selectedColumnIndex];

      return selectedColumn.getChildPaneBuilder(selectedTableRow.contexts);
    },

    onRebuild_() {
      if (this.processMemoryDumps_ === undefined ||
          this.processMemoryDumps_.length === 0) {
        // Show the info text (hide the table).
        this.$.info_text.style.display = 'block';
        this.$.table.style.display = 'none';

        this.$.table.clear();
        this.$.table.rebuild();
        return;
      }

      // Show the table (hide the info text).
      this.$.info_text.style.display = 'none';
      this.$.table.style.display = 'block';

      const rows = this.createRows_();
      const columns = this.createColumns_(rows);
      const footerRows = this.createFooterRows_(rows, columns);

      this.$.table.tableRows = rows;
      this.$.table.footerRows = footerRows;
      this.$.table.tableColumns = columns;
      this.$.table.rebuild();

      this.restoreSelection_();
    },

    createRows_() {
      // Timestamp (list index) -> Process ID (dict key) -> PMD.
      const timeToPidToProcessMemoryDump = this.processMemoryDumps_;

      // Process ID (dict key) -> Timestamp (list index) -> PMD or undefined.
      const pidToTimeToProcessMemoryDump = tr.b.invertArrayOfDicts(
          timeToPidToProcessMemoryDump);

      // Process (list index) -> Component (dict key) -> Cell.
      const rows = [];
      for (const [pid, timeToDump] of
          Object.entries(pidToTimeToProcessMemoryDump)) {
        // Get the process associated with the dumps. We can use any defined
        // process memory dump in timeToDump since they all have the same
        // pid.
        const process = timeToDump.find(x => x).process;

        // Used memory (total resident, PSS, ...).
        const usedMemoryCells = tr.ui.analysis.createCells(timeToDump,
            function(dump) {
              const sizes = {};

              const totals = dump.totals;
              if (totals !== undefined) {
                // Common totals.
                for (const [totalName, cellName] of
                    Object.entries(UsedMemoryColumn.TOTALS_MAP)) {
                  const total = totals[totalName];
                  if (total === undefined) continue;
                  sizes[cellName] = new Scalar(
                  sizeInBytes_smallerIsBetter, total);
                }

                // Platform-specific totals (e.g. private resident on Mac).
                const platformSpecific = totals.platformSpecific;
                if (platformSpecific !== undefined) {
                  for (const [name, size] of Object.entries(platformSpecific)) {
                    let newName = name;
                    if (UsedMemoryColumn.PLATFORM_SPECIFIC_TOTALS_MAP[name] ===
                        undefined) {
                      // Change raw OS-specific total name to a friendly
                      // column title (e.g. 'private_bytes' -> 'Private').
                      if (name.endsWith(PLATFORM_SPECIFIC_TOTAL_NAME_SUFFIX)) {
                        newName = name.substring(0, name.length -
                            PLATFORM_SPECIFIC_TOTAL_NAME_SUFFIX.length);
                      }
                      newName = newName.replace('_', ' ').trim();
                      newName =
                          newName.charAt(0).toUpperCase() + newName.slice(1);
                    } else {
                      newName =
                          UsedMemoryColumn.PLATFORM_SPECIFIC_TOTALS_MAP[name];
                    }
                    sizes[newName] = new Scalar(
                    sizeInBytes_smallerIsBetter, size);
                  }
                }
              }

              // VM regions byte stats.
              const vmRegions = dump.mostRecentVmRegions;
              if (vmRegions !== undefined) {
                for (const [byteStatName, cellName] of
                    Object.entries(UsedMemoryColumn.BYTE_STAT_MAP)) {
                  const byteStat = vmRegions.byteStats[byteStatName];
                  if (byteStat === undefined) continue;
                  sizes[cellName] = new Scalar(
                  sizeInBytes_smallerIsBetter, byteStat);
                }
              }

              return sizes;
            });

        // Allocator memory (v8, oilpan, ...).
        const allocatorCells = tr.ui.analysis.createCells(timeToDump,
            function(dump) {
              const memoryAllocatorDumps = dump.memoryAllocatorDumps;
              if (memoryAllocatorDumps === undefined) return undefined;

              const sizes = {};
              memoryAllocatorDumps.forEach(function(allocatorDump) {
                let rootDisplayedSizeNumeric = allocatorDump.numerics[
                DISPLAYED_SIZE_NUMERIC_NAME];
                if (rootDisplayedSizeNumeric === undefined) {
                  rootDisplayedSizeNumeric =
                  new Scalar(sizeInBytes_smallerIsBetter, 0);
                }
                sizes[allocatorDump.fullName] = rootDisplayedSizeNumeric;
              });
              return sizes;
            });

        rows.push({
          title: process.userFriendlyName,
          contexts: timeToDump,
          usedMemoryCells,
          allocatorCells
        });
      }
      return rows;
    },

    createFooterRows_(rows, columns) {
      // Add a 'Total' row if there are at least two process memory dumps.
      if (rows.length <= 1) return [];

      const totalRow = {title: 'Total'};
      tr.ui.analysis.aggregateTableRowCells(totalRow, rows, columns);

      return [totalRow];
    },

    createColumns_(rows) {
      const titleColumn = new ProcessNameColumn();
      titleColumn.width = '200px';

      const usedMemorySizeColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'usedMemoryCells',
        aggregationMode: this.aggregationMode_,
        rules: UsedMemoryColumn.RULES
      });

      const allocatorSizeColumns = tr.ui.analysis.MemoryColumn.fromRows(rows, {
        cellKey: 'allocatorCells',
        aggregationMode: this.aggregationMode_,
        rules: AllocatorColumn.RULES
      });

      const sizeColumns = usedMemorySizeColumns.concat(allocatorSizeColumns);
      tr.ui.analysis.MemoryColumn.spaceEqually(sizeColumns);

      const columns = [titleColumn].concat(sizeColumns);
      return columns;
    },

    storeSelection_() {
      let selectedRowTitle;
      const selectedRow = this.$.table.selectedTableRow;
      if (selectedRow !== undefined) {
        selectedRowTitle = selectedRow.title;
      }

      let selectedColumnName;
      const selectedColumnIndex = this.$.table.selectedColumnIndex;
      if (selectedColumnIndex !== undefined) {
        const selectedColumn = this.$.table.tableColumns[selectedColumnIndex];
        selectedColumnName = selectedColumn.name;
      }

      this.$.state.set(
          {rowTitle: selectedRowTitle, columnName: selectedColumnName});
    },

    restoreSelection_() {
      const settings = this.$.state.get();
      if (settings === undefined || settings.rowTitle === undefined ||
          settings.columnName === undefined) {
        return;
      }

      const selectedColumnIndex = this.$.table.tableColumns.findIndex(
          col => col.name === settings.columnName);
      if (selectedColumnIndex === -1) return;

      const selectedRowTitle = settings.rowTitle;
      const selectedRow = this.$.table.tableRows.find(
          row => row.title === selectedRowTitle);
      if (selectedRow === undefined) return;

      this.$.table.selectedTableRow = selectedRow;
      this.$.table.selectedColumnIndex = selectedColumnIndex;
    }
  });

  return {
    // All exports are for testing only.
    ProcessNameColumn,
    UsedMemoryColumn,
    PeakMemoryColumn,
    ByteStatColumn,
    AllocatorColumn,
    TracingColumn,
  };
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  Polymer({
    is: 'tr-ui-a-memory-dump-header-pane',
    behaviors: [tr.ui.analysis.StackedPane],

    created() {
      this.containerMemoryDumps_ = undefined;
    },

    ready() {
      Polymer.dom(this.$.aggregation_mode_container).appendChild(
          tr.ui.b.createSelector(this, 'aggregationMode',
              'memoryDumpHeaderPane.aggregationMode',
              tr.ui.analysis.MemoryColumn.AggregationMode.DIFF, [
                {
                  label: 'Diff',
                  value: tr.ui.analysis.MemoryColumn.AggregationMode.DIFF
                },
                {
                  label: 'Max',
                  value: tr.ui.analysis.MemoryColumn.AggregationMode.MAX
                }
              ]));
    },

    /**
     * Sets the container memory dumps and schedules rebuilding the pane.
     *
     * The provided value should be a chronologically sorted list of
     * ContainerMemoryDump objects. All of the dumps must be associated with
     * the same container (i.e. containerMemoryDumps must be either a list of
     * ProcessMemoryDump(s) belonging to the same process, or a list of
     * GlobalMemoryDump(s)). Example:
     *
     *   [
     *     tr.model.ProcessMemoryDump {},  // PMD at timestamp 1.
     *     tr.model.ProcessMemoryDump {},  // PMD at timestamp 2.
     *     tr.model.ProcessMemoryDump {}   // PMD at timestamp 3.
     *   ]
     */
    set containerMemoryDumps(containerMemoryDumps) {
      this.containerMemoryDumps_ = containerMemoryDumps;
      this.scheduleRebuild_();
    },

    get containerMemoryDumps() {
      return this.containerMemoryDumps_;
    },

    set aggregationMode(aggregationMode) {
      this.aggregationMode_ = aggregationMode;
      this.scheduleRebuild_();
    },

    get aggregationMode() {
      return this.aggregationMode_;
    },

    onRebuild_() {
      this.updateLabel_();
      this.updateAggregationModeSelector_();
      this.changeChildPane_();
    },

    updateLabel_() {
      Polymer.dom(this.$.label).textContent = '';

      if (this.containerMemoryDumps_ === undefined ||
          this.containerMemoryDumps_.length <= 0) {
        Polymer.dom(this.$.label).textContent = 'No memory dumps selected';
        return;
      }

      const containerDumpCount = this.containerMemoryDumps_.length;
      const isMultiSelection = containerDumpCount > 1;

      Polymer.dom(this.$.label).appendChild(document.createTextNode(
          'Selected ' + containerDumpCount + ' memory dump' +
          (isMultiSelection ? 's' : '') +
          ' in ' + this.containerMemoryDumps_[0].containerName + ' at '));
      // TODO(petrcermak): Use <tr-v-ui-scalar-span> once it can be displayed
      // inline. See https://github.com/catapult-project/catapult/issues/1371.
      Polymer.dom(this.$.label).appendChild(document.createTextNode(
          tr.b.Unit.byName.timeStampInMs.format(
              this.containerMemoryDumps_[0].start)));
      if (isMultiSelection) {
        const ELLIPSIS = String.fromCharCode(8230);
        Polymer.dom(this.$.label).appendChild(
            document.createTextNode(ELLIPSIS));
        Polymer.dom(this.$.label).appendChild(document.createTextNode(
            tr.b.Unit.byName.timeStampInMs.format(
                this.containerMemoryDumps_[containerDumpCount - 1].start)));
      }
    },

    updateAggregationModeSelector_() {
      let displayStyle;
      if (this.containerMemoryDumps_ === undefined ||
          this.containerMemoryDumps_.length <= 1) {
        displayStyle = 'none';
      } else {
        displayStyle = 'initial';
      }
      this.$.aggregation_mode_container.style.display = displayStyle;
    },

    changeChildPane_() {
      this.childPaneBuilder = function() {
        if (this.containerMemoryDumps_ === undefined ||
            this.containerMemoryDumps_.length <= 0) {
          return undefined;
        }

        const overviewPane = document.createElement(
            'tr-ui-a-memory-dump-overview-pane');
        overviewPane.processMemoryDumps = this.containerMemoryDumps_.map(
            function(containerDump) {
              return containerDump.processMemoryDumps;
            });
        overviewPane.aggregationMode = this.aggregationMode;
        return overviewPane;
      }.bind(this);
    }
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-a-stacked-pane-view',

  /**
   * Add a pane to the stacked pane view. This method performs two operations:
   *
   *   1. Remove existing descendant panes
   *      If the optional parent pane is provided, all its current descendant
   *      panes are removed. Otherwise, all panes are removed from the view.
   *
   *   2. Build and add new pane
   *      If a pane builder is provided and returns a pane, the new pane is
   *      appended to the view (after the provided parent, or at the top).
   */
  setPaneBuilder(paneBuilder, opt_parentPane) {
    const paneContainer = this.$.pane_container;

    // If the parent pane is provided, it must be an HTML element and a child
    // of the pane container.
    if (opt_parentPane) {
      if (!(opt_parentPane instanceof HTMLElement)) {
        throw new Error('Parent pane must be an HTML element');
      }
      if (opt_parentPane.parentElement !== paneContainer) {
        throw new Error('Parent pane must be a child of the pane container');
      }
    }

    // Remove all descendants of the parent pane (or all panes if no parent
    // pane was specified) in reverse order.
    while (Polymer.dom(paneContainer).lastElementChild !== null &&
           Polymer.dom(paneContainer).lastElementChild !== opt_parentPane) {
      const removedPane = Polymer.dom(this.$.pane_container).lastElementChild;
      const listener = this.listeners_.get(removedPane);
      if (listener === undefined) {
        throw new Error('No listener associated with pane');
      }
      this.listeners_.delete(removedPane);
      removedPane.removeEventListener(
          'request-child-pane-change', listener);
      Polymer.dom(paneContainer).removeChild(removedPane);
    }

    if (opt_parentPane && opt_parentPane.parentElement !== paneContainer) {
      throw new Error('Parent pane was removed from the pane container');
    }

    // This check is performed here (and not at the beginning of the method)
    // because undefined pane builder means that the parent pane requested
    // having no child pane (e.g. when selection is cleared).
    if (!paneBuilder) return;

    const pane = paneBuilder();
    if (!pane) return;

    if (!(pane instanceof HTMLElement)) {
      throw new Error('Pane must be an HTML element');
    }

    // Listen for child pane change requests from the newly added pane.
    const listener = function(event) {
      this.setPaneBuilder(pane.childPaneBuilder, pane);
    }.bind(this);
    if (!this.listeners_) {
      // Instead of initializing the listeners map in a created() callback,
      // we do it lazily here so that subclasses could provide their own
      // created() callback (Polymer currently doesn't allow calling overriden
      // superclass methods in strict mode).
      this.listeners_ = new WeakMap();
    }
    this.listeners_.set(pane, listener);
    pane.addEventListener('request-child-pane-change', listener);

    Polymer.dom(paneContainer).appendChild(pane);
    pane.appended();
  },

  /**
   * Request rebuilding all panes in the view. The panes are rebuilt from the
   * top to the bottom (so that parent panes could request changing their
   * child panes when they're being rebuilt and the newly constructed child
   * panes would be rebuilt as well).
   */
  rebuild() {
    let currentPane = Polymer.dom(this.$.pane_container).firstElementChild;
    while (currentPane) {
      currentPane.rebuild();
      currentPane = currentPane.nextElementSibling;
    }
  },

  // For testing purposes.
  get panesForTesting() {
    const panes = [];
    let currentChild = Polymer.dom(this.$.pane_container).firstElementChild;
    while (currentChild) {
      panes.push(currentChild);
      currentChild = currentChild.nextElementSibling;
    }
    return panes;
  }
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  Polymer({
    is: 'tr-ui-a-container-memory-dump-sub-view',
    behaviors: [tr.ui.analysis.AnalysisSubView],

    set selection(selection) {
      if (selection === undefined) {
        this.currentSelection_ = undefined;
        this.dumpsByContainerName_ = undefined;
        this.updateContents_();
        return;
      }

      // Check that the selection contains only container memory dumps.
      selection.forEach(function(event) {
        if (!(event instanceof tr.model.ContainerMemoryDump)) {
          throw new Error(
              'Memory dump sub-view only supports container memory dumps');
        }
      });
      this.currentSelection_ = selection;

      // Group the selected memory dumps by container name and sort them
      // chronologically.
      this.dumpsByContainerName_ = tr.b.groupIntoMap(
          this.currentSelection_.toArray(), dump => dump.containerName);
      for (const dumps of this.dumpsByContainerName_.values()) {
        dumps.sort((a, b) => a.start - b.start);
      }

      this.updateContents_();
    },

    get selection() {
      return this.currentSelection_;
    },

    get requiresTallView() {
      return true;
    },

    updateContents_() {
      Polymer.dom(this.$.content).textContent = '';

      if (this.dumpsByContainerName_ === undefined) return;

      const containerNames = Array.from(this.dumpsByContainerName_.keys());
      if (containerNames.length === 0) return;

      if (containerNames.length > 1) {
        this.buildViewForMultipleContainerNames_();
      } else {
        this.buildViewForSingleContainerName_();
      }
    },

    buildViewForSingleContainerName_() {
      const containerMemoryDumps = tr.b.getFirstElement(
          this.dumpsByContainerName_.values());
      const dumpView = this.ownerDocument.createElement(
          'tr-ui-a-stacked-pane-view');
      Polymer.dom(this.$.content).appendChild(dumpView);
      dumpView.setPaneBuilder(function() {
        const headerPane = document.createElement(
            'tr-ui-a-memory-dump-header-pane');
        headerPane.containerMemoryDumps = containerMemoryDumps;
        return headerPane;
      });
    },

    buildViewForMultipleContainerNames_() {
      // TODO(petrcermak): Provide a more sophisticated view for this case.
      const ownerDocument = this.ownerDocument;

      const rows = [];
      for (const [containerName, dumps] of this.dumpsByContainerName_) {
        rows.push({
          containerName,
          subRows: dumps,
          isExpanded: true,
        });
      }
      rows.sort(function(a, b) {
        return a.containerName.localeCompare(b.containerName);
      });

      const columns = [
        {
          title: 'Dump',

          value(row) {
            if (row.subRows === undefined) {
              return this.singleDumpValue_(row);
            }
            return this.groupedDumpValue_(row);
          },

          singleDumpValue_(row) {
            const linkEl = ownerDocument.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(new tr.model.EventSet([row]));
            Polymer.dom(linkEl).appendChild(tr.v.ui.createScalarSpan(
                row.start, {
                  unit: tr.b.Unit.byName.timeStampInMs,
                  ownerDocument
                }));
            return linkEl;
          },

          groupedDumpValue_(row) {
            const linkEl = ownerDocument.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(new tr.model.EventSet(row.subRows));
            Polymer.dom(linkEl).appendChild(tr.ui.b.createSpan({
              ownerDocument,
              textContent: row.subRows.length + ' memory dump' +
                  (row.subRows.length === 1 ? '' : 's') + ' in '
            }));
            Polymer.dom(linkEl).appendChild(tr.ui.b.createSpan({
              ownerDocument,
              textContent: row.containerName,
              bold: true
            }));
            return linkEl;
          }
        }
      ];

      const table = this.ownerDocument.createElement('tr-ui-b-table');
      table.tableColumns = columns;
      table.tableRows = rows;
      table.showHeader = false;
      table.rebuild();
      Polymer.dom(this.$.content).appendChild(table);
    }
  });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-container-memory-dump-sub-view',
      tr.model.GlobalMemoryDump,
      {
        multi: false,
        title: 'Global Memory Dump',
      });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-container-memory-dump-sub-view',
      tr.model.GlobalMemoryDump,
      {
        multi: true,
        title: 'Global Memory Dumps',
      });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-container-memory-dump-sub-view',
      tr.model.ProcessMemoryDump,
      {
        multi: false,
        title: 'Process Memory Dump',
      });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-container-memory-dump-sub-view',
      tr.model.ProcessMemoryDump,
      {
        multi: true,
        title: 'Process Memory Dumps',
      });

  return {};
});


'use strict';
(function() {
  const COUNTER_SAMPLE_TABLE_COLUMNS = [
    {
      title: 'Counter',
      width: '150px',
      value(row) { return row.counter; }
    },
    {
      title: 'Series',
      width: '150px',
      value(row) { return row.series; }
    },
    {
      title: 'Time',
      width: '150px',
      value(row) { return row.start; }
    },
    {
      title: 'Value',
      width: '100%',
      value(row) { return row.value; }
    }
  ];

  Polymer({
    is: 'tr-ui-a-counter-sample-sub-view',
    behaviors: [tr.ui.analysis.AnalysisSubView],

    ready() {
      this.currentSelection_ = undefined;
      this.$.table.tableColumns = COUNTER_SAMPLE_TABLE_COLUMNS;
    },

    get selection() {
      return this.currentSelection_;
    },

    set selection(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    updateContents_() {
      this.$.table.tableRows =
          this.selection ? this.getRows_(this.selection.toArray()) : [];
      this.$.table.rebuild();
    },

    /**
     * Returns the table rows for the specified samples.
     *
     * We print each counter/series combination the first time that it
     * appears. For subsequent samples in each series, we omit the counter
     * and series name. This makes it easy to scan to find the next series.
     *
     * Each series can be collapsed. In the expanded state, all samples
     * are shown. In the collapsed state, only the first sample is displayed.
     */
    getRows_(samples) {
      const samplesByCounter = tr.b.groupIntoMap(
          samples, sample => sample.series.counter.guid);

      const rows = [];
      for (const counterSamples of samplesByCounter.values()) {
        const samplesBySeries = tr.b.groupIntoMap(
            counterSamples, sample => sample.series.guid);

        for (const seriesSamples of samplesBySeries.values()) {
          const seriesRows = this.getRowsForSamples_(seriesSamples);
          seriesRows[0].counter = seriesSamples[0].series.counter.name;
          seriesRows[0].series = seriesSamples[0].series.name;

          if (seriesRows.length > 1) {
            seriesRows[0].subRows = seriesRows.slice(1);
            seriesRows[0].isExpanded = true;
          }

          rows.push(seriesRows[0]);
        }
      }

      return rows;
    },

    getRowsForSamples_(samples) {
      return samples.map(function(sample) {
        return {
          start: sample.timestamp,
          value: sample.value
        };
      });
    }
  });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-counter-sample-sub-view',
      tr.model.CounterSample,
      {
        multi: false,
        title: 'Counter Sample',
      });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-counter-sample-sub-view',
      tr.model.CounterSample,
      {
        multi: true,
        title: 'Counter Samples',
      });
})();


'use strict';
tr.exportTo('tr.ui.analysis', function() {
  function MultiEventSummary(title, events) {
    this.title = title;
    this.duration_ = undefined;
    this.selfTime_ = undefined;
    this.events_ = events;

    this.cpuTimesComputed_ = false;
    this.cpuSelfTime_ = undefined;
    this.cpuDuration_ = undefined;

    this.maxDuration_ = undefined;
    this.maxCpuDuration_ = undefined;
    this.maxSelfTime_ = undefined;
    this.maxCpuSelfTime_ = undefined;

    this.untotallableArgs_ = [];
    this.totalledArgs_ = undefined;
  }
  MultiEventSummary.prototype = {

    set title(title) {
      if (title === 'Totals') {
        this.totalsRow = true;
      }
      this.title_ = title;
    },

    get title() {
      return this.title_;
    },

    get duration() {
      if (this.duration_ === undefined) {
        this.duration_ = tr.b.math.Statistics.sum(
            this.events_, function(event) {
              return event.duration;
            });
      }
      return this.duration_;
    },

    get cpuSelfTime() {
      this.computeCpuTimesIfNeeded_();
      return this.cpuSelfTime_;
    },

    get cpuDuration() {
      this.computeCpuTimesIfNeeded_();
      return this.cpuDuration_;
    },

    computeCpuTimesIfNeeded_() {
      if (this.cpuTimesComputed_) return;
      this.cpuTimesComputed_ = true;

      let cpuSelfTime = 0;
      let cpuDuration = 0;
      let hasCpuData = false;
      for (const event of this.events_) {
        if (event.cpuDuration !== undefined) {
          cpuDuration += event.cpuDuration;
          hasCpuData = true;
        }

        if (event.cpuSelfTime !== undefined) {
          cpuSelfTime += event.cpuSelfTime;
          hasCpuData = true;
        }
      }
      if (hasCpuData) {
        this.cpuDuration_ = cpuDuration;
        this.cpuSelfTime_ = cpuSelfTime;
      }
    },

    get selfTime() {
      if (this.selfTime_ === undefined) {
        this.selfTime_ = 0;
        for (const event of this.events_) {
          if (event.selfTime !== undefined) {
            this.selfTime_ += event.selfTime;
          }
        }
      }
      return this.selfTime_;
    },

    get events() {
      return this.events_;
    },

    get numEvents() {
      return this.events_.length;
    },

    get numAlerts() {
      if (this.numAlerts_ === undefined) {
        this.numAlerts_ = tr.b.math.Statistics.sum(this.events_, event =>
          event.associatedAlerts.length
        );
      }
      return this.numAlerts_;
    },

    get untotallableArgs() {
      this.updateArgsIfNeeded_();
      return this.untotallableArgs_;
    },

    get totalledArgs() {
      this.updateArgsIfNeeded_();
      return this.totalledArgs_;
    },


    get maxDuration() {
      if (this.maxDuration_ === undefined) {
        this.maxDuration_ = tr.b.math.Statistics.max(
            this.events_, function(event) {
              return event.duration;
            });
      }
      return this.maxDuration_;
    },


    get maxCpuDuration() {
      if (this.maxCpuDuration_ === undefined) {
        this.maxCpuDuration_ = tr.b.math.Statistics.max(
            this.events_, function(event) {
              return event.cpuDuration;
            });
      }
      return this.maxCpuDuration_;
    },


    get maxSelfTime() {
      if (this.maxSelfTime_ === undefined) {
        this.maxSelfTime_ = tr.b.math.Statistics.max(
            this.events_, function(event) {
              return event.selfTime;
            });
      }
      return this.maxSelfTime_;
    },


    get maxCpuSelfTime() {
      if (this.maxCpuSelfTime_ === undefined) {
        this.maxCpuSelfTime_ = tr.b.math.Statistics.max(
            this.events_, function(event) {
              return event.cpuSelfTime;
            });
      }
      return this.maxCpuSelfTime_;
    },


    updateArgsIfNeeded_() {
      if (this.totalledArgs_ !== undefined) return;

      const untotallableArgs = {};
      const totalledArgs = {};
      for (const event of this.events_) {
        for (const argName in event.args) {
          const argVal = event.args[argName];
          const type = typeof argVal;
          if (type !== 'number') {
            untotallableArgs[argName] = true;
            delete totalledArgs[argName];
            continue;
          }
          if (untotallableArgs[argName]) {
            continue;
          }

          if (totalledArgs[argName] === undefined) {
            totalledArgs[argName] = 0;
          }
          totalledArgs[argName] += argVal;
        }
      }
      this.untotallableArgs_ = Object.keys(untotallableArgs);
      this.totalledArgs_ = totalledArgs;
    }
  };

  return {
    MultiEventSummary,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-a-multi-event-summary-table',

  ready() {
    this.showTotals_ = false;
    this.eventsHaveDuration_ = true;
    this.eventsHaveSubRows_ = true;
    this.eventsByTitle_ = undefined;
  },

  updateTableColumns_(rows, maxValues) {
    let hasCpuData = false;
    let hasAlerts = false;
    rows.forEach(function(row) {
      if (row.cpuDuration !== undefined) {
        hasCpuData = true;
      }
      if (row.cpuSelfTime !== undefined) {
        hasCpuData = true;
      }
      if (row.numAlerts) {
        hasAlerts = true;
      }
    });

    const ownerDocument = this.ownerDocument;

    const columns = [];

    columns.push({
      title: 'Name',
      value(row) {
        if (row.title === 'Totals') return 'Totals';

        const linkEl = document.createElement('tr-ui-a-analysis-link');
        linkEl.setSelectionAndContent(function() {
          return new tr.model.EventSet(row.events);
        }, row.title);
        return linkEl;
      },
      width: '350px',
      cmp(rowA, rowB) {
        return rowA.title.localeCompare(rowB.title);
      }
    });
    if (this.eventsHaveDuration_) {
      columns.push({
        title: 'Wall Duration',
        value(row) {
          return tr.v.ui.createScalarSpan(row.duration, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            customContextRange: row.totalsRow ? undefined :
                tr.b.math.Range.fromExplicitRange(0, maxValues.duration),
            ownerDocument,
          });
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          return rowA.duration - rowB.duration;
        }
      });
    }

    if (this.eventsHaveDuration_ && hasCpuData) {
      columns.push({
        title: 'CPU Duration',
        value(row) {
          return tr.v.ui.createScalarSpan(row.cpuDuration, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            customContextRange: row.totalsRow ? undefined :
                tr.b.math.Range.fromExplicitRange(0, maxValues.cpuDuration),
            ownerDocument,
          });
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          return rowA.cpuDuration - rowB.cpuDuration;
        }
      });
    }

    if (this.eventsHaveSubRows_ && this.eventsHaveDuration_) {
      columns.push({
        title: 'Self time',
        value(row) {
          return tr.v.ui.createScalarSpan(row.selfTime, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            customContextRange: row.totalsRow ? undefined :
                tr.b.math.Range.fromExplicitRange(0, maxValues.selfTime),
            ownerDocument,
          });
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          return rowA.selfTime - rowB.selfTime;
        }
      });
    }

    if (this.eventsHaveSubRows_ && this.eventsHaveDuration_ && hasCpuData) {
      columns.push({
        title: 'CPU Self Time',
        value(row) {
          return tr.v.ui.createScalarSpan(row.cpuSelfTime, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            customContextRange: row.totalsRow ? undefined :
                tr.b.math.Range.fromExplicitRange(0, maxValues.cpuSelfTime),
            ownerDocument,
          });
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          return rowA.cpuSelfTime - rowB.cpuSelfTime;
        }
      });
    }

    if (this.eventsHaveDuration_) {
      columns.push({
        title: 'Average ' + (hasCpuData ? 'CPU' : 'Wall') + ' Duration',
        value(row) {
          const totalDuration = hasCpuData ? row.cpuDuration : row.duration;
          return tr.v.ui.createScalarSpan(totalDuration / row.numEvents, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            customContextRange: row.totalsRow ? undefined :
                tr.b.math.Range.fromExplicitRange(0, maxValues.duration),
            ownerDocument,
          });
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          if (hasCpuData) {
            return rowA.cpuDuration / rowA.numEvents -
                rowB.cpuDuration / rowB.numEvents;
          }
          return rowA.duration / rowA.numEvents -
              rowB.duration / rowB.numEvents;
        }
      });
    }

    columns.push({
      title: 'Occurrences',
      value(row) {
        return row.numEvents;
      },
      width: '<upated further down>',
      cmp(rowA, rowB) {
        return rowA.numEvents - rowB.numEvents;
      }
    });

    let alertsColumnIndex;
    if (hasAlerts) {
      columns.push({
        title: 'Num Alerts',
        value(row) {
          return row.numAlerts;
        },
        width: '<upated further down>',
        cmp(rowA, rowB) {
          return rowA.numAlerts - rowB.numAlerts;
        }
      });
      alertsColumnIndex = columns.length - 1;
    }
    let colWidthPercentage;
    if (columns.length === 1) {
      colWidthPercentage = '100%';
    } else {
      colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';
    }

    for (let i = 1; i < columns.length; i++) {
      columns[i].width = colWidthPercentage;
    }

    this.$.table.tableColumns = columns;

    if (hasAlerts) {
      this.$.table.sortColumnIndex = alertsColumnIndex;
      this.$.table.sortDescending = true;
    }
  },

  configure(config) {
    if (config.eventsByTitle === undefined) {
      throw new Error('Required: eventsByTitle');
    }

    if (config.showTotals !== undefined) {
      this.showTotals_ = config.showTotals;
    } else {
      this.showTotals_ = true;
    }

    if (config.eventsHaveDuration !== undefined) {
      this.eventsHaveDuration_ = config.eventsHaveDuration;
    } else {
      this.eventsHaveDuration_ = true;
    }

    if (config.eventsHaveSubRows !== undefined) {
      this.eventsHaveSubRows_ = config.eventsHaveSubRows;
    } else {
      this.eventsHaveSubRows_ = true;
    }

    this.eventsByTitle_ = config.eventsByTitle;
    this.updateContents_();
  },

  get showTotals() {
    return this.showTotals_;
  },

  set showTotals(showTotals) {
    this.showTotals_ = showTotals;
    this.updateContents_();
  },

  get eventsHaveDuration() {
    return this.eventsHaveDuration_;
  },

  set eventsHaveDuration(eventsHaveDuration) {
    this.eventsHaveDuration_ = eventsHaveDuration;
    this.updateContents_();
  },

  get eventsHaveSubRows() {
    return this.eventsHaveSubRows_;
  },

  set eventsHaveSubRows(eventsHaveSubRows) {
    this.eventsHaveSubRows_ = eventsHaveSubRows;
    this.updateContents_();
  },

  get eventsByTitle() {
    return this.eventsByTitle_;
  },

  set eventsByTitle(eventsByTitle) {
    this.eventsByTitle_ = eventsByTitle;
    this.updateContents_();
  },

  get selectionBounds() {
    return this.selectionBounds_;
  },

  set selectionBounds(selectionBounds) {
    this.selectionBounds_ = selectionBounds;
    this.updateContents_();
  },

  updateContents_() {
    let eventsByTitle;
    if (this.eventsByTitle_ !== undefined) {
      eventsByTitle = this.eventsByTitle_;
    } else {
      eventsByTitle = [];
    }

    const allEvents = new tr.model.EventSet();
    const rows = [];
    for (const [title, eventsOfSingleTitle] of Object.entries(eventsByTitle)) {
      for (const event of eventsOfSingleTitle) allEvents.push(event);
      const row = new tr.ui.analysis.MultiEventSummary(
          title, eventsOfSingleTitle);
      rows.push(row);
    }

    this.updateTableColumns_(rows);
    this.$.table.tableRows = rows;

    const maxValues = {
      duration: undefined,
      selfTime: undefined,
      cpuSelfTime: undefined,
      cpuDuration: undefined
    };

    if (this.eventsHaveDuration) {
      for (const column in maxValues) {
        maxValues[column] = tr.b.math.Statistics.max(rows, function(event) {
          return event[column];
        });
      }
    }

    const footerRows = [];

    if (this.showTotals_) {
      const multiEventSummary = new tr.ui.analysis.MultiEventSummary(
        'Totals', allEvents);
      footerRows.push(multiEventSummary);
    }


    this.updateTableColumns_(rows, maxValues);
    this.$.table.tableRows = rows;

    // TODO(selection bounds).

    // TODO(sorting)

    this.$.table.footerRows = footerRows;
    this.$.table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-selection-summary-table',
  created() {
    this.selection_ = new tr.b.math.Range();
  },

  ready() {
    this.$.table.showHeader = false;
    this.$.table.tableColumns = [
      {
        title: 'Name',
        value(row) { return row.title; },
        width: '350px'
      },
      {
        title: 'Value',
        width: '100%',
        value(row) {
          return row.value;
        }
      }
    ];
  },

  get selection() {
    return this.selection_;
  },

  set selection(selection) {
    this.selection_ = selection;
    this.updateContents_();
  },

  updateContents_() {
    const selection = this.selection_;
    const rows = [];
    let hasRange;
    if (this.selection_ && (!selection.bounds.isEmpty)) {
      hasRange = true;
    } else {
      hasRange = false;
    }

    rows.push({
      title: 'Selection start',
      value: hasRange ? tr.v.ui.createScalarSpan(
          selection.bounds.min, {
            unit: tr.b.Unit.byName.timeStampInMs,
            ownerDocument: this.ownerDocument
          }) : '<empty>'
    });
    rows.push({
      title: 'Selection extent',
      value: hasRange ? tr.v.ui.createScalarSpan(
          selection.bounds.range, {
            unit: tr.b.Unit.byName.timeDurationInMs,
            ownerDocument: this.ownerDocument
          }) : '<empty>'
    });

    this.$.table.tableRows = rows;
    this.$.table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-b-radio-picker',

  created() {
    this.needsInit_ = true;
    this.settingsKey_ = undefined;
    this.isReady_ = false;
    this.radioButtons_ = undefined;
    // Keeping track of which key is selected. This member should only be set
    // set inside select() method to make sure that logical state & the UI
    // state is consistent.
    this.selectedKey_ = undefined;
  },

  ready() {
    this.isReady_ = true;
    this.maybeInit_();
    this.maybeRenderRadioButtons_();
  },

  get vertical() {
    return this.getAttribute('vertical');
  },

  set vertical(vertical) {
    if (vertical) {
      this.setAttribute('vertical', true);
    } else {
      this.removeAttribute('vertical');
    }
  },

  get settingsKey() {
    return this.settingsKey_;
  },

  set settingsKey(settingsKey) {
    if (!this.needsInit_) {
      throw new Error('Already initialized.');
    }
    this.settingsKey_ = settingsKey;
    this.maybeInit_();
  },

  maybeInit_() {
    if (!this.needsInit_) return;
    if (this.settingsKey_ === undefined) return;
    this.needsInit_ = false;
    this.select(tr.b.Settings.get(this.settingsKey_));
  },

  set items(items) {
    this.radioButtons_ = {};
    items.forEach(function(e) {
      if (e.key in this.radioButtons_) {
        throw new Error(e.key + ' already exists');
      }
      const radioButton = document.createElement('div');
      const input = document.createElement('input');
      const label = document.createElement('label');
      input.type = 'radio';
      input.id = e.label;
      input.addEventListener('click', function() {
        this.select(e.key);
      }.bind(this));
      Polymer.dom(label).innerHTML = e.label;
      label.htmlFor = e.label;
      label.style.display = 'inline';
      Polymer.dom(radioButton).appendChild(input);
      Polymer.dom(radioButton).appendChild(label);
      this.radioButtons_[e.key] = input;
    }.bind(this));

    this.maybeInit_();
    this.maybeRenderRadioButtons_();
  },

  maybeRenderRadioButtons_() {
    if (!this.isReady_) return;
    if (this.radioButtons_ === undefined) return;
    for (const key in this.radioButtons_) {
      Polymer.dom(this.$.container).appendChild(
          this.radioButtons_[key].parentElement);
    }
    if (this.selectedKey_ !== undefined) {
      this.select(this.selectedKey_);
    }
  },

  select(key) {
    if (key === undefined || key === this.selectedKey_) {
      return;
    }
    if (this.radioButtons_ === undefined) {
      this.selectedKey_ = key;
      return;
    }
    if (!(key in this.radioButtons_)) {
      throw new Error(key + ' does not exists');
    }
    // Unselect the previous radio, update the key & select the new one.
    if (this.selectedKey_ !== undefined) {
      this.radioButtons_[this.selectedKey_].checked = false;
    }
    this.selectedKey_ = key;
    tr.b.Settings.set(this.settingsKey_, this.selectedKey_);
    if (this.selectedKey_ !== undefined) {
      this.radioButtons_[this.selectedKey_].checked = true;
    }

    this.dispatchEvent(new tr.b.Event('change', false));
  },

  get selectedKey() {
    return this.selectedKey_;
  },
});


'use strict';

Polymer({
  is: 'tr-ui-b-chart-legend-key',

  ready() {
    this.$.checkbox.addEventListener(
        'change', this.onCheckboxChange_.bind(this));
  },

  /**
   * Dispatch an event when the checkbox is toggled.
   * The checkbox is visible when optional is set to true.
   */
  onCheckboxChange_() {
    tr.b.dispatchSimpleEvent(this, tr.ui.b.DataSeriesEnableChangeEventType,
        true, false,
        {key: Polymer.dom(this).textContent, enabled: this.enabled});
  },

  set textContent(t) {
    Polymer.dom(this.$.label).textContent = t;
    Polymer.dom(this.$.link).textContent = t;
    this.updateContents_();
  },

  set width(w) {
    w -= 20;  // reserve 20px for the checkbox
    this.$.link.style.width = w + 'px';
    this.$.label.style.width = w + 'px';
  },

  get textContent() {
    return Polymer.dom(this.$.label).textContent;
  },

  /**
   * When a legend-key is "optional", then its checkbox is visible to allow
   * the user to enable/disable the data series for the key.
   *
   * @param {boolean} optional
   */
  set optional(optional) {
    this.$.checkbox.style.visibility = optional ? 'visible' : 'hidden';
  },

  get optional() {
    return this.$.checkbox.style.visibility === 'visible';
  },

  set enabled(enabled) {
    this.$.checkbox.checked = enabled ? 'checked' : '';
  },

  get enabled() {
    return this.$.checkbox.checked;
  },

  set color(c) {
    this.$.label.style.color = c;
    this.$.link.color = c;
  },

  /**
   * When target is defined, label is hidden and link is shown.
   * When the link is clicked, then a RequestSelectionChangeEvent is
   * dispatched containing the target.
   * When target is undefined, label is shown and link is hidden, so that the
   * link is not clickable.
   */
  set target(target) {
    this.$.link.setSelectionAndContent(
        target, Polymer.dom(this.$.label).textContent);
    this.updateContents_();
  },

  get target() {
    return this.$.link.selection;
  },

  set title(title) {
    this.$.link.title = title;
  },

  updateContents_() {
    this.$.link.style.display = this.target ? '' : 'none';
    this.$.label.style.display = this.target ? 'none' : '';
    this.$.label.htmlFor = this.optional ? 'checkbox' : '';
  }
});

/* Copyright (c) 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */
'use strict';

(function(window) {
  window.define = function(x) {
    window.d3 = x;
  };
  window.define.amd = true;
})(this);

!function(){function n(n){return null!=n&&!isNaN(n)}function t(n){return n.length}function e(n){for(var t=1;n*t%1;)t*=10;return t}function r(n,t){try{for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}catch(r){n.prototype=t}}function u(){}function i(n){return aa+n in this}function o(n){return n=aa+n,n in this&&delete this[n]}function a(){var n=[];return this.forEach(function(t){n.push(t)}),n}function c(){var n=0;for(var t in this)t.charCodeAt(0)===ca&&++n;return n}function s(){for(var n in this)if(n.charCodeAt(0)===ca)return!1;return!0}function l(){}function f(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function h(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.substring(1);for(var e=0,r=sa.length;r>e;++e){var u=sa[e]+t;if(u in n)return u}}function g(){}function p(){}function v(n){function t(){for(var t,r=e,u=-1,i=r.length;++u<i;)(t=r[u].on)&&t.apply(this,arguments);return n}var e=[],r=new u;return t.on=function(t,u){var i,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,i=e.indexOf(o)).concat(e.slice(i+1)),r.remove(t)),u&&e.push(r.set(t,{on:u})),n)},t}function d(){Xo.event.preventDefault()}function m(){for(var n,t=Xo.event;n=t.sourceEvent;)t=n;return t}function y(n){for(var t=new p,e=0,r=arguments.length;++e<r;)t[arguments[e]]=v(t);return t.of=function(e,r){return function(u){try{var i=u.sourceEvent=Xo.event;u.target=n,Xo.event=u,t[u.type].apply(e,r)}finally{Xo.event=i}}},t}function x(n){return fa(n,da),n}function M(n){return"function"==typeof n?n:function(){return ha(n,this)}}function _(n){return"function"==typeof n?n:function(){return ga(n,this)}}function b(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function u(){this.setAttribute(n,t)}function i(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=Xo.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?i:u}function w(n){return n.trim().replace(/\s+/g," ")}function S(n){return new RegExp("(?:^|\\s+)"+Xo.requote(n)+"(?:\\s+|$)","g")}function k(n){return n.trim().split(/^|\s+/)}function E(n,t){function e(){for(var e=-1;++e<u;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<u;)n[e](this,r)}n=k(n).map(A);var u=n.length;return"function"==typeof t?r:e}function A(n){var t=S(n);return function(e,r){if(u=e.classList)return r?u.add(n):u.remove(n);var u=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(u)||e.setAttribute("class",w(u+" "+n))):e.setAttribute("class",w(u.replace(t," ")))}}function C(n,t,e){function r(){this.style.removeProperty(n)}function u(){this.style.setProperty(n,t,e)}function i(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?i:u}function N(n,t){function e(){delete this[n]}function r(){this[n]=t}function u(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?u:r}function L(n){return"function"==typeof n?n:(n=Xo.ns.qualify(n)).local?function(){return this.ownerDocument.createElementNS(n.space,n.local)}:function(){return this.ownerDocument.createElementNS(this.namespaceURI,n)}}function T(n){return{__data__:n}}function q(n){return function(){return va(this,n)}}function z(n){return arguments.length||(n=Xo.ascending),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function R(n,t){for(var e=0,r=n.length;r>e;e++)for(var u,i=n[e],o=0,a=i.length;a>o;o++)(u=i[o])&&t(u,o,e);return n}function D(n){return fa(n,ya),n}function P(n){var t,e;return function(r,u,i){var o,a=n[i].update,c=a.length;for(i!=e&&(e=i,t=0),u>=t&&(t=u+1);!(o=a[t])&&++t<c;);return o}}function U(){var n=this.__transition__;n&&++n.active}function j(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function u(){var u=c(t,Bo(arguments));r.call(this),this.addEventListener(n,this[o]=u,u.$=e),u._=t}function i(){var t,e=new RegExp("^__on([^.]+)"+Xo.requote(n)+"$");for(var r in this)if(t=r.match(e)){var u=this[r];this.removeEventListener(t[1],u,u.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),c=H;a>0&&(n=n.substring(0,a));var s=Ma.get(n);return s&&(n=s,c=F),a?t?u:r:t?g:i}function H(n,t){return function(e){var r=Xo.event;Xo.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{Xo.event=r}}}function F(n,t){var e=H(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function O(){var n=".dragsuppress-"+ ++ba,t="click"+n,e=Xo.select(Go).on("touchmove"+n,d).on("dragstart"+n,d).on("selectstart"+n,d);if(_a){var r=Jo.style,u=r[_a];r[_a]="none"}return function(i){function o(){e.on(t,null)}e.on(n,null),_a&&(r[_a]=u),i&&(e.on(t,function(){d(),o()},!0),setTimeout(o,0))}}function Y(n,t){t.changedTouches&&(t=t.changedTouches[0]);var e=n.ownerSVGElement||n;if(e.createSVGPoint){var r=e.createSVGPoint();if(0>wa&&(Go.scrollX||Go.scrollY)){e=Xo.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var u=e[0][0].getScreenCTM();wa=!(u.f||u.e),e.remove()}return wa?(r.x=t.pageX,r.y=t.pageY):(r.x=t.clientX,r.y=t.clientY),r=r.matrixTransform(n.getScreenCTM().inverse()),[r.x,r.y]}var i=n.getBoundingClientRect();return[t.clientX-i.left-n.clientLeft,t.clientY-i.top-n.clientTop]}function I(n){return n>0?1:0>n?-1:0}function Z(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function V(n){return n>1?0:-1>n?Sa:Math.acos(n)}function X(n){return n>1?Ea:-1>n?-Ea:Math.asin(n)}function $(n){return((n=Math.exp(n))-1/n)/2}function B(n){return((n=Math.exp(n))+1/n)/2}function W(n){return((n=Math.exp(2*n))-1)/(n+1)}function J(n){return(n=Math.sin(n/2))*n}function G(){}function K(n,t,e){return new Q(n,t,e)}function Q(n,t,e){this.h=n,this.s=t,this.l=e}function nt(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?i+(o-i)*n/60:180>n?o:240>n?i+(o-i)*(240-n)/60:i}function u(n){return Math.round(255*r(n))}var i,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,i=2*e-o,gt(u(n+120),u(n),u(n-120))}function tt(n,t,e){return new et(n,t,e)}function et(n,t,e){this.h=n,this.c=t,this.l=e}function rt(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),ut(e,Math.cos(n*=Na)*t,Math.sin(n)*t)}function ut(n,t,e){return new it(n,t,e)}function it(n,t,e){this.l=n,this.a=t,this.b=e}function ot(n,t,e){var r=(n+16)/116,u=r+t/500,i=r-e/200;return u=ct(u)*Fa,r=ct(r)*Oa,i=ct(i)*Ya,gt(lt(3.2404542*u-1.5371385*r-.4985314*i),lt(-.969266*u+1.8760108*r+.041556*i),lt(.0556434*u-.2040259*r+1.0572252*i))}function at(n,t,e){return n>0?tt(Math.atan2(e,t)*La,Math.sqrt(t*t+e*e),n):tt(0/0,0/0,n)}function ct(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function st(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function lt(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function ft(n){return gt(n>>16,255&n>>8,255&n)}function ht(n){return ft(n)+""}function gt(n,t,e){return new pt(n,t,e)}function pt(n,t,e){this.r=n,this.g=t,this.b=e}function vt(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function dt(n,t,e){var r,u,i,o,a=0,c=0,s=0;if(u=/([a-z]+)\((.*)\)/i.exec(n))switch(i=u[2].split(","),u[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Mt(i[0]),Mt(i[1]),Mt(i[2]))}return(o=Va.get(n))?t(o.r,o.g,o.b):(null!=n&&"#"===n.charAt(0)&&(r=parseInt(n.substring(1),16),isNaN(r)||(4===n.length?(a=(3840&r)>>4,a=a>>4|a,c=240&r,c=c>>4|c,s=15&r,s=s<<4|s):7===n.length&&(a=(16711680&r)>>16,c=(65280&r)>>8,s=255&r))),t(a,c,s))}function mt(n,t,e){var r,u,i=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-i,c=(o+i)/2;return a?(u=.5>c?a/(o+i):a/(2-o-i),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=0/0,u=c>0&&1>c?0:r),K(r,u,c)}function yt(n,t,e){n=xt(n),t=xt(t),e=xt(e);var r=st((.4124564*n+.3575761*t+.1804375*e)/Fa),u=st((.2126729*n+.7151522*t+.072175*e)/Oa),i=st((.0193339*n+.119192*t+.9503041*e)/Ya);return ut(116*u-16,500*(r-u),200*(u-i))}function xt(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Mt(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function _t(n){return"function"==typeof n?n:function(){return n}}function bt(n){return n}function wt(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),St(t,e,n,r)}}function St(n,t,e,r){function u(){var n,t=c.status;if(!t&&c.responseText||t>=200&&300>t||304===t){try{n=e.call(i,c)}catch(r){return o.error.call(i,r),void 0}o.load.call(i,n)}else o.error.call(i,c)}var i={},o=Xo.dispatch("beforesend","progress","load","error"),a={},c=new XMLHttpRequest,s=null;return!Go.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(n)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=u:c.onreadystatechange=function(){c.readyState>3&&u()},c.onprogress=function(n){var t=Xo.event;Xo.event=n;try{o.progress.call(i,c)}finally{Xo.event=t}},i.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",i)},i.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",i):t},i.responseType=function(n){return arguments.length?(s=n,i):s},i.response=function(n){return e=n,i},["get","post"].forEach(function(n){i[n]=function(){return i.send.apply(i,[n].concat(Bo(arguments)))}}),i.send=function(e,r,u){if(2===arguments.length&&"function"==typeof r&&(u=r,r=null),c.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),c.setRequestHeader)for(var l in a)c.setRequestHeader(l,a[l]);return null!=t&&c.overrideMimeType&&c.overrideMimeType(t),null!=s&&(c.responseType=s),null!=u&&i.on("error",u).on("load",function(n){u(null,n)}),o.beforesend.call(i,c),c.send(null==r?null:r),i},i.abort=function(){return c.abort(),i},Xo.rebind(i,o,"on"),null==r?i:i.get(kt(r))}function kt(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Et(){var n=At(),t=Ct()-n;t>24?(isFinite(t)&&(clearTimeout(Wa),Wa=setTimeout(Et,t)),Ba=0):(Ba=1,Ga(Et))}function At(){var n=Date.now();for(Ja=Xa;Ja;)n>=Ja.t&&(Ja.f=Ja.c(n-Ja.t)),Ja=Ja.n;return n}function Ct(){for(var n,t=Xa,e=1/0;t;)t.f?t=n?n.n=t.n:Xa=t.n:(t.t<e&&(e=t.t),t=(n=t).n);return $a=n,e}function Nt(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Lt(n,t){var e=Math.pow(10,3*oa(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function Tt(n){var t=n.decimal,e=n.thousands,r=n.grouping,u=n.currency,i=r?function(n){for(var t=n.length,u=[],i=0,o=r[0];t>0&&o>0;)u.push(n.substring(t-=o,t+o)),o=r[i=(i+1)%r.length];return u.reverse().join(e)}:bt;return function(n){var e=Qa.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"",c=e[4]||"",s=e[5],l=+e[6],f=e[7],h=e[8],g=e[9],p=1,v="",d="",m=!1;switch(h&&(h=+h.substring(1)),(s||"0"===r&&"="===o)&&(s=r="0",o="=",f&&(l-=Math.floor((l-1)/4))),g){case"n":f=!0,g="g";break;case"%":p=100,d="%",g="f";break;case"p":p=100,d="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(v="0"+g.toLowerCase());case"c":case"d":m=!0,h=0;break;case"s":p=-1,g="r"}"$"===c&&(v=u[0],d=u[1]),"r"!=g||h||(g="g"),null!=h&&("g"==g?h=Math.max(1,Math.min(21,h)):("e"==g||"f"==g)&&(h=Math.max(0,Math.min(20,h)))),g=nc.get(g)||qt;var y=s&&f;return function(n){var e=d;if(m&&n%1)return"";var u=0>n||0===n&&0>1/n?(n=-n,"-"):a;if(0>p){var c=Xo.formatPrefix(n,h);n=c.scale(n),e=c.symbol+d}else n*=p;n=g(n,h);var x=n.lastIndexOf("."),M=0>x?n:n.substring(0,x),_=0>x?"":t+n.substring(x+1);!s&&f&&(M=i(M));var b=v.length+M.length+_.length+(y?0:u.length),w=l>b?new Array(b=l-b+1).join(r):"";return y&&(M=i(w+M)),u+=v,n=M+_,("<"===o?u+n+w:">"===o?w+u+n:"^"===o?w.substring(0,b>>=1)+u+n+w.substring(b):u+(y?n:w+n))+e}}}function qt(n){return n+""}function zt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function Rt(n,t,e){function r(t){var e=n(t),r=i(e,1);return r-t>t-e?e:r}function u(e){return t(e=n(new ec(e-1)),1),e}function i(n,e){return t(n=new ec(+n),e),n}function o(n,r,i){var o=u(n),a=[];if(i>1)for(;r>o;)e(o)%i||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{ec=zt;var r=new zt;return r._=n,o(r,t,e)}finally{ec=Date}}n.floor=n,n.round=r,n.ceil=u,n.offset=i,n.range=o;var c=n.utc=Dt(n);return c.floor=c,c.round=Dt(r),c.ceil=Dt(u),c.offset=Dt(i),c.range=a,n}function Dt(n){return function(t,e){try{ec=zt;var r=new zt;return r._=t,n(r,e)._}finally{ec=Date}}}function Pt(n){function t(n){function t(t){for(var e,u,i,o=[],a=-1,c=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.substring(c,a)),null!=(u=uc[e=n.charAt(++a)])&&(e=n.charAt(++a)),(i=C[e])&&(e=i(t,null==u?"e"===e?" ":"0":u)),o.push(e),c=a+1);return o.push(n.substring(c,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},u=e(r,n,t,0);if(u!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var i=null!=r.Z&&ec!==zt,o=new(i?zt:ec);return"j"in r?o.setFullYear(r.y,0,r.j):"w"in r&&("W"in r||"U"in r)?(o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+Math.floor(r.Z/100),r.M+r.Z%100,r.S,r.L),i?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var u,i,o,a=0,c=t.length,s=e.length;c>a;){if(r>=s)return-1;if(u=t.charCodeAt(a++),37===u){if(o=t.charAt(a++),i=N[o in uc?t.charAt(a++):o],!i||(r=i(n,e,r))<0)return-1}else if(u!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){b.lastIndex=0;var r=b.exec(t.substring(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){M.lastIndex=0;var r=M.exec(t.substring(e));return r?(n.w=_.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){E.lastIndex=0;var r=E.exec(t.substring(e));return r?(n.m=A.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.substring(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,C.c.toString(),t,r)}function c(n,t,r){return e(n,C.x.toString(),t,r)}function s(n,t,r){return e(n,C.X.toString(),t,r)}function l(n,t,e){var r=x.get(t.substring(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var f=n.dateTime,h=n.date,g=n.time,p=n.periods,v=n.days,d=n.shortDays,m=n.months,y=n.shortMonths;t.utc=function(n){function e(n){try{ec=zt;var t=new ec;return t._=n,r(t)}finally{ec=Date}}var r=t(n);return e.parse=function(n){try{ec=zt;var t=r.parse(n);return t&&t._}finally{ec=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ee;var x=Xo.map(),M=jt(v),_=Ht(v),b=jt(d),w=Ht(d),S=jt(m),k=Ht(m),E=jt(y),A=Ht(y);p.forEach(function(n,t){x.set(n.toLowerCase(),t)});var C={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return y[n.getMonth()]},B:function(n){return m[n.getMonth()]},c:t(f),d:function(n,t){return Ut(n.getDate(),t,2)},e:function(n,t){return Ut(n.getDate(),t,2)},H:function(n,t){return Ut(n.getHours(),t,2)},I:function(n,t){return Ut(n.getHours()%12||12,t,2)},j:function(n,t){return Ut(1+tc.dayOfYear(n),t,3)},L:function(n,t){return Ut(n.getMilliseconds(),t,3)},m:function(n,t){return Ut(n.getMonth()+1,t,2)},M:function(n,t){return Ut(n.getMinutes(),t,2)},p:function(n){return p[+(n.getHours()>=12)]},S:function(n,t){return Ut(n.getSeconds(),t,2)},U:function(n,t){return Ut(tc.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Ut(tc.mondayOfYear(n),t,2)},x:t(h),X:t(g),y:function(n,t){return Ut(n.getFullYear()%100,t,2)},Y:function(n,t){return Ut(n.getFullYear()%1e4,t,4)},Z:ne,"%":function(){return"%"}},N={a:r,A:u,b:i,B:o,c:a,d:Bt,e:Bt,H:Jt,I:Jt,j:Wt,L:Qt,m:$t,M:Gt,p:l,S:Kt,U:Ot,w:Ft,W:Yt,x:c,X:s,y:Zt,Y:It,Z:Vt,"%":te};return t}function Ut(n,t,e){var r=0>n?"-":"",u=(r?-n:n)+"",i=u.length;return r+(e>i?new Array(e-i+1).join(t)+u:u)}function jt(n){return new RegExp("^(?:"+n.map(Xo.requote).join("|")+")","i")}function Ht(n){for(var t=new u,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Ft(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Ot(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.U=+r[0],e+r[0].length):-1}function Yt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e));return r?(n.W=+r[0],e+r[0].length):-1}function It(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Zt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.y=Xt(+r[0]),e+r[0].length):-1}function Vt(n,t,e){return/^[+-]\d{4}$/.test(t=t.substring(e,e+5))?(n.Z=+t,e+5):-1}function Xt(n){return n+(n>68?1900:2e3)}function $t(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Bt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function Wt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function Jt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function Gt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function Kt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function Qt(n,t,e){ic.lastIndex=0;var r=ic.exec(t.substring(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ne(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=~~(oa(t)/60),u=oa(t)%60;return e+Ut(r,"0",2)+Ut(u,"0",2)}function te(n,t,e){oc.lastIndex=0;var r=oc.exec(t.substring(e,e+1));return r?e+r[0].length:-1}function ee(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function re(){}function ue(n,t,e){var r=e.s=n+t,u=r-n,i=r-u;e.t=n-i+(t-u)}function ie(n,t){n&&lc.hasOwnProperty(n.type)&&lc[n.type](n,t)}function oe(n,t,e){var r,u=-1,i=n.length-e;for(t.lineStart();++u<i;)r=n[u],t.point(r[0],r[1],r[2]);t.lineEnd()}function ae(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)oe(n[e],t,1);t.polygonEnd()}function ce(){function n(n,t){n*=Na,t=t*Na/2+Sa/4;var e=n-r,o=e>=0?1:-1,a=o*e,c=Math.cos(t),s=Math.sin(t),l=i*s,f=u*c+l*Math.cos(a),h=l*o*Math.sin(a);hc.add(Math.atan2(h,f)),r=n,u=c,i=s}var t,e,r,u,i;gc.point=function(o,a){gc.point=n,r=(t=o)*Na,u=Math.cos(a=(e=a)*Na/2+Sa/4),i=Math.sin(a)},gc.lineEnd=function(){n(t,e)}}function se(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function le(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function fe(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function he(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function ge(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function pe(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function ve(n){return[Math.atan2(n[1],n[0]),X(n[2])]}function de(n,t){return oa(n[0]-t[0])<Aa&&oa(n[1]-t[1])<Aa}function me(n,t){n*=Na;var e=Math.cos(t*=Na);ye(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function ye(n,t,e){++pc,dc+=(n-dc)/pc,mc+=(t-mc)/pc,yc+=(e-yc)/pc}function xe(){function n(n,u){n*=Na;var i=Math.cos(u*=Na),o=i*Math.cos(n),a=i*Math.sin(n),c=Math.sin(u),s=Math.atan2(Math.sqrt((s=e*c-r*a)*s+(s=r*o-t*c)*s+(s=t*a-e*o)*s),t*o+e*a+r*c);vc+=s,xc+=s*(t+(t=o)),Mc+=s*(e+(e=a)),_c+=s*(r+(r=c)),ye(t,e,r)}var t,e,r;kc.point=function(u,i){u*=Na;var o=Math.cos(i*=Na);t=o*Math.cos(u),e=o*Math.sin(u),r=Math.sin(i),kc.point=n,ye(t,e,r)}}function Me(){kc.point=me}function _e(){function n(n,t){n*=Na;var e=Math.cos(t*=Na),o=e*Math.cos(n),a=e*Math.sin(n),c=Math.sin(t),s=u*c-i*a,l=i*o-r*c,f=r*a-u*o,h=Math.sqrt(s*s+l*l+f*f),g=r*o+u*a+i*c,p=h&&-V(g)/h,v=Math.atan2(h,g);bc+=p*s,wc+=p*l,Sc+=p*f,vc+=v,xc+=v*(r+(r=o)),Mc+=v*(u+(u=a)),_c+=v*(i+(i=c)),ye(r,u,i)}var t,e,r,u,i;kc.point=function(o,a){t=o,e=a,kc.point=n,o*=Na;var c=Math.cos(a*=Na);r=c*Math.cos(o),u=c*Math.sin(o),i=Math.sin(a),ye(r,u,i)},kc.lineEnd=function(){n(t,e),kc.lineEnd=Me,kc.point=me}}function be(){return!0}function we(n,t,e,r,u){var i=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(de(e,r)){u.lineStart();for(var a=0;t>a;++a)u.point((e=n[a])[0],e[1]);return u.lineEnd(),void 0}var c=new ke(e,n,null,!0),s=new ke(e,null,c,!1);c.o=s,i.push(c),o.push(s),c=new ke(r,n,null,!1),s=new ke(r,null,c,!0),c.o=s,i.push(c),o.push(s)}}),o.sort(t),Se(i),Se(o),i.length){for(var a=0,c=e,s=o.length;s>a;++a)o[a].e=c=!c;for(var l,f,h=i[0];;){for(var g=h,p=!0;g.v;)if((g=g.n)===h)return;l=g.z,u.lineStart();do{if(g.v=g.o.v=!0,g.e){if(p)for(var a=0,s=l.length;s>a;++a)u.point((f=l[a])[0],f[1]);else r(g.x,g.n.x,1,u);g=g.n}else{if(p){l=g.p.z;for(var a=l.length-1;a>=0;--a)u.point((f=l[a])[0],f[1])}else r(g.x,g.p.x,-1,u);g=g.p}g=g.o,l=g.z,p=!p}while(!g.v);u.lineEnd()}}}function Se(n){if(t=n.length){for(var t,e,r=0,u=n[0];++r<t;)u.n=e=n[r],e.p=u,u=e;u.n=e=n[0],e.p=u}}function ke(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Ee(n,t,e,r){return function(u,i){function o(t,e){var r=u(t,e);n(t=r[0],e=r[1])&&i.point(t,e)}function a(n,t){var e=u(n,t);d.point(e[0],e[1])}function c(){y.point=a,d.lineStart()}function s(){y.point=o,d.lineEnd()}function l(n,t){v.push([n,t]);var e=u(n,t);M.point(e[0],e[1])}function f(){M.lineStart(),v=[]}function h(){l(v[0][0],v[0][1]),M.lineEnd();var n,t=M.clean(),e=x.buffer(),r=e.length;if(v.pop(),p.push(v),v=null,r){if(1&t){n=e[0];var u,r=n.length-1,o=-1;for(i.lineStart();++o<r;)i.point((u=n[o])[0],u[1]);return i.lineEnd(),void 0}r>1&&2&t&&e.push(e.pop().concat(e.shift())),g.push(e.filter(Ae))}}var g,p,v,d=t(i),m=u.invert(r[0],r[1]),y={point:o,lineStart:c,lineEnd:s,polygonStart:function(){y.point=l,y.lineStart=f,y.lineEnd=h,g=[],p=[],i.polygonStart()},polygonEnd:function(){y.point=o,y.lineStart=c,y.lineEnd=s,g=Xo.merge(g);var n=Le(m,p);g.length?we(g,Ne,n,e,i):n&&(i.lineStart(),e(null,null,1,i),i.lineEnd()),i.polygonEnd(),g=p=null},sphere:function(){i.polygonStart(),i.lineStart(),e(null,null,1,i),i.lineEnd(),i.polygonEnd()}},x=Ce(),M=t(x);return y}}function Ae(n){return n.length>1}function Ce(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:g,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ne(n,t){return((n=n.x)[0]<0?n[1]-Ea-Aa:Ea-n[1])-((t=t.x)[0]<0?t[1]-Ea-Aa:Ea-t[1])}function Le(n,t){var e=n[0],r=n[1],u=[Math.sin(e),-Math.cos(e),0],i=0,o=0;hc.reset();for(var a=0,c=t.length;c>a;++a){var s=t[a],l=s.length;if(l)for(var f=s[0],h=f[0],g=f[1]/2+Sa/4,p=Math.sin(g),v=Math.cos(g),d=1;;){d===l&&(d=0),n=s[d];var m=n[0],y=n[1]/2+Sa/4,x=Math.sin(y),M=Math.cos(y),_=m-h,b=_>=0?1:-1,w=b*_,S=w>Sa,k=p*x;if(hc.add(Math.atan2(k*b*Math.sin(w),v*M+k*Math.cos(w))),i+=S?_+b*ka:_,S^h>=e^m>=e){var E=fe(se(f),se(n));pe(E);var A=fe(u,E);pe(A);var C=(S^_>=0?-1:1)*X(A[2]);(r>C||r===C&&(E[0]||E[1]))&&(o+=S^_>=0?1:-1)}if(!d++)break;h=m,p=x,v=M,f=n}}return(-Aa>i||Aa>i&&0>hc)^1&o}function Te(n){var t,e=0/0,r=0/0,u=0/0;return{lineStart:function(){n.lineStart(),t=1},point:function(i,o){var a=i>0?Sa:-Sa,c=oa(i-e);oa(c-Sa)<Aa?(n.point(e,r=(r+o)/2>0?Ea:-Ea),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(i,r),t=0):u!==a&&c>=Sa&&(oa(e-u)<Aa&&(e-=u*Aa),oa(i-a)<Aa&&(i-=a*Aa),r=qe(e,r,i,o),n.point(u,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=i,r=o),u=a},lineEnd:function(){n.lineEnd(),e=r=0/0},clean:function(){return 2-t}}}function qe(n,t,e,r){var u,i,o=Math.sin(n-e);return oa(o)>Aa?Math.atan((Math.sin(t)*(i=Math.cos(r))*Math.sin(e)-Math.sin(r)*(u=Math.cos(t))*Math.sin(n))/(u*i*o)):(t+r)/2}function ze(n,t,e,r){var u;if(null==n)u=e*Ea,r.point(-Sa,u),r.point(0,u),r.point(Sa,u),r.point(Sa,0),r.point(Sa,-u),r.point(0,-u),r.point(-Sa,-u),r.point(-Sa,0),r.point(-Sa,u);else if(oa(n[0]-t[0])>Aa){var i=n[0]<t[0]?Sa:-Sa;u=e*i/2,r.point(-i,u),r.point(0,u),r.point(i,u)}else r.point(t[0],t[1])}function Re(n){function t(n,t){return Math.cos(n)*Math.cos(t)>i}function e(n){var e,i,c,s,l;return{lineStart:function(){s=c=!1,l=1},point:function(f,h){var g,p=[f,h],v=t(f,h),d=o?v?0:u(f,h):v?u(f+(0>f?Sa:-Sa),h):0;if(!e&&(s=c=v)&&n.lineStart(),v!==c&&(g=r(e,p),(de(e,g)||de(p,g))&&(p[0]+=Aa,p[1]+=Aa,v=t(p[0],p[1]))),v!==c)l=0,v?(n.lineStart(),g=r(p,e),n.point(g[0],g[1])):(g=r(e,p),n.point(g[0],g[1]),n.lineEnd()),e=g;else if(a&&e&&o^v){var m;d&i||!(m=r(p,e,!0))||(l=0,o?(n.lineStart(),n.point(m[0][0],m[0][1]),n.point(m[1][0],m[1][1]),n.lineEnd()):(n.point(m[1][0],m[1][1]),n.lineEnd(),n.lineStart(),n.point(m[0][0],m[0][1])))}!v||e&&de(e,p)||n.point(p[0],p[1]),e=p,c=v,i=d},lineEnd:function(){c&&n.lineEnd(),e=null},clean:function(){return l|(s&&c)<<1}}}function r(n,t,e){var r=se(n),u=se(t),o=[1,0,0],a=fe(r,u),c=le(a,a),s=a[0],l=c-s*s;if(!l)return!e&&n;var f=i*c/l,h=-i*s/l,g=fe(o,a),p=ge(o,f),v=ge(a,h);he(p,v);var d=g,m=le(p,d),y=le(d,d),x=m*m-y*(le(p,p)-1);if(!(0>x)){var M=Math.sqrt(x),_=ge(d,(-m-M)/y);if(he(_,p),_=ve(_),!e)return _;var b,w=n[0],S=t[0],k=n[1],E=t[1];w>S&&(b=w,w=S,S=b);var A=S-w,C=oa(A-Sa)<Aa,N=C||Aa>A;if(!C&&k>E&&(b=k,k=E,E=b),N?C?k+E>0^_[1]<(oa(_[0]-w)<Aa?k:E):k<=_[1]&&_[1]<=E:A>Sa^(w<=_[0]&&_[0]<=S)){var L=ge(d,(-m+M)/y);return he(L,p),[_,ve(L)]}}}function u(t,e){var r=o?n:Sa-n,u=0;return-r>t?u|=1:t>r&&(u|=2),-r>e?u|=4:e>r&&(u|=8),u}var i=Math.cos(n),o=i>0,a=oa(i)>Aa,c=cr(n,6*Na);return Ee(t,e,c,o?[0,-n]:[-Sa,n-Sa])}function De(n,t,e,r){return function(u){var i,o=u.a,a=u.b,c=o.x,s=o.y,l=a.x,f=a.y,h=0,g=1,p=l-c,v=f-s;if(i=n-c,p||!(i>0)){if(i/=p,0>p){if(h>i)return;g>i&&(g=i)}else if(p>0){if(i>g)return;i>h&&(h=i)}if(i=e-c,p||!(0>i)){if(i/=p,0>p){if(i>g)return;i>h&&(h=i)}else if(p>0){if(h>i)return;g>i&&(g=i)}if(i=t-s,v||!(i>0)){if(i/=v,0>v){if(h>i)return;g>i&&(g=i)}else if(v>0){if(i>g)return;i>h&&(h=i)}if(i=r-s,v||!(0>i)){if(i/=v,0>v){if(i>g)return;i>h&&(h=i)}else if(v>0){if(h>i)return;g>i&&(g=i)}return h>0&&(u.a={x:c+h*p,y:s+h*v}),1>g&&(u.b={x:c+g*p,y:s+g*v}),u}}}}}}function Pe(n,t,e,r){function u(r,u){return oa(r[0]-n)<Aa?u>0?0:3:oa(r[0]-e)<Aa?u>0?2:1:oa(r[1]-t)<Aa?u>0?1:0:u>0?3:2}function i(n,t){return o(n.x,t.x)}function o(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function c(n){for(var t=0,e=d.length,r=n[1],u=0;e>u;++u)for(var i,o=1,a=d[u],c=a.length,s=a[0];c>o;++o)i=a[o],s[1]<=r?i[1]>r&&Z(s,i,n)>0&&++t:i[1]<=r&&Z(s,i,n)<0&&--t,s=i;return 0!==t}function s(i,a,c,s){var l=0,f=0;if(null==i||(l=u(i,c))!==(f=u(a,c))||o(i,a)<0^c>0){do s.point(0===l||3===l?n:e,l>1?r:t);while((l=(l+c+4)%4)!==f)}else s.point(a[0],a[1])}function l(u,i){return u>=n&&e>=u&&i>=t&&r>=i}function f(n,t){l(n,t)&&a.point(n,t)}function h(){N.point=p,d&&d.push(m=[]),S=!0,w=!1,_=b=0/0}function g(){v&&(p(y,x),M&&w&&A.rejoin(),v.push(A.buffer())),N.point=f,w&&a.lineEnd()}function p(n,t){n=Math.max(-Ac,Math.min(Ac,n)),t=Math.max(-Ac,Math.min(Ac,t));var e=l(n,t);if(d&&m.push([n,t]),S)y=n,x=t,M=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:_,y:b},b:{x:n,y:t}};C(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}_=n,b=t,w=e}var v,d,m,y,x,M,_,b,w,S,k,E=a,A=Ce(),C=De(n,t,e,r),N={point:f,lineStart:h,lineEnd:g,polygonStart:function(){a=A,v=[],d=[],k=!0},polygonEnd:function(){a=E,v=Xo.merge(v);var t=c([n,r]),e=k&&t,u=v.length;(e||u)&&(a.polygonStart(),e&&(a.lineStart(),s(null,null,1,a),a.lineEnd()),u&&we(v,i,t,s,a),a.polygonEnd()),v=d=m=null}};return N}}function Ue(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function je(n){var t=0,e=Sa/3,r=nr(n),u=r(t,e);return u.parallels=function(n){return arguments.length?r(t=n[0]*Sa/180,e=n[1]*Sa/180):[180*(t/Sa),180*(e/Sa)]},u}function He(n,t){function e(n,t){var e=Math.sqrt(i-2*u*Math.sin(t))/u;return[e*Math.sin(n*=u),o-e*Math.cos(n)]}var r=Math.sin(n),u=(r+Math.sin(t))/2,i=1+r*(2*u-r),o=Math.sqrt(i)/u;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/u,X((i-(n*n+e*e)*u*u)/(2*u))]},e}function Fe(){function n(n,t){Nc+=u*n-r*t,r=n,u=t}var t,e,r,u;Rc.point=function(i,o){Rc.point=n,t=r=i,e=u=o},Rc.lineEnd=function(){n(t,e)}}function Oe(n,t){Lc>n&&(Lc=n),n>qc&&(qc=n),Tc>t&&(Tc=t),t>zc&&(zc=t)}function Ye(){function n(n,t){o.push("M",n,",",t,i)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function u(){o.push("Z")}var i=Ie(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return i=Ie(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Ie(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Ze(n,t){dc+=n,mc+=t,++yc}function Ve(){function n(n,r){var u=n-t,i=r-e,o=Math.sqrt(u*u+i*i);xc+=o*(t+n)/2,Mc+=o*(e+r)/2,_c+=o,Ze(t=n,e=r)}var t,e;Pc.point=function(r,u){Pc.point=n,Ze(t=r,e=u)}}function Xe(){Pc.point=Ze}function $e(){function n(n,t){var e=n-r,i=t-u,o=Math.sqrt(e*e+i*i);xc+=o*(r+n)/2,Mc+=o*(u+t)/2,_c+=o,o=u*n-r*t,bc+=o*(r+n),wc+=o*(u+t),Sc+=3*o,Ze(r=n,u=t)}var t,e,r,u;Pc.point=function(i,o){Pc.point=n,Ze(t=r=i,e=u=o)},Pc.lineEnd=function(){n(t,e)}}function Be(n){function t(t,e){n.moveTo(t,e),n.arc(t,e,o,0,ka)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function u(){a.point=t}function i(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:u,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=u,a.point=t},pointRadius:function(n){return o=n,a},result:g};return a}function We(n){function t(n){return(a?r:e)(n)}function e(t){return Ke(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){x=0/0,S.point=i,t.lineStart()}function i(e,r){var i=se([e,r]),o=n(e,r);u(x,M,y,_,b,w,x=o[0],M=o[1],y=e,_=i[0],b=i[1],w=i[2],a,t),t.point(x,M)}function o(){S.point=e,t.lineEnd()}function c(){r(),S.point=s,S.lineEnd=l}function s(n,t){i(f=n,h=t),g=x,p=M,v=_,d=b,m=w,S.point=i}function l(){u(x,M,y,_,b,w,g,p,f,v,d,m,a,t),S.lineEnd=o,o()}var f,h,g,p,v,d,m,y,x,M,_,b,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=c},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function u(t,e,r,a,c,s,l,f,h,g,p,v,d,m){var y=l-t,x=f-e,M=y*y+x*x;if(M>4*i&&d--){var _=a+g,b=c+p,w=s+v,S=Math.sqrt(_*_+b*b+w*w),k=Math.asin(w/=S),E=oa(oa(w)-1)<Aa||oa(r-h)<Aa?(r+h)/2:Math.atan2(b,_),A=n(E,k),C=A[0],N=A[1],L=C-t,T=N-e,q=x*L-y*T;(q*q/M>i||oa((y*L+x*T)/M-.5)>.3||o>a*g+c*p+s*v)&&(u(t,e,r,a,c,s,C,N,E,_/=S,b/=S,w,d,m),m.point(C,N),u(C,N,E,_,b,w,l,f,h,g,p,v,d,m))}}var i=.5,o=Math.cos(30*Na),a=16;return t.precision=function(n){return arguments.length?(a=(i=n*n)>0&&16,t):Math.sqrt(i)},t}function Je(n){var t=We(function(t,e){return n([t*La,e*La])});return function(n){return tr(t(n))}}function Ge(n){this.stream=n}function Ke(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function Qe(n){return nr(function(){return n})()}function nr(n){function t(n){return n=a(n[0]*Na,n[1]*Na),[n[0]*h+c,s-n[1]*h]}function e(n){return n=a.invert((n[0]-c)/h,(s-n[1])/h),n&&[n[0]*La,n[1]*La]}function r(){a=Ue(o=ur(m,y,x),i);var n=i(v,d);return c=g-n[0]*h,s=p+n[1]*h,u()}function u(){return l&&(l.valid=!1,l=null),t}var i,o,a,c,s,l,f=We(function(n,t){return n=i(n,t),[n[0]*h+c,s-n[1]*h]}),h=150,g=480,p=250,v=0,d=0,m=0,y=0,x=0,M=Ec,_=bt,b=null,w=null;return t.stream=function(n){return l&&(l.valid=!1),l=tr(M(o,f(_(n)))),l.valid=!0,l},t.clipAngle=function(n){return arguments.length?(M=null==n?(b=n,Ec):Re((b=+n)*Na),u()):b
},t.clipExtent=function(n){return arguments.length?(w=n,_=n?Pe(n[0][0],n[0][1],n[1][0],n[1][1]):bt,u()):w},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(g=+n[0],p=+n[1],r()):[g,p]},t.center=function(n){return arguments.length?(v=n[0]%360*Na,d=n[1]%360*Na,r()):[v*La,d*La]},t.rotate=function(n){return arguments.length?(m=n[0]%360*Na,y=n[1]%360*Na,x=n.length>2?n[2]%360*Na:0,r()):[m*La,y*La,x*La]},Xo.rebind(t,f,"precision"),function(){return i=n.apply(this,arguments),t.invert=i.invert&&e,r()}}function tr(n){return Ke(n,function(t,e){n.point(t*Na,e*Na)})}function er(n,t){return[n,t]}function rr(n,t){return[n>Sa?n-ka:-Sa>n?n+ka:n,t]}function ur(n,t,e){return n?t||e?Ue(or(n),ar(t,e)):or(n):t||e?ar(t,e):rr}function ir(n){return function(t,e){return t+=n,[t>Sa?t-ka:-Sa>t?t+ka:t,e]}}function or(n){var t=ir(n);return t.invert=ir(-n),t}function ar(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*r+a*u;return[Math.atan2(c*i-l*o,a*r-s*u),X(l*i+c*o)]}var r=Math.cos(n),u=Math.sin(n),i=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,c=Math.sin(n)*e,s=Math.sin(t),l=s*i-c*o;return[Math.atan2(c*i+s*o,a*r+l*u),X(l*r-a*u)]},e}function cr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(u,i,o,a){var c=o*t;null!=u?(u=sr(e,u),i=sr(e,i),(o>0?i>u:u>i)&&(u+=o*ka)):(u=n+o*ka,i=n-.5*c);for(var s,l=u;o>0?l>i:i>l;l-=c)a.point((s=ve([e,-r*Math.cos(l),-r*Math.sin(l)]))[0],s[1])}}function sr(n,t){var e=se(t);e[0]-=n,pe(e);var r=V(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Aa)%(2*Math.PI)}function lr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function fr(n,t,e){var r=Xo.range(n,t-Aa,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function hr(n){return n.source}function gr(n){return n.target}function pr(n,t,e,r){var u=Math.cos(t),i=Math.sin(t),o=Math.cos(r),a=Math.sin(r),c=u*Math.cos(n),s=u*Math.sin(n),l=o*Math.cos(e),f=o*Math.sin(e),h=2*Math.asin(Math.sqrt(J(r-t)+u*o*J(e-n))),g=1/Math.sin(h),p=h?function(n){var t=Math.sin(n*=h)*g,e=Math.sin(h-n)*g,r=e*c+t*l,u=e*s+t*f,o=e*i+t*a;return[Math.atan2(u,r)*La,Math.atan2(o,Math.sqrt(r*r+u*u))*La]}:function(){return[n*La,t*La]};return p.distance=h,p}function vr(){function n(n,u){var i=Math.sin(u*=Na),o=Math.cos(u),a=oa((n*=Na)-t),c=Math.cos(a);Uc+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*i-e*o*c)*a),e*i+r*o*c),t=n,e=i,r=o}var t,e,r;jc.point=function(u,i){t=u*Na,e=Math.sin(i*=Na),r=Math.cos(i),jc.point=n},jc.lineEnd=function(){jc.point=jc.lineEnd=g}}function dr(n,t){function e(t,e){var r=Math.cos(t),u=Math.cos(e),i=n(r*u);return[i*u*Math.sin(t),i*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),u=t(r),i=Math.sin(u),o=Math.cos(u);return[Math.atan2(n*i,r*o),Math.asin(r&&e*i/r)]},e}function mr(n,t){function e(n,t){var e=oa(oa(t)-Ea)<Aa?0:o/Math.pow(u(t),i);return[e*Math.sin(i*n),o-e*Math.cos(i*n)]}var r=Math.cos(n),u=function(n){return Math.tan(Sa/4+n/2)},i=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(u(t)/u(n)),o=r*Math.pow(u(n),i)/i;return i?(e.invert=function(n,t){var e=o-t,r=I(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(o/r,1/i))-Ea]},e):xr}function yr(n,t){function e(n,t){var e=i-t;return[e*Math.sin(u*n),i-e*Math.cos(u*n)]}var r=Math.cos(n),u=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),i=r/u+n;return oa(u)<Aa?er:(e.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/u,i-I(u)*Math.sqrt(n*n+e*e)]},e)}function xr(n,t){return[n,Math.log(Math.tan(Sa/4+t/2))]}function Mr(n){var t,e=Qe(n),r=e.scale,u=e.translate,i=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=u.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=i.apply(e,arguments);if(o===e){if(t=null==n){var a=Sa*r(),c=u();i([[c[0]-a,c[1]-a],[c[0]+a,c[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function _r(n,t){return[Math.log(Math.tan(Sa/4+t/2)),-n]}function br(n){return n[0]}function wr(n){return n[1]}function Sr(n){for(var t=n.length,e=[0,1],r=2,u=2;t>u;u++){for(;r>1&&Z(n[e[r-2]],n[e[r-1]],n[u])<=0;)--r;e[r++]=u}return e.slice(0,r)}function kr(n,t){return n[0]-t[0]||n[1]-t[1]}function Er(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Ar(n,t,e,r){var u=n[0],i=e[0],o=t[0]-u,a=r[0]-i,c=n[1],s=e[1],l=t[1]-c,f=r[1]-s,h=(a*(c-s)-f*(u-i))/(f*o-a*l);return[u+h*o,c+h*l]}function Cr(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Nr(){Jr(this),this.edge=this.site=this.circle=null}function Lr(n){var t=Jc.pop()||new Nr;return t.site=n,t}function Tr(n){Or(n),$c.remove(n),Jc.push(n),Jr(n)}function qr(n){var t=n.circle,e=t.x,r=t.cy,u={x:e,y:r},i=n.P,o=n.N,a=[n];Tr(n);for(var c=i;c.circle&&oa(e-c.circle.x)<Aa&&oa(r-c.circle.cy)<Aa;)i=c.P,a.unshift(c),Tr(c),c=i;a.unshift(c),Or(c);for(var s=o;s.circle&&oa(e-s.circle.x)<Aa&&oa(r-s.circle.cy)<Aa;)o=s.N,a.push(s),Tr(s),s=o;a.push(s),Or(s);var l,f=a.length;for(l=1;f>l;++l)s=a[l],c=a[l-1],$r(s.edge,c.site,s.site,u);c=a[0],s=a[f-1],s.edge=Vr(c.site,s.site,null,u),Fr(c),Fr(s)}function zr(n){for(var t,e,r,u,i=n.x,o=n.y,a=$c._;a;)if(r=Rr(a,o)-i,r>Aa)a=a.L;else{if(u=i-Dr(a,o),!(u>Aa)){r>-Aa?(t=a.P,e=a):u>-Aa?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var c=Lr(n);if($c.insert(t,c),t||e){if(t===e)return Or(t),e=Lr(t.site),$c.insert(c,e),c.edge=e.edge=Vr(t.site,c.site),Fr(t),Fr(e),void 0;if(!e)return c.edge=Vr(t.site,c.site),void 0;Or(t),Or(e);var s=t.site,l=s.x,f=s.y,h=n.x-l,g=n.y-f,p=e.site,v=p.x-l,d=p.y-f,m=2*(h*d-g*v),y=h*h+g*g,x=v*v+d*d,M={x:(d*y-g*x)/m+l,y:(h*x-v*y)/m+f};$r(e.edge,s,p,M),c.edge=Vr(s,n,null,M),e.edge=Vr(n,p,null,M),Fr(t),Fr(e)}}function Rr(n,t){var e=n.site,r=e.x,u=e.y,i=u-t;if(!i)return r;var o=n.P;if(!o)return-1/0;e=o.site;var a=e.x,c=e.y,s=c-t;if(!s)return a;var l=a-r,f=1/i-1/s,h=l/s;return f?(-h+Math.sqrt(h*h-2*f*(l*l/(-2*s)-c+s/2+u-i/2)))/f+r:(r+a)/2}function Dr(n,t){var e=n.N;if(e)return Rr(e,t);var r=n.site;return r.y===t?r.x:1/0}function Pr(n){this.site=n,this.edges=[]}function Ur(n){for(var t,e,r,u,i,o,a,c,s,l,f=n[0][0],h=n[1][0],g=n[0][1],p=n[1][1],v=Xc,d=v.length;d--;)if(i=v[d],i&&i.prepare())for(a=i.edges,c=a.length,o=0;c>o;)l=a[o].end(),r=l.x,u=l.y,s=a[++o%c].start(),t=s.x,e=s.y,(oa(r-t)>Aa||oa(u-e)>Aa)&&(a.splice(o,0,new Br(Xr(i.site,l,oa(r-f)<Aa&&p-u>Aa?{x:f,y:oa(t-f)<Aa?e:p}:oa(u-p)<Aa&&h-r>Aa?{x:oa(e-p)<Aa?t:h,y:p}:oa(r-h)<Aa&&u-g>Aa?{x:h,y:oa(t-h)<Aa?e:g}:oa(u-g)<Aa&&r-f>Aa?{x:oa(e-g)<Aa?t:f,y:g}:null),i.site,null)),++c)}function jr(n,t){return t.angle-n.angle}function Hr(){Jr(this),this.x=this.y=this.arc=this.site=this.cy=null}function Fr(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,u=n.site,i=e.site;if(r!==i){var o=u.x,a=u.y,c=r.x-o,s=r.y-a,l=i.x-o,f=i.y-a,h=2*(c*f-s*l);if(!(h>=-Ca)){var g=c*c+s*s,p=l*l+f*f,v=(f*g-s*p)/h,d=(c*p-l*g)/h,f=d+a,m=Gc.pop()||new Hr;m.arc=n,m.site=u,m.x=v+o,m.y=f+Math.sqrt(v*v+d*d),m.cy=f,n.circle=m;for(var y=null,x=Wc._;x;)if(m.y<x.y||m.y===x.y&&m.x<=x.x){if(!x.L){y=x.P;break}x=x.L}else{if(!x.R){y=x;break}x=x.R}Wc.insert(y,m),y||(Bc=m)}}}}function Or(n){var t=n.circle;t&&(t.P||(Bc=t.N),Wc.remove(t),Gc.push(t),Jr(t),n.circle=null)}function Yr(n){for(var t,e=Vc,r=De(n[0][0],n[0][1],n[1][0],n[1][1]),u=e.length;u--;)t=e[u],(!Ir(t,n)||!r(t)||oa(t.a.x-t.b.x)<Aa&&oa(t.a.y-t.b.y)<Aa)&&(t.a=t.b=null,e.splice(u,1))}function Ir(n,t){var e=n.b;if(e)return!0;var r,u,i=n.a,o=t[0][0],a=t[1][0],c=t[0][1],s=t[1][1],l=n.l,f=n.r,h=l.x,g=l.y,p=f.x,v=f.y,d=(h+p)/2,m=(g+v)/2;if(v===g){if(o>d||d>=a)return;if(h>p){if(i){if(i.y>=s)return}else i={x:d,y:c};e={x:d,y:s}}else{if(i){if(i.y<c)return}else i={x:d,y:s};e={x:d,y:c}}}else if(r=(h-p)/(v-g),u=m-r*d,-1>r||r>1)if(h>p){if(i){if(i.y>=s)return}else i={x:(c-u)/r,y:c};e={x:(s-u)/r,y:s}}else{if(i){if(i.y<c)return}else i={x:(s-u)/r,y:s};e={x:(c-u)/r,y:c}}else if(v>g){if(i){if(i.x>=a)return}else i={x:o,y:r*o+u};e={x:a,y:r*a+u}}else{if(i){if(i.x<o)return}else i={x:a,y:r*a+u};e={x:o,y:r*o+u}}return n.a=i,n.b=e,!0}function Zr(n,t){this.l=n,this.r=t,this.a=this.b=null}function Vr(n,t,e,r){var u=new Zr(n,t);return Vc.push(u),e&&$r(u,n,t,e),r&&$r(u,t,n,r),Xc[n.i].edges.push(new Br(u,n,t)),Xc[t.i].edges.push(new Br(u,t,n)),u}function Xr(n,t,e){var r=new Zr(n,null);return r.a=t,r.b=e,Vc.push(r),r}function $r(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Br(n,t,e){var r=n.a,u=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(u.x-r.x,r.y-u.y):Math.atan2(r.x-u.x,u.y-r.y)}function Wr(){this._=null}function Jr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function Gr(n,t){var e=t,r=t.R,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Kr(n,t){var e=t,r=t.L,u=e.U;u?u.L===e?u.L=r:u.R=r:n._=r,r.U=u,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function Qr(n){for(;n.L;)n=n.L;return n}function nu(n,t){var e,r,u,i=n.sort(tu).pop();for(Vc=[],Xc=new Array(n.length),$c=new Wr,Wc=new Wr;;)if(u=Bc,i&&(!u||i.y<u.y||i.y===u.y&&i.x<u.x))(i.x!==e||i.y!==r)&&(Xc[i.i]=new Pr(i),zr(i),e=i.x,r=i.y),i=n.pop();else{if(!u)break;qr(u.arc)}t&&(Yr(t),Ur(t));var o={cells:Xc,edges:Vc};return $c=Wc=Vc=Xc=null,o}function tu(n,t){return t.y-n.y||t.x-n.x}function eu(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function ru(n){return n.x}function uu(n){return n.y}function iu(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function ou(n,t,e,r,u,i){if(!n(t,e,r,u,i)){var o=.5*(e+u),a=.5*(r+i),c=t.nodes;c[0]&&ou(n,c[0],e,r,o,a),c[1]&&ou(n,c[1],o,r,u,a),c[2]&&ou(n,c[2],e,a,o,i),c[3]&&ou(n,c[3],o,a,u,i)}}function au(n,t){n=Xo.rgb(n),t=Xo.rgb(t);var e=n.r,r=n.g,u=n.b,i=t.r-e,o=t.g-r,a=t.b-u;return function(n){return"#"+vt(Math.round(e+i*n))+vt(Math.round(r+o*n))+vt(Math.round(u+a*n))}}function cu(n,t){var e,r={},u={};for(e in n)e in t?r[e]=fu(n[e],t[e]):u[e]=n[e];for(e in t)e in n||(u[e]=t[e]);return function(n){for(e in r)u[e]=r[e](n);return u}}function su(n,t){return t-=n=+n,function(e){return n+t*e}}function lu(n,t){var e,r,u,i,o,a=0,c=0,s=[],l=[];for(n+="",t+="",Qc.lastIndex=0,r=0;e=Qc.exec(t);++r)e.index&&s.push(t.substring(a,c=e.index)),l.push({i:s.length,x:e[0]}),s.push(null),a=Qc.lastIndex;for(a<t.length&&s.push(t.substring(a)),r=0,i=l.length;(e=Qc.exec(n))&&i>r;++r)if(o=l[r],o.x==e[0]){if(o.i)if(null==s[o.i+1])for(s[o.i-1]+=o.x,s.splice(o.i,1),u=r+1;i>u;++u)l[u].i--;else for(s[o.i-1]+=o.x+s[o.i+1],s.splice(o.i,2),u=r+1;i>u;++u)l[u].i-=2;else if(null==s[o.i+1])s[o.i]=o.x;else for(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1),u=r+1;i>u;++u)l[u].i--;l.splice(r,1),i--,r--}else o.x=su(parseFloat(e[0]),parseFloat(o.x));for(;i>r;)o=l.pop(),null==s[o.i+1]?s[o.i]=o.x:(s[o.i]=o.x+s[o.i+1],s.splice(o.i+1,1)),i--;return 1===s.length?null==s[0]?(o=l[0].x,function(n){return o(n)+""}):function(){return t}:function(n){for(r=0;i>r;++r)s[(o=l[r]).i]=o.x(n);return s.join("")}}function fu(n,t){for(var e,r=Xo.interpolators.length;--r>=0&&!(e=Xo.interpolators[r](n,t)););return e}function hu(n,t){var e,r=[],u=[],i=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(fu(n[e],t[e]));for(;i>e;++e)u[e]=n[e];for(;o>e;++e)u[e]=t[e];return function(n){for(e=0;a>e;++e)u[e]=r[e](n);return u}}function gu(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function pu(n){return function(t){return 1-n(1-t)}}function vu(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function du(n){return n*n}function mu(n){return n*n*n}function yu(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function xu(n){return function(t){return Math.pow(t,n)}}function Mu(n){return 1-Math.cos(n*Ea)}function _u(n){return Math.pow(2,10*(n-1))}function bu(n){return 1-Math.sqrt(1-n*n)}function wu(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/ka*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*ka/t)}}function Su(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function ku(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Eu(n,t){n=Xo.hcl(n),t=Xo.hcl(t);var e=n.h,r=n.c,u=n.l,i=t.h-e,o=t.c-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return rt(e+i*n,r+o*n,u+a*n)+""}}function Au(n,t){n=Xo.hsl(n),t=Xo.hsl(t);var e=n.h,r=n.s,u=n.l,i=t.h-e,o=t.s-r,a=t.l-u;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(i)?(i=0,e=isNaN(e)?t.h:e):i>180?i-=360:-180>i&&(i+=360),function(n){return nt(e+i*n,r+o*n,u+a*n)+""}}function Cu(n,t){n=Xo.lab(n),t=Xo.lab(t);var e=n.l,r=n.a,u=n.b,i=t.l-e,o=t.a-r,a=t.b-u;return function(n){return ot(e+i*n,r+o*n,u+a*n)+""}}function Nu(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function Lu(n){var t=[n.a,n.b],e=[n.c,n.d],r=qu(t),u=Tu(t,e),i=qu(zu(e,t,-u))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,u*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*La,this.translate=[n.e,n.f],this.scale=[r,i],this.skew=i?Math.atan2(u,i)*La:0}function Tu(n,t){return n[0]*t[0]+n[1]*t[1]}function qu(n){var t=Math.sqrt(Tu(n,n));return t&&(n[0]/=t,n[1]/=t),t}function zu(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ru(n,t){var e,r=[],u=[],i=Xo.transform(n),o=Xo.transform(t),a=i.translate,c=o.translate,s=i.rotate,l=o.rotate,f=i.skew,h=o.skew,g=i.scale,p=o.scale;return a[0]!=c[0]||a[1]!=c[1]?(r.push("translate(",null,",",null,")"),u.push({i:1,x:su(a[0],c[0])},{i:3,x:su(a[1],c[1])})):c[0]||c[1]?r.push("translate("+c+")"):r.push(""),s!=l?(s-l>180?l+=360:l-s>180&&(s+=360),u.push({i:r.push(r.pop()+"rotate(",null,")")-2,x:su(s,l)})):l&&r.push(r.pop()+"rotate("+l+")"),f!=h?u.push({i:r.push(r.pop()+"skewX(",null,")")-2,x:su(f,h)}):h&&r.push(r.pop()+"skewX("+h+")"),g[0]!=p[0]||g[1]!=p[1]?(e=r.push(r.pop()+"scale(",null,",",null,")"),u.push({i:e-4,x:su(g[0],p[0])},{i:e-2,x:su(g[1],p[1])})):(1!=p[0]||1!=p[1])&&r.push(r.pop()+"scale("+p+")"),e=u.length,function(n){for(var t,i=-1;++i<e;)r[(t=u[i]).i]=t.x(n);return r.join("")}}function Du(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return(e-n)*t}}function Pu(n,t){return t=t-(n=+n)?1/(t-n):0,function(e){return Math.max(0,Math.min(1,(e-n)*t))}}function Uu(n){for(var t=n.source,e=n.target,r=Hu(t,e),u=[t];t!==r;)t=t.parent,u.push(t);for(var i=u.length;e!==r;)u.splice(i,0,e),e=e.parent;return u}function ju(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Hu(n,t){if(n===t)return n;for(var e=ju(n),r=ju(t),u=e.pop(),i=r.pop(),o=null;u===i;)o=u,u=e.pop(),i=r.pop();return o}function Fu(n){n.fixed|=2}function Ou(n){n.fixed&=-7}function Yu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function Iu(n){n.fixed&=-5}function Zu(n,t,e){var r=0,u=0;if(n.charge=0,!n.leaf)for(var i,o=n.nodes,a=o.length,c=-1;++c<a;)i=o[c],null!=i&&(Zu(i,t,e),n.charge+=i.charge,r+=i.charge*i.cx,u+=i.charge*i.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var s=t*e[n.point.index];n.charge+=n.pointCharge=s,r+=s*n.point.x,u+=s*n.point.y}n.cx=r/n.charge,n.cy=u/n.charge}function Vu(n,t){return Xo.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=Wu,n}function Xu(n){return n.children}function $u(n){return n.value}function Bu(n,t){return t.value-n.value}function Wu(n){return Xo.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function Ju(n){return n.x}function Gu(n){return n.y}function Ku(n,t,e){n.y0=t,n.y=e}function Qu(n){return Xo.range(n.length)}function ni(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function ti(n){for(var t,e=1,r=0,u=n[0][1],i=n.length;i>e;++e)(t=n[e][1])>u&&(r=e,u=t);return r}function ei(n){return n.reduce(ri,0)}function ri(n,t){return n+t[1]}function ui(n,t){return ii(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function ii(n,t){for(var e=-1,r=+n[0],u=(n[1]-r)/t,i=[];++e<=t;)i[e]=u*e+r;return i}function oi(n){return[Xo.min(n),Xo.max(n)]}function ai(n,t){return n.parent==t.parent?1:2}function ci(n){var t=n.children;return t&&t.length?t[0]:n._tree.thread}function si(n){var t,e=n.children;return e&&(t=e.length)?e[t-1]:n._tree.thread}function li(n,t){var e=n.children;if(e&&(u=e.length))for(var r,u,i=-1;++i<u;)t(r=li(e[i],t),n)>0&&(n=r);return n}function fi(n,t){return n.x-t.x}function hi(n,t){return t.x-n.x}function gi(n,t){return n.depth-t.depth}function pi(n,t){function e(n,r){var u=n.children;if(u&&(o=u.length))for(var i,o,a=null,c=-1;++c<o;)i=u[c],e(i,a),a=i;t(n,r)}e(n,null)}function vi(n){for(var t,e=0,r=0,u=n.children,i=u.length;--i>=0;)t=u[i]._tree,t.prelim+=e,t.mod+=e,e+=t.shift+(r+=t.change)}function di(n,t,e){n=n._tree,t=t._tree;var r=e/(t.number-n.number);n.change+=r,t.change-=r,t.shift+=e,t.prelim+=e,t.mod+=e}function mi(n,t,e){return n._tree.ancestor.parent==t.parent?n._tree.ancestor:e}function yi(n,t){return n.value-t.value}function xi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Mi(n,t){n._pack_next=t,t._pack_prev=n}function _i(n,t){var e=t.x-n.x,r=t.y-n.y,u=n.r+t.r;return.999*u*u>e*e+r*r}function bi(n){function t(n){l=Math.min(n.x-n.r,l),f=Math.max(n.x+n.r,f),h=Math.min(n.y-n.r,h),g=Math.max(n.y+n.r,g)}if((e=n.children)&&(s=e.length)){var e,r,u,i,o,a,c,s,l=1/0,f=-1/0,h=1/0,g=-1/0;if(e.forEach(wi),r=e[0],r.x=-r.r,r.y=0,t(r),s>1&&(u=e[1],u.x=u.r,u.y=0,t(u),s>2))for(i=e[2],Ei(r,u,i),t(i),xi(r,i),r._pack_prev=i,xi(i,u),u=r._pack_next,o=3;s>o;o++){Ei(r,u,i=e[o]);var p=0,v=1,d=1;for(a=u._pack_next;a!==u;a=a._pack_next,v++)if(_i(a,i)){p=1;break}if(1==p)for(c=r._pack_prev;c!==a._pack_prev&&!_i(c,i);c=c._pack_prev,d++);p?(d>v||v==d&&u.r<r.r?Mi(r,u=a):Mi(r=c,u),o--):(xi(r,i),u=i,t(i))}var m=(l+f)/2,y=(h+g)/2,x=0;for(o=0;s>o;o++)i=e[o],i.x-=m,i.y-=y,x=Math.max(x,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=x,e.forEach(Si)}}function wi(n){n._pack_next=n._pack_prev=n}function Si(n){delete n._pack_next,delete n._pack_prev}function ki(n,t,e,r){var u=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,u)for(var i=-1,o=u.length;++i<o;)ki(u[i],t,e,r)}function Ei(n,t,e){var r=n.r+e.r,u=t.x-n.x,i=t.y-n.y;if(r&&(u||i)){var o=t.r+e.r,a=u*u+i*i;o*=o,r*=r;var c=.5+(r-o)/(2*a),s=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+c*u+s*i,e.y=n.y+c*i-s*u}else e.x=n.x+r,e.y=n.y}function Ai(n){return 1+Xo.max(n,function(n){return n.y})}function Ci(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Ni(n){var t=n.children;return t&&t.length?Ni(t[0]):n}function Li(n){var t,e=n.children;return e&&(t=e.length)?Li(e[t-1]):n}function Ti(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function qi(n,t){var e=n.x+t[3],r=n.y+t[0],u=n.dx-t[1]-t[3],i=n.dy-t[0]-t[2];return 0>u&&(e+=u/2,u=0),0>i&&(r+=i/2,i=0),{x:e,y:r,dx:u,dy:i}}function zi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Ri(n){return n.rangeExtent?n.rangeExtent():zi(n.range())}function Di(n,t,e,r){var u=e(n[0],n[1]),i=r(t[0],t[1]);return function(n){return i(u(n))}}function Pi(n,t){var e,r=0,u=n.length-1,i=n[r],o=n[u];return i>o&&(e=r,r=u,u=e,e=i,i=o,o=e),n[r]=t.floor(i),n[u]=t.ceil(o),n}function Ui(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:ls}function ji(n,t,e,r){var u=[],i=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)u.push(e(n[o-1],n[o])),i.push(r(t[o-1],t[o]));return function(t){var e=Xo.bisect(n,t,1,a)-1;return i[e](u[e](t))}}function Hi(n,t,e,r){function u(){var u=Math.min(n.length,t.length)>2?ji:Di,c=r?Pu:Du;return o=u(n,t,c,e),a=u(t,n,c,fu),i}function i(n){return o(n)}var o,a;return i.invert=function(n){return a(n)},i.domain=function(t){return arguments.length?(n=t.map(Number),u()):n},i.range=function(n){return arguments.length?(t=n,u()):t},i.rangeRound=function(n){return i.range(n).interpolate(Nu)},i.clamp=function(n){return arguments.length?(r=n,u()):r},i.interpolate=function(n){return arguments.length?(e=n,u()):e},i.ticks=function(t){return Ii(n,t)},i.tickFormat=function(t,e){return Zi(n,t,e)},i.nice=function(t){return Oi(n,t),u()},i.copy=function(){return Hi(n,t,e,r)},u()}function Fi(n,t){return Xo.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Oi(n,t){return Pi(n,Ui(Yi(n,t)[2]))}function Yi(n,t){null==t&&(t=10);var e=zi(n),r=e[1]-e[0],u=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),i=t/r*u;return.15>=i?u*=10:.35>=i?u*=5:.75>=i&&(u*=2),e[0]=Math.ceil(e[0]/u)*u,e[1]=Math.floor(e[1]/u)*u+.5*u,e[2]=u,e}function Ii(n,t){return Xo.range.apply(Xo,Yi(n,t))}function Zi(n,t,e){var r=Yi(n,t);return Xo.format(e?e.replace(Qa,function(n,t,e,u,i,o,a,c,s,l){return[t,e,u,i,o,a,c,s||"."+Xi(l,r),l].join("")}):",."+Vi(r[2])+"f")}function Vi(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function Xi(n,t){var e=Vi(t[2]);return n in fs?Math.abs(e-Vi(Math.max(Math.abs(t[0]),Math.abs(t[1]))))+ +("e"!==n):e-2*("%"===n)}function $i(n,t,e,r){function u(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function i(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(u(t))}return o.invert=function(t){return i(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(u)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(u)),o):t},o.nice=function(){var t=Pi(r.map(u),e?Math:gs);return n.domain(t),r=t.map(i),o},o.ticks=function(){var n=zi(r),o=[],a=n[0],c=n[1],s=Math.floor(u(a)),l=Math.ceil(u(c)),f=t%1?2:t;if(isFinite(l-s)){if(e){for(;l>s;s++)for(var h=1;f>h;h++)o.push(i(s)*h);o.push(i(s))}else for(o.push(i(s));s++<l;)for(var h=f-1;h>0;h--)o.push(i(s)*h);for(s=0;o[s]<a;s++);for(l=o.length;o[l-1]>c;l--);o=o.slice(s,l)}return o},o.tickFormat=function(n,t){if(!arguments.length)return hs;arguments.length<2?t=hs:"function"!=typeof t&&(t=Xo.format(t));var r,a=Math.max(.1,n/o.ticks().length),c=e?(r=1e-12,Math.ceil):(r=-1e-12,Math.floor);return function(n){return n/i(c(u(n)+r))<=a?t(n):""}},o.copy=function(){return $i(n.copy(),t,e,r)},Fi(o,n)}function Bi(n,t,e){function r(t){return n(u(t))}var u=Wi(t),i=Wi(1/t);return r.invert=function(t){return i(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(u)),r):e},r.ticks=function(n){return Ii(e,n)},r.tickFormat=function(n,t){return Zi(e,n,t)},r.nice=function(n){return r.domain(Oi(e,n))},r.exponent=function(o){return arguments.length?(u=Wi(t=o),i=Wi(1/t),n.domain(e.map(u)),r):t},r.copy=function(){return Bi(n.copy(),t,e)},Fi(r,n)}function Wi(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function Ji(n,t){function e(e){return o[((i.get(e)||"range"===t.t&&i.set(e,n.push(e)))-1)%o.length]}function r(t,e){return Xo.range(n.length).map(function(n){return t+e*n})}var i,o,a;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new u;for(var o,a=-1,c=r.length;++a<c;)i.has(o=r[a])||i.set(o,n.push(o));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(o=n,a=0,t={t:"range",a:arguments},e):o},e.rangePoints=function(u,i){arguments.length<2&&(i=0);var c=u[0],s=u[1],l=(s-c)/(Math.max(1,n.length-1)+i);return o=r(n.length<2?(c+s)/2:c+l*i/2,l),a=0,t={t:"rangePoints",a:arguments},e},e.rangeBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=(f-l)/(n.length-i+2*c);return o=r(l+h*c,h),s&&o.reverse(),a=h*(1-i),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(u,i,c){arguments.length<2&&(i=0),arguments.length<3&&(c=i);var s=u[1]<u[0],l=u[s-0],f=u[1-s],h=Math.floor((f-l)/(n.length-i+2*c)),g=f-l-(n.length-i)*h;return o=r(l+Math.round(g/2),h),s&&o.reverse(),a=Math.round(h*(1-i)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return a},e.rangeExtent=function(){return zi(t.a[0])},e.copy=function(){return Ji(n,t)},e.domain(n)}function Gi(n,t){function e(){var e=0,i=t.length;for(u=[];++e<i;)u[e-1]=Xo.quantile(n,e/i);return r}function r(n){return isNaN(n=+n)?void 0:t[Xo.bisect(u,n)]}var u;return r.domain=function(t){return arguments.length?(n=t.filter(function(n){return!isNaN(n)}).sort(Xo.ascending),e()):n},r.range=function(n){return arguments.length?(t=n,e()):t},r.quantiles=function(){return u},r.invertExtent=function(e){return e=t.indexOf(e),0>e?[0/0,0/0]:[e>0?u[e-1]:n[0],e<u.length?u[e]:n[n.length-1]]},r.copy=function(){return Gi(n,t)},e()}function Ki(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(i*(t-n))))]}function u(){return i=e.length/(t-n),o=e.length-1,r}var i,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],u()):[n,t]},r.range=function(n){return arguments.length?(e=n,u()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?0/0:t/i+n,[t,t+1/i]},r.copy=function(){return Ki(n,t,e)},u()}function Qi(n,t){function e(e){return e>=e?t[Xo.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return Qi(n,t)},e}function no(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Ii(n,t)},t.tickFormat=function(t,e){return Zi(n,t,e)},t.copy=function(){return no(n)},t}function to(n){return n.innerRadius}function eo(n){return n.outerRadius}function ro(n){return n.startAngle}function uo(n){return n.endAngle}function io(n){function t(t){function o(){s.push("M",i(n(l),a))}for(var c,s=[],l=[],f=-1,h=t.length,g=_t(e),p=_t(r);++f<h;)u.call(this,c=t[f],f)?l.push([+g.call(this,c,f),+p.call(this,c,f)]):l.length&&(o(),l=[]);return l.length&&o(),s.length?s.join(""):null}var e=br,r=wr,u=be,i=oo,o=i.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(u=n,t):u},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?i=n:(i=Ms.get(n)||oo).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function oo(n){return n.join("L")}function ao(n){return oo(n)+"Z"}function co(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&u.push("H",r[0]),u.join("")}function so(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("V",(r=n[t])[1],"H",r[0]);return u.join("")}function lo(n){for(var t=0,e=n.length,r=n[0],u=[r[0],",",r[1]];++t<e;)u.push("H",(r=n[t])[0],"V",r[1]);return u.join("")}function fo(n,t){return n.length<4?oo(n):n[1]+po(n.slice(1,n.length-1),vo(n,t))}function ho(n,t){return n.length<3?oo(n):n[0]+po((n.push(n[0]),n),vo([n[n.length-2]].concat(n,[n[1]]),t))}function go(n,t){return n.length<3?oo(n):n[0]+po(n,vo(n,t))}function po(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return oo(n);var e=n.length!=t.length,r="",u=n[0],i=n[1],o=t[0],a=o,c=1;if(e&&(r+="Q"+(i[0]-2*o[0]/3)+","+(i[1]-2*o[1]/3)+","+i[0]+","+i[1],u=n[1],c=2),t.length>1){a=t[1],i=n[c],c++,r+="C"+(u[0]+o[0])+","+(u[1]+o[1])+","+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1];for(var s=2;s<t.length;s++,c++)i=n[c],a=t[s],r+="S"+(i[0]-a[0])+","+(i[1]-a[1])+","+i[0]+","+i[1]}if(e){var l=n[c];r+="Q"+(i[0]+2*a[0]/3)+","+(i[1]+2*a[1]/3)+","+l[0]+","+l[1]}return r}function vo(n,t){for(var e,r=[],u=(1-t)/2,i=n[0],o=n[1],a=1,c=n.length;++a<c;)e=i,i=o,o=n[a],r.push([u*(o[0]-e[0]),u*(o[1]-e[1])]);return r}function mo(n){if(n.length<3)return oo(n);var t=1,e=n.length,r=n[0],u=r[0],i=r[1],o=[u,u,u,(r=n[1])[0]],a=[i,i,i,r[1]],c=[u,",",i,"L",_o(ws,o),",",_o(ws,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),bo(c,o,a);return n.pop(),c.push("L",r),c.join("")}function yo(n){if(n.length<4)return oo(n);for(var t,e=[],r=-1,u=n.length,i=[0],o=[0];++r<3;)t=n[r],i.push(t[0]),o.push(t[1]);for(e.push(_o(ws,i)+","+_o(ws,o)),--r;++r<u;)t=n[r],i.shift(),i.push(t[0]),o.shift(),o.push(t[1]),bo(e,i,o);return e.join("")}function xo(n){for(var t,e,r=-1,u=n.length,i=u+4,o=[],a=[];++r<4;)e=n[r%u],o.push(e[0]),a.push(e[1]);for(t=[_o(ws,o),",",_o(ws,a)],--r;++r<i;)e=n[r%u],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),bo(t,o,a);return t.join("")}function Mo(n,t){var e=n.length-1;if(e)for(var r,u,i=n[0][0],o=n[0][1],a=n[e][0]-i,c=n[e][1]-o,s=-1;++s<=e;)r=n[s],u=s/e,r[0]=t*r[0]+(1-t)*(i+u*a),r[1]=t*r[1]+(1-t)*(o+u*c);return mo(n)}function _o(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function bo(n,t,e){n.push("C",_o(_s,t),",",_o(_s,e),",",_o(bs,t),",",_o(bs,e),",",_o(ws,t),",",_o(ws,e))}function wo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function So(n){for(var t=0,e=n.length-1,r=[],u=n[0],i=n[1],o=r[0]=wo(u,i);++t<e;)r[t]=(o+(o=wo(u=i,i=n[t+1])))/2;return r[t]=o,r}function ko(n){for(var t,e,r,u,i=[],o=So(n),a=-1,c=n.length-1;++a<c;)t=wo(n[a],n[a+1]),oa(t)<Aa?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,u=e*e+r*r,u>9&&(u=3*t/Math.sqrt(u),o[a]=u*e,o[a+1]=u*r));for(a=-1;++a<=c;)u=(n[Math.min(c,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),i.push([u||0,o[a]*u||0]);return i}function Eo(n){return n.length<3?oo(n):n[0]+po(n,ko(n))}function Ao(n){for(var t,e,r,u=-1,i=n.length;++u<i;)t=n[u],e=t[0],r=t[1]+ys,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Co(n){function t(t){function c(){v.push("M",a(n(m),f),l,s(n(d.reverse()),f),"Z")}for(var h,g,p,v=[],d=[],m=[],y=-1,x=t.length,M=_t(e),_=_t(u),b=e===r?function(){return g}:_t(r),w=u===i?function(){return p}:_t(i);++y<x;)o.call(this,h=t[y],y)?(d.push([g=+M.call(this,h,y),p=+_.call(this,h,y)]),m.push([+b.call(this,h,y),+w.call(this,h,y)])):d.length&&(c(),d=[],m=[]);return d.length&&c(),v.length?v.join(""):null}var e=br,r=br,u=0,i=wr,o=be,a=oo,c=a.key,s=a,l="L",f=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(u=i=n,t):i},t.y0=function(n){return arguments.length?(u=n,t):u},t.y1=function(n){return arguments.length?(i=n,t):i},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(c="function"==typeof n?a=n:(a=Ms.get(n)||oo).key,s=a.reverse||a,l=a.closed?"M":"L",t):c},t.tension=function(n){return arguments.length?(f=n,t):f},t}function No(n){return n.radius}function Lo(n){return[n.x,n.y]}function To(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]+ys;return[e*Math.cos(r),e*Math.sin(r)]}}function qo(){return 64}function zo(){return"circle"}function Ro(n){var t=Math.sqrt(n/Sa);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Do(n,t){return fa(n,Ns),n.id=t,n}function Po(n,t,e,r){var u=n.id;return R(n,"function"==typeof e?function(n,i,o){n.__transition__[u].tween.set(t,r(e.call(n,n.__data__,i,o)))}:(e=r(e),function(n){n.__transition__[u].tween.set(t,e)}))}function Uo(n){return null==n&&(n=""),function(){this.textContent=n}}function jo(n,t,e,r){var i=n.__transition__||(n.__transition__={active:0,count:0}),o=i[e];if(!o){var a=r.time;o=i[e]={tween:new u,time:a,ease:r.ease,delay:r.delay,duration:r.duration},++i.count,Xo.timer(function(r){function u(r){return i.active>e?s():(i.active=e,o.event&&o.event.start.call(n,l,t),o.tween.forEach(function(e,r){(r=r.call(n,l,t))&&v.push(r)}),Xo.timer(function(){return p.c=c(r||1)?be:c,1},0,a),void 0)}function c(r){if(i.active!==e)return s();for(var u=r/g,a=f(u),c=v.length;c>0;)v[--c].call(n,a);return u>=1?(o.event&&o.event.end.call(n,l,t),s()):void 0}function s(){return--i.count?delete i[e]:delete n.__transition__,1}var l=n.__data__,f=o.ease,h=o.delay,g=o.duration,p=Ja,v=[];return p.t=h+a,r>=h?u(r-h):(p.c=u,void 0)},0,a)}}function Ho(n,t){n.attr("transform",function(n){return"translate("+t(n)+",0)"})}function Fo(n,t){n.attr("transform",function(n){return"translate(0,"+t(n)+")"})}function Oo(n){return n.toISOString()}function Yo(n,t,e){function r(t){return n(t)}function u(n,e){var r=n[1]-n[0],u=r/e,i=Xo.bisect(js,u);return i==js.length?[t.year,Yi(n.map(function(n){return n/31536e6}),e)[2]]:i?t[u/js[i-1]<js[i]/u?i-1:i]:[Os,Yi(n,e)[2]]
}return r.invert=function(t){return Io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(Io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,Io(+e+1),t).length}var i=r.domain(),o=zi(i),a=null==n?u(o,10):"number"==typeof n&&u(o,n);return a&&(n=a[0],t=a[1]),r.domain(Pi(i,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=Io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=Io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=zi(r.domain()),i=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return i&&(n=i[0],t=i[1]),n.range(e[0],Io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return Yo(n.copy(),t,e)},Fi(r,n)}function Io(n){return new Date(n)}function Zo(n){return JSON.parse(n.responseText)}function Vo(n){var t=Wo.createRange();return t.selectNode(Wo.body),t.createContextualFragment(n.responseText)}var Xo={version:"3.4.3"};Date.now||(Date.now=function(){return+new Date});var $o=[].slice,Bo=function(n){return $o.call(n)},Wo=document,Jo=Wo.documentElement,Go=window;try{Bo(Jo.childNodes)[0].nodeType}catch(Ko){Bo=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}try{Wo.createElement("div").style.setProperty("opacity",0,"")}catch(Qo){var na=Go.Element.prototype,ta=na.setAttribute,ea=na.setAttributeNS,ra=Go.CSSStyleDeclaration.prototype,ua=ra.setProperty;na.setAttribute=function(n,t){ta.call(this,n,t+"")},na.setAttributeNS=function(n,t,e){ea.call(this,n,t,e+"")},ra.setProperty=function(n,t,e){ua.call(this,n,t+"",e)}}Xo.ascending=function(n,t){return t>n?-1:n>t?1:n>=t?0:0/0},Xo.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:0/0},Xo.min=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&e>r&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&e>r&&(e=r)}return e},Xo.max=function(n,t){var e,r,u=-1,i=n.length;if(1===arguments.length){for(;++u<i&&!(null!=(e=n[u])&&e>=e);)e=void 0;for(;++u<i;)null!=(r=n[u])&&r>e&&(e=r)}else{for(;++u<i&&!(null!=(e=t.call(n,n[u],u))&&e>=e);)e=void 0;for(;++u<i;)null!=(r=t.call(n,n[u],u))&&r>e&&(e=r)}return e},Xo.extent=function(n,t){var e,r,u,i=-1,o=n.length;if(1===arguments.length){for(;++i<o&&!(null!=(e=u=n[i])&&e>=e);)e=u=void 0;for(;++i<o;)null!=(r=n[i])&&(e>r&&(e=r),r>u&&(u=r))}else{for(;++i<o&&!(null!=(e=u=t.call(n,n[i],i))&&e>=e);)e=void 0;for(;++i<o;)null!=(r=t.call(n,n[i],i))&&(e>r&&(e=r),r>u&&(u=r))}return[e,u]},Xo.sum=function(n,t){var e,r=0,u=n.length,i=-1;if(1===arguments.length)for(;++i<u;)isNaN(e=+n[i])||(r+=e);else for(;++i<u;)isNaN(e=+t.call(n,n[i],i))||(r+=e);return r},Xo.mean=function(t,e){var r,u=t.length,i=0,o=-1,a=0;if(1===arguments.length)for(;++o<u;)n(r=t[o])&&(i+=(r-i)/++a);else for(;++o<u;)n(r=e.call(t,t[o],o))&&(i+=(r-i)/++a);return a?i:void 0},Xo.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),u=+n[r-1],i=e-r;return i?u+i*(n[r]-u):u},Xo.median=function(t,e){return arguments.length>1&&(t=t.map(e)),t=t.filter(n),t.length?Xo.quantile(t.sort(Xo.ascending),.5):void 0},Xo.bisector=function(n){return{left:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;n.call(t,t[i],i)<e?r=i+1:u=i}return r},right:function(t,e,r,u){for(arguments.length<3&&(r=0),arguments.length<4&&(u=t.length);u>r;){var i=r+u>>>1;e<n.call(t,t[i],i)?u=i:r=i+1}return r}}};var ia=Xo.bisector(function(n){return n});Xo.bisectLeft=ia.left,Xo.bisect=Xo.bisectRight=ia.right,Xo.shuffle=function(n){for(var t,e,r=n.length;r;)e=0|Math.random()*r--,t=n[r],n[r]=n[e],n[e]=t;return n},Xo.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},Xo.pairs=function(n){for(var t,e=0,r=n.length-1,u=n[0],i=new Array(0>r?0:r);r>e;)i[e]=[t=u,u=n[++e]];return i},Xo.zip=function(){if(!(u=arguments.length))return[];for(var n=-1,e=Xo.min(arguments,t),r=new Array(e);++n<e;)for(var u,i=-1,o=r[n]=new Array(u);++i<u;)o[i]=arguments[i][n];return r},Xo.transpose=function(n){return Xo.zip.apply(Xo,n)},Xo.keys=function(n){var t=[];for(var e in n)t.push(e);return t},Xo.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},Xo.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},Xo.merge=function(n){for(var t,e,r,u=n.length,i=-1,o=0;++i<u;)o+=n[i].length;for(e=new Array(o);--u>=0;)for(r=n[u],t=r.length;--t>=0;)e[--o]=r[t];return e};var oa=Math.abs;Xo.range=function(n,t,r){if(arguments.length<3&&(r=1,arguments.length<2&&(t=n,n=0)),1/0===(t-n)/r)throw new Error("infinite range");var u,i=[],o=e(oa(r)),a=-1;if(n*=o,t*=o,r*=o,0>r)for(;(u=n+r*++a)>t;)i.push(u/o);else for(;(u=n+r*++a)<t;)i.push(u/o);return i},Xo.map=function(n){var t=new u;if(n instanceof u)n.forEach(function(n,e){t.set(n,e)});else for(var e in n)t.set(e,n[e]);return t},r(u,{has:i,get:function(n){return this[aa+n]},set:function(n,t){return this[aa+n]=t},remove:o,keys:a,values:function(){var n=[];return this.forEach(function(t,e){n.push(e)}),n},entries:function(){var n=[];return this.forEach(function(t,e){n.push({key:t,value:e})}),n},size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1),this[t])}});var aa="\x00",ca=aa.charCodeAt(0);Xo.nest=function(){function n(t,a,c){if(c>=o.length)return r?r.call(i,a):e?a.sort(e):a;for(var s,l,f,h,g=-1,p=a.length,v=o[c++],d=new u;++g<p;)(h=d.get(s=v(l=a[g])))?h.push(l):d.set(s,[l]);return t?(l=t(),f=function(e,r){l.set(e,n(t,r,c))}):(l={},f=function(e,r){l[e]=n(t,r,c)}),d.forEach(f),l}function t(n,e){if(e>=o.length)return n;var r=[],u=a[e++];return n.forEach(function(n,u){r.push({key:n,values:t(u,e)})}),u?r.sort(function(n,t){return u(n.key,t.key)}):r}var e,r,i={},o=[],a=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(Xo.map,e,0),0)},i.key=function(n){return o.push(n),i},i.sortKeys=function(n){return a[o.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},Xo.set=function(n){var t=new l;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},r(l,{has:i,add:function(n){return this[aa+n]=!0,n},remove:function(n){return n=aa+n,n in this&&delete this[n]},values:a,size:c,empty:s,forEach:function(n){for(var t in this)t.charCodeAt(0)===ca&&n.call(this,t.substring(1))}}),Xo.behavior={},Xo.rebind=function(n,t){for(var e,r=1,u=arguments.length;++r<u;)n[e=arguments[r]]=f(n,t,t[e]);return n};var sa=["webkit","ms","moz","Moz","o","O"];Xo.dispatch=function(){for(var n=new p,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=v(n);return n},p.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.substring(e+1),n=n.substring(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},Xo.event=null,Xo.requote=function(n){return n.replace(la,"\\$&")};var la=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,fa={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},ha=function(n,t){return t.querySelector(n)},ga=function(n,t){return t.querySelectorAll(n)},pa=Jo[h(Jo,"matchesSelector")],va=function(n,t){return pa.call(n,t)};"function"==typeof Sizzle&&(ha=function(n,t){return Sizzle(n,t)[0]||null},ga=Sizzle,va=Sizzle.matchesSelector),Xo.selection=function(){return xa};var da=Xo.selection.prototype=[];da.select=function(n){var t,e,r,u,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var c=-1,s=r.length;++c<s;)(u=r[c])?(t.push(e=n.call(u,u.__data__,c,o)),e&&"__data__"in u&&(e.__data__=u.__data__)):t.push(null)}return x(i)},da.selectAll=function(n){var t,e,r=[];n=_(n);for(var u=-1,i=this.length;++u<i;)for(var o=this[u],a=-1,c=o.length;++a<c;)(e=o[a])&&(r.push(t=Bo(n.call(e,e.__data__,a,u))),t.parentNode=e);return x(r)};var ma={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};Xo.ns={prefix:ma,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&(e=n.substring(0,t),n=n.substring(t+1)),ma.hasOwnProperty(e)?{space:ma[e],local:n}:n}},da.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=Xo.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(b(t,n[t]));return this}return this.each(b(n,t))},da.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=k(n)).length,u=-1;if(t=e.classList){for(;++u<r;)if(!t.contains(n[u]))return!1}else for(t=e.getAttribute("class");++u<r;)if(!S(n[u]).test(t))return!1;return!0}for(t in n)this.each(E(t,n[t]));return this}return this.each(E(n,t))},da.style=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t="");for(e in n)this.each(C(e,n[e],t));return this}if(2>r)return Go.getComputedStyle(this.node(),null).getPropertyValue(n);e=""}return this.each(C(n,t,e))},da.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(N(t,n[t]));return this}return this.each(N(n,t))},da.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},da.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},da.append=function(n){return n=L(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},da.insert=function(n,t){return n=L(n),t=M(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},da.remove=function(){return this.each(function(){var n=this.parentNode;n&&n.removeChild(this)})},da.data=function(n,t){function e(n,e){var r,i,o,a=n.length,f=e.length,h=Math.min(a,f),g=new Array(f),p=new Array(f),v=new Array(a);if(t){var d,m=new u,y=new u,x=[];for(r=-1;++r<a;)d=t.call(i=n[r],i.__data__,r),m.has(d)?v[r]=i:m.set(d,i),x.push(d);for(r=-1;++r<f;)d=t.call(e,o=e[r],r),(i=m.get(d))?(g[r]=i,i.__data__=o):y.has(d)||(p[r]=T(o)),y.set(d,o),m.remove(d);for(r=-1;++r<a;)m.has(x[r])&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],o=e[r],i?(i.__data__=o,g[r]=i):p[r]=T(o);for(;f>r;++r)p[r]=T(e[r]);for(;a>r;++r)v[r]=n[r]}p.update=g,p.parentNode=g.parentNode=v.parentNode=n.parentNode,c.push(p),s.push(g),l.push(v)}var r,i,o=-1,a=this.length;if(!arguments.length){for(n=new Array(a=(r=this[0]).length);++o<a;)(i=r[o])&&(n[o]=i.__data__);return n}var c=D([]),s=x([]),l=x([]);if("function"==typeof n)for(;++o<a;)e(r=this[o],n.call(r,r.parentNode.__data__,o));else for(;++o<a;)e(r=this[o],n);return s.enter=function(){return c},s.exit=function(){return l},s},da.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},da.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]),t.parentNode=(e=this[i]).parentNode;for(var a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return x(u)},da.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],u=r.length-1,i=r[u];--u>=0;)(e=r[u])&&(i&&i!==e.nextSibling&&i.parentNode.insertBefore(e,i),i=e);return this},da.sort=function(n){n=z.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},da.each=function(n){return R(this,function(t,e,r){n.call(t,t.__data__,e,r)})},da.call=function(n){var t=Bo(arguments);return n.apply(t[0]=this,t),this},da.empty=function(){return!this.node()},da.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,u=e.length;u>r;r++){var i=e[r];if(i)return i}return null},da.size=function(){var n=0;return this.each(function(){++n}),n};var ya=[];Xo.selection.enter=D,Xo.selection.enter.prototype=ya,ya.append=da.append,ya.empty=da.empty,ya.node=da.node,ya.call=da.call,ya.size=da.size,ya.select=function(n){for(var t,e,r,u,i,o=[],a=-1,c=this.length;++a<c;){r=(u=this[a]).update,o.push(t=[]),t.parentNode=u.parentNode;for(var s=-1,l=u.length;++s<l;)(i=u[s])?(t.push(r[s]=e=n.call(u.parentNode,i.__data__,s,a)),e.__data__=i.__data__):t.push(null)}return x(o)},ya.insert=function(n,t){return arguments.length<2&&(t=P(this)),da.insert.call(this,n,t)},da.transition=function(){for(var n,t,e=ks||++Ls,r=[],u=Es||{time:Date.now(),ease:yu,delay:0,duration:250},i=-1,o=this.length;++i<o;){r.push(n=[]);for(var a=this[i],c=-1,s=a.length;++c<s;)(t=a[c])&&jo(t,c,e,u),n.push(t)}return Do(r,e)},da.interrupt=function(){return this.each(U)},Xo.select=function(n){var t=["string"==typeof n?ha(n,Wo):n];return t.parentNode=Jo,x([t])},Xo.selectAll=function(n){var t=Bo("string"==typeof n?ga(n,Wo):n);return t.parentNode=Jo,x([t])};var xa=Xo.select(Jo);da.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(j(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(j(n,t,e))};var Ma=Xo.map({mouseenter:"mouseover",mouseleave:"mouseout"});Ma.forEach(function(n){"on"+n in Wo&&Ma.remove(n)});var _a="onselectstart"in Wo?null:h(Jo.style,"userSelect"),ba=0;Xo.mouse=function(n){return Y(n,m())};var wa=/WebKit/.test(Go.navigator.userAgent)?-1:0;Xo.touches=function(n,t){return arguments.length<2&&(t=m().touches),t?Bo(t).map(function(t){var e=Y(n,t);return e.identifier=t.identifier,e}):[]},Xo.behavior.drag=function(){function n(){this.on("mousedown.drag",o).on("touchstart.drag",a)}function t(){return Xo.event.changedTouches[0].identifier}function e(n,t){return Xo.touches(n).filter(function(n){return n.identifier===t})[0]}function r(n,t,e,r){return function(){function o(){var n=t(l,g),e=n[0]-v[0],r=n[1]-v[1];d|=e|r,v=n,f({type:"drag",x:n[0]+c[0],y:n[1]+c[1],dx:e,dy:r})}function a(){m.on(e+"."+p,null).on(r+"."+p,null),y(d&&Xo.event.target===h),f({type:"dragend"})}var c,s=this,l=s.parentNode,f=u.of(s,arguments),h=Xo.event.target,g=n(),p=null==g?"drag":"drag-"+g,v=t(l,g),d=0,m=Xo.select(Go).on(e+"."+p,o).on(r+"."+p,a),y=O();i?(c=i.apply(s,arguments),c=[c.x-v[0],c.y-v[1]]):c=[0,0],f({type:"dragstart"})}}var u=y(n,"drag","dragstart","dragend"),i=null,o=r(g,Xo.mouse,"mousemove","mouseup"),a=r(t,e,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},Xo.rebind(n,u,"on")};var Sa=Math.PI,ka=2*Sa,Ea=Sa/2,Aa=1e-6,Ca=Aa*Aa,Na=Sa/180,La=180/Sa,Ta=Math.SQRT2,qa=2,za=4;Xo.interpolateZoom=function(n,t){function e(n){var t=n*y;if(m){var e=B(v),o=i/(qa*h)*(e*W(Ta*t+v)-$(v));return[r+o*s,u+o*l,i*e/B(Ta*t+v)]}return[r+n*s,u+n*l,i*Math.exp(Ta*t)]}var r=n[0],u=n[1],i=n[2],o=t[0],a=t[1],c=t[2],s=o-r,l=a-u,f=s*s+l*l,h=Math.sqrt(f),g=(c*c-i*i+za*f)/(2*i*qa*h),p=(c*c-i*i-za*f)/(2*c*qa*h),v=Math.log(Math.sqrt(g*g+1)-g),d=Math.log(Math.sqrt(p*p+1)-p),m=d-v,y=(m||Math.log(c/i))/Ta;return e.duration=1e3*y,e},Xo.behavior.zoom=function(){function n(n){n.on(A,s).on(Pa+".zoom",f).on(C,h).on("dblclick.zoom",g).on(L,l)}function t(n){return[(n[0]-S.x)/S.k,(n[1]-S.y)/S.k]}function e(n){return[n[0]*S.k+S.x,n[1]*S.k+S.y]}function r(n){S.k=Math.max(E[0],Math.min(E[1],n))}function u(n,t){t=e(t),S.x+=n[0]-t[0],S.y+=n[1]-t[1]}function i(){_&&_.domain(M.range().map(function(n){return(n-S.x)/S.k}).map(M.invert)),w&&w.domain(b.range().map(function(n){return(n-S.y)/S.k}).map(b.invert))}function o(n){n({type:"zoomstart"})}function a(n){i(),n({type:"zoom",scale:S.k,translate:[S.x,S.y]})}function c(n){n({type:"zoomend"})}function s(){function n(){l=1,u(Xo.mouse(r),g),a(i)}function e(){f.on(C,Go===r?h:null).on(N,null),p(l&&Xo.event.target===s),c(i)}var r=this,i=T.of(r,arguments),s=Xo.event.target,l=0,f=Xo.select(Go).on(C,n).on(N,e),g=t(Xo.mouse(r)),p=O();U.call(r),o(i)}function l(){function n(){var n=Xo.touches(g);return h=S.k,n.forEach(function(n){n.identifier in v&&(v[n.identifier]=t(n))}),n}function e(){for(var t=Xo.event.changedTouches,e=0,i=t.length;i>e;++e)v[t[e].identifier]=null;var o=n(),c=Date.now();if(1===o.length){if(500>c-x){var s=o[0],l=v[s.identifier];r(2*S.k),u(s,l),d(),a(p)}x=c}else if(o.length>1){var s=o[0],f=o[1],h=s[0]-f[0],g=s[1]-f[1];m=h*h+g*g}}function i(){for(var n,t,e,i,o=Xo.touches(g),c=0,s=o.length;s>c;++c,i=null)if(e=o[c],i=v[e.identifier]){if(t)break;n=e,t=i}if(i){var l=(l=e[0]-n[0])*l+(l=e[1]-n[1])*l,f=m&&Math.sqrt(l/m);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+i[0])/2,(t[1]+i[1])/2],r(f*h)}x=null,u(n,t),a(p)}function f(){if(Xo.event.touches.length){for(var t=Xo.event.changedTouches,e=0,r=t.length;r>e;++e)delete v[t[e].identifier];for(var u in v)return void n()}b.on(M,null).on(_,null),w.on(A,s).on(L,l),k(),c(p)}var h,g=this,p=T.of(g,arguments),v={},m=0,y=Xo.event.changedTouches[0].identifier,M="touchmove.zoom-"+y,_="touchend.zoom-"+y,b=Xo.select(Go).on(M,i).on(_,f),w=Xo.select(g).on(A,null).on(L,e),k=O();U.call(g),e(),o(p)}function f(){var n=T.of(this,arguments);m?clearTimeout(m):(U.call(this),o(n)),m=setTimeout(function(){m=null,c(n)},50),d();var e=v||Xo.mouse(this);p||(p=t(e)),r(Math.pow(2,.002*Ra())*S.k),u(e,p),a(n)}function h(){p=null}function g(){var n=T.of(this,arguments),e=Xo.mouse(this),i=t(e),s=Math.log(S.k)/Math.LN2;o(n),r(Math.pow(2,Xo.event.shiftKey?Math.ceil(s)-1:Math.floor(s)+1)),u(e,i),a(n),c(n)}var p,v,m,x,M,_,b,w,S={x:0,y:0,k:1},k=[960,500],E=Da,A="mousedown.zoom",C="mousemove.zoom",N="mouseup.zoom",L="touchstart.zoom",T=y(n,"zoomstart","zoom","zoomend");return n.event=function(n){n.each(function(){var n=T.of(this,arguments),t=S;ks?Xo.select(this).transition().each("start.zoom",function(){S=this.__chart__||{x:0,y:0,k:1},o(n)}).tween("zoom:zoom",function(){var e=k[0],r=k[1],u=e/2,i=r/2,o=Xo.interpolateZoom([(u-S.x)/S.k,(i-S.y)/S.k,e/S.k],[(u-t.x)/t.k,(i-t.y)/t.k,e/t.k]);return function(t){var r=o(t),c=e/r[2];this.__chart__=S={x:u-r[0]*c,y:i-r[1]*c,k:c},a(n)}}).each("end.zoom",function(){c(n)}):(this.__chart__=S,o(n),a(n),c(n))})},n.translate=function(t){return arguments.length?(S={x:+t[0],y:+t[1],k:S.k},i(),n):[S.x,S.y]},n.scale=function(t){return arguments.length?(S={x:S.x,y:S.y,k:+t},i(),n):S.k},n.scaleExtent=function(t){return arguments.length?(E=null==t?Da:[+t[0],+t[1]],n):E},n.center=function(t){return arguments.length?(v=t&&[+t[0],+t[1]],n):v},n.size=function(t){return arguments.length?(k=t&&[+t[0],+t[1]],n):k},n.x=function(t){return arguments.length?(_=t,M=t.copy(),S={x:0,y:0,k:1},n):_},n.y=function(t){return arguments.length?(w=t,b=t.copy(),S={x:0,y:0,k:1},n):w},Xo.rebind(n,T,"on")};var Ra,Da=[0,1/0],Pa="onwheel"in Wo?(Ra=function(){return-Xo.event.deltaY*(Xo.event.deltaMode?120:1)},"wheel"):"onmousewheel"in Wo?(Ra=function(){return Xo.event.wheelDelta},"mousewheel"):(Ra=function(){return-Xo.event.detail},"MozMousePixelScroll");G.prototype.toString=function(){return this.rgb()+""},Xo.hsl=function(n,t,e){return 1===arguments.length?n instanceof Q?K(n.h,n.s,n.l):dt(""+n,mt,K):K(+n,+t,+e)};var Ua=Q.prototype=new G;Ua.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,this.l/n)},Ua.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),K(this.h,this.s,n*this.l)},Ua.rgb=function(){return nt(this.h,this.s,this.l)},Xo.hcl=function(n,t,e){return 1===arguments.length?n instanceof et?tt(n.h,n.c,n.l):n instanceof it?at(n.l,n.a,n.b):at((n=yt((n=Xo.rgb(n)).r,n.g,n.b)).l,n.a,n.b):tt(+n,+t,+e)};var ja=et.prototype=new G;ja.brighter=function(n){return tt(this.h,this.c,Math.min(100,this.l+Ha*(arguments.length?n:1)))},ja.darker=function(n){return tt(this.h,this.c,Math.max(0,this.l-Ha*(arguments.length?n:1)))},ja.rgb=function(){return rt(this.h,this.c,this.l).rgb()},Xo.lab=function(n,t,e){return 1===arguments.length?n instanceof it?ut(n.l,n.a,n.b):n instanceof et?rt(n.l,n.c,n.h):yt((n=Xo.rgb(n)).r,n.g,n.b):ut(+n,+t,+e)};var Ha=18,Fa=.95047,Oa=1,Ya=1.08883,Ia=it.prototype=new G;Ia.brighter=function(n){return ut(Math.min(100,this.l+Ha*(arguments.length?n:1)),this.a,this.b)},Ia.darker=function(n){return ut(Math.max(0,this.l-Ha*(arguments.length?n:1)),this.a,this.b)},Ia.rgb=function(){return ot(this.l,this.a,this.b)},Xo.rgb=function(n,t,e){return 1===arguments.length?n instanceof pt?gt(n.r,n.g,n.b):dt(""+n,gt,nt):gt(~~n,~~t,~~e)};var Za=pt.prototype=new G;Za.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,u=30;return t||e||r?(t&&u>t&&(t=u),e&&u>e&&(e=u),r&&u>r&&(r=u),gt(Math.min(255,~~(t/n)),Math.min(255,~~(e/n)),Math.min(255,~~(r/n)))):gt(u,u,u)},Za.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),gt(~~(n*this.r),~~(n*this.g),~~(n*this.b))},Za.hsl=function(){return mt(this.r,this.g,this.b)},Za.toString=function(){return"#"+vt(this.r)+vt(this.g)+vt(this.b)};var Va=Xo.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});Va.forEach(function(n,t){Va.set(n,ft(t))}),Xo.functor=_t,Xo.xhr=wt(bt),Xo.dsv=function(n,t){function e(n,e,i){arguments.length<3&&(i=e,e=null);var o=St(n,t,null==e?r:u(e),i);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:u(n)):e},o}function r(n){return e.parse(n.responseText)}function u(n){return function(t){return e.parse(t.responseText,n)}}function i(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),c=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var u=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(u(n),e)}:u})},e.parseRows=function(n,t){function e(){if(l>=s)return o;if(u)return u=!1,i;var t=l;if(34===n.charCodeAt(t)){for(var e=t;e++<s;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}l=e+2;var r=n.charCodeAt(e+1);return 13===r?(u=!0,10===n.charCodeAt(e+2)&&++l):10===r&&(u=!0),n.substring(t+1,e).replace(/""/g,'"')}for(;s>l;){var r=n.charCodeAt(l++),a=1;if(10===r)u=!0;else if(13===r)u=!0,10===n.charCodeAt(l)&&(++l,++a);else if(r!==c)continue;return n.substring(t,l-a)}return n.substring(t)}for(var r,u,i={},o={},a=[],s=n.length,l=0,f=0;(r=e())!==o;){for(var h=[];r!==i&&r!==o;)h.push(r),r=e();(!t||(h=t(h,f++)))&&a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new l,u=[];return t.forEach(function(n){for(var t in n)r.has(t)||u.push(r.add(t))}),[u.map(o).join(n)].concat(t.map(function(t){return u.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(i).join("\n")},e},Xo.csv=Xo.dsv(",","text/csv"),Xo.tsv=Xo.dsv("	","text/tab-separated-values");var Xa,$a,Ba,Wa,Ja,Ga=Go[h(Go,"requestAnimationFrame")]||function(n){setTimeout(n,17)};Xo.timer=function(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var u=e+t,i={c:n,t:u,f:!1,n:null};$a?$a.n=i:Xa=i,$a=i,Ba||(Wa=clearTimeout(Wa),Ba=1,Ga(Et))},Xo.timer.flush=function(){At(),Ct()},Xo.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var Ka=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Lt);Xo.formatPrefix=function(n,t){var e=0;return n&&(0>n&&(n*=-1),t&&(n=Xo.round(n,Nt(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((0>=e?e+1:e-1)/3)))),Ka[8+e/3]};var Qa=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,nc=Xo.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=Xo.round(n,Nt(n,t))).toFixed(Math.max(0,Math.min(20,Nt(n*(1+1e-15),t))))}}),tc=Xo.time={},ec=Date;zt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){rc.setUTCDate.apply(this._,arguments)},setDay:function(){rc.setUTCDay.apply(this._,arguments)},setFullYear:function(){rc.setUTCFullYear.apply(this._,arguments)},setHours:function(){rc.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){rc.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){rc.setUTCMinutes.apply(this._,arguments)},setMonth:function(){rc.setUTCMonth.apply(this._,arguments)},setSeconds:function(){rc.setUTCSeconds.apply(this._,arguments)},setTime:function(){rc.setTime.apply(this._,arguments)}};var rc=Date.prototype;tc.year=Rt(function(n){return n=tc.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),tc.years=tc.year.range,tc.years.utc=tc.year.utc.range,tc.day=Rt(function(n){var t=new ec(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),tc.days=tc.day.range,tc.days.utc=tc.day.utc.range,tc.dayOfYear=function(n){var t=tc.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=tc[n]=Rt(function(n){return(n=tc.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});tc[n+"s"]=e.range,tc[n+"s"].utc=e.utc.range,tc[n+"OfYear"]=function(n){var e=tc.year(n).getDay();return Math.floor((tc.dayOfYear(n)+(e+t)%7)/7)}}),tc.week=tc.sunday,tc.weeks=tc.sunday.range,tc.weeks.utc=tc.sunday.utc.range,tc.weekOfYear=tc.sundayOfYear;var uc={"-":"",_:" ",0:"0"},ic=/^\s*\d+/,oc=/^%/;Xo.locale=function(n){return{numberFormat:Tt(n),timeFormat:Pt(n)}};var ac=Xo.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});Xo.format=ac.numberFormat,Xo.geo={},re.prototype={s:0,t:0,add:function(n){ue(n,this.t,cc),ue(cc.s,this.s,this),this.s?this.t+=cc.t:this.s=cc.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var cc=new re;Xo.geo.stream=function(n,t){n&&sc.hasOwnProperty(n.type)?sc[n.type](n,t):ie(n,t)};var sc={Feature:function(n,t){ie(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,u=e.length;++r<u;)ie(e[r].geometry,t)}},lc={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){oe(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)oe(e[r],t,0)},Polygon:function(n,t){ae(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,u=e.length;++r<u;)ae(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,u=e.length;++r<u;)ie(e[r],t)}};Xo.geo.area=function(n){return fc=0,Xo.geo.stream(n,gc),fc};var fc,hc=new re,gc={sphere:function(){fc+=4*Sa},point:g,lineStart:g,lineEnd:g,polygonStart:function(){hc.reset(),gc.lineStart=ce},polygonEnd:function(){var n=2*hc;fc+=0>n?4*Sa+n:n,gc.lineStart=gc.lineEnd=gc.point=g}};Xo.geo.bounds=function(){function n(n,t){x.push(M=[l=n,h=n]),f>t&&(f=t),t>g&&(g=t)}function t(t,e){var r=se([t*Na,e*Na]);if(m){var u=fe(m,r),i=[u[1],-u[0],0],o=fe(i,u);pe(o),o=ve(o);var c=t-p,s=c>0?1:-1,v=o[0]*La*s,d=oa(c)>180;if(d^(v>s*p&&s*t>v)){var y=o[1]*La;y>g&&(g=y)}else if(v=(v+360)%360-180,d^(v>s*p&&s*t>v)){var y=-o[1]*La;f>y&&(f=y)}else f>e&&(f=e),e>g&&(g=e);d?p>t?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t):h>=l?(l>t&&(l=t),t>h&&(h=t)):t>p?a(l,t)>a(l,h)&&(h=t):a(t,h)>a(l,h)&&(l=t)}else n(t,e);m=r,p=t}function e(){_.point=t}function r(){M[0]=l,M[1]=h,_.point=n,m=null}function u(n,e){if(m){var r=n-p;y+=oa(r)>180?r+(r>0?360:-360):r}else v=n,d=e;gc.point(n,e),t(n,e)}function i(){gc.lineStart()}function o(){u(v,d),gc.lineEnd(),oa(y)>Aa&&(l=-(h=180)),M[0]=l,M[1]=h,m=null}function a(n,t){return(t-=n)<0?t+360:t}function c(n,t){return n[0]-t[0]}function s(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var l,f,h,g,p,v,d,m,y,x,M,_={point:n,lineStart:e,lineEnd:r,polygonStart:function(){_.point=u,_.lineStart=i,_.lineEnd=o,y=0,gc.polygonStart()},polygonEnd:function(){gc.polygonEnd(),_.point=n,_.lineStart=e,_.lineEnd=r,0>hc?(l=-(h=180),f=-(g=90)):y>Aa?g=90:-Aa>y&&(f=-90),M[0]=l,M[1]=h}};return function(n){g=h=-(l=f=1/0),x=[],Xo.geo.stream(n,_);
var t=x.length;if(t){x.sort(c);for(var e,r=1,u=x[0],i=[u];t>r;++r)e=x[r],s(e[0],u)||s(e[1],u)?(a(u[0],e[1])>a(u[0],u[1])&&(u[1]=e[1]),a(e[0],u[1])>a(u[0],u[1])&&(u[0]=e[0])):i.push(u=e);for(var o,e,p=-1/0,t=i.length-1,r=0,u=i[t];t>=r;u=e,++r)e=i[r],(o=a(u[1],e[0]))>p&&(p=o,l=e[0],h=u[1])}return x=M=null,1/0===l||1/0===f?[[0/0,0/0],[0/0,0/0]]:[[l,f],[h,g]]}}(),Xo.geo.centroid=function(n){pc=vc=dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,kc);var t=bc,e=wc,r=Sc,u=t*t+e*e+r*r;return Ca>u&&(t=xc,e=Mc,r=_c,Aa>vc&&(t=dc,e=mc,r=yc),u=t*t+e*e+r*r,Ca>u)?[0/0,0/0]:[Math.atan2(e,t)*La,X(r/Math.sqrt(u))*La]};var pc,vc,dc,mc,yc,xc,Mc,_c,bc,wc,Sc,kc={sphere:g,point:me,lineStart:xe,lineEnd:Me,polygonStart:function(){kc.lineStart=_e},polygonEnd:function(){kc.lineStart=xe}},Ec=Ee(be,Te,ze,[-Sa,-Sa/2]),Ac=1e9;Xo.geo.clipExtent=function(){var n,t,e,r,u,i,o={stream:function(n){return u&&(u.valid=!1),u=i(n),u.valid=!0,u},extent:function(a){return arguments.length?(i=Pe(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),u&&(u.valid=!1,u=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(Xo.geo.conicEqualArea=function(){return je(He)}).raw=He,Xo.geo.albers=function(){return Xo.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},Xo.geo.albersUsa=function(){function n(n){var i=n[0],o=n[1];return t=null,e(i,o),t||(r(i,o),t)||u(i,o),t}var t,e,r,u,i=Xo.geo.albers(),o=Xo.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=Xo.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=i.scale(),e=i.translate(),r=(n[0]-e[0])/t,u=(n[1]-e[1])/t;return(u>=.12&&.234>u&&r>=-.425&&-.214>r?o:u>=.166&&.234>u&&r>=-.214&&-.115>r?a:i).invert(n)},n.stream=function(n){var t=i.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,u){t.point(n,u),e.point(n,u),r.point(n,u)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(i.precision(t),o.precision(t),a.precision(t),n):i.precision()},n.scale=function(t){return arguments.length?(i.scale(t),o.scale(.35*t),a.scale(t),n.translate(i.translate())):i.scale()},n.translate=function(t){if(!arguments.length)return i.translate();var s=i.scale(),l=+t[0],f=+t[1];return e=i.translate(t).clipExtent([[l-.455*s,f-.238*s],[l+.455*s,f+.238*s]]).stream(c).point,r=o.translate([l-.307*s,f+.201*s]).clipExtent([[l-.425*s+Aa,f+.12*s+Aa],[l-.214*s-Aa,f+.234*s-Aa]]).stream(c).point,u=a.translate([l-.205*s,f+.212*s]).clipExtent([[l-.214*s+Aa,f+.166*s+Aa],[l-.115*s-Aa,f+.234*s-Aa]]).stream(c).point,n},n.scale(1070)};var Cc,Nc,Lc,Tc,qc,zc,Rc={point:g,lineStart:g,lineEnd:g,polygonStart:function(){Nc=0,Rc.lineStart=Fe},polygonEnd:function(){Rc.lineStart=Rc.lineEnd=Rc.point=g,Cc+=oa(Nc/2)}},Dc={point:Oe,lineStart:g,lineEnd:g,polygonStart:g,polygonEnd:g},Pc={point:Ze,lineStart:Ve,lineEnd:Xe,polygonStart:function(){Pc.lineStart=$e},polygonEnd:function(){Pc.point=Ze,Pc.lineStart=Ve,Pc.lineEnd=Xe}};Xo.geo.path=function(){function n(n){return n&&("function"==typeof a&&i.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=u(i)),Xo.geo.stream(n,o)),i.result()}function t(){return o=null,n}var e,r,u,i,o,a=4.5;return n.area=function(n){return Cc=0,Xo.geo.stream(n,u(Rc)),Cc},n.centroid=function(n){return dc=mc=yc=xc=Mc=_c=bc=wc=Sc=0,Xo.geo.stream(n,u(Pc)),Sc?[bc/Sc,wc/Sc]:_c?[xc/_c,Mc/_c]:yc?[dc/yc,mc/yc]:[0/0,0/0]},n.bounds=function(n){return qc=zc=-(Lc=Tc=1/0),Xo.geo.stream(n,u(Dc)),[[Lc,Tc],[qc,zc]]},n.projection=function(n){return arguments.length?(u=(e=n)?n.stream||Je(n):bt,t()):e},n.context=function(n){return arguments.length?(i=null==(r=n)?new Ye:new Be(n),"function"!=typeof a&&i.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(i.pointRadius(+t),+t),n):a},n.projection(Xo.geo.albersUsa()).context(null)},Xo.geo.transform=function(n){return{stream:function(t){var e=new Ge(t);for(var r in n)e[r]=n[r];return e}}},Ge.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},Xo.geo.projection=Qe,Xo.geo.projectionMutator=nr,(Xo.geo.equirectangular=function(){return Qe(er)}).raw=er.invert=er,Xo.geo.rotation=function(n){function t(t){return t=n(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t}return n=ur(n[0]%360*Na,n[1]*Na,n.length>2?n[2]*Na:0),t.invert=function(t){return t=n.invert(t[0]*Na,t[1]*Na),t[0]*=La,t[1]*=La,t},t},rr.invert=er,Xo.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=ur(-n[0]*Na,-n[1]*Na,0).invert,u=[];return e(null,null,1,{point:function(n,e){u.push(n=t(n,e)),n[0]*=La,n[1]*=La}}),{type:"Polygon",coordinates:[u]}}var t,e,r=[0,0],u=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=cr((t=+r)*Na,u*Na),n):t},n.precision=function(r){return arguments.length?(e=cr(t*Na,(u=+r)*Na),n):u},n.angle(90)},Xo.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Na,u=n[1]*Na,i=t[1]*Na,o=Math.sin(r),a=Math.cos(r),c=Math.sin(u),s=Math.cos(u),l=Math.sin(i),f=Math.cos(i);return Math.atan2(Math.sqrt((e=f*o)*e+(e=s*l-c*f*a)*e),c*l+s*f*a)},Xo.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return Xo.range(Math.ceil(i/d)*d,u,d).map(h).concat(Xo.range(Math.ceil(s/m)*m,c,m).map(g)).concat(Xo.range(Math.ceil(r/p)*p,e,p).filter(function(n){return oa(n%d)>Aa}).map(l)).concat(Xo.range(Math.ceil(a/v)*v,o,v).filter(function(n){return oa(n%m)>Aa}).map(f))}var e,r,u,i,o,a,c,s,l,f,h,g,p=10,v=p,d=90,m=360,y=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(i).concat(g(c).slice(1),h(u).reverse().slice(1),g(s).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(i=+t[0][0],u=+t[1][0],s=+t[0][1],c=+t[1][1],i>u&&(t=i,i=u,u=t),s>c&&(t=s,s=c,c=t),n.precision(y)):[[i,s],[u,c]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(y)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],m=+t[1],n):[d,m]},n.minorStep=function(t){return arguments.length?(p=+t[0],v=+t[1],n):[p,v]},n.precision=function(t){return arguments.length?(y=+t,l=lr(a,o,90),f=fr(r,e,y),h=lr(s,c,90),g=fr(i,u,y),n):y},n.majorExtent([[-180,-90+Aa],[180,90-Aa]]).minorExtent([[-180,-80-Aa],[180,80+Aa]])},Xo.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||u.apply(this,arguments)]}}var t,e,r=hr,u=gr;return n.distance=function(){return Xo.geo.distance(t||r.apply(this,arguments),e||u.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(u=t,e="function"==typeof t?null:t,n):u},n.precision=function(){return arguments.length?n:0},n},Xo.geo.interpolate=function(n,t){return pr(n[0]*Na,n[1]*Na,t[0]*Na,t[1]*Na)},Xo.geo.length=function(n){return Uc=0,Xo.geo.stream(n,jc),Uc};var Uc,jc={sphere:g,point:g,lineStart:vr,lineEnd:g,polygonStart:g,polygonEnd:g},Hc=dr(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(Xo.geo.azimuthalEqualArea=function(){return Qe(Hc)}).raw=Hc;var Fc=dr(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},bt);(Xo.geo.azimuthalEquidistant=function(){return Qe(Fc)}).raw=Fc,(Xo.geo.conicConformal=function(){return je(mr)}).raw=mr,(Xo.geo.conicEquidistant=function(){return je(yr)}).raw=yr;var Oc=dr(function(n){return 1/n},Math.atan);(Xo.geo.gnomonic=function(){return Qe(Oc)}).raw=Oc,xr.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Ea]},(Xo.geo.mercator=function(){return Mr(xr)}).raw=xr;var Yc=dr(function(){return 1},Math.asin);(Xo.geo.orthographic=function(){return Qe(Yc)}).raw=Yc;var Ic=dr(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(Xo.geo.stereographic=function(){return Qe(Ic)}).raw=Ic,_r.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Ea]},(Xo.geo.transverseMercator=function(){var n=Mr(_r),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[-n[1],n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},n.rotate([0,0])}).raw=_r,Xo.geom={},Xo.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,u=_t(e),i=_t(r),o=n.length,a=[],c=[];for(t=0;o>t;t++)a.push([+u.call(this,n[t],t),+i.call(this,n[t],t),t]);for(a.sort(kr),t=0;o>t;t++)c.push([a[t][0],-a[t][1]]);var s=Sr(a),l=Sr(c),f=l[0]===s[0],h=l[l.length-1]===s[s.length-1],g=[];for(t=s.length-1;t>=0;--t)g.push(n[a[s[t]][2]]);for(t=+f;t<l.length-h;++t)g.push(n[a[l[t]][2]]);return g}var e=br,r=wr;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},Xo.geom.polygon=function(n){return fa(n,Zc),n};var Zc=Xo.geom.polygon.prototype=[];Zc.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],u=0;++t<e;)n=r,r=this[t],u+=n[1]*r[0]-n[0]*r[1];return.5*u},Zc.centroid=function(n){var t,e,r=-1,u=this.length,i=0,o=0,a=this[u-1];for(arguments.length||(n=-1/(6*this.area()));++r<u;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],i+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[i*n,o*n]},Zc.clip=function(n){for(var t,e,r,u,i,o,a=Cr(n),c=-1,s=this.length-Cr(this),l=this[s-1];++c<s;){for(t=n.slice(),n.length=0,u=this[c],i=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Er(o,l,u)?(Er(i,l,u)||n.push(Ar(i,o,l,u)),n.push(o)):Er(i,l,u)&&n.push(Ar(i,o,l,u)),i=o;a&&n.push(n[0]),l=u}return n};var Vc,Xc,$c,Bc,Wc,Jc=[],Gc=[];Pr.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(jr),t.length},Br.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},Wr.prototype={insert:function(n,t){var e,r,u;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=Qr(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(u=r.R,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.R&&(Gr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Kr(this,r))):(u=r.L,u&&u.C?(e.C=u.C=!1,r.C=!0,n=r):(n===e.L&&(Kr(this,e),n=e,e=n.U),e.C=!1,r.C=!0,Gr(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,u=n.U,i=n.L,o=n.R;if(e=i?o?Qr(o):i:o,u?u.L===n?u.L=e:u.R=e:this._=e,i&&o?(r=e.C,e.C=n.C,e.L=i,i.U=e,e!==o?(u=e.U,e.U=n.U,n=e.R,u.L=n,e.R=o,o.U=e):(e.U=u,u=e,n=e.R)):(r=n.C,n=e),n&&(n.U=u),!r){if(n&&n.C)return n.C=!1,void 0;do{if(n===this._)break;if(n===u.L){if(t=u.R,t.C&&(t.C=!1,u.C=!0,Gr(this,u),t=u.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,Kr(this,t),t=u.R),t.C=u.C,u.C=t.R.C=!1,Gr(this,u),n=this._;break}}else if(t=u.L,t.C&&(t.C=!1,u.C=!0,Kr(this,u),t=u.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,Gr(this,t),t=u.L),t.C=u.C,u.C=t.L.C=!1,Kr(this,u),n=this._;break}t.C=!0,n=u,u=u.U}while(!n.C);n&&(n.C=!1)}}},Xo.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],u=a[0][1],i=a[1][0],o=a[1][1];return nu(e(n),a).cells.forEach(function(e,a){var c=e.edges,s=e.site,l=t[a]=c.length?c.map(function(n){var t=n.start();return[t.x,t.y]}):s.x>=r&&s.x<=i&&s.y>=u&&s.y<=o?[[r,o],[i,o],[i,u],[r,u]]:[];l.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(i(n,t)/Aa)*Aa,y:Math.round(o(n,t)/Aa)*Aa,i:t}})}var r=br,u=wr,i=r,o=u,a=Kc;return n?t(n):(t.links=function(n){return nu(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return nu(e(n)).cells.forEach(function(e,r){for(var u,i,o=e.site,a=e.edges.sort(jr),c=-1,s=a.length,l=a[s-1].edge,f=l.l===o?l.r:l.l;++c<s;)u=l,i=f,l=a[c].edge,f=l.l===o?l.r:l.l,r<i.i&&r<f.i&&eu(o,i,f)<0&&t.push([n[r],n[i.i],n[f.i]])}),t},t.x=function(n){return arguments.length?(i=_t(r=n),t):r},t.y=function(n){return arguments.length?(o=_t(u=n),t):u},t.clipExtent=function(n){return arguments.length?(a=null==n?Kc:n,t):a===Kc?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===Kc?null:a&&a[1]},t)};var Kc=[[-1e6,-1e6],[1e6,1e6]];Xo.geom.delaunay=function(n){return Xo.geom.voronoi().triangles(n)},Xo.geom.quadtree=function(n,t,e,r,u){function i(n){function i(n,t,e,r,u,i,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var c=n.x,l=n.y;if(null!=c)if(oa(c-e)+oa(l-r)<.01)s(n,t,e,r,u,i,o,a);else{var f=n.point;n.x=n.y=n.point=null,s(n,f,c,l,u,i,o,a),s(n,t,e,r,u,i,o,a)}else n.x=e,n.y=r,n.point=t}else s(n,t,e,r,u,i,o,a)}function s(n,t,e,r,u,o,a,c){var s=.5*(u+a),l=.5*(o+c),f=e>=s,h=r>=l,g=(h<<1)+f;n.leaf=!1,n=n.nodes[g]||(n.nodes[g]=iu()),f?u=s:a=s,h?o=l:c=l,i(n,t,e,r,u,o,a,c)}var l,f,h,g,p,v,d,m,y,x=_t(a),M=_t(c);if(null!=t)v=t,d=e,m=r,y=u;else if(m=y=-(v=d=1/0),f=[],h=[],p=n.length,o)for(g=0;p>g;++g)l=n[g],l.x<v&&(v=l.x),l.y<d&&(d=l.y),l.x>m&&(m=l.x),l.y>y&&(y=l.y),f.push(l.x),h.push(l.y);else for(g=0;p>g;++g){var _=+x(l=n[g],g),b=+M(l,g);v>_&&(v=_),d>b&&(d=b),_>m&&(m=_),b>y&&(y=b),f.push(_),h.push(b)}var w=m-v,S=y-d;w>S?y=d+w:m=v+S;var k=iu();if(k.add=function(n){i(k,n,+x(n,++g),+M(n,g),v,d,m,y)},k.visit=function(n){ou(n,k,v,d,m,y)},g=-1,null==t){for(;++g<p;)i(k,n[g],f[g],h[g],v,d,m,y);--g}else n.forEach(k.add);return f=h=n=l=null,k}var o,a=br,c=wr;return(o=arguments.length)?(a=ru,c=uu,3===o&&(u=e,r=t,e=t=0),i(n)):(i.x=function(n){return arguments.length?(a=n,i):a},i.y=function(n){return arguments.length?(c=n,i):c},i.extent=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],u=+n[1][1]),i):null==t?null:[[t,e],[r,u]]},i.size=function(n){return arguments.length?(null==n?t=e=r=u=null:(t=e=0,r=+n[0],u=+n[1]),i):null==t?null:[r-t,u-e]},i)},Xo.interpolateRgb=au,Xo.interpolateObject=cu,Xo.interpolateNumber=su,Xo.interpolateString=lu;var Qc=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;Xo.interpolate=fu,Xo.interpolators=[function(n,t){var e=typeof t;return("string"===e?Va.has(t)||/^(#|rgb\(|hsl\()/.test(t)?au:lu:t instanceof G?au:"object"===e?Array.isArray(t)?hu:cu:su)(n,t)}],Xo.interpolateArray=hu;var ns=function(){return bt},ts=Xo.map({linear:ns,poly:xu,quad:function(){return du},cubic:function(){return mu},sin:function(){return Mu},exp:function(){return _u},circle:function(){return bu},elastic:wu,back:Su,bounce:function(){return ku}}),es=Xo.map({"in":bt,out:pu,"in-out":vu,"out-in":function(n){return vu(pu(n))}});Xo.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.substring(0,t):n,r=t>=0?n.substring(t+1):"in";return e=ts.get(e)||ns,r=es.get(r)||bt,gu(r(e.apply(null,$o.call(arguments,1))))},Xo.interpolateHcl=Eu,Xo.interpolateHsl=Au,Xo.interpolateLab=Cu,Xo.interpolateRound=Nu,Xo.transform=function(n){var t=Wo.createElementNS(Xo.ns.prefix.svg,"g");return(Xo.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new Lu(e?e.matrix:rs)})(n)},Lu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var rs={a:1,b:0,c:0,d:1,e:0,f:0};Xo.interpolateTransform=Ru,Xo.layout={},Xo.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Uu(n[e]));return t}},Xo.layout.chord=function(){function n(){var n,s,f,h,g,p={},v=[],d=Xo.range(i),m=[];for(e=[],r=[],n=0,h=-1;++h<i;){for(s=0,g=-1;++g<i;)s+=u[h][g];v.push(s),m.push(Xo.range(i)),n+=s}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&m.forEach(function(n,t){n.sort(function(n,e){return a(u[t][n],u[t][e])})}),n=(ka-l*i)/n,s=0,h=-1;++h<i;){for(f=s,g=-1;++g<i;){var y=d[h],x=m[y][g],M=u[y][x],_=s,b=s+=M*n;p[y+"-"+x]={index:y,subindex:x,startAngle:_,endAngle:b,value:M}}r[y]={index:y,startAngle:f,endAngle:s,value:(s-f)/n},s+=l}for(h=-1;++h<i;)for(g=h-1;++g<i;){var w=p[h+"-"+g],S=p[g+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}c&&t()}function t(){e.sort(function(n,t){return c((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,u,i,o,a,c,s={},l=0;return s.matrix=function(n){return arguments.length?(i=(u=n)&&u.length,e=r=null,s):u},s.padding=function(n){return arguments.length?(l=n,e=r=null,s):l},s.sortGroups=function(n){return arguments.length?(o=n,e=r=null,s):o},s.sortSubgroups=function(n){return arguments.length?(a=n,e=null,s):a},s.sortChords=function(n){return arguments.length?(c=n,e&&t(),s):c},s.chords=function(){return e||n(),e},s.groups=function(){return r||n(),r},s},Xo.layout.force=function(){function n(n){return function(t,e,r,u){if(t.point!==n){var i=t.cx-n.x,o=t.cy-n.y,a=u-e,c=i*i+o*o;if(c>a*a/d){if(p>c){var s=t.charge/c;n.px-=i*s,n.py-=o*s}return!0}if(t.point&&c&&p>c){var s=t.pointCharge/c;n.px-=i*s,n.py-=o*s}}return!t.charge}}function t(n){n.px=Xo.event.x,n.py=Xo.event.y,a.resume()}var e,r,u,i,o,a={},c=Xo.dispatch("start","tick","end"),s=[1,1],l=.9,f=us,h=is,g=-30,p=os,v=.1,d=.64,m=[],y=[];return a.tick=function(){if((r*=.99)<.005)return c.end({type:"end",alpha:r=0}),!0;var t,e,a,f,h,p,d,x,M,_=m.length,b=y.length;for(e=0;b>e;++e)a=y[e],f=a.source,h=a.target,x=h.x-f.x,M=h.y-f.y,(p=x*x+M*M)&&(p=r*i[e]*((p=Math.sqrt(p))-u[e])/p,x*=p,M*=p,h.x-=x*(d=f.weight/(h.weight+f.weight)),h.y-=M*d,f.x+=x*(d=1-d),f.y+=M*d);if((d=r*v)&&(x=s[0]/2,M=s[1]/2,e=-1,d))for(;++e<_;)a=m[e],a.x+=(x-a.x)*d,a.y+=(M-a.y)*d;if(g)for(Zu(t=Xo.geom.quadtree(m),r,o),e=-1;++e<_;)(a=m[e]).fixed||t.visit(n(a));for(e=-1;++e<_;)a=m[e],a.fixed?(a.x=a.px,a.y=a.py):(a.x-=(a.px-(a.px=a.x))*l,a.y-=(a.py-(a.py=a.y))*l);c.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(m=n,a):m},a.links=function(n){return arguments.length?(y=n,a):y},a.size=function(n){return arguments.length?(s=n,a):s},a.linkDistance=function(n){return arguments.length?(f="function"==typeof n?n:+n,a):f},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(l=+n,a):l},a.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,a):g},a.chargeDistance=function(n){return arguments.length?(p=n*n,a):Math.sqrt(p)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?r=n>0?n:0:n>0&&(c.start({type:"start",alpha:r=n}),Xo.timer(a.tick)),a):r},a.start=function(){function n(n,r){if(!e){for(e=new Array(c),a=0;c>a;++a)e[a]=[];for(a=0;s>a;++a){var u=y[a];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var i,o=e[t],a=-1,s=o.length;++a<s;)if(!isNaN(i=o[a][n]))return i;return Math.random()*r}var t,e,r,c=m.length,l=y.length,p=s[0],v=s[1];for(t=0;c>t;++t)(r=m[t]).index=t,r.weight=0;for(t=0;l>t;++t)r=y[t],"number"==typeof r.source&&(r.source=m[r.source]),"number"==typeof r.target&&(r.target=m[r.target]),++r.source.weight,++r.target.weight;for(t=0;c>t;++t)r=m[t],isNaN(r.x)&&(r.x=n("x",p)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof f)for(t=0;l>t;++t)u[t]=+f.call(this,y[t],t);else for(t=0;l>t;++t)u[t]=f;if(i=[],"function"==typeof h)for(t=0;l>t;++t)i[t]=+h.call(this,y[t],t);else for(t=0;l>t;++t)i[t]=h;if(o=[],"function"==typeof g)for(t=0;c>t;++t)o[t]=+g.call(this,m[t],t);else for(t=0;c>t;++t)o[t]=g;return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){return e||(e=Xo.behavior.drag().origin(bt).on("dragstart.force",Fu).on("drag.force",t).on("dragend.force",Ou)),arguments.length?(this.on("mouseover.force",Yu).on("mouseout.force",Iu).call(e),void 0):e},Xo.rebind(a,c,"on")};var us=20,is=1,os=1/0;Xo.layout.hierarchy=function(){function n(t,o,a){var c=u.call(e,t,o);if(t.depth=o,a.push(t),c&&(s=c.length)){for(var s,l,f=-1,h=t.children=new Array(s),g=0,p=o+1;++f<s;)l=h[f]=n(c[f],p,a),l.parent=t,g+=l.value;r&&h.sort(r),i&&(t.value=g)}else delete t.children,i&&(t.value=+i.call(e,t,o)||0);return t}function t(n,r){var u=n.children,o=0;if(u&&(a=u.length))for(var a,c=-1,s=r+1;++c<a;)o+=t(u[c],s);else i&&(o=+i.call(e,n,r)||0);return i&&(n.value=o),o}function e(t){var e=[];return n(t,0,e),e}var r=Bu,u=Xu,i=$u;return e.sort=function(n){return arguments.length?(r=n,e):r},e.children=function(n){return arguments.length?(u=n,e):u},e.value=function(n){return arguments.length?(i=n,e):i},e.revalue=function(n){return t(n,0),n},e},Xo.layout.partition=function(){function n(t,e,r,u){var i=t.children;if(t.x=e,t.y=t.depth*u,t.dx=r,t.dy=u,i&&(o=i.length)){var o,a,c,s=-1;for(r=t.value?r/t.value:0;++s<o;)n(a=i[s],e,c=a.value*r,u),e+=c}}function t(n){var e=n.children,r=0;if(e&&(u=e.length))for(var u,i=-1;++i<u;)r=Math.max(r,t(e[i]));return 1+r}function e(e,i){var o=r.call(this,e,i);return n(o[0],0,u[0],u[1]/t(o[0])),o}var r=Xo.layout.hierarchy(),u=[1,1];return e.size=function(n){return arguments.length?(u=n,e):u},Vu(e,r)},Xo.layout.pie=function(){function n(i){var o=i.map(function(e,r){return+t.call(n,e,r)}),a=+("function"==typeof r?r.apply(this,arguments):r),c=(("function"==typeof u?u.apply(this,arguments):u)-a)/Xo.sum(o),s=Xo.range(i.length);null!=e&&s.sort(e===as?function(n,t){return o[t]-o[n]}:function(n,t){return e(i[n],i[t])});var l=[];return s.forEach(function(n){var t;l[n]={data:i[n],value:t=o[n],startAngle:a,endAngle:a+=t*c}}),l}var t=Number,e=as,r=0,u=ka;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(u=t,n):u},n};var as={};Xo.layout.stack=function(){function n(a,c){var s=a.map(function(e,r){return t.call(n,e,r)}),l=s.map(function(t){return t.map(function(t,e){return[i.call(n,t,e),o.call(n,t,e)]})}),f=e.call(n,l,c);s=Xo.permute(s,f),l=Xo.permute(l,f);var h,g,p,v=r.call(n,l,c),d=s.length,m=s[0].length;for(g=0;m>g;++g)for(u.call(n,s[0][g],p=v[g],l[0][g][1]),h=1;d>h;++h)u.call(n,s[h][g],p+=l[h-1][g][1],l[h][g][1]);return a}var t=bt,e=Qu,r=ni,u=Ku,i=Ju,o=Gu;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:cs.get(t)||Qu,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:ss.get(t)||ni,n):r},n.x=function(t){return arguments.length?(i=t,n):i},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(u=t,n):u},n};var cs=Xo.map({"inside-out":function(n){var t,e,r=n.length,u=n.map(ti),i=n.map(ei),o=Xo.range(r).sort(function(n,t){return u[n]-u[t]}),a=0,c=0,s=[],l=[];for(t=0;r>t;++t)e=o[t],c>a?(a+=i[e],s.push(e)):(c+=i[e],l.push(e));return l.reverse().concat(s)},reverse:function(n){return Xo.range(n.length).reverse()},"default":Qu}),ss=Xo.map({silhouette:function(n){var t,e,r,u=n.length,i=n[0].length,o=[],a=0,c=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;i>e;++e)c[e]=(a-o[e])/2;return c},wiggle:function(n){var t,e,r,u,i,o,a,c,s,l=n.length,f=n[0],h=f.length,g=[];for(g[0]=c=s=0,e=1;h>e;++e){for(t=0,u=0;l>t;++t)u+=n[t][e][1];for(t=0,i=0,a=f[e][0]-f[e-1][0];l>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;i+=o*n[t][e][1]}g[e]=c-=u?i/u*a:0,s>c&&(s=c)}for(e=0;h>e;++e)g[e]-=s;return g},expand:function(n){var t,e,r,u=n.length,i=n[0].length,o=1/u,a=[];for(e=0;i>e;++e){for(t=0,r=0;u>t;t++)r+=n[t][e][1];if(r)for(t=0;u>t;t++)n[t][e][1]/=r;else for(t=0;u>t;t++)n[t][e][1]=o}for(e=0;i>e;++e)a[e]=0;return a},zero:ni});Xo.layout.histogram=function(){function n(n,i){for(var o,a,c=[],s=n.map(e,this),l=r.call(this,s,i),f=u.call(this,l,s,i),i=-1,h=s.length,g=f.length-1,p=t?1:1/h;++i<g;)o=c[i]=[],o.dx=f[i+1]-(o.x=f[i]),o.y=0;if(g>0)for(i=-1;++i<h;)a=s[i],a>=l[0]&&a<=l[1]&&(o=c[Xo.bisect(f,a,1,g)-1],o.y+=p,o.push(n[i]));return c}var t=!0,e=Number,r=oi,u=ui;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=_t(t),n):r},n.bins=function(t){return arguments.length?(u="number"==typeof t?function(n){return ii(n,t)}:_t(t),n):u},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},Xo.layout.tree=function(){function n(n,i){function o(n,t){var r=n.children,u=n._tree;if(r&&(i=r.length)){for(var i,a,s,l=r[0],f=l,h=-1;++h<i;)s=r[h],o(s,a),f=c(s,a,f),a=s;vi(n);var g=.5*(l._tree.prelim+s._tree.prelim);t?(u.prelim=t._tree.prelim+e(n,t),u.mod=u.prelim-g):u.prelim=g}else t&&(u.prelim=t._tree.prelim+e(n,t))}function a(n,t){n.x=n._tree.prelim+t;var e=n.children;if(e&&(r=e.length)){var r,u=-1;for(t+=n._tree.mod;++u<r;)a(e[u],t)}}function c(n,t,r){if(t){for(var u,i=n,o=n,a=t,c=n.parent.children[0],s=i._tree.mod,l=o._tree.mod,f=a._tree.mod,h=c._tree.mod;a=si(a),i=ci(i),a&&i;)c=ci(c),o=si(o),o._tree.ancestor=n,u=a._tree.prelim+f-i._tree.prelim-s+e(a,i),u>0&&(di(mi(a,n,r),n,u),s+=u,l+=u),f+=a._tree.mod,s+=i._tree.mod,h+=c._tree.mod,l+=o._tree.mod;a&&!si(o)&&(o._tree.thread=a,o._tree.mod+=f-l),i&&!ci(c)&&(c._tree.thread=i,c._tree.mod+=s-h,r=n)}return r}var s=t.call(this,n,i),l=s[0];pi(l,function(n,t){n._tree={ancestor:n,prelim:0,mod:0,change:0,shift:0,number:t?t._tree.number+1:0}}),o(l),a(l,-l._tree.prelim);var f=li(l,hi),h=li(l,fi),g=li(l,gi),p=f.x-e(f,h)/2,v=h.x+e(h,f)/2,d=g.depth||1;return pi(l,u?function(n){n.x*=r[0],n.y=n.depth*r[1],delete n._tree}:function(n){n.x=(n.x-p)/(v-p)*r[0],n.y=n.depth/d*r[1],delete n._tree}),s}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.pack=function(){function n(n,i){var o=e.call(this,n,i),a=o[0],c=u[0],s=u[1],l=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,pi(a,function(n){n.r=+l(n.value)}),pi(a,bi),r){var f=r*(t?1:Math.max(2*a.r/c,2*a.r/s))/2;pi(a,function(n){n.r+=f}),pi(a,bi),pi(a,function(n){n.r-=f})}return ki(a,c/2,s/2,t?1:1/Math.max(2*a.r/c,2*a.r/s)),o}var t,e=Xo.layout.hierarchy().sort(yi),r=0,u=[1,1];return n.size=function(t){return arguments.length?(u=t,n):u},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},Vu(n,e)},Xo.layout.cluster=function(){function n(n,i){var o,a=t.call(this,n,i),c=a[0],s=0;pi(c,function(n){var t=n.children;t&&t.length?(n.x=Ci(t),n.y=Ai(t)):(n.x=o?s+=e(n,o):0,n.y=0,o=n)});var l=Ni(c),f=Li(c),h=l.x-e(l,f)/2,g=f.x+e(f,l)/2;return pi(c,u?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(g-h)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),a}var t=Xo.layout.hierarchy().sort(null).value(null),e=ai,r=[1,1],u=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(u=null==(r=t),n):u?null:r},n.nodeSize=function(t){return arguments.length?(u=null!=(r=t),n):u?r:null},Vu(n,t)},Xo.layout.treemap=function(){function n(n,t){for(var e,r,u=-1,i=n.length;++u<i;)r=(e=n[u]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var i=e.children;if(i&&i.length){var o,a,c,s=f(e),l=[],h=i.slice(),p=1/0,v="slice"===g?s.dx:"dice"===g?s.dy:"slice-dice"===g?1&e.depth?s.dy:s.dx:Math.min(s.dx,s.dy);for(n(h,s.dx*s.dy/e.value),l.area=0;(c=h.length)>0;)l.push(o=h[c-1]),l.area+=o.area,"squarify"!==g||(a=r(l,v))<=p?(h.pop(),p=a):(l.area-=l.pop().area,u(l,v,s,!1),v=Math.min(s.dx,s.dy),l.length=l.area=0,p=1/0);l.length&&(u(l,v,s,!0),l.length=l.area=0),i.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var i,o=f(t),a=r.slice(),c=[];for(n(a,o.dx*o.dy/t.value),c.area=0;i=a.pop();)c.push(i),c.area+=i.area,null!=i.z&&(u(c,i.z?o.dx:o.dy,o,!a.length),c.length=c.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,u=0,i=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(i>e&&(i=e),e>u&&(u=e));return r*=r,t*=t,r?Math.max(t*u*p/r,r/(t*i*p)):1/0}function u(n,t,e,r){var u,i=-1,o=n.length,a=e.x,s=e.y,l=t?c(n.area/t):0;if(t==e.dx){for((r||l>e.dy)&&(l=e.dy);++i<o;)u=n[i],u.x=a,u.y=s,u.dy=l,a+=u.dx=Math.min(e.x+e.dx-a,l?c(u.area/l):0);u.z=!0,u.dx+=e.x+e.dx-a,e.y+=l,e.dy-=l}else{for((r||l>e.dx)&&(l=e.dx);++i<o;)u=n[i],u.x=a,u.y=s,u.dx=l,s+=u.dy=Math.min(e.y+e.dy-s,l?c(u.area/l):0);u.z=!1,u.dy+=e.y+e.dy-s,e.x+=l,e.dx-=l}}function i(r){var u=o||a(r),i=u[0];return i.x=0,i.y=0,i.dx=s[0],i.dy=s[1],o&&a.revalue(i),n([i],i.dx*i.dy/i.value),(o?e:t)(i),h&&(o=u),u}var o,a=Xo.layout.hierarchy(),c=Math.round,s=[1,1],l=null,f=Ti,h=!1,g="squarify",p=.5*(1+Math.sqrt(5));return i.size=function(n){return arguments.length?(s=n,i):s},i.padding=function(n){function t(t){var e=n.call(i,t,t.depth);return null==e?Ti(t):qi(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return qi(t,n)}if(!arguments.length)return l;var r;return f=null==(l=n)?Ti:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,i},i.round=function(n){return arguments.length?(c=n?Math.round:Number,i):c!=Number},i.sticky=function(n){return arguments.length?(h=n,o=null,i):h},i.ratio=function(n){return arguments.length?(p=n,i):p},i.mode=function(n){return arguments.length?(g=n+"",i):g},Vu(i,a)},Xo.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,u;do e=2*Math.random()-1,r=2*Math.random()-1,u=e*e+r*r;while(!u||u>1);return n+t*e*Math.sqrt(-2*Math.log(u)/u)}},logNormal:function(){var n=Xo.random.normal.apply(Xo,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=Xo.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},Xo.scale={};var ls={floor:bt,ceil:bt};Xo.scale.linear=function(){return Hi([0,1],[0,1],fu,!1)};var fs={s:1,g:1,p:1,r:1,e:1};Xo.scale.log=function(){return $i(Xo.scale.linear().domain([0,1]),10,!0,[1,10])};var hs=Xo.format(".0e"),gs={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};Xo.scale.pow=function(){return Bi(Xo.scale.linear(),1,[0,1])},Xo.scale.sqrt=function(){return Xo.scale.pow().exponent(.5)},Xo.scale.ordinal=function(){return Ji([],{t:"range",a:[[]]})},Xo.scale.category10=function(){return Xo.scale.ordinal().range(ps)},Xo.scale.category20=function(){return Xo.scale.ordinal().range(vs)},Xo.scale.category20b=function(){return Xo.scale.ordinal().range(ds)},Xo.scale.category20c=function(){return Xo.scale.ordinal().range(ms)};var ps=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(ht),vs=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(ht),ds=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(ht),ms=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(ht);Xo.scale.quantile=function(){return Gi([],[])},Xo.scale.quantize=function(){return Ki(0,1,[0,1])},Xo.scale.threshold=function(){return Qi([.5],[0,1])
},Xo.scale.identity=function(){return no([0,1])},Xo.svg={},Xo.svg.arc=function(){function n(){var n=t.apply(this,arguments),i=e.apply(this,arguments),o=r.apply(this,arguments)+ys,a=u.apply(this,arguments)+ys,c=(o>a&&(c=o,o=a,a=c),a-o),s=Sa>c?"0":"1",l=Math.cos(o),f=Math.sin(o),h=Math.cos(a),g=Math.sin(a);return c>=xs?n?"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"M0,"+n+"A"+n+","+n+" 0 1,0 0,"+-n+"A"+n+","+n+" 0 1,0 0,"+n+"Z":"M0,"+i+"A"+i+","+i+" 0 1,1 0,"+-i+"A"+i+","+i+" 0 1,1 0,"+i+"Z":n?"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L"+n*h+","+n*g+"A"+n+","+n+" 0 "+s+",0 "+n*l+","+n*f+"Z":"M"+i*l+","+i*f+"A"+i+","+i+" 0 "+s+",1 "+i*h+","+i*g+"L0,0"+"Z"}var t=to,e=eo,r=ro,u=uo;return n.innerRadius=function(e){return arguments.length?(t=_t(e),n):t},n.outerRadius=function(t){return arguments.length?(e=_t(t),n):e},n.startAngle=function(t){return arguments.length?(r=_t(t),n):r},n.endAngle=function(t){return arguments.length?(u=_t(t),n):u},n.centroid=function(){var n=(t.apply(this,arguments)+e.apply(this,arguments))/2,i=(r.apply(this,arguments)+u.apply(this,arguments))/2+ys;return[Math.cos(i)*n,Math.sin(i)*n]},n};var ys=-Ea,xs=ka-Aa;Xo.svg.line=function(){return io(bt)};var Ms=Xo.map({linear:oo,"linear-closed":ao,step:co,"step-before":so,"step-after":lo,basis:mo,"basis-open":yo,"basis-closed":xo,bundle:Mo,cardinal:go,"cardinal-open":fo,"cardinal-closed":ho,monotone:Eo});Ms.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var _s=[0,2/3,1/3,0],bs=[0,1/3,2/3,0],ws=[0,1/6,2/3,1/6];Xo.svg.line.radial=function(){var n=io(Ao);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},so.reverse=lo,lo.reverse=so,Xo.svg.area=function(){return Co(bt)},Xo.svg.area.radial=function(){var n=Co(Ao);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},Xo.svg.chord=function(){function n(n,a){var c=t(this,i,n,a),s=t(this,o,n,a);return"M"+c.p0+r(c.r,c.p1,c.a1-c.a0)+(e(c,s)?u(c.r,c.p1,c.r,c.p0):u(c.r,c.p1,s.r,s.p0)+r(s.r,s.p1,s.a1-s.a0)+u(s.r,s.p1,c.r,c.p0))+"Z"}function t(n,t,e,r){var u=t.call(n,e,r),i=a.call(n,u,r),o=c.call(n,u,r)+ys,l=s.call(n,u,r)+ys;return{r:i,a0:o,a1:l,p0:[i*Math.cos(o),i*Math.sin(o)],p1:[i*Math.cos(l),i*Math.sin(l)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Sa)+",1 "+t}function u(n,t,e,r){return"Q 0,0 "+r}var i=hr,o=gr,a=No,c=ro,s=uo;return n.radius=function(t){return arguments.length?(a=_t(t),n):a},n.source=function(t){return arguments.length?(i=_t(t),n):i},n.target=function(t){return arguments.length?(o=_t(t),n):o},n.startAngle=function(t){return arguments.length?(c=_t(t),n):c},n.endAngle=function(t){return arguments.length?(s=_t(t),n):s},n},Xo.svg.diagonal=function(){function n(n,u){var i=t.call(this,n,u),o=e.call(this,n,u),a=(i.y+o.y)/2,c=[i,{x:i.x,y:a},{x:o.x,y:a},o];return c=c.map(r),"M"+c[0]+"C"+c[1]+" "+c[2]+" "+c[3]}var t=hr,e=gr,r=Lo;return n.source=function(e){return arguments.length?(t=_t(e),n):t},n.target=function(t){return arguments.length?(e=_t(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},Xo.svg.diagonal.radial=function(){var n=Xo.svg.diagonal(),t=Lo,e=n.projection;return n.projection=function(n){return arguments.length?e(To(t=n)):t},n},Xo.svg.symbol=function(){function n(n,r){return(Ss.get(t.call(this,n,r))||Ro)(e.call(this,n,r))}var t=zo,e=qo;return n.type=function(e){return arguments.length?(t=_t(e),n):t},n.size=function(t){return arguments.length?(e=_t(t),n):e},n};var Ss=Xo.map({circle:Ro,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Cs)),e=t*Cs;return"M0,"+-t+"L"+e+",0"+" 0,"+t+" "+-e+",0"+"Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/As),e=t*As/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});Xo.svg.symbolTypes=Ss.keys();var ks,Es,As=Math.sqrt(3),Cs=Math.tan(30*Na),Ns=[],Ls=0;Ns.call=da.call,Ns.empty=da.empty,Ns.node=da.node,Ns.size=da.size,Xo.transition=function(n){return arguments.length?ks?n.transition():n:xa.transition()},Xo.transition.prototype=Ns,Ns.select=function(n){var t,e,r,u=this.id,i=[];n=M(n);for(var o=-1,a=this.length;++o<a;){i.push(t=[]);for(var c=this[o],s=-1,l=c.length;++s<l;)(r=c[s])&&(e=n.call(r,r.__data__,s,o))?("__data__"in r&&(e.__data__=r.__data__),jo(e,s,u,r.__transition__[u]),t.push(e)):t.push(null)}return Do(i,u)},Ns.selectAll=function(n){var t,e,r,u,i,o=this.id,a=[];n=_(n);for(var c=-1,s=this.length;++c<s;)for(var l=this[c],f=-1,h=l.length;++f<h;)if(r=l[f]){i=r.__transition__[o],e=n.call(r,r.__data__,f,c),a.push(t=[]);for(var g=-1,p=e.length;++g<p;)(u=e[g])&&jo(u,g,o,i),t.push(u)}return Do(a,o)},Ns.filter=function(n){var t,e,r,u=[];"function"!=typeof n&&(n=q(n));for(var i=0,o=this.length;o>i;i++){u.push(t=[]);for(var e=this[i],a=0,c=e.length;c>a;a++)(r=e[a])&&n.call(r,r.__data__,a,i)&&t.push(r)}return Do(u,this.id)},Ns.tween=function(n,t){var e=this.id;return arguments.length<2?this.node().__transition__[e].tween.get(n):R(this,null==t?function(t){t.__transition__[e].tween.remove(n)}:function(r){r.__transition__[e].tween.set(n,t)})},Ns.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function u(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function i(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?Ru:fu,a=Xo.ns.qualify(n);return Po(this,"attr."+n,t,a.local?i:u)},Ns.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(u));return r&&function(n){this.setAttribute(u,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(u.space,u.local));return r&&function(n){this.setAttributeNS(u.space,u.local,r(n))}}var u=Xo.ns.qualify(n);return this.tween("attr."+n,u.local?r:e)},Ns.style=function(n,t,e){function r(){this.style.removeProperty(n)}function u(t){return null==t?r:(t+="",function(){var r,u=Go.getComputedStyle(this,null).getPropertyValue(n);return u!==t&&(r=fu(u,t),function(t){this.style.setProperty(n,r(t),e)})})}var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(t="");for(e in n)this.style(e,n[e],t);return this}e=""}return Po(this,"style."+n,t,u)},Ns.styleTween=function(n,t,e){function r(r,u){var i=t.call(this,r,u,Go.getComputedStyle(this,null).getPropertyValue(n));return i&&function(t){this.style.setProperty(n,i(t),e)}}return arguments.length<3&&(e=""),this.tween("style."+n,r)},Ns.text=function(n){return Po(this,"text",n,Uo)},Ns.remove=function(){return this.each("end.transition",function(){var n;this.__transition__.count<2&&(n=this.parentNode)&&n.removeChild(this)})},Ns.ease=function(n){var t=this.id;return arguments.length<1?this.node().__transition__[t].ease:("function"!=typeof n&&(n=Xo.ease.apply(Xo,arguments)),R(this,function(e){e.__transition__[t].ease=n}))},Ns.delay=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].delay=+n.call(e,e.__data__,r,u)}:(n=+n,function(e){e.__transition__[t].delay=n}))},Ns.duration=function(n){var t=this.id;return R(this,"function"==typeof n?function(e,r,u){e.__transition__[t].duration=Math.max(1,n.call(e,e.__data__,r,u))}:(n=Math.max(1,n),function(e){e.__transition__[t].duration=n}))},Ns.each=function(n,t){var e=this.id;if(arguments.length<2){var r=Es,u=ks;ks=e,R(this,function(t,r,u){Es=t.__transition__[e],n.call(t,t.__data__,r,u)}),Es=r,ks=u}else R(this,function(r){var u=r.__transition__[e];(u.event||(u.event=Xo.dispatch("start","end"))).on(n,t)});return this},Ns.transition=function(){for(var n,t,e,r,u=this.id,i=++Ls,o=[],a=0,c=this.length;c>a;a++){o.push(n=[]);for(var t=this[a],s=0,l=t.length;l>s;s++)(e=t[s])&&(r=Object.create(e.__transition__[u]),r.delay+=r.duration,jo(e,s,i,r)),n.push(e)}return Do(o,i)},Xo.svg.axis=function(){function n(n){n.each(function(){var n,s=Xo.select(this),l=this.__chart__||e,f=this.__chart__=e.copy(),h=null==c?f.ticks?f.ticks.apply(f,a):f.domain():c,g=null==t?f.tickFormat?f.tickFormat.apply(f,a):bt:t,p=s.selectAll(".tick").data(h,f),v=p.enter().insert("g",".domain").attr("class","tick").style("opacity",Aa),d=Xo.transition(p.exit()).style("opacity",Aa).remove(),m=Xo.transition(p).style("opacity",1),y=Ri(f),x=s.selectAll(".domain").data([0]),M=(x.enter().append("path").attr("class","domain"),Xo.transition(x));v.append("line"),v.append("text");var _=v.select("line"),b=m.select("line"),w=p.select("text").text(g),S=v.select("text"),k=m.select("text");switch(r){case"bottom":n=Ho,_.attr("y2",u),S.attr("y",Math.max(u,0)+o),b.attr("x2",0).attr("y2",u),k.attr("x",0).attr("y",Math.max(u,0)+o),w.attr("dy",".71em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+i+"V0H"+y[1]+"V"+i);break;case"top":n=Ho,_.attr("y2",-u),S.attr("y",-(Math.max(u,0)+o)),b.attr("x2",0).attr("y2",-u),k.attr("x",0).attr("y",-(Math.max(u,0)+o)),w.attr("dy","0em").style("text-anchor","middle"),M.attr("d","M"+y[0]+","+-i+"V0H"+y[1]+"V"+-i);break;case"left":n=Fo,_.attr("x2",-u),S.attr("x",-(Math.max(u,0)+o)),b.attr("x2",-u).attr("y2",0),k.attr("x",-(Math.max(u,0)+o)).attr("y",0),w.attr("dy",".32em").style("text-anchor","end"),M.attr("d","M"+-i+","+y[0]+"H0V"+y[1]+"H"+-i);break;case"right":n=Fo,_.attr("x2",u),S.attr("x",Math.max(u,0)+o),b.attr("x2",u).attr("y2",0),k.attr("x",Math.max(u,0)+o).attr("y",0),w.attr("dy",".32em").style("text-anchor","start"),M.attr("d","M"+i+","+y[0]+"H0V"+y[1]+"H"+i)}if(f.rangeBand){var E=f,A=E.rangeBand()/2;l=f=function(n){return E(n)+A}}else l.rangeBand?l=f:d.call(n,f);v.call(n,l),m.call(n,f)})}var t,e=Xo.scale.linear(),r=Ts,u=6,i=6,o=3,a=[10],c=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in qs?t+"":Ts,n):r},n.ticks=function(){return arguments.length?(a=arguments,n):a},n.tickValues=function(t){return arguments.length?(c=t,n):c},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(u=+t,i=+arguments[e-1],n):u},n.innerTickSize=function(t){return arguments.length?(u=+t,n):u},n.outerTickSize=function(t){return arguments.length?(i=+t,n):i},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Ts="bottom",qs={top:1,right:1,bottom:1,left:1};Xo.svg.brush=function(){function n(i){i.each(function(){var i=Xo.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=i.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),i.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=i.selectAll(".resize").data(p,bt);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return zs[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,f=Xo.transition(i),h=Xo.transition(o);c&&(l=Ri(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),e(f)),s&&(l=Ri(s),h.attr("y",l[0]).attr("height",l[1]-l[0]),r(f)),t(f)})}function t(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+l[+/e$/.test(n)]+","+f[+/^s/.test(n)]+")"})}function e(n){n.select(".extent").attr("x",l[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",l[1]-l[0])}function r(n){n.select(".extent").attr("y",f[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",f[1]-f[0])}function u(){function u(){32==Xo.event.keyCode&&(C||(x=null,L[0]-=l[1],L[1]-=f[1],C=2),d())}function p(){32==Xo.event.keyCode&&2==C&&(L[0]+=l[1],L[1]+=f[1],C=0,d())}function v(){var n=Xo.mouse(_),u=!1;M&&(n[0]+=M[0],n[1]+=M[1]),C||(Xo.event.altKey?(x||(x=[(l[0]+l[1])/2,(f[0]+f[1])/2]),L[0]=l[+(n[0]<x[0])],L[1]=f[+(n[1]<x[1])]):x=null),E&&m(n,c,0)&&(e(S),u=!0),A&&m(n,s,1)&&(r(S),u=!0),u&&(t(S),w({type:"brush",mode:C?"move":"resize"}))}function m(n,t,e){var r,u,a=Ri(t),c=a[0],s=a[1],p=L[e],v=e?f:l,d=v[1]-v[0];return C&&(c-=p,s-=d+p),r=(e?g:h)?Math.max(c,Math.min(s,n[e])):n[e],C?u=(r+=p)+d:(x&&(p=Math.max(c,Math.min(s,2*x[e]-r))),r>p?(u=r,r=p):u=p),v[0]!=r||v[1]!=u?(e?o=null:i=null,v[0]=r,v[1]=u,!0):void 0}function y(){v(),S.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),Xo.select("body").style("cursor",null),T.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),N(),w({type:"brushend"})}var x,M,_=this,b=Xo.select(Xo.event.target),w=a.of(_,arguments),S=Xo.select(_),k=b.datum(),E=!/^(n|s)$/.test(k)&&c,A=!/^(e|w)$/.test(k)&&s,C=b.classed("extent"),N=O(),L=Xo.mouse(_),T=Xo.select(Go).on("keydown.brush",u).on("keyup.brush",p);if(Xo.event.changedTouches?T.on("touchmove.brush",v).on("touchend.brush",y):T.on("mousemove.brush",v).on("mouseup.brush",y),S.interrupt().selectAll("*").interrupt(),C)L[0]=l[0]-L[0],L[1]=f[0]-L[1];else if(k){var q=+/w$/.test(k),z=+/^n/.test(k);M=[l[1-q]-L[0],f[1-z]-L[1]],L[0]=l[q],L[1]=f[z]}else Xo.event.altKey&&(x=L.slice());S.style("pointer-events","none").selectAll(".resize").style("display",null),Xo.select("body").style("cursor",b.style("cursor")),w({type:"brushstart"}),v()}var i,o,a=y(n,"brushstart","brush","brushend"),c=null,s=null,l=[0,0],f=[0,0],h=!0,g=!0,p=Rs[0];return n.event=function(n){n.each(function(){var n=a.of(this,arguments),t={x:l,y:f,i:i,j:o},e=this.__chart__||t;this.__chart__=t,ks?Xo.select(this).transition().each("start.brush",function(){i=e.i,o=e.j,l=e.x,f=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=hu(l,t.x),r=hu(f,t.y);return i=o=null,function(u){l=t.x=e(u),f=t.y=r(u),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){i=t.i,o=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,p=Rs[!c<<1|!s],n):c},n.y=function(t){return arguments.length?(s=t,p=Rs[!c<<1|!s],n):s},n.clamp=function(t){return arguments.length?(c&&s?(h=!!t[0],g=!!t[1]):c?h=!!t:s&&(g=!!t),n):c&&s?[h,g]:c?h:s?g:null},n.extent=function(t){var e,r,u,a,h;return arguments.length?(c&&(e=t[0],r=t[1],s&&(e=e[0],r=r[0]),i=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(h=e,e=r,r=h),(e!=l[0]||r!=l[1])&&(l=[e,r])),s&&(u=t[0],a=t[1],c&&(u=u[1],a=a[1]),o=[u,a],s.invert&&(u=s(u),a=s(a)),u>a&&(h=u,u=a,a=h),(u!=f[0]||a!=f[1])&&(f=[u,a])),n):(c&&(i?(e=i[0],r=i[1]):(e=l[0],r=l[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(h=e,e=r,r=h))),s&&(o?(u=o[0],a=o[1]):(u=f[0],a=f[1],s.invert&&(u=s.invert(u),a=s.invert(a)),u>a&&(h=u,u=a,a=h))),c&&s?[[e,u],[r,a]]:c?[e,r]:s&&[u,a])},n.clear=function(){return n.empty()||(l=[0,0],f=[0,0],i=o=null),n},n.empty=function(){return!!c&&l[0]==l[1]||!!s&&f[0]==f[1]},Xo.rebind(n,a,"on")};var zs={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Rs=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Ds=tc.format=ac.timeFormat,Ps=Ds.utc,Us=Ps("%Y-%m-%dT%H:%M:%S.%LZ");Ds.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Oo:Us,Oo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Oo.toString=Us.toString,tc.second=Rt(function(n){return new ec(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),tc.seconds=tc.second.range,tc.seconds.utc=tc.second.utc.range,tc.minute=Rt(function(n){return new ec(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),tc.minutes=tc.minute.range,tc.minutes.utc=tc.minute.utc.range,tc.hour=Rt(function(n){var t=n.getTimezoneOffset()/60;return new ec(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),tc.hours=tc.hour.range,tc.hours.utc=tc.hour.utc.range,tc.month=Rt(function(n){return n=tc.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),tc.months=tc.month.range,tc.months.utc=tc.month.utc.range;var js=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Hs=[[tc.second,1],[tc.second,5],[tc.second,15],[tc.second,30],[tc.minute,1],[tc.minute,5],[tc.minute,15],[tc.minute,30],[tc.hour,1],[tc.hour,3],[tc.hour,6],[tc.hour,12],[tc.day,1],[tc.day,2],[tc.week,1],[tc.month,1],[tc.month,3],[tc.year,1]],Fs=Ds.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",be]]),Os={range:function(n,t,e){return Xo.range(Math.ceil(n/e)*e,+t,e).map(Io)},floor:bt,ceil:bt};Hs.year=tc.year,tc.scale=function(){return Yo(Xo.scale.linear(),Hs,Fs)};var Ys=Hs.map(function(n){return[n[0].utc,n[1]]}),Is=Ps.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",be]]);Ys.year=tc.year.utc,tc.scale.utc=function(){return Yo(Xo.scale.linear(),Ys,Is)},Xo.text=wt(function(n){return n.responseText}),Xo.json=function(n,t){return St(n,"application/json",Zo,t)},Xo.html=function(n,t){return St(n,"text/html",Vo,t)},Xo.xml=wt(function(n){return n.responseXML}),"function"==typeof define&&define.amd?define(Xo):"object"==typeof module&&module.exports?module.exports=Xo:this.d3=Xo}();
/* Copyright (c) 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */
'use strict';

(function(window) {
  window.define = undefined;
}).call(this, this);


'use strict';

tr.exportTo('tr.ui.b', function() {
  const DataSeriesEnableChangeEventType = 'data-series-enabled-change';

  const THIS_DOC = document.currentScript.ownerDocument;

  const svgNS = 'http://www.w3.org/2000/svg';
  const ColorScheme = tr.b.ColorScheme;

  function getColorOfKey(key, selected) {
    let id = ColorScheme.getColorIdForGeneralPurposeString(key);
    if (selected) {
      id += ColorScheme.properties.brightenedOffsets[0];
    }
    return ColorScheme.colorsAsStrings[id];
  }

  /**
   * Returns width and height of SVG text node.
   *
   * @param {!Element} parentNode
   * @param {string} text
   * @param {function(!Element)=} opt_callback
   * @param {*=} opt_this
   * @returns {!Object}
   */
  function getSVGTextSize(parentNode, text, opt_callback, opt_this) {
    const textNode = document.createElementNS(
        'http://www.w3.org/2000/svg', 'text');
    textNode.setAttributeNS(null, 'x', 0);
    textNode.setAttributeNS(null, 'y', 0);
    textNode.setAttributeNS(null, 'fill', 'black');
    textNode.appendChild(document.createTextNode(text));
    parentNode.appendChild(textNode);
    if (opt_callback) {
      opt_callback.call(opt_this || parentNode, textNode);
    }
    const width = textNode.getComputedTextLength();
    const height = textNode.getBBox().height;
    parentNode.removeChild(textNode);
    return {width, height};
  }

  function DataSeries(key) {
    this.key_ = key;
    this.target_ = undefined;
    this.title_ = '';
    this.optional_ = false;
    this.enabled_ = true;
    this.color_ = getColorOfKey(key, false);
    this.highlightedColor_ = getColorOfKey(key, true);
  }

  DataSeries.prototype = {
    get key() {
      return this.key_;
    },

    get title() {
      return this.title_;
    },

    set title(t) {
      this.title_ = t;
    },

    get color() {
      return this.color_;
    },

    set color(c) {
      this.color_ = c;
    },

    get highlightedColor() {
      return this.highlightedColor_;
    },

    set highlightedColor(c) {
      this.highlightedColor_ = c;
    },

    get optional() {
      return this.optional_;
    },

    set optional(optional) {
      this.optional_ = optional;
    },

    get enabled() {
      return this.enabled_;
    },

    set enabled(enabled) {
      // If the caller is disabling a data series, but it wasn't optional, then
      // force it to be optional.
      if (!this.optional && !enabled) {
        this.optional = true;
      }
      this.enabled_ = enabled;
    },

    get target() {
      return this.target_;
    },

    set target(t) {
      this.target_ = t;
    }
  };

  /**
   * A virtual base class for basic charts that provides basic chart
   * infrastructure such as a title and legend.
   *
   * Generally, setting a field on a chart instance will cause it to update its
   * contents, which assumes that the chart is attached to a document, so
   * callers should create the chart and immediately attach it to a document
   * before configuring it. Embedders that are polymer dom-modules can use the
   * attached() callback to wait to configure the chart until they are attached
   * to a document.
   *
   * TODO(#3058) Use a class for Polymer 2.0.
   *
   * @constructor
   */
  const ChartBase = tr.ui.b.define('svg', undefined, svgNS);

  ChartBase.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    getDataSeries(key) {
      if (!this.seriesByKey_.has(key)) {
        this.seriesByKey_.set(key, new DataSeries(key));
      }
      return this.seriesByKey_.get(key);
    },

    decorate() {
      Polymer.dom(this).classList.add('chart-base');
      this.chartTitle_ = undefined;
      this.seriesByKey_ = new Map();
      this.graphWidth_ = undefined;
      this.graphHeight_ = undefined;
      this.margin = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
      };
      this.hideLegend_ = false;

      // This should use tr.ui.b.instantiateTemplate. However, creating
      // svg-namespaced elements inside a template isn't possible. Thus, this
      // hack.
      const template =
          Polymer.dom(THIS_DOC).querySelector('#chart-base-template');
      const svgEl = Polymer.dom(template.content).querySelector('svg');
      for (let i = 0; i < Polymer.dom(svgEl).children.length; i++) {
        Polymer.dom(this).appendChild(
            Polymer.dom(svgEl.children[i]).cloneNode(true));
      }

      this.addEventListener(DataSeriesEnableChangeEventType,
          this.onDataSeriesEnableChange_.bind(this));
    },

    get hideLegend() {
      return this.hideLegend_;
    },

    set hideLegend(h) {
      this.hideLegend_ = h;
      this.updateContents_();
    },

    isSeriesEnabled(key) {
      return this.getDataSeries(key).enabled;
    },

    onDataSeriesEnableChange_(event) {
      this.getDataSeries(event.key).enabled = event.enabled;
      this.updateContents_();
    },

    get chartTitle() {
      return this.chartTitle_;
    },

    set chartTitle(chartTitle) {
      this.chartTitle_ = chartTitle;
      this.updateContents_();
    },

    get chartAreaElement() {
      return Polymer.dom(this).querySelector('#chart-area');
    },

    get graphWidth() {
      if (this.graphWidth_ === undefined) return this.defaultGraphWidth;
      return this.graphWidth_;
    },

    set graphWidth(width) {
      this.graphWidth_ = width;
      this.updateContents_();
    },

    get defaultGraphWidth() {
      return 0;
    },

    get graphHeight() {
      if (this.graphHeight_ === undefined) return this.defaultGraphHeight;
      return this.graphHeight_;
    },

    set graphHeight(height) {
      this.graphHeight_ = height;
      this.updateContents_();
    },

    get defaultGraphHeight() {
      return 0;
    },

    get totalWidth() {
      return this.margin.left + this.graphWidth + this.margin.right;
    },

    get totalHeight() {
      return this.margin.top + this.graphHeight + this.margin.bottom;
    },

    updateMargins_() {
      const legendSize = this.computeLegendSize_();
      this.margin.right = Math.max(this.margin.right, legendSize.width);
      this.margin.bottom = Math.max(
          this.margin.bottom,
          legendSize.height - this.graphHeight);

      if (this.chartTitle_) {
        const titleSize = getSVGTextSize(this, this.chartTitle_, textNode => {
          textNode.style.fontSize = '16pt';
        });
        this.margin.top = Math.max(this.margin.top, titleSize.height + 15);
        const horizontalOverhangPx = (titleSize.width - this.graphWidth) / 2;
        this.margin.left = Math.max(this.margin.left, horizontalOverhangPx);
        this.margin.right = Math.max(this.margin.right, horizontalOverhangPx);
      }
    },

    computeLegendSize_() {
      let width = 0;
      let height = 0;
      if (this.hideLegend) return {width, height};

      for (const series of this.seriesByKey_.values()) {
        const textSize = getSVGTextSize(this, series.key);
        width = Math.max(width, textSize.width + 20);
        height += textSize.height;
      }
      return {width, height};
    },

    updateDimensions_() {
      const thisSel = d3.select(this);
      thisSel.attr('width', this.totalWidth);
      thisSel.attr('height', this.totalHeight);

      d3.select(this.chartAreaElement).attr(
          'transform',
          'translate(' + this.margin.left + ', ' + this.margin.top + ')');
    },

    updateContents_() {
      this.updateMargins_();
      this.updateDimensions_();
      this.updateTitle_();
      this.updateLegend_();
    },

    updateTitle_() {
      const titleSel = d3.select(this.chartAreaElement).select('#title');
      if (!this.chartTitle_) {
        titleSel.style('display', 'none');
        return;
      }
      titleSel.attr('transform', 'translate(' + this.graphWidth * 0.5 + ',-15)')
          .style('display', undefined)
          .style('text-anchor', 'middle')
          .style('font-size', '16pt')
          .attr('class', 'title')
          .attr('width', this.graphWidth)
          .text(this.chartTitle_);
    },

    updateLegend_() {
      const chartAreaSel = d3.select(this.chartAreaElement);
      chartAreaSel.selectAll('.legend').remove();
      if (this.hideLegend) return;

      const series = [...this.seriesByKey_.values()].reverse();
      const legendEntriesSel = chartAreaSel.selectAll('.legend').data(series);

      legendEntriesSel.enter()
          .append('foreignObject')
          .attr('class', 'legend')
          .attr('x', this.graphWidth + 2)
          .attr('width', this.margin.right)
          .attr('height', 18)
          .attr('transform', (series, i) => 'translate(0,' + i * 18 + ')')
          .append('xhtml:body')
          .style('margin', 0)
          .append('tr-ui-b-chart-legend-key')
          .property('color', series =>
                    ((this.currentHighlightedLegendKey === series.key) ?
                     series.highlightedColor : series.color))
          .property('width', this.margin.right)
          .property('target', series => series.target)
          .property('title', series => series.title)
          .property('optional', series => series.optional)
          .property('enabled', series => series.enabled)
          .text(series => series.key);
      legendEntriesSel.exit().remove();
    },

    get highlightedLegendKey() {
      return this.highlightedLegendKey_;
    },

    set highlightedLegendKey(highlightedLegendKey) {
      this.highlightedLegendKey_ = highlightedLegendKey;
      this.updateHighlight_();
    },

    get currentHighlightedLegendKey() {
      if (this.tempHighlightedLegendKey_) {
        return this.tempHighlightedLegendKey_;
      }
      return this.highlightedLegendKey_;
    },

    pushTempHighlightedLegendKey(key) {
      if (this.tempHighlightedLegendKey_) {
        throw new Error('push cannot nest');
      }
      this.tempHighlightedLegendKey_ = key;
      this.updateHighlight_();
    },

    popTempHighlightedLegendKey(key) {
      if (this.tempHighlightedLegendKey_ !== key) {
        throw new Error('pop cannot happen');
      }
      this.tempHighlightedLegendKey_ = undefined;
      this.updateHighlight_();
    },

    updateHighlight_() {
      // Update label colors.
      const chartAreaSel = d3.select(this.chartAreaElement);
      const legendEntriesSel = chartAreaSel.selectAll('.legend');
      const getDataSeries = chart.getDataSeries.bind(chart);
      const currentHighlightedLegendKey = chart.currentHighlightedLegendKey;
      legendEntriesSel.each(function(key) {
        // NOTE: this = legendEntry
        const dataSeries = getDataSeries(key);
        if (key === currentHighlightedLegendKey) {
          this.style.fill = dataSeries.highlightedColor;
          this.style.fontWeight = 'bold';
        } else {
          this.style.fill = dataSeries.color;
          this.style.fontWeight = '';
        }
      });
    }
  };

  return {
    ChartBase,
    DataSeriesEnableChangeEventType,
    getColorOfKey,
    getSVGTextSize,
  };
});


'use strict';

/**
 * @fileoverview A Mouse-event abtraction that waits for
 *   mousedown, then watches for subsequent mousemove events
 *   until the next mouseup event, then waits again.
 *   State changes are signaled with
 *      'mouse-tracker-start' : mousedown and tracking
 *      'mouse-tracker-move' : mouse move
 *      'mouse-tracker-end' : mouseup and not tracking.
 */

tr.exportTo('tr.ui.b', function() {
  /**
   * @constructor
   * @param {HTMLElement} targetElement will recv events 'mouse-tracker-start',
   *     'mouse-tracker-move', 'mouse-tracker-end'.
   */
  function MouseTracker(opt_targetElement) {
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.onMouseUp_ = this.onMouseUp_.bind(this);

    this.targetElement = opt_targetElement;
  }

  MouseTracker.prototype = {

    get targetElement() {
      return this.targetElement_;
    },

    set targetElement(targetElement) {
      if (this.targetElement_) {
        this.targetElement_.removeEventListener('mousedown', this.onMouseDown_);
      }
      this.targetElement_ = targetElement;
      if (this.targetElement_) {
        this.targetElement_.addEventListener('mousedown', this.onMouseDown_);
      }
    },

    onMouseDown_(e) {
      if (e.button !== 0) return true;

      e = this.remakeEvent_(e, 'mouse-tracker-start');
      this.targetElement_.dispatchEvent(e);
      document.addEventListener('mousemove', this.onMouseMove_);
      document.addEventListener('mouseup', this.onMouseUp_);
      this.targetElement_.addEventListener('blur', this.onMouseUp_);
      this.savePreviousUserSelect_ = document.body.style['-webkit-user-select'];
      document.body.style['-webkit-user-select'] = 'none';
      e.preventDefault();
      return true;
    },

    onMouseMove_(e) {
      e = this.remakeEvent_(e, 'mouse-tracker-move');
      this.targetElement_.dispatchEvent(e);
    },

    onMouseUp_(e) {
      document.removeEventListener('mousemove', this.onMouseMove_);
      document.removeEventListener('mouseup', this.onMouseUp_);
      this.targetElement_.removeEventListener('blur', this.onMouseUp_);
      document.body.style['-webkit-user-select'] =
          this.savePreviousUserSelect_;
      e = this.remakeEvent_(e, 'mouse-tracker-end');
      this.targetElement_.dispatchEvent(e);
    },

    remakeEvent_(e, newType) {
      const remade = new tr.b.Event(newType, true, true);
      remade.x = e.x;
      remade.y = e.y;
      remade.offsetX = e.offsetX;
      remade.offsetY = e.offsetY;
      remade.clientX = e.clientX;
      remade.clientY = e.clientY;
      return remade;
    }

  };

  function trackMouseMovesUntilMouseUp(mouseMoveHandler,
      opt_mouseUpHandler, opt_keyUpHandler) {
    function cleanupAndDispatchToMouseUp(e) {
      document.removeEventListener('mousemove', mouseMoveHandler);
      if (opt_keyUpHandler) {
        document.removeEventListener('keyup', opt_keyUpHandler);
      }
      document.removeEventListener('mouseup', cleanupAndDispatchToMouseUp);
      if (opt_mouseUpHandler) {
        opt_mouseUpHandler(e);
      }
    }
    document.addEventListener('mousemove', mouseMoveHandler);
    if (opt_keyUpHandler) {
      document.addEventListener('keyup', opt_keyUpHandler);
    }
    document.addEventListener('mouseup', cleanupAndDispatchToMouseUp);
  }

  return {
    MouseTracker,
    trackMouseMovesUntilMouseUp,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  // This does not include the tick labels.
  const D3_Y_AXIS_WIDTH_PX = 9;

  // This includes the tick labels.
  const D3_X_AXIS_HEIGHT_PX = 23;

  // For charts with log y-axes, the y-axis tick values may need to be sanitized
  // if the data is zero or negative.
  function sanitizePower(x, defaultValue) {
    if (!isNaN(x) && isFinite(x) && (x !== 0)) return x;
    return defaultValue;
  }

  const ChartBase2D = tr.ui.b.define('chart-base-2d', tr.ui.b.ChartBase);

  ChartBase2D.prototype = {
    __proto__: tr.ui.b.ChartBase.prototype,

    decorate() {
      super.decorate();
      Polymer.dom(this).classList.add('chart-base-2d');

      this.xScale_ = d3.scale.linear();
      this.yScale_ = d3.scale.linear();
      this.isYLogScale_ = false;
      this.yLogScaleBase_ = 10;
      this.yLogScaleMin_ = undefined;
      this.autoDataRange_ = new tr.b.math.Range();
      this.overrideDataRange_ = undefined;
      this.hideXAxis_ = false;
      this.hideYAxis_ = false;
      this.data_ = [];
      this.xAxisLabel_ = '';
      this.yAxisLabel_ = '';
      this.textHeightPx_ = 0;
      this.unit_ = undefined;

      d3.select(this.chartAreaElement)
          .append('g')
          .attr('id', 'brushes');
      d3.select(this.chartAreaElement)
          .append('g')
          .attr('id', 'series');

      this.addEventListener('mousedown', this.onMouseDown_.bind(this));
    },

    get yLogScaleBase() {
      return this.yLogScaleBase_;
    },

    set yLogScaleBase(b) {
      this.yLogScaleBase_ = b;
    },

    get unit() {
      return this.unit_;
    },

    set unit(unit) {
      this.unit_ = unit;
      this.updateContents_();
    },

    get xAxisLabel() {
      return this.xAxisLabel_;
    },

    set xAxisLabel(label) {
      this.xAxisLabel_ = label;
    },

    get yAxisLabel() {
      return this.yAxisLabel_;
    },

    set yAxisLabel(label) {
      this.yAxisLabel_ = label;
    },

    get hideXAxis() {
      return this.hideXAxis_;
    },

    set hideXAxis(h) {
      this.hideXAxis_ = h;
      this.updateContents_();
    },

    get hideYAxis() {
      return this.hideYAxis_;
    },

    set hideYAxis(h) {
      this.hideYAxis_ = h;
      this.updateContents_();
    },

    get data() {
      return this.data_;
    },

    /**
     * Sets the data array for the object
     *
     * @param {Array} data The data. Each element must be an object, with at
     * least an x property. All other properties become series names in the
     * chart. The data can be sparse (i.e. every x value does not have to
     * contain data for every series).
     */
    set data(data) {
      if (data === undefined) {
        throw new Error('data must be an Array');
      }

      this.data_ = data;
      this.updateSeriesKeys_();
      this.updateDataRange_();
      this.updateContents_();
    },

    set isYLogScale(logScale) {
      if (logScale) {
        this.yScale_ = d3.scale.log().base(this.yLogScaleBase);
      } else {
        this.yScale_ = d3.scale.linear();
      }
      this.isYLogScale_ = logScale;
    },

    getYScaleMin_() {
      return this.isYLogScale_ ? this.yLogScaleMin_ : 0;
    },

    getYScaleDomain_(minValue, maxValue) {
      if (this.overrideDataRange_ !== undefined) {
        return [this.dataRange.min, this.dataRange.max];
      }
      if (this.isYLogScale_) {
        return [this.getYScaleMin_(), maxValue];
      }
      return [Math.min(minValue, this.getYScaleMin_()), maxValue];
    },

    getSampleWidth_(data, index, leftSide) {
      let leftIndex;
      let rightIndex;
      if (leftSide) {
        leftIndex = Math.max(index - 1, 0);
        rightIndex = index;
      } else {
        leftIndex = index;
        rightIndex = Math.min(index + 1, data.length - 1);
      }
      const leftWidth = this.getXForDatum_(data[index], index) -
        this.getXForDatum_(data[leftIndex], leftIndex);
      const rightWidth = this.getXForDatum_(data[rightIndex], rightIndex) -
        this.getXForDatum_(data[index], index);
      return tr.b.math.Statistics.mean([leftWidth, rightWidth]);
    },

    updateSeriesKeys_() {
      // Don't clear seriesByKey_; the caller might have put state in it using
      // getDataSeries() before setting data.
      this.data_.forEach(function(datum) {
        Object.keys(datum).forEach(function(key) {
          if (this.isDatumFieldSeries_(key)) {
            this.getDataSeries(key);
          }
        }, this);
      }, this);
    },

    isDatumFieldSeries_(fieldName) {
      return fieldName !== 'x';
    },

    getXForDatum_(datum, index) {
      return datum.x;
    },

    updateMargins_() {
      this.margin.left = this.hideYAxis ? 0 : this.yAxisWidth;
      this.margin.bottom = this.hideXAxis ? 0 : this.xAxisHeight;

      if (this.hideXAxis && !this.hideYAxis) {
        this.margin.bottom = 10;
      }
      if (this.hideYAxis && !this.hideXAxis) {
        this.margin.left = 10;
      }
      this.margin.top = this.hideYAxis ? 0 : 10;

      if (this.yAxisLabel) {
        this.margin.top += this.textHeightPx_;
      }
      if (this.xAxisLabel) {
        this.margin.right = Math.max(this.margin.right,
            16 + tr.ui.b.getSVGTextSize(this, this.xAxisLabel).width);
      }

      super.updateMargins_();
    },

    get xAxisHeight() {
      return D3_X_AXIS_HEIGHT_PX;
    },

    computeScaleTickWidth_(scale) {
      if (this.data.length === 0) return 0;

      let tickValues = scale.ticks();
      let tickFormat = scale.tickFormat();

      if (this.isYLogScale_) {
        const enclosingPowers = this.dataRange.enclosingPowers();
        tickValues = [];
        const maxPower = sanitizePower(enclosingPowers.max, this.yLogScaleBase);
        for (let power = sanitizePower(enclosingPowers.min, 1);
             power <= maxPower;
             power *= this.yLogScaleBase) {
          tickValues.push(power);
        }
        tickFormat = v => v.toString();
      }

      if (this.unit) {
        tickFormat = v => this.unit.format(v);
      }

      let maxTickWidth = 0;
      for (const tickValue of tickValues) {
        maxTickWidth = Math.max(maxTickWidth,
            tr.ui.b.getSVGTextSize(this, tickFormat(tickValue)).width);
      }

      return D3_Y_AXIS_WIDTH_PX + maxTickWidth;
    },

    get yAxisWidth() {
      return this.computeScaleTickWidth_(this.yScale_);
    },

    updateScales_() {
      if (this.data_.length === 0) return;

      this.xScale_.range([0, this.graphWidth]);
      this.xScale_.domain(d3.extent(this.data_, this.getXForDatum_.bind(this)));

      this.yScale_.range([this.graphHeight, 0]);
      this.yScale_.domain([this.dataRange.min, this.dataRange.max]);
    },

    updateBrushContents_(brushSel) {
      brushSel.selectAll('*').remove();
    },

    updateXAxis_(xAxis) {
      xAxis.selectAll('*').remove();
      xAxis[0][0].style.opacity = 0;
      if (this.hideXAxis) return;

      this.drawXAxis_(xAxis);

      const label = xAxis.append('text').attr('class', 'label');
      this.drawXAxisTicks_(xAxis);
      this.drawXAxisLabel_(label);
      xAxis[0][0].style.opacity = 1;
    },

    drawXAxis_(xAxis) {
      xAxis.attr('transform', 'translate(0,' + this.graphHeight + ')')
          .call(d3.svg.axis()
              .scale(this.xScale_)
              .orient('bottom'));
    },

    drawXAxisLabel_(label) {
      label
          .attr('x', this.graphWidth + 16)
          .attr('y', 8)
          .text(this.xAxisLabel);
    },

    drawXAxisTicks_(xAxis) {
      let previousRight = undefined;
      xAxis.selectAll('.tick')[0].forEach(function(tick) {
        const currentLeft = tick.transform.baseVal[0].matrix.e;
        if ((previousRight === undefined) ||
            (currentLeft > (previousRight + 3))) {
          const currentWidth = tick.getBBox().width;
          previousRight = currentLeft + currentWidth;
        } else {
          tick.style.opacity = 0;
        }
      });
    },

    set overrideDataRange(range) {
      this.overrideDataRange_ = range;
    },

    get dataRange() {
      if (this.overrideDataRange_ !== undefined) {
        return this.overrideDataRange_;
      }
      return this.autoDataRange_;
    },

    updateDataRange_() {
      if (this.overrideDataRange_ !== undefined) return;

      const dataBySeriesKey = this.getDataBySeriesKey_();
      this.autoDataRange_.reset();
      for (const [series, values] of Object.entries(dataBySeriesKey)) {
        for (let i = 0; i < values.length; i++) {
          this.autoDataRange_.addValue(values[i][series]);
        }
      }

      // Choose the closest power of yLogScaleBase, rounded down, as the
      // smallest tick to display.
      this.yLogScaleMin_ = undefined;
      if (this.autoDataRange_.min !== undefined) {
        let minValue = this.autoDataRange_.min;
        if (minValue === 0) {
          minValue = 1;
        }

        const onePowerLess = tr.b.math.lesserPower(
            minValue / this.yLogScaleBase);
        this.yLogScaleMin_ = onePowerLess;
      }
    },

    updateYAxis_(yAxis) {
      yAxis.selectAll('*').remove();
      yAxis[0][0].style.opacity = 0;
      if (this.hideYAxis) return;

      this.drawYAxis_(yAxis);
      this.drawYAxisTicks_(yAxis);

      const label = yAxis.append('text').attr('class', 'label');
      this.drawYAxisLabel_(label);
    },

    drawYAxis_(yAxis) {
      let axisModifier = d3.svg.axis()
        .scale(this.yScale_)
        .orient('left');

      let tickFormat;

      if (this.isYLogScale_) {
        if (this.yLogScaleMin_ === undefined) return;
        const tickValues = [];
        const enclosingPowers = this.dataRange.enclosingPowers();
        const maxPower = sanitizePower(enclosingPowers.max, this.yLogScaleBase);
        for (let power = sanitizePower(enclosingPowers.min, 1);
             power <= maxPower;
             power *= this.yLogScaleBase) {
          tickValues.push(power);
        }

        // The default tickFormat() for log scales always uses scientific
        // notation. Override it to use Number.toString(), which only uses
        // scientific notation for extreme values, and uses decimal notation for
        // a broader range of values. Decimal notation is generally slightly
        // easier to skim than scientific notation in the context of chart axes.
        axisModifier = axisModifier.tickValues(tickValues);
        tickFormat = v => v.toString();
      }

      if (this.unit) {
        tickFormat = v => this.unit.format(v);
      }

      if (tickFormat) {
        axisModifier = axisModifier.tickFormat(tickFormat);
      }

      yAxis.call(axisModifier);
    },

    drawYAxisLabel_(label) {
      const labelWidthPx = Math.ceil(tr.ui.b.getSVGTextSize(
          this.chartAreaElement, this.yAxisLabel).width);
      label
          .attr('x', -labelWidthPx)
          .attr('y', -8)
          .text(this.yAxisLabel);
    },

    drawYAxisTicks_(yAxis) {
      let previousTop = undefined;
      yAxis.selectAll('.tick')[0].forEach(function(tick) {
        const bbox = tick.getBBox();
        const currentTop = tick.transform.baseVal[0].matrix.f;
        const currentBottom = currentTop + bbox.height;
        if ((previousTop === undefined) ||
            (previousTop > (currentBottom + 3))) {
          previousTop = currentTop;
        } else {
          tick.style.opacity = 0;
        }
      });
      yAxis[0][0].style.opacity = 1;
    },

    updateContents_() {
      if (this.textHeightPx_ === 0) {
        // Measure the height of a string that is as tall as it can be,
        // with both an ascender and a descender.
        // https://en.wikipedia.org/wiki/Ascender_(typography)
        this.textHeightPx_ = tr.ui.b.getSVGTextSize(this, 'Ay').height;
        // If the chart is not yet rooted in a document, then the height will be
        // 0. Callers should make sure that updateContents_ is called at least
        // once after the chart is rooted in a document so that textHeightPx_
        // can be computed.
      }

      this.updateScales_();
      super.updateContents_();
      const chartAreaSel = d3.select(this.chartAreaElement);
      this.updateXAxis_(chartAreaSel.select('.x.axis'));
      this.updateYAxis_(chartAreaSel.select('.y.axis'));
      this.updateBrushContents_(chartAreaSel.select('#brushes'));
      this.updateDataContents_(chartAreaSel.select('#series'));
    },

    updateDataContents_(seriesSel) {
      throw new Error('Not implemented');
    },

    /**
     * Returns a map of series key to the data for that series.
     *
     * Example:
     * // returns {y: [{x: 1, y: 1}, {x: 3, y: 3}], z: [{x: 2, z: 2}]}
     * this.data_ = [{x: 1, y: 1}, {x: 2, z: 2}, {x: 3, y: 3}];
     * this.getDataBySeriesKey_();
     * @return {Object} A map of series data by series key.
     */
    getDataBySeriesKey_() {
      const dataBySeriesKey = {};
      for (const [key, series] of this.seriesByKey_) {
        dataBySeriesKey[key] = [];
      }

      this.data_.forEach(function(multiSeriesDatum, index) {
        const x = this.getXForDatum_(multiSeriesDatum, index);

        d3.keys(multiSeriesDatum).forEach(function(seriesKey) {
          // Skip 'x' - it's not a series
          if (seriesKey === 'x') return;

          if (multiSeriesDatum[seriesKey] === undefined) return;

          if (!this.isDatumFieldSeries_(seriesKey)) return;

          const singleSeriesDatum = {x};
          singleSeriesDatum[seriesKey] = multiSeriesDatum[seriesKey];
          dataBySeriesKey[seriesKey].push(singleSeriesDatum);
        }, this);
      }, this);

      return dataBySeriesKey;
    },

    getChartPointAtClientPoint_(clientPoint) {
      const rect = this.getBoundingClientRect();
      return {
        x: clientPoint.x - rect.left - this.margin.left,
        y: clientPoint.y - rect.top - this.margin.top
      };
    },

    getDataPointAtChartPoint_(chartPoint) {
      return {
        x: tr.b.math.clamp(this.xScale_.invert(chartPoint.x),
            this.xScale_.domain()[0], this.xScale_.domain()[1]),
        y: tr.b.math.clamp(this.yScale_.invert(chartPoint.y),
            this.yScale_.domain()[0], this.yScale_.domain()[1])
      };
    },

    getDataPointAtClientPoint_(clientX, clientY) {
      const chartPoint = this.getChartPointAtClientPoint_(
          {x: clientX, y: clientY});
      return this.getDataPointAtChartPoint_(chartPoint);
    },

    prepareDataEvent_(mouseEvent, dataEvent) {
      const dataPoint = this.getDataPointAtClientPoint_(
          mouseEvent.clientX, mouseEvent.clientY);
      dataEvent.x = dataPoint.x;
      dataEvent.y = dataPoint.y;
    },

    onMouseDown_(mouseEvent) {
      tr.ui.b.trackMouseMovesUntilMouseUp(
          this.onMouseMove_.bind(this, mouseEvent.button),
          this.onMouseUp_.bind(this, mouseEvent.button));
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
      const dataEvent = new tr.b.Event('item-mousedown');
      dataEvent.button = mouseEvent.button;
      Polymer.dom(this).classList.add('updating-brushing-state');
      this.prepareDataEvent_(mouseEvent, dataEvent);
      this.dispatchEvent(dataEvent);
    },

    onMouseMove_(button, mouseEvent) {
      if (mouseEvent.buttons !== undefined) {
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
      }
      const dataEvent = new tr.b.Event('item-mousemove');
      dataEvent.button = button;
      this.prepareDataEvent_(mouseEvent, dataEvent);
      this.dispatchEvent(dataEvent);
    },

    onMouseUp_(button, mouseEvent) {
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
      const dataEvent = new tr.b.Event('item-mouseup');
      dataEvent.button = button;
      this.prepareDataEvent_(mouseEvent, dataEvent);
      this.dispatchEvent(dataEvent);
      Polymer.dom(this).classList.remove('updating-brushing-state');
    }
  };

  return {
    ChartBase2D,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const ChartBase2D = tr.ui.b.ChartBase2D;
  const ChartBase2DBrushX = tr.ui.b.define(
      'chart-base-2d-brush-1d', ChartBase2D);

  ChartBase2DBrushX.prototype = {
    __proto__: ChartBase2D.prototype,

    decorate() {
      super.decorate();
      this.brushedRange_ = new tr.b.math.Range();
    },

    set brushedRange(range) {
      this.brushedRange_.reset();
      this.brushedRange_.addRange(range);
      this.updateContents_();
    },

    get brushedRange() {
      return tr.b.math.Range.fromDict(this.brushedRange_.toJSON());
    },

    computeBrushRangeFromIndices(indexA, indexB) {
      indexA = tr.b.math.clamp(indexA, 0, this.data_.length - 1);
      indexB = tr.b.math.clamp(indexB, 0, this.data_.length - 1);
      const leftIndex = Math.min(indexA, indexB);
      const rightIndex = Math.max(indexA, indexB);

      const brushRange = new tr.b.math.Range();
      brushRange.addValue(
          this.getXForDatum_(this.data_[leftIndex], leftIndex) -
          this.getSampleWidth_(this.data_, leftIndex, true));
      brushRange.addValue(
          this.getXForDatum_(this.data_[rightIndex], rightIndex) +
          this.getSampleWidth_(this.data_, rightIndex, false));
      return brushRange;
    },

    getDataIndex_(dataX) {
      if (this.data.length === 0) return undefined;
      const bisect = d3.bisector(this.getXForDatum_.bind(this)).right;
      return bisect(this.data_, dataX) - 1;
    },

    prepareDataEvent_(mouseEvent, dataEvent) {
      ChartBase2D.prototype.prepareDataEvent_.call(
          this, mouseEvent, dataEvent);
      dataEvent.index = this.getDataIndex_(dataEvent.x);
      if (dataEvent.index !== undefined) {
        dataEvent.data = this.data_[dataEvent.index];
      }
    },

    updateBrushContents_(brushSel) {
      brushSel.selectAll('*').remove();
      const brushes = this.brushedRange_.isEmpty ? [] : [this.brushedRange_];
      const brushRectsSel = brushSel.selectAll('rect').data(brushes);
      brushRectsSel.enter().append('rect');
      brushRectsSel.exit().remove();
      this.drawBrush_(brushRectsSel);
    },

    drawBrush_(brushRectsSel) {
      brushRectsSel
          .attr('x', d => this.xScale_(d.min))
          .attr('y', 0)
          .attr('width', d => this.xScale_(d.max) - this.xScale_(d.min))
          .attr('height', this.graphHeight);
    }
  };

  return {
    ChartBase2DBrushX,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const ColumnChart = tr.ui.b.define('column-chart', tr.ui.b.ChartBase2DBrushX);

  ColumnChart.prototype = {
    __proto__: tr.ui.b.ChartBase2DBrushX.prototype,

    decorate() {
      super.decorate();

      // ColumnChart allows bars to have arbitrary, non-uniform widths. Bars
      // need not all be the same width. The width of each bar is automatically
      // computed from the bar's x-coordinate and that of the next bar, which
      // can not define the width of the last bar. This is the width (in the
      // xScale's domain (as opposed to the xScale's range (which is measured in
      // pixels))) of the last bar. When there are at least 2 bars, this is
      // computed as the average width of the bars. When there is a single bar,
      // this must default to a non-zero number so that the width of the only
      // bar will not be zero.
      this.xCushion_ = 1;

      this.isStacked_ = false;

      this.enableHoverBox = true;
      this.displayXInHover = false;
    },

    set isStacked(stacked) {
      this.isStacked_ = true;
      this.updateContents_();
    },

    get isStacked() {
      return this.isStacked_;
    },

    get defaultGraphHeight() {
      return 100;
    },

    get defaultGraphWidth() {
      return 10 * this.data_.length;
    },

    updateScales_() {
      if (this.data_.length === 0) return;

      let xDifferences = 0;
      let currentX = undefined;
      let previousX = undefined;
      this.data_.forEach(function(datum, index) {
        previousX = currentX;
        currentX = this.getXForDatum_(datum, index);
        if (previousX !== undefined) {
          xDifferences += currentX - previousX;
        }
      }, this);

      // X.
      // Leave a cushion on the right so that the last rect doesn't
      // exceed the chart boundaries. The last rect's width is set to the
      // average width of the rects, which is chart.width / data.length.
      this.xScale_.range([0, this.graphWidth]);
      const domain = d3.extent(this.data_, this.getXForDatum_.bind(this));
      if (this.data_.length > 1) {
        this.xCushion_ = xDifferences / (this.data_.length - 1);
      }
      this.xScale_.domain([domain[0], domain[1] + this.xCushion_]);

      // Y.
      this.yScale_.range([this.graphHeight, 0]);
      this.yScale_.domain(this.getYScaleDomain_(
          this.dataRange.min, this.dataRange.max));
    },

    updateDataRange_() {
      if (!this.isStacked) {
        super.updateDataRange_();
        return;
      }

      this.autoDataRange_.reset();
      this.autoDataRange_.addValue(0);
      for (const datum of this.data_) {
        let sum = 0;
        for (const [key, series] of this.seriesByKey_) {
          if (datum[key] === undefined) {
            continue;
          }
          sum += datum[key];
        }
        this.autoDataRange_.addValue(sum);
      }
    },

    getStackedRectsForDatum_(datum, index) {
      const stacks = [];
      let bottom = this.yScale_.range()[0];
      let sum = 0;
      for (const [key, series] of this.seriesByKey_) {
        if (datum[key] === undefined || !this.isSeriesEnabled(key)) {
          continue;
        }

        sum += this.dataRange.clamp(datum[key]);
        const heightPx = bottom - this.yScale_(sum);
        bottom -= heightPx;
        stacks.push({
          key,
          value: datum[key],
          color: this.getDataSeries(key).color,
          heightPx,
          topPx: bottom,
          underflow: sum < this.dataRange.min,
          overflow: sum > this.dataRange.max,
        });
      }
      return stacks;
    },

    getRectsForDatum_(datum, index) {
      if (this.isStacked) {
        return this.getStackedRectsForDatum_(datum, index);
      }

      const stacks = [];
      for (const [key, series] of this.seriesByKey_) {
        if (datum[key] === undefined || !this.isSeriesEnabled(key)) {
          continue;
        }

        const clampedValue = this.dataRange.clamp(datum[key]);
        const topPx = this.yScale_(Math.max(
            clampedValue, this.getYScaleMin_()));
        stacks.push({
          key,
          value: datum[key],
          topPx,
          heightPx: this.yScale_.range()[0] - topPx,
          color: this.getDataSeries(key).color,
          underflow: datum[key] < this.dataRange.min,
          overflow: datum[key] > this.dataRange.max,
        });
      }
      stacks.sort(function(a, b) {
        return b.topPx - a.topPx;
      });
      return stacks;
    },

    drawHoverValueBox_(rect) {
      const rectHoverEvent = new tr.b.Event('rect-mouseenter');
      rectHoverEvent.rect = rect;
      this.dispatchEvent(rectHoverEvent);

      if (!this.enableHoverBox) return;

      const seriesKeys = [...this.seriesByKey_.keys()];
      const chartAreaSel = d3.select(this.chartAreaElement);
      chartAreaSel.selectAll('.hover').remove();
      let keyWidthPx = 0;
      let keyHeightPx = 0;
      if (seriesKeys.length > 1) {
        keyWidthPx = tr.ui.b.getSVGTextSize(
            this.chartAreaElement, rect.key).width + 5;
        keyHeightPx = this.textHeightPx_;
      }

      let xLabelWidthPx = 0;
      let xLabelHeightPx = 0;
      if (this.displayXInHover) {
        xLabelWidthPx = tr.ui.b.getSVGTextSize(
            this.chartAreaElement, rect.datum.x).width + 5;
        xLabelHeightPx = this.textHeightPx_;
      }

      let value = rect.value;
      if (this.unit) value = this.unit.format(value);
      const valueWidthPx = tr.ui.b.getSVGTextSize(
          this.chartAreaElement, value).width + 5;
      const valueHeightPx = this.textHeightPx_;

      const hoverWidthPx = Math.max(keyWidthPx, valueWidthPx, xLabelWidthPx);

      let hoverLeftPx = rect.leftPx + (rect.widthPx / 2);
      hoverLeftPx = Math.max(hoverLeftPx - hoverWidthPx, -this.margin.left);

      const hoverHeightPx = keyHeightPx + valueHeightPx + xLabelHeightPx + 2;

      let hoverTopPx = rect.topPx;
      hoverTopPx = Math.min(
          hoverTopPx, this.getBoundingClientRect().height - hoverHeightPx - 12);

      chartAreaSel
          .append('rect')
          .attr('class', 'hover')
          .on('mouseleave', () => this.clearHoverValueBox_(rect))
          .attr('fill', 'white')
          .attr('stroke', 'black')
          .attr('x', hoverLeftPx)
          .attr('y', hoverTopPx)
          .attr('width', hoverWidthPx)
          .attr('height', hoverHeightPx);

      if (seriesKeys.length > 1) {
        chartAreaSel
            .append('text')
            .attr('class', 'hover')
            .on('mouseleave', () => this.clearHoverValueBox_(rect))
            .attr('fill', rect.color)
            .attr('x', hoverLeftPx + 2)
            .attr('y', hoverTopPx + keyHeightPx - 2)
            .text(rect.key);
      }

      if (this.displayXInHover) {
        chartAreaSel.append('text')
            .attr('class', 'hover')
            .on('mouseleave', () => this.clearHoverValueBox_(rect))
            .attr('fill', rect.color)
            .attr('x', hoverLeftPx + 2)
            .attr('y', hoverTopPx + keyHeightPx + xLabelHeightPx - 2)
            .text(rect.datum.x);
      }

      chartAreaSel
          .append('text')
          .attr('class', 'hover')
          .on('mouseleave', () => this.clearHoverValueBox_(rect))
          .attr('fill', rect.color)
          .attr('x', hoverLeftPx + 2)
          .attr('y', hoverTopPx + hoverHeightPx - 2)
          .text(value);
    },

    clearHoverValueBox_(rect) {
      const event = window.event;
      if (event.relatedTarget &&
          Array.from(event.relatedTarget.classList).includes('hover')) {
        return;
      }

      const rectHoverEvent = new tr.b.Event('rect-mouseleave');
      rectHoverEvent.rect = rect;
      this.dispatchEvent(rectHoverEvent);

      d3.select(this.chartAreaElement).selectAll('.hover').remove();
    },

    drawRect_(rect, sel) {
      sel = sel.data([rect]);
      sel.enter().append('rect')
          .attr('fill', rect.color)
          .attr('x', rect.leftPx)
          .attr('y', rect.topPx)
          .attr('width', rect.widthPx)
          .attr('height', rect.heightPx)
          .on('mouseenter', this.drawHoverValueBox_.bind(this, rect))
          .on('mouseleave', this.clearHoverValueBox_.bind(this, rect));
      sel.exit().remove();
    },

    drawUnderflow_(rect, sel) {
      sel = sel.data([rect]);
      sel.enter().append('text')
          .text('*')
          .attr('fill', rect.color)
          .attr('x', rect.leftPx + (rect.widthPx / 2))
          .attr('y', this.graphHeight)
          .on('mouseenter', this.drawHoverValueBox_.bind(this, rect))
          .on('mouseleave', this.clearHoverValueBox_.bind(this, rect));
      sel.exit().remove();
    },

    drawOverflow_(rect, sel) {
      sel = sel.data([rect]);
      sel.enter().append('text')
          .text('*')
          .attr('fill', rect.color)
          .attr('x', rect.leftPx + (rect.widthPx / 2))
          .attr('y', 0);
      sel.exit().remove();
    },

    updateDataContents_(dataSel) {
      dataSel.selectAll('*').remove();
      const chartAreaSel = d3.select(this.chartAreaElement);
      const seriesKeys = [...this.seriesByKey_.keys()];
      const rectsSel = dataSel.selectAll('path');
      this.data_.forEach(function(datum, index) {
        const currentX = this.getXForDatum_(datum, index);
        let width = undefined;
        if (index < (this.data_.length - 1)) {
          const nextX = this.getXForDatum_(this.data_[index + 1], index + 1);
          width = nextX - currentX;
        } else {
          width = this.xCushion_;
        }
        for (const rect of this.getRectsForDatum_(datum, index)) {
          rect.datum = datum;
          rect.index = index;
          rect.leftPx = this.xScale_(currentX);
          rect.rightPx = this.xScale_(currentX + width);
          rect.widthPx = rect.rightPx - rect.leftPx;
          this.drawRect_(rect, rectsSel);
          if (rect.underflow) {
            this.drawUnderflow_(rect, rectsSel);
          }
          if (rect.overflow) {
            this.drawOverflow_(rect, rectsSel);
          }
        }
      }, this);
    }
  };

  return {
    ColumnChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const MIN_GUIDELINE_HEIGHT_PX = 3;

  const CHECKBOX_WIDTH_PX = 18;

  const NameColumnChart = tr.ui.b.define(
      'name-column-chart', tr.ui.b.ColumnChart);

  NameColumnChart.prototype = {
    __proto__: tr.ui.b.ColumnChart.prototype,

    get xAxisHeight() {
      // Add 5px for descenders because SVG draws text baselines at the
      // specified y-coordinate.
      return 5 + (this.textHeightPx_ * this.data_.length);
    },

    updateMargins_() {
      super.updateMargins_();
      let xAxisTickOverhangPx = 0;
      for (let i = 0; i < this.data_.length; ++i) {
        const datum = this.data_[i];
        xAxisTickOverhangPx = Math.max(xAxisTickOverhangPx,
            this.xScale_(i) + tr.ui.b.getSVGTextSize(this, datum.x).width -
            this.graphWidth);
      }
      this.margin.right = Math.max(this.margin.right, xAxisTickOverhangPx);
    },

    getXForDatum_(datum, index) {
      return index;
    },

    get xAxisTickOffset() {
      return 0.5;
    },

    updateXAxis_(xAxis) {
      xAxis.selectAll('*').remove();
      if (this.hideXAxis) return;

      // Draw the tick labels from |this.data_[*].x|.
      // Lay them out so that the text doesn't overlap.
      // They may overhang into |this.margin.right|.
      const nameTexts = xAxis.selectAll('text')
        .data(this.data_);
      nameTexts
          .enter()
          .append('text')
          .attr('transform', (d, index) => 'translate(0, ' +
            this.textHeightPx_ * (this.data_.length - index) + ')')
          .attr('x', (d, index) => this.xScale_(index))
          .attr('y', d => this.graphHeight)
          .text(d => d.x);
      nameTexts.exit().remove();

      // Draw lines to guide the eye from bottom center of the column to the
      // tick label.
      const guideLines = xAxis.selectAll('line.guide').data(this.data_);
      guideLines.enter()
          .append('line')
          .attr('x1', (d, index) => this.xScale_(index + this.xAxisTickOffset))
          .attr('x2', (d, index) => this.xScale_(index + this.xAxisTickOffset))
          .attr('y1', () => this.graphHeight)
          .attr('y2', (d, index) => this.graphHeight + Math.max(
              MIN_GUIDELINE_HEIGHT_PX,
            (this.textHeightPx_ * (this.data_.length - index - 1))));
    }
  };

  return {
    NameColumnChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const LineChart = tr.ui.b.define('line-chart', tr.ui.b.ChartBase2DBrushX);

  LineChart.prototype = {
    __proto__: tr.ui.b.ChartBase2DBrushX.prototype,

    decorate() {
      super.decorate();
      this.enableHoverBox = true;
      this.displayXInHover = false;
    },

    get defaultGraphWidth() {
      return 20 * this.data_.length;
    },

    get defaultGraphHeight() {
      return 100;
    },

    drawHoverValueBox_(circle) {
      tr.ui.b.ColumnChart.prototype.drawHoverValueBox_.call(this, circle);
    },

    clearHoverValueBox_(circle) {
      tr.ui.b.ColumnChart.prototype.clearHoverValueBox_.call(this, circle);
    },

    updateDataContents_(dataSel) {
      dataSel.selectAll('*').remove();
      const dataBySeriesKey = this.getDataBySeriesKey_();
      const seriesKeys = [...this.seriesByKey_.keys()];
      const pathsSel = dataSel.selectAll('path').data(seriesKeys);
      pathsSel.enter()
          .append('path')
          .style('fill', 'none')
          .style('stroke-width', '1.5px')
          .style('stroke', key => this.getDataSeries(key).color)
          .attr('d', key => {
            const line = d3.svg.line()
                .x(d => this.xScale_(d.x))
                .y(d => this.yScale_(this.dataRange.clamp(d[key])));
            return line(dataBySeriesKey[key]);
          });
      pathsSel.exit().remove();

      if (this.enableHoverBox) {
        for (let index = 0; index < this.data_.length; ++index) {
          const datum = this.data_[index];
          const x = this.getXForDatum_(datum, index);
          for (const [key, value] of Object.entries(datum)) {
            if (key === 'x') continue;
            if (value === undefined) continue;
            const color = this.getDataSeries(key).color;
            const circle = document.createElementNS(
                'http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', this.xScale_(x));
            circle.setAttribute('cy',
                this.yScale_(this.dataRange.clamp(value)));
            circle.setAttribute('r', 5);
            circle.style.fill = color;
            circle.datum = datum;
            circle.key = key;
            circle.value = datum[key];
            circle.leftPx = this.xScale_(x);
            circle.widthPx = 0;
            circle.color = color;
            circle.topPx = this.yScale_(this.dataRange.clamp(value));
            circle.heightPx = 0;
            circle.addEventListener(
                'mouseenter', () => this.drawHoverValueBox_(circle));
            circle.addEventListener(
                'mouseleave', () => this.clearHoverValueBox_(circle));
            dataSel[0][0].appendChild(circle);
          }
        }
      }
    }
  };

  return {
    LineChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const LineChart = tr.ui.b.LineChart;

  // @constructor
  const NameLineChart = tr.ui.b.define('name-line-chart', LineChart);

  NameLineChart.prototype = {
    __proto__: LineChart.prototype,

    getXForDatum_(datum, index) {
      return index;
    },

    get xAxisHeight() {
      // Add 5px for descenders because SVG draws text baselines at the
      // specified y-coordinate.
      return 5 + (this.textHeightPx_ * this.data_.length);
    },

    get xAxisTickOffset() {
      return 0;
    },

    updateMargins_() {
      tr.ui.b.NameColumnChart.prototype.updateMargins_.call(this);
    },

    updateXAxis_(xAxis) {
      xAxis.selectAll('*').remove();
      if (this.hideXAxis) return;

      tr.ui.b.NameColumnChart.prototype.updateXAxis_.call(this, xAxis);

      const baseline = xAxis.selectAll('path').data([this]);
      baseline.enter().append('line')
          .attr('stroke', 'black')
          .attr('x1', this.xScale_(0))
          .attr('x2', this.xScale_(this.data_.length - 1))
          .attr('y1', this.graphHeight)
          .attr('y2', this.graphHeight);
      baseline.exit().remove();
    }
  };

  return {
    NameLineChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const BoxChart = tr.ui.b.define('box-chart', tr.ui.b.NameLineChart);

  BoxChart.prototype = {
    __proto__: tr.ui.b.NameLineChart.prototype,

    get hideLegend() {
      return true;
    },

    updateDataRange_() {
      if (this.overrideDataRange_ !== undefined) {
        return;
      }

      this.autoDataRange_.reset();
      for (const datum of this.data_) {
        this.autoDataRange_.addValue(datum.percentile_0);
        this.autoDataRange_.addValue(datum.percentile_100);
      }
    },

    updateScales_() {
      super.updateScales_();
      this.xScale_.domain([0, this.data_.length]);
    },

    get xAxisTickOffset() {
      return 0.5;
    },

    updateDataRange_() {
      if (this.overrideDataRange_ !== undefined) return;

      this.autoDataRange_.reset();
      for (const datum of this.data_) {
        this.autoDataRange_.addValue(datum.percentile_0);
        this.autoDataRange_.addValue(datum.percentile_100);
      }
    },

    updateXAxis_(xAxis) {
      xAxis.selectAll('*').remove();
      if (this.hideXAxis) return;

      tr.ui.b.NameColumnChart.prototype.updateXAxis_.call(this, xAxis);

      const baseline = xAxis.selectAll('path').data([this]);
      baseline.enter().append('line')
          .attr('stroke', 'black')
          .attr('x1', this.xScale_(0))
          .attr('x2', this.xScale_(this.data_.length))
          .attr('y1', this.graphHeight)
          .attr('y2', this.graphHeight);
      baseline.exit().remove();
    },

    updateDataContents_(dataSel) {
      dataSel.selectAll('*').remove();
      const boxesSel = dataSel.selectAll('path');
      for (let index = 0; index < this.data_.length; ++index) {
        const datum = this.data_[index];
        const color = datum.color || 'black';

        // Draw a box between percentiles 25 and 75:
        let sel = boxesSel.data([datum]);
        sel.enter().append('rect')
            .attr('fill', color)
            .attr('x', this.xScale_(index + 0.2))
            .attr('width',
            this.xScale_(index + 0.8) - this.xScale_(index + 0.2))
            .attr('y', this.yScale_(datum.percentile_75))
            .attr('height', this.yScale_(datum.percentile_25) -
              this.yScale_(datum.percentile_75));
        sel.exit().remove();

        // Draw a horizontal line for percentile_50:
        sel = boxesSel.data([datum]);
        sel.enter().append('line')
            .attr('stroke', color)
            .attr('x1', this.xScale_(index))
            .attr('x2', this.xScale_(index + 1))
            .attr('y1', this.yScale_(datum.percentile_50))
            .attr('y2', this.yScale_(datum.percentile_50));
        sel.exit().remove();

        // Draw two shorter horizontal lines for percentiles 0 and 100:
        sel = boxesSel.data([datum]);
        sel.enter().append('line')
            .attr('stroke', color)
            .attr('x1', this.xScale_(index + 0.4))
            .attr('x2', this.xScale_(index + 0.6))
            .attr('y1', this.yScale_(datum.percentile_0))
            .attr('y2', this.yScale_(datum.percentile_0));
        sel.exit().remove();
        sel = boxesSel.data([datum]);
        sel.enter().append('line')
            .attr('stroke', color)
            .attr('x1', this.xScale_(index + 0.4))
            .attr('x2', this.xScale_(index + 0.6))
            .attr('y1', this.yScale_(datum.percentile_100))
            .attr('y2', this.yScale_(datum.percentile_100));
        sel.exit().remove();

        // Draw a vertical line between percentiles 0 and 100.
        sel = boxesSel.data([datum]);
        sel.enter().append('line')
            .attr('stroke', color)
            .attr('x1', this.xScale_(index + 0.5))
            .attr('x2', this.xScale_(index + 0.5))
            .attr('y1', this.yScale_(datum.percentile_100))
            .attr('y2', this.yScale_(datum.percentile_0));
        sel.exit().remove();
      }
    }
  };

  return {
    BoxChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const BarChart = tr.ui.b.define('bar-chart', tr.ui.b.ColumnChart);

  BarChart.prototype = {
    __proto__: tr.ui.b.ColumnChart.prototype,

    decorate() {
      super.decorate();
      this.verticalScale_ = undefined;
      this.horizontalScale_ = undefined;
    },

    updateScales_() {
      super.updateScales_();
      this.yScale_.range([this.graphWidth, 0]);
      this.xScale_.range([0, this.graphHeight]);
      this.verticalScale_ = this.isYLogScale_ ? d3.scale.log(10) :
        d3.scale.linear();
      this.verticalScale_.domain(this.xScale_.domain());
      this.verticalScale_.range([this.graphHeight, 0]);
      this.horizontalScale_ = d3.scale.linear();
      this.horizontalScale_.domain(this.yScale_.domain());
      this.horizontalScale_.range([0, this.graphWidth]);
    },

    get defaultGraphHeight() {
      return Math.max(20, 10 * this.data_.length);
    },

    get defaultGraphWidth() {
      return 100;
    },

    get barHeight() {
      return this.graphHeight / this.data.length;
    },

    drawBrush_(brushRectsSel) {
      brushRectsSel
          .attr('x', 0)
          .attr('width', this.graphWidth)
          .attr('y', d => this.verticalScale_(d.max))
          .attr('height', d =>
            this.verticalScale_(d.min) - this.verticalScale_(d.max));
    },

    getDataPointAtChartPoint_(chartPoint) {
      const flippedPoint = {
        x: this.graphHeight - chartPoint.y,
        y: this.graphWidth - chartPoint.x
      };
      return super.getDataPointAtChartPoint_(flippedPoint);
    },

    drawXAxis_(xAxis) {
      xAxis.attr('transform', 'translate(0,' + this.graphHeight + ')')
          .call(d3.svg.axis()
              .scale(this.horizontalScale_)
              .orient('bottom'));
    },

    get yAxisWidth() {
      return this.computeScaleTickWidth_(this.verticalScale_);
    },

    drawYAxis_(yAxis) {
      const axisModifier = d3.svg.axis()
        .scale(this.verticalScale_)
        .orient('left');
      yAxis.call(axisModifier);
    },

    drawHoverValueBox_(rect) {
      const rectHoverEvent = new tr.b.Event('rect-mouseenter');
      rectHoverEvent.rect = rect;
      this.dispatchEvent(rectHoverEvent);

      if (!this.enableHoverBox) return;

      const seriesKeys = [...this.seriesByKey_.keys()];
      const chartAreaSel = d3.select(this.chartAreaElement);
      chartAreaSel.selectAll('.hover').remove();
      let keyWidthPx = 0;
      let keyHeightPx = 0;
      let xWidthPx = 0;
      let xHeightPx = 0;
      if (seriesKeys.length > 1) {
        keyWidthPx = tr.ui.b.getSVGTextSize(
            this.chartAreaElement, rect.key).width;
        keyHeightPx = this.textHeightPx_;
      }
      if (this.data.length > 1) {
        xWidthPx = tr.ui.b.getSVGTextSize(
            this.chartAreaElement, '' + rect.datum.x).width;
        xHeightPx = this.textHeightPx_;
      }
      const valueWidthPx = tr.ui.b.getSVGTextSize(
          this.chartAreaElement, rect.value).width;
      const valueHeightPx = this.textHeightPx_;
      const hoverWidthPx = Math.min(
          Math.max(keyWidthPx, xWidthPx, valueWidthPx) + 5,
          Math.max(50, rect.widthPx));
      const hoverTopPx = rect.topPx + (rect.heightPx / 2);
      const hoverLeftPx = rect.leftPx + rect.widthPx - hoverWidthPx;

      chartAreaSel
          .append('rect')
          .attr('class', 'hover')
          .attr('fill', 'white')
          .attr('x', hoverLeftPx)
          .attr('y', hoverTopPx)
          .attr('width', hoverWidthPx)
          .attr('height', keyHeightPx + xHeightPx + valueHeightPx);

      if (seriesKeys.length > 1) {
        chartAreaSel
            .append('text')
            .attr('class', 'hover')
            .attr('fill', rect.color)
            .attr('x', hoverLeftPx + 2)
            .attr('y', hoverTopPx + keyHeightPx - 3)
            .text(rect.key);
      }
      if (this.data.length > 1) {
        chartAreaSel
            .append('text')
            .attr('class', 'hover')
            .attr('fill', rect.color)
            .attr('x', hoverLeftPx + 2)
            .attr('y', hoverTopPx + keyHeightPx + valueHeightPx - 3)
            .text('' + rect.datum.x);
      }

      chartAreaSel
          .append('text')
          .attr('class', 'hover')
          .attr('fill', rect.color)
          .attr('x', hoverLeftPx + 2)
          .attr('y', hoverTopPx + xHeightPx + keyHeightPx + valueHeightPx - 3)
          .text(rect.value);
    },

    flipRect_(rect) {
      // Flip |rect| around |y=x|.
      return {
        datum: rect.datum,
        index: rect.index,
        key: rect.key,
        value: rect.value,
        color: rect.color,
        topPx: this.graphHeight - rect.leftPx - rect.widthPx,
        leftPx: this.graphWidth - rect.topPx - rect.heightPx,
        widthPx: rect.heightPx,
        heightPx: rect.widthPx,
        underflow: rect.underflow,
        overflow: rect.overflow,
      };
    },

    drawRect_(rect, sel) {
      super.drawRect_(this.flipRect_(rect), sel);
    },

    drawUnderflow_(rect, rectsSel) {
      let sel = rectsSel.data([rect]);
      sel.enter().append('text')
          .text('*')
          .attr('fill', rect.color)
          .attr('x', 0)
          .attr('y', this.graphHeight - rect.leftPx +
            3 + (rect.widthPx / 2));
      sel.exit().remove();

      sel = rectsSel.data([rect]);
      sel.enter().append('rect')
          .attr('fill', 'rgba(0, 0, 0, 0)')
          .attr('x', 0)
          .attr('y', this.graphHeight - rect.leftPx - rect.widthPx)
          .attr('width', 10)
          .attr('height', rect.widthPx)
          .on('mouseenter', () => this.drawHoverValueBox_(this.flipRect_(rect)))
          .on('mouseleave', () => this.clearHoverValueBox_(rect));
      sel.exit().remove();
    },

    drawOverflow_(rect, sel) {
      sel = sel.data([rect]);
      sel.enter().append('text')
          .text('*')
          .attr('fill', rect.color)
          .attr('x', this.graphWidth)
          .attr('y', this.graphHeight - rect.leftPx +
            3 + (rect.widthPx / 2));
      sel.exit().remove();
    }
  };

  return {
    BarChart,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const NameBarChart = tr.ui.b.define('name-bar-chart', tr.ui.b.BarChart);

  const Y_AXIS_PADDING = 2;

  NameBarChart.prototype = {
    __proto__: tr.ui.b.BarChart.prototype,

    getDataPointAtChartPoint_(chartPoint) {
      return {
        x: tr.ui.b.BarChart.prototype.getDataPointAtChartPoint_.call(
            this, chartPoint).x,
        y: parseInt(Math.floor(
            (this.graphHeight - chartPoint.y) / this.barHeight))
      };
    },

    getXForDatum_(datum, index) {
      return index;
    },

    get yAxisWidth() {
      if (this.data.length === 0) return 0;
      return Y_AXIS_PADDING + tr.b.math.Statistics.max(
          this.data_, d => tr.ui.b.getSVGTextSize(this, d.x).width);
    },

    get defaultGraphHeight() {
      return (3 + this.textHeightPx_) * this.data.length;
    },

    updateYAxis_(yAxis) {
      // Building the y-axis requires measuring text.
      // If necessary, wait for this element to be displayed.
      if (tr.ui.b.getSVGTextSize(this, 'test').width === 0) {
        tr.b.requestAnimationFrame(() => this.updateYAxis_(yAxis));
        return;
      }

      // When we can measure text, we're ready to build the y-axis.
      yAxis.selectAll('*').remove();
      const nameTexts = yAxis.selectAll('text').data(this.data_);
      nameTexts
          .enter()
          .append('text')
          .attr('x', d => -(
            tr.ui.b.getSVGTextSize(this, d.x).width + Y_AXIS_PADDING))
          .attr('y', (d, index) => this.verticalScale_(index))
          .text(d => d.x);
      nameTexts.exit().remove();

      let previousTop = undefined;
      for (const text of nameTexts[0]) {
        const bbox = text.getBBox();
        if ((previousTop === undefined) ||
            (previousTop > (bbox.y + bbox.height))) {
          previousTop = bbox.y;
        } else {
          text.style.opacity = 0;
        }
      }
    }
  };

  return {
    NameBarChart,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  const DIAGNOSTIC_SPAN_BEHAVIOR = {
    created() {
      this.diagnostic_ = undefined;
      this.name_ = undefined;
      this.histogram_ = undefined;
    },

    attached() {
      if (this.diagnostic_) this.updateContents_();
    },

    get diagnostic() {
      return this.diagnostic_;
    },

    build(diagnostic, name, histogram) {
      this.diagnostic_ = diagnostic;
      this.name_ = name;
      this.histogram_ = histogram;
      if (this.isAttached) this.updateContents_();
    },

    updateContents_() {
      throw new Error('dom-modules must override updateContents_()');
    }
  };

  return {
    DIAGNOSTIC_SPAN_BEHAVIOR,
  };
});


'use strict';

tr.exportTo('tr.v.ui', function() {
  const DEFAULT_COLOR_SCHEME = new tr.b.SinebowColorGenerator();

  class BreakdownTableSummaryRow {
    constructor(displayElement, histogramNames) {
      this.displayElement_ = displayElement;
      this.histogramNames_ = histogramNames;
      this.keySpan_ = undefined;
    }

    get numberValue() {
      // Prevent this row from appearing in the ColumnChart.
      return undefined;
    }

    get keySpan() {
      if (this.keySpan_ === undefined) {
        if (this.histogramNames_.length) {
          this.keySpan_ = document.createElement('tr-ui-a-analysis-link');
          this.keySpan_.setSelectionAndContent(
              this.histogramNames_, 'Select All');
        } else {
          this.keySpan_ = 'Sum';
        }
      }
      return this.keySpan_;
    }

    get name() {
      return 'Sum';
    }

    get displayElement() {
      return this.displayElement_;
    }

    get stringPercent() {
      return '100%';
    }
  }

  class BreakdownTableRow {
    constructor(name, value, unit, color) {
      this.name_ = name;
      this.value = value;
      this.unit = unit;

      if (!this.isHistogram && typeof value !== 'number') {
        throw new Error('unsupported value ' + value);
      }

      this.tableSum_ = undefined;
      this.keySpan_ = undefined;

      this.color_ = color;
      const hsl = this.color.toHSL();
      hsl.l *= 0.85;
      this.highlightedColor_ = tr.b.Color.fromHSL(hsl);

      if (this.isHistogram) {
        this.displayElement_ = tr.v.ui.createScalarSpan(this.numberValue, {
          unit: this.value.unit,
        });
      } else {
        this.displayElement_ = tr.ui.b.createSpan({
          textContent: this.stringValue,
        });
      }
    }

    get isHistogram() {
      return this.value instanceof tr.v.Histogram;
    }

    get name() {
      return this.name_;
    }

    get color() {
      return this.color_;
    }

    get highlightedColor() {
      return this.highlightedColor_;
    }

    get keySpan() {
      if (this.keySpan_ === undefined) {
        if (this.isHistogram) {
          this.keySpan_ = document.createElement('tr-ui-a-analysis-link');
          this.keySpan_.setSelectionAndContent([this.value.name], this.name);
          this.keySpan_.color = this.color;
          this.keySpan_.title = this.value.name;
        } else {
          this.keySpan_ = document.createElement('span');
          this.keySpan_.innerText = this.name;
          this.keySpan_.style.color = this.color;
        }
      }
      return this.keySpan_;
    }

    /**
    * @return {number|undefined}
    */
    get numberValue() {
      if (this.isHistogram) return this.value.sum;
      if (!isNaN(this.value) &&
          (this.value !== Infinity) &&
          (this.value !== -Infinity) &&
          (this.value > 0)) return this.value;
      // Prevent this row from appearing in the ColumnChart.
      return undefined;
    }

    get stringValue() {
      if (!this.isHistogram &&
          (isNaN(this.value) ||
          this.value === Infinity ||
          this.value === -Infinity)) {
        return this.value.toString();
      }
      if (this.unit !== undefined) return this.unit.format(this.value);
      if (this.isHistogram) return this.value.sum.toString();
      return this.value.toString();
    }

    set tableSum(s) {
      this.tableSum_ = s;
    }

    get stringPercent() {
      if (this.tableSum_ === undefined) return '';
      const num = this.numberValue;
      if (num === undefined) return '';
      return Math.floor(num * 100.0 / this.tableSum_) + '%';
    }

    get displayElement() {
      return this.displayElement_;
    }

    compare(other) {
      if (this.numberValue === undefined) {
        if (other.numberValue === undefined) {
          return this.name.localeCompare(other.name);
        }
        return 1;
      }
      if (other.numberValue === undefined) {
        return -1;
      }
      if (this.numberValue === other.numberValue) {
        return this.name.localeCompare(other.name);
      }
      return other.numberValue - this.numberValue;
    }
  }

  Polymer({
    is: 'tr-v-ui-breakdown-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    created() {
      this.chart_ = new tr.ui.b.ColumnChart();
      this.chart_.graphHeight = 130;
      this.chart_.isStacked = true;
      this.chart_.hideXAxis = true;
      this.chart_.hideLegend = true;
      this.chart_.enableHoverBox = false;
      this.chart_.addEventListener('rect-mouseenter',
          event => this.onRectMouseEnter_(event));
      this.chart_.addEventListener('rect-mouseleave',
          event => this.onRectMouseLeave_(event));
    },

    onRectMouseEnter_(event) {
      for (const row of this.$.table.tableRows) {
        if (row.name === event.rect.key) {
          row.displayElement.style.background = event.rect.color;
          row.keySpan.scrollIntoViewIfNeeded();
        } else {
          row.displayElement.style.background = '';
        }
      }
    },

    onRectMouseLeave_(event) {
      for (const row of this.$.table.tableRows) {
        row.displayElement.style.background = '';
      }
    },

    ready() {
      Polymer.dom(this.$.container).appendChild(this.chart_);

      this.$.table.zebra = true;
      this.$.table.showHeader = false;
      this.$.table.tableColumns = [
        {
          value: row => row.keySpan,
        },
        {
          value: row => row.displayElement,
          align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,
        },
        {
          value: row => row.stringPercent,
          align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,
        },
      ];
    },

    updateContents_() {
      this.$.container.style.display = 'none';
      this.$.table.style.display = 'none';
      this.$.empty.style.display = 'block';

      if (!this.diagnostic_) {
        this.chart_.data = [];
        return;
      }

      if (this.histogram_) this.chart_.unit = this.histogram_.unit;

      let colorScheme = undefined;
      // https://github.com/catapult-project/catapult/issues/2970
      if (this.diagnostic.colorScheme ===
          tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER) {
        colorScheme = (name) => {
          let cat = name.split(' ');
          cat = cat[cat.length - 1];
          return tr.e.chrome.ChromeUserFriendlyCategoryDriver.getColor(cat);
        };
      } else if (this.diagnostic.colorScheme !== undefined) {
        colorScheme = (name) => tr.b.FixedColorSchemeRegistry.lookUp(
            this.diagnostic.colorScheme).getColor(name);
      } else {
        colorScheme = (name) => DEFAULT_COLOR_SCHEME.colorForKey(name);
      }

      const tableRows = [];
      let tableSum = 0;
      const histogramNames = [];
      for (const [name, value] of this.diagnostic) {
        const row = new BreakdownTableRow(
            name, value, this.chart_.unit, colorScheme(name));
        tableRows.push(row);
        if (row.numberValue !== undefined) tableSum += row.numberValue;
        if (row.isHistogram) {
          histogramNames.push(value.name);
        }
      }
      tableRows.sort((x, y) => x.compare(y));

      if (tableSum > 0) {
        let summaryDisplayElement = tableSum;
        if (this.chart_.unit !== undefined) {
          summaryDisplayElement = this.chart_.unit.format(tableSum);
        }
        summaryDisplayElement = tr.ui.b.createSpan({
          textContent: summaryDisplayElement,
        });
        tableRows.unshift(new BreakdownTableSummaryRow(
            summaryDisplayElement, histogramNames));
      }

      const chartData = {x: 0};
      for (const row of tableRows) {
        if (row.numberValue === undefined) continue;

        // Let the row compute its percentage.
        row.tableSum = tableSum;

        // Add it to the chart.
        chartData[row.name] = row.numberValue;

        // Configure the colors.
        const dataSeries = this.chart_.getDataSeries(row.name);
        dataSeries.color = row.color;
        dataSeries.highlightedColor = row.highlightedColor;
      }

      if (tableRows.length > 0) {
        this.$.table.style.display = 'block';
        this.$.empty.style.display = 'none';
        this.$.table.tableRows = tableRows;
        this.$.table.rebuild();
      }

      if (Object.keys(chartData).length > 1) {
        this.$.container.style.display = 'block';
        this.$.empty.style.display = 'none';
        this.chart_.data = [chartData];
      }
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-collected-related-event-set-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      Polymer.dom(this).textContent = '';
      for (const [canonicalUrl, events] of this.diagnostic) {
        const link = document.createElement('a');
        if (events.length === 1) {
          const event = tr.b.getOnlyElement(events);
          link.textContent = event.title + ' ' +
            tr.b.Unit.byName.timeDurationInMs.format(event.duration);
        } else {
          link.textContent = events.length + ' events';
        }
        link.href = canonicalUrl;
        Polymer.dom(this).appendChild(link);
        Polymer.dom(this).appendChild(document.createElement('br'));
      }
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-date-range-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      if (this.diagnostic === undefined) {
        Polymer.dom(this).textContent = '';
        return;
      }

      Polymer.dom(this).textContent = this.diagnostic.toString();
    }
  });

  return {};
});


'use strict';

function isTable(object) {
  if (!(object instanceof Array) ||
      (object.length < 2)) return false;
  for (const colName in object[0]) {
    if (typeof colName !== 'string') return false;
  }
  for (let i = 0; i < object.length; ++i) {
    if (!(object[i] instanceof Object)) return false;
    for (const colName in object[i]) {
      if (i && (object[0][colName] === undefined)) return false;
      const cellType = typeof object[i][colName];
      if (cellType !== 'string' && cellType !== 'number') return false;
    }
    if (i) {
      for (const colName in object[0]) {
        if (object[i][colName] === undefined) return false;
      }
    }
  }
  return true;
}

Polymer({
  is: 'tr-ui-a-generic-object-view',

  ready() {
    this.object_ = undefined;
  },

  get object() {
    return this.object_;
  },

  set object(object) {
    this.object_ = object;
    this.updateContents_();
  },

  updateContents_() {
    Polymer.dom(this.$.content).textContent = '';
    this.appendElementsForType_('', this.object_, 0, 0, 5, '');
  },

  appendElementsForType_(
      label, object, indent, depth, maxDepth, suffix) {
    if (depth > maxDepth) {
      this.appendSimpleText_(
          label, indent, '<recursion limit reached>', suffix);
      return;
    }

    if (object === undefined) {
      this.appendSimpleText_(label, indent, 'undefined', suffix);
      return;
    }

    if (object === null) {
      this.appendSimpleText_(label, indent, 'null', suffix);
      return;
    }

    if (!(object instanceof Object)) {
      const type = typeof object;
      if (type !== 'string') {
        return this.appendSimpleText_(label, indent, object, suffix);
      }
      let objectReplaced = false;
      if ((object[0] === '{' && object[object.length - 1] === '}') ||
          (object[0] === '[' && object[object.length - 1] === ']')) {
        try {
          object = JSON.parse(object);
          objectReplaced = true;
        } catch (e) {
        }
      }
      if (!objectReplaced) {
        if (object.includes('\n')) {
          const lines = object.split('\n');
          lines.forEach(function(line, i) {
            let text;
            let ioff;
            let ll;
            let ss;
            if (i === 0) {
              text = '"' + line;
              ioff = 0;
              ll = label;
              ss = '';
            } else if (i < lines.length - 1) {
              text = line;
              ioff = 1;
              ll = '';
              ss = '';
            } else {
              text = line + '"';
              ioff = 1;
              ll = '';
              ss = suffix;
            }

            const el = this.appendSimpleText_(
                ll, indent + ioff * label.length + ioff, text, ss);
            el.style.whiteSpace = 'pre';
            return el;
          }, this);
          return;
        }
        if (tr.b.isUrl(object)) {
          const link = document.createElement('a');
          link.href = object;
          link.textContent = object;
          this.appendElementWithLabel_(label, indent, link, suffix);
          return;
        }
        this.appendSimpleText_(
            label, indent, '"' + object + '"', suffix);
        return;
      }
    }

    if (object instanceof tr.model.ObjectSnapshot) {
      const link = document.createElement('tr-ui-a-analysis-link');
      link.selection = new tr.model.EventSet(object);
      this.appendElementWithLabel_(label, indent, link, suffix);
      return;
    }

    if (object instanceof tr.model.ObjectInstance) {
      const link = document.createElement('tr-ui-a-analysis-link');
      link.selection = new tr.model.EventSet(object);
      this.appendElementWithLabel_(label, indent, link, suffix);
      return;
    }

    if (object instanceof tr.b.math.Rect) {
      this.appendSimpleText_(label, indent, object.toString(), suffix);
      return;
    }

    if (object instanceof tr.b.Scalar) {
      const el = this.ownerDocument.createElement('tr-v-ui-scalar-span');
      el.value = object;
      el.inline = true;
      this.appendElementWithLabel_(label, indent, el, suffix);
      return;
    }

    if (object instanceof Array) {
      this.appendElementsForArray_(
          label, object, indent, depth, maxDepth, suffix);
      return;
    }

    this.appendElementsForObject_(
        label, object, indent, depth, maxDepth, suffix);
  },

  appendElementsForArray_(
      label, object, indent, depth, maxDepth, suffix) {
    if (object.length === 0) {
      this.appendSimpleText_(label, indent, '[]', suffix);
      return;
    }

    if (isTable(object)) {
      const table = document.createElement('tr-ui-b-table');
      const columns = [];
      for (const colName of Object.keys(object[0])) {
        let allStrings = true;
        let allNumbers = true;
        for (let i = 0; i < object.length; ++i) {
          if (typeof(object[i][colName]) !== 'string') {
            allStrings = false;
          }

          if (typeof(object[i][colName]) !== 'number') {
            allNumbers = false;
          }

          if (!allStrings && !allNumbers) break;
        }

        const column = {title: colName};
        column.value = function(row) {
          return row[colName];
        };

        if (allStrings) {
          column.cmp = function(x, y) {
            return x[colName].localeCompare(y[colName]);
          };
        } else if (allNumbers) {
          column.cmp = function(x, y) {
            return x[colName] - y[colName];
          };
        }
        columns.push(column);
      }
      table.tableColumns = columns;
      table.tableRows = object;
      this.appendElementWithLabel_(label, indent, table, suffix);
      table.rebuild();
      return;
    }

    this.appendElementsForType_(
        label + '[',
        object[0],
        indent, depth + 1, maxDepth,
        object.length > 1 ? ',' : ']' + suffix);
    for (let i = 1; i < object.length; i++) {
      this.appendElementsForType_(
          '',
          object[i],
          indent + label.length + 1, depth + 1, maxDepth,
          i < object.length - 1 ? ',' : ']' + suffix);
    }
    return;
  },

  appendElementsForObject_(
      label, object, indent, depth, maxDepth, suffix) {
    const keys = Object.keys(object);
    if (keys.length === 0) {
      this.appendSimpleText_(label, indent, '{}', suffix);
      return;
    }

    this.appendElementsForType_(
        label + '{' + keys[0] + ': ',
        object[keys[0]],
        indent, depth, maxDepth,
        keys.length > 1 ? ',' : '}' + suffix);
    for (let i = 1; i < keys.length; i++) {
      this.appendElementsForType_(
          keys[i] + ': ',
          object[keys[i]],
          indent + label.length + 1, depth + 1, maxDepth,
          i < keys.length - 1 ? ',' : '}' + suffix);
    }
  },

  appendElementWithLabel_(label, indent, dataElement, suffix) {
    const row = document.createElement('div');

    const indentSpan = document.createElement('span');
    indentSpan.style.whiteSpace = 'pre';
    for (let i = 0; i < indent; i++) {
      Polymer.dom(indentSpan).textContent += ' ';
    }
    Polymer.dom(row).appendChild(indentSpan);

    const labelSpan = document.createElement('span');
    Polymer.dom(labelSpan).textContent = label;
    Polymer.dom(row).appendChild(labelSpan);

    Polymer.dom(row).appendChild(dataElement);
    const suffixSpan = document.createElement('span');
    Polymer.dom(suffixSpan).textContent = suffix;
    Polymer.dom(row).appendChild(suffixSpan);

    row.dataElement = dataElement;
    Polymer.dom(this.$.content).appendChild(row);
  },

  appendSimpleText_(label, indent, text, suffix) {
    const el = this.ownerDocument.createElement('span');
    Polymer.dom(el).textContent = text;
    this.appendElementWithLabel_(label, indent, el, suffix);
    return el;
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-generic-object-view-with-label',

  ready() {
    this.labelEl_ = document.createElement('div');
    this.genericObjectView_ =
        document.createElement('tr-ui-a-generic-object-view');
    Polymer.dom(this.root).appendChild(this.labelEl_);
    Polymer.dom(this.root).appendChild(this.genericObjectView_);
  },

  get label() {
    return Polymer.dom(this.labelEl_).textContent;
  },

  set label(label) {
    Polymer.dom(this.labelEl_).textContent = label;
  },

  get object() {
    return this.genericObjectView_.object;
  },

  set object(object) {
    this.genericObjectView_.object = object;
  }
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-generic-set-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      this.$.generic.style.display = 'none';
      this.$.links.textContent = '';
      if (this.diagnostic === undefined) return;
      const values = Array.from(this.diagnostic);

      let areAllStrings = true;
      let areAllNumbers = true;
      for (const value of values) {
        if (typeof value !== 'number') {
          areAllNumbers = false;
          if (typeof value !== 'string') {
            areAllStrings = false;
            break;
          }
        }
      }

      if (!areAllStrings) {
        this.$.generic.style.display = '';
        this.$.generic.object = values;
        return;
      }

      if (areAllNumbers) {
        values.sort((x, y) => x - y);
      } else {
        values.sort();
      }

      for (const value of values) {
        const link = {textContent: '' + value};
        if (tr.b.isUrl(value)) link.href = value;
        if (this.name_ === tr.v.d.RESERVED_NAMES.TRACE_URLS) {
          link.textContent = value.substr(1 + value.lastIndexOf('/'));
        }
        const linkEl = tr.ui.b.createLink(link);
        if (link.href) {
          linkEl.target = '_blank';
          // In case there's a listener in the hierarchy that calls
          // preventDefault(), stop the event from propagating to it so that
          // clicking the link always opens it in a new tab.
          linkEl.addEventListener('click', e => e.stopPropagation());
        }
        this.$.links.appendChild(linkEl);
      }
    }
  });

  return {
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-related-event-set-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      Polymer.dom(this).textContent = '';
      const events = new tr.model.EventSet([...this.diagnostic]);
      const link = document.createElement('tr-ui-a-analysis-link');
      let label = events.length + ' events';
      if (events.length === 1) {
        const event = tr.b.getOnlyElement(events);
        label = event.title + ' ';
        label += tr.b.Unit.byName.timeDurationInMs.format(
            event.duration);
      }
      link.setSelectionAndContent(events, label);
      Polymer.dom(this).appendChild(link);
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-related-histogram-map-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    ready() {
      this.$.table.showHeader = false;
      this.$.table.tableColumns = [
        {value: row => row[0]},
        {value: row => row[1]},
      ];
    },

    updateContents_() {
      Polymer.dom(this).textContent = '';

      const rows = [];

      const histogramNames = new Set();
      for (const [name, hist] of this.diagnostic) {
        histogramNames.add(hist.name);
      }
      if (histogramNames.size > 1) {
        const link = document.createElement('tr-ui-a-analysis-link');
        link.setSelectionAndContent(Array.from(histogramNames), 'Select All');
        rows.push([link, '']);
      }

      for (const [name, hist] of this.diagnostic) {
        const link = document.createElement('tr-ui-a-analysis-link');
        link.setSelectionAndContent([hist.name], name);
        const scalarSpan = tr.v.ui.createScalarSpan(hist);
        rows.push([link, scalarSpan]);
      }
      this.$.table.tableRows = rows;
      this.$.table.rebuild();
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-scalar-diagnostic-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      this.$.scalar.setValueAndUnit(this.diagnostic.value.value,
          this.diagnostic.value.unit);
    }
  });

  return {};
});


'use strict';
Polymer({
  is: 'tr-v-ui-tag-map-span',
  behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

  updateContents_() {
    if (this.diagnostic === undefined) {
      this.$.generic.object = undefined;
      return;
    }

    const obj = {};
    for (const [tag, stories] of this.diagnostic.tagsToStoryNames) {
      obj[tag] = Array.from(stories);
    }
    this.$.generic.object = obj;
  },

  onShow_() {
    this.$.show.style.display = 'none';
    this.$.hide.style.display = 'block';
    this.$.generic.style.display = 'block';
  },

  onHide_() {
    this.$.show.style.display = 'block';
    this.$.hide.style.display = 'none';
    this.$.generic.style.display = 'none';
  },
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-unmergeable-diagnostic-set-span',
    behaviors: [tr.v.ui.DIAGNOSTIC_SPAN_BEHAVIOR],

    updateContents_() {
      Polymer.dom(this).textContent = '';
      for (const diagnostic of this.diagnostic) {
        const div = document.createElement('div');
        div.appendChild(tr.v.ui.createDiagnosticSpan(
            diagnostic, this.name_, this.histogram_));
        Polymer.dom(this).appendChild(div);
      }
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  /**
   * Find the name of a polymer element registered to display |diagnostic|
   * or one of its base classes.
   *
   * @param {!tr.v.d.Diagnostic} diagnostic
   * @return {string}
   */
  function findElementNameForDiagnostic(diagnostic) {
    let typeInfo = undefined;
    let curProto = diagnostic.constructor.prototype;
    while (curProto) {
      typeInfo = tr.v.d.Diagnostic.findTypeInfo(curProto.constructor);
      if (typeInfo && typeInfo.metadata.elementName) break;
      typeInfo = undefined;
      curProto = curProto.__proto__;
    }

    if (typeInfo === undefined) {
      throw new Error(
          diagnostic.constructor.name +
          ' or a base class must have a registered elementName');
    }

    const tagName = typeInfo.metadata.elementName;

    if (tr.ui.b.isUnknownElementName(tagName)) {
      throw new Error('Element not registered: ' + tagName);
    }

    return tagName;
  }

  /**
   * Create a visualization for |diagnostic|.
   *
   * @param {!tr.v.d.Diagnostic} diagnostic
   * @param {string} name
   * @param {!tr.v.Histogram} histogram
   * @return {Element}
   */
  function createDiagnosticSpan(diagnostic, name, histogram) {
    const tagName = findElementNameForDiagnostic(diagnostic);
    const span = document.createElement(tagName);
    if (span.build === undefined) throw new Error(tagName);
    span.build(diagnostic, name, histogram);
    return span;
  }

  return {
    createDiagnosticSpan,
  };
});


'use strict';

tr.exportTo('tr.v.ui', function() {
  function makeColumn(title, histogram) {
    return {
      title,
      value(map) {
        const diagnostic = map.get(title);
        if (!diagnostic) return '';
        return tr.v.ui.createDiagnosticSpan(diagnostic, title, histogram);
      }
    };
  }

  Polymer({
    is: 'tr-v-ui-diagnostic-map-table',

    created() {
      this.diagnosticMaps_ = undefined;
      this.histogram_ = undefined;
      this.isMetadata_ = false;
    },

    set histogram(h) {
      this.histogram_ = h;
    },

    set isMetadata(m) {
      this.isMetadata_ = m;
      this.$.table.showHeader = !this.isMetadata_;
    },

    /**
     * The |title| will be used as the heading for the column containing
     * diagnostic-spans for |diagnosticMap|'s Diagnostics.
     *
     * @param {!Array.<!Object>} maps
     * @param {!string} maps[].title
     * @param {!tr.v.d.DiagnosticMap} maps[].diagnosticMap
     */
    set diagnosticMaps(maps) {
      this.diagnosticMaps_ = maps;
      this.updateContents_();
    },

    get diagnosticMaps() {
      return this.diagnosticMaps_;
    },

    updateContents_() {
      if (this.isMetadata_ && this.diagnosticMaps_.length !== 1) {
        throw new Error(
            'Metadata diagnostic-map-tables require exactly 1 DiagnosticMap');
      }
      if (this.diagnosticMaps_ === undefined ||
          this.diagnosticMaps_.length === 0) {
        this.$.table.tableRows = [];
        this.$.table.tableColumns = [];
        return;
      }

      let names = new Set();
      for (const map of this.diagnosticMaps_) {
        for (const [name, diagnostic] of map) {
          // https://github.com/catapult-project/catapult/issues/2842
          if (diagnostic instanceof tr.v.d.UnmergeableDiagnosticSet) continue;
          if (diagnostic instanceof tr.v.d.CollectedRelatedEventSet) continue;
          if (diagnostic instanceof tr.v.d.GroupingPath) continue;

          names.add(name);
        }
      }
      names = Array.from(names).sort();

      const histogram = this.histogram_;
      if (this.isMetadata_) {
        const diagnosticMap = this.diagnosticMaps_[0];
        this.$.table.tableColumns = [
          {
            value(name) {
              return name.name;
            }
          },
          {
            value(name) {
              const diagnostic = diagnosticMap.get(name.name);
              if (!diagnostic) return '';
              return tr.v.ui.createDiagnosticSpan(
                  diagnostic, name.name, histogram);
            }
          },
        ];
        this.$.table.tableRows = names.map(name => {
          // tr-ui-b-table requires rows to be objects.
          return {name};
        });
      } else {
        this.$.table.tableColumns = names.map(
            name => makeColumn(name, histogram));
        this.$.table.tableRows = this.diagnosticMaps_;
      }

      this.$.table.rebuild();
    }
  });

  return {};
});


'use strict';
tr.exportTo('tr.b', function() {
  class Serializable {
    constructor() {
      Object.defineProperty(this, 'properties_', {
        configurable: false,
        enumerable: false,
        value: new Map(),
      });
    }

    /**
     * @param {string} name
     * @param {!Object} initialValue
     */
    define(name, initialValue) {
      if (this[name] !== undefined) {
        throw new Error(`"${name}" is already defined.`);
      }
      if (name[name.length - 1] === '_') {
        throw new Error(`"${name}" cannot end with an underscore.`);
      }

      this.properties_.set(name, initialValue);

      Object.defineProperty(this, name, {
        configurable: false,
        enumerable: true,
        get: () => this.properties_.get(name),
        set: value => this.setProperty_(name, value),
      });
    }

    setProperty_(name, value) {
      this.properties_.set(name, value);
    }

    clone() {
      return Serializable.fromDict(this.asDict());
    }

    asDict() {
      function visit(obj) {
        if (obj instanceof Serializable) return obj.asDict();
        if (obj instanceof Set) return Array.from(obj);
        if (obj instanceof Array) return obj.map(visit);
        if (!(obj instanceof Map)) return obj;

        const result = {};
        for (const [name, value] of obj) {
          result[name] = visit(value);
        }
        return result;
      }

      const dict = {type: this.constructor.name};
      for (const [name, value] of this.properties_) {
        dict[name.replace(/_$/, '')] = visit(value);
      }
      return dict;
    }

    static fromDict(dict) {
      function visit(d) {
        if (d instanceof Array) return d.map(visit);
        if (!(d instanceof Object)) return d;
        if (typeof d.type === 'string') return Serializable.fromDict(d);

        const result = new Map();
        for (const [name, value] of Object.entries(d)) {
          result.set(name, visit(value));
        }
        return result;
      }

      const typeInfo = Serializable.findTypeInfoWithName(dict.type);
      const result = new typeInfo.constructor();
      for (const [name, value] of Object.entries(dict)) {
        result[name] = visit(value);
      }
      return result;
    }
  }

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Serializable;
  tr.b.decorateExtensionRegistry(Serializable, options);

  return {
    Serializable,
  };
});


'use strict';
tr.exportTo('tr.b', function() {
  /*
   * This is a base class for MVC Model classes.
   * Subclasses must call super() and define() in their constructors to define
   * managed properties.
   * Call addUpdateListener(listener) to listen for update events.
   *
   * When clients set fields on an instance of a subclass of ViewState,
   * an update event will be dispatched containing the delta.
   *
   * Defined properties can optionally contain instances of any ViewState
   * subclass in Arrays, Maps, or Sets, recursively. Update events do not bubble
   * up through parent ViewStateModels. This allows clients to choose whether to
   * listen to every sub-ViewState or select instances. This also allows
   * ViewState subclasses to define circular references if necessary, though
   * that is not supported for serialization.
   */
  class ViewState extends tr.b.Serializable {
    constructor() {
      super();
      tr.b.EventTarget.decorate(this);
    }

    setProperty_(name, value) {
      this.update(new Map([[name, value]]));
    }

    async updateFromViewState(other) {
      await this.update(other.properties_);
    }

    /**
     * Updates properties, and, if any of them actually changed, dispatches
     * an event with delta = {propertyName: {previous, current}}.
     *
     * @param {!(Object|Map)} delta
     */
    async update(delta) {
      // This method only wants to iterate over delta, so convert it to a map.
      if (!(delta instanceof Map)) delta = new Map(Object.entries(delta));

      // Clients presumably want to test for changes to specific fields by name,
      // which is easier with dictionaries, so the actualDelta is a dictionary.
      const actualDelta = {};
      for (const [name, current] of delta) {
        const previous = this[name];
        if (previous === current) continue;

        actualDelta[name] = {previous, current};
        tr.b.Serializable.prototype.setProperty_.call(this, name, current);
      }

      if (Object.keys(actualDelta).length === 0) return;

      await tr.b.dispatchSimpleEventAsync(
          this, this.updateEventName_, {delta: actualDelta});
    }

    get updateEventName_() {
      return this.constructor.name + '.update';
    }

    /**
     * @param {!function(!tr.b.Event)} listener
     */
    addUpdateListener(listener) {
      this.addEventListener(this.updateEventName_, listener);
    }

    /**
     * @param {!function(!tr.b.Event)} listener
     */
    removeUpdateListener(listener) {
      this.removeEventListener(this.updateEventName_, listener);
    }
  }

  return {
    ViewState,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  class HistogramSetViewState extends tr.b.ViewState {
    constructor() {
      super();
      this.define('searchQuery', '');
      this.define('referenceDisplayLabel', '');
      this.define('displayStatisticName', '');
      this.define('showAll', false);
      this.define('groupings', []);
      this.define('sortColumnIndex', 0);
      this.define('sortDescending', false);
      this.define('constrainNameColumn', true);
      this.define('tableRowStates', new Map());
      this.define('alpha', 0.01);
    }
  }

  tr.b.ViewState.register(HistogramSetViewState);

  class HistogramSetTableRowState extends tr.b.ViewState {
    constructor() {
      super();
      this.define('isExpanded', false);
      this.define('isOverviewed', false);
      this.define('cells', new Map());
      this.define('subRows', new Map());
      this.define('diagnosticsTab', '');
    }

    asCompactDict() {
      const result = {};
      if (this.isExpanded) result.e = '1';
      if (this.isOverviewed) result.o = '1';
      if (this.diagnosticsTab) result.d = this.diagnosticsTab;
      const cells = {};
      for (const [name, cell] of this.cells) {
        const cellDict = cell.asCompactDict();
        if (cellDict === undefined) continue;
        cells[name] = cellDict;
      }
      if (Object.keys(cells).length > 0) result.c = cells;

      const subRows = {};
      for (const [name, row] of this.subRows) {
        const rowDict = row.asCompactDict();
        if (rowDict === undefined) continue;
        subRows[name] = rowDict;
      }
      if (Object.keys(subRows).length > 0) result.r = subRows;

      if (Object.keys(result).length === 0) return undefined;

      return result;
    }

    async updateFromCompactDict(dict) {
      await this.update({
        isExpanded: dict.e === '1',
        isOverviewed: dict.o === '1',
        diagnosticsTab: dict.d || '',
      });

      for (const [name, cellDict] of Object.entries(dict.c || {})) {
        const cell = this.cells.get(name);
        if (cell === undefined) continue;
        await cell.updateFromCompactDict(cellDict);
      }

      for (const [name, subRowDict] of Object.entries(dict.r || {})) {
        const subRow = this.subRows.get(name);
        if (subRow === undefined) continue;
        await subRow.updateFromCompactDict(subRowDict);
      }
    }

    * walk() {
      yield this;
      for (const row of this.subRows.values()) yield* row.walk();
    }

    static* walkAll(rootRows) {
      for (const rootRow of rootRows) yield* rootRow.walk();
    }
  }

  tr.b.ViewState.register(HistogramSetTableRowState);

  class HistogramSetTableCellState extends tr.b.ViewState {
    constructor() {
      super();
      this.define('isOpen', false);
      this.define('brushedBinRange', new tr.b.math.Range());
      this.define('mergeSampleDiagnostics', true);
    }

    asCompactDict() {
      const result = {};
      if (this.isOpen) result.o = '1';
      if (!this.mergeSampleDiagnostics) result.m = '0';
      if (!this.brushedBinRange.isEmpty) {
        result.b = this.brushedBinRange.min + '_' + this.brushedBinRange.max;
      }
      if (Object.keys(result).length === 0) return undefined;
      return result;
    }

    async updateFromCompactDict(dict) {
      let binRange = this.brushedBinRange;
      if (dict.b) {
        let [bMin, bMax] = dict.b.split('_');
        bMin = parseInt(bMin);
        bMax = parseInt(bMax);
        if (bMin !== binRange.min || bMax !== binRange.max) {
          binRange = tr.b.math.Range.fromExplicitRange(bMin, bMax);
        }
      }
      await this.update({
        isOpen: dict.o === '1',
        brushedBinRange: binRange,
        mergeSampleDiagnostics: dict.m !== '0',
      });
    }
  }

  tr.b.ViewState.register(HistogramSetTableCellState);

  return {
    HistogramSetTableCellState,
    HistogramSetTableRowState,
    HistogramSetViewState,
  };
});


'use strict';
Polymer({
  is: 'tr-v-ui-scalar-map-table',

  created() {
    /** @type {!Map.<string, !tr.b.Scalar>} */
    this.scalarMap_ = new Map();

    /** @type {!Map.<string, !tr.b.math.Statistics.Significance>} */
    this.significance_ = new Map();
  },

  ready() {
    this.$.table.showHeader = false;
    this.$.table.tableColumns = [
      {
        value(row) {
          return row.name;
        }
      },
      {
        value(row) {
          const span = tr.v.ui.createScalarSpan(row.value);
          if (row.significance !== undefined) {
            span.significance = row.significance;
          } else if (row.anyRowsHaveSignificance) {
            // Ensure vertical alignment.
            span.style.marginRight = '18px';
          }
          span.style.whiteSpace = 'nowrap';
          return span;
        }
      }
    ];
  },

  get scalarMap() {
    return this.scalarMap_;
  },

  /**
   * @param {!Map.<string,!tr.b.Scalar>} map
   */
  set scalarMap(map) {
    this.scalarMap_ = map;
    this.updateContents_();
  },

  /**
   * @param {string} key
   * @param {!tr.b.math.Statistics.Significance} significance
   */
  setSignificanceForKey(key, significance) {
    this.significance_.set(key, significance);
    this.updateContents_();
  },

  updateContents_() {
    const rows = [];
    for (const [key, scalar] of this.scalarMap) {
      rows.push({
        name: key,
        value: scalar,
        significance: this.significance_.get(key),
        anyRowsHaveSignificance: (this.significance_.size > 0)
      });
    }
    this.$.table.tableRows = rows;
    this.$.table.rebuild();
  }
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  const DEFAULT_BAR_HEIGHT_PX = 5;
  const TRUNCATE_BIN_MARGIN = 0.15;
  const IGNORE_DELTA_STATISTICS_NAMES = [
    `${tr.v.DELTA}min`,
    `%${tr.v.DELTA}min`,
    `${tr.v.DELTA}max`,
    `%${tr.v.DELTA}max`,
    `${tr.v.DELTA}sum`,
    `%${tr.v.DELTA}sum`,
    `${tr.v.DELTA}count`,
    `%${tr.v.DELTA}count`,
  ];

  Polymer({
    is: 'tr-v-ui-histogram-span',

    created() {
      this.viewStateListener_ = this.onViewStateUpdate_.bind(this);
      this.viewState = new tr.v.ui.HistogramSetTableCellState();
      this.rowStateListener_ = this.onRowStateUpdate_.bind(this);
      this.rowState = new tr.v.ui.HistogramSetTableRowState();

      this.histogram_ = undefined;
      this.referenceHistogram_ = undefined;
      this.graphWidth_ = undefined;
      this.graphHeight_ = undefined;
      this.mouseDownBin_ = undefined;
      this.prevBrushedBinRange_ = new tr.b.math.Range();
      this.anySampleDiagnostics_ = false;
      this.canMergeSampleDiagnostics_ = true;
      this.alpha_ = undefined;
    },

    get rowState() {
      return this.rowState_;
    },

    set rowState(rs) {
      if (this.rowState) {
        this.rowState.removeUpdateListener(this.rowStateListener_);
      }
      this.rowState_ = rs;
      this.rowState.addUpdateListener(this.rowStateListener_);
      if (this.isAttached) this.updateContents_();
    },

    get viewState() {
      return this.viewState_;
    },

    set viewState(vs) {
      if (this.viewState) {
        this.viewState.removeUpdateListener(this.viewStateListener_);
      }
      this.viewState_ = vs;
      this.viewState.addUpdateListener(this.viewStateListener_);
      if (this.isAttached) this.updateContents_();
    },

    onViewStateUpdate_(event) {
      if (event.delta.brushedBinRange) {
        if (this.chart_ !== undefined) {
          this.chart_.brushedRange = this.viewState.brushedBinRange;
        }
        this.updateDiagnostics_();
      }

      if (event.delta.mergeSampleDiagnostics &&
          (this.viewState.mergeSampleDiagnostics !==
           this.$.merge_sample_diagnostics.checked)) {
        this.$.merge_sample_diagnostics.checked =
          this.canMergeSampleDiagnostics &&
          this.viewState.mergeSampleDiagnostics;
        this.updateDiagnostics_();
      }
    },

    onRowStateUpdate_(event) {
      if (event.delta.diagnosticsTab) {
        if (this.rowState.diagnosticsTab ===
            this.$.sample_diagnostics_container.tabLabel) {
          this.updateDiagnostics_();
        } else {
          for (const tab of this.$.diagnostics.subViews) {
            if (this.rowState.diagnosticsTab === tab.tabLabel) {
              this.$.diagnostics.selectedSubView = tab;
              break;
            }
          }
        }
      }
    },

    ready() {
      this.$.metric_diagnostics.tabLabel = 'histogram diagnostics';
      this.$.sample_diagnostics_container.tabLabel = 'sample diagnostics';
      this.$.metadata_diagnostics.tabLabel = 'metadata';
      this.$.metadata_diagnostics.isMetadata = true;
      this.$.diagnostics.addEventListener(
          'selected-tab-change', this.onSelectedDiagnosticsChanged_.bind(this));
      this.$.drag_handle.target = this.$.container;
      this.$.drag_handle.addEventListener(
          'drag-handle-resize', this.onResize_.bind(this));
    },

    attached() {
      if (this.histogram_ !== undefined) this.updateContents_();
    },

    get canMergeSampleDiagnostics() {
      return this.canMergeSampleDiagnostics_;
    },

    set canMergeSampleDiagnostics(merge) {
      this.canMergeSampleDiagnostics_ = merge;
      if (!merge) this.viewState.mergeSampleDiagnostics = false;
      this.$.merge_sample_diagnostics_container.style.display = (
          merge ? '' : 'none');
    },

    onResize_(event) {
      event.stopPropagation();
      let heightPx = parseInt(this.$.container.style.height);
      if (heightPx < this.defaultGraphHeight) {
        heightPx = this.defaultGraphHeight;
        this.$.container.style.height = this.defaultGraphHeight + 'px';
      }
      this.chart_.graphHeight = heightPx - (this.chart_.margin.top +
          this.chart_.margin.bottom);
      this.$.stats_container.style.maxHeight =
        this.chart_.getBoundingClientRect().height + 'px';
    },

    /**
    * Get the width in pixels of the widest bar in the bar chart, not the total
    * bar chart svg tag, which includes margins containing axes and legend.
    *
    * @return {number}
    */
    get graphWidth() {
      return this.graphWidth_ || this.defaultGraphWidth;
    },

    /**
    * Set the width in pixels of the widest bar in the bar chart, not the total
    * bar chart svg tag, which includes margins containing axes and legend.
    *
    * @param {number} width
    */
    set graphWidth(width) {
      this.graphWidth_ = width;
    },

    /**
    * Get the height in pixels of the bars in the bar chart, not the total
    * bar chart svg tag, which includes margins containing axes and legend.
    *
    * @return {number}
    */
    get graphHeight() {
      return this.graphHeight_ || this.defaultGraphHeight;
    },

    /**
    * Set the height in pixels of the bars in the bar chart, not the total
    * bar chart svg tag, which includes margins containing axes and legend.
    *
    * @param {number} height
    */
    set graphHeight(height) {
      this.graphHeight_ = height;
    },

    /**
    * Get the height in pixels of one bar in the bar chart.
    *
    * @return {number}
    */
    get barHeight() {
      return this.chart_.barHeight;
    },

    /**
    * Set the height in pixels of one bar in the bar chart.
    *
    * @param {number} px
    */
    set barHeight(px) {
      this.graphHeight = this.computeChartHeight_(px);
    },

    computeChartHeight_(barHeightPx) {
      return (this.chart_.margin.top +
          this.chart_.margin.bottom +
          (barHeightPx * this.histogram.allBins.length));
    },

    get defaultGraphHeight() {
      if (this.histogram && this.histogram.allBins.length === 1) {
        return 150;
      }
      return this.computeChartHeight_(DEFAULT_BAR_HEIGHT_PX);
    },

    get defaultGraphWidth() {
      if (this.histogram.allBins.length === 1) {
        return 100;
      }
      return 300;
    },

    get brushedBins() {
      const bins = [];
      if (this.histogram && !this.viewState.brushedBinRange.isEmpty) {
        for (let i = this.viewState.brushedBinRange.min;
            i < this.viewState.brushedBinRange.max; ++i) {
          bins.push(this.histogram.allBins[i]);
        }
      }
      return bins;
    },

    async updateBrushedRange_(binIndex) {
      const brushedBinRange = new tr.b.math.Range();
      brushedBinRange.addValue(tr.b.math.clamp(
          this.mouseDownBinIndex_, 0, this.histogram.allBins.length - 1));
      brushedBinRange.addValue(tr.b.math.clamp(
          binIndex, 0, this.histogram.allBins.length - 1));
      brushedBinRange.max += 1;
      await this.viewState.update({brushedBinRange});
    },

    onMouseDown_(chartEvent) {
      chartEvent.stopPropagation();
      if (!this.histogram) return;
      this.prevBrushedBinRange_ = this.viewState.brushedBinRange;
      this.mouseDownBinIndex_ = chartEvent.y;
      this.updateBrushedRange_(chartEvent.y);
    },

    onMouseMove_(chartEvent) {
      chartEvent.stopPropagation();
      if (!this.histogram) return;
      this.updateBrushedRange_(chartEvent.y);
    },

    onMouseUp_(chartEvent) {
      chartEvent.stopPropagation();
      if (!this.histogram) return;
      this.updateBrushedRange_(chartEvent.y);
      if (this.prevBrushedBinRange_.range === 1 &&
          this.viewState.brushedBinRange.range === 1 &&
          (this.prevBrushedBinRange_.min ===
           this.viewState.brushedBinRange.min)) {
        tr.b.Timing.instant('histogram-span', 'clearBrushedBins');
        this.viewState.update({brushedBinRange: new tr.b.math.Range()});
      } else {
        tr.b.Timing.instant('histogram-span', 'brushBins');
      }
      this.mouseDownBinIndex_ = undefined;
    },

    async onSelectedDiagnosticsChanged_() {
      await this.rowState.update({
        diagnosticsTab: this.$.diagnostics.selectedSubView.tabLabel,
      });
      if ((this.$.diagnostics.selectedSubView ===
           this.$.sample_diagnostics_container) &&
          this.histogram &&
          this.viewState.brushedBinRange.isEmpty) {
        // When the user selects the sample diagnostics tab, if they haven't
        // already brushed any bins, then automatically brush all bins.
        const brushedBinRange = tr.b.math.Range.fromExplicitRange(
            0, this.histogram.allBins.length);
        await this.viewState.update({brushedBinRange});
        this.updateDiagnostics_();
      }
    },

    updateDiagnostics_() {
      let maps = [];
      for (const bin of this.brushedBins) {
        for (const map of bin.diagnosticMaps) {
          maps.push(map);
        }
      }

      if (this.$.merge_sample_diagnostics.checked !==
          this.viewState.mergeSampleDiagnostics) {
        this.viewState.update({
          mergeSampleDiagnostics: this.$.merge_sample_diagnostics.checked});
      }

      if (this.viewState.mergeSampleDiagnostics) {
        const merged = new tr.v.d.DiagnosticMap();
        for (const map of maps) {
          merged.addDiagnostics(map);
        }
        maps = [merged];
      }

      const mark = tr.b.Timing.mark('histogram-span',
          (this.viewState.mergeSampleDiagnostics ? 'merge' : 'split') +
           'SampleDiagnostics');
      this.$.sample_diagnostics.diagnosticMaps = maps;
      mark.end();

      if (this.anySampleDiagnostics_) {
        this.$.diagnostics.selectedSubView =
          this.$.sample_diagnostics_container;
      }
    },

    get histogram() {
      return this.histogram_;
    },

    set histogram(histogram) {
      if (histogram === this.histogram_) return;
      this.histogram_ = histogram;
      this.$.metric_diagnostics.histogram = histogram;
      this.$.sample_diagnostics.histogram = histogram;

      this.anySampleDiagnostics_ = false;
      for (const bin of this.histogram.allBins) {
        if (bin.diagnosticMaps.length > 0) {
          this.anySampleDiagnostics_ = true;
          break;
        }
      }

      if (this.isAttached) this.updateContents_();
    },

    get referenceHistogram() {
      return this.referenceHistogram_;
    },

    set referenceHistogram(histogram) {
      if (histogram === this.referenceHistogram_) {
        return;
      }
      this.referenceHistogram_ = histogram;
      if (this.histogram) this.updateContents_();
    },

    set alpha(a) {
      if (tr.b.math.approximately(a, this.alpha_)) return;
      this.alpha_ = a;
      if (this.referenceHistogram) this.updateContents_();
    },

    getDeltaScalars_(statNames, scalarMap) {
      if (!this.histogram.canCompare(this.referenceHistogram)) return;

      const mwu = tr.b.math.Statistics.mwu(
          this.histogram.sampleValues,
          this.referenceHistogram.sampleValues,
          this.alpha_);

      for (const deltaStatName of tr.v.Histogram.getDeltaStatisticsNames(
          statNames)) {
        if (IGNORE_DELTA_STATISTICS_NAMES.includes(deltaStatName)) continue;
        const scalar = this.histogram.getStatisticScalar(
            deltaStatName, this.referenceHistogram, mwu);
        if (scalar === undefined) continue;
        scalarMap.set(deltaStatName, scalar);
      }

      if (this.histogram.unit.improvementDirection !==
          tr.b.ImprovementDirection.DONT_CARE) {
        this.$.stats.setSignificanceForKey(
            `${tr.v.DELTA}avg`, mwu.significance);
      }
    },

    set isYLogScale(logScale) {
      this.chart_.isYLogScale = logScale;
    },

    async updateContents_() {
      this.$.chart.style.display = 'none';
      this.$.drag_handle.style.display = 'none';
      this.$.container.style.justifyContent = '';

      while (Polymer.dom(this.$.chart).lastChild) {
        Polymer.dom(this.$.chart).removeChild(
            Polymer.dom(this.$.chart).lastChild);
      }

      if (!this.histogram) return;
      this.$.container.style.display = '';

      const scalarMap = new Map();
      this.getDeltaScalars_(this.histogram.statisticsNames, scalarMap);
      for (const [name, scalar] of this.histogram.statisticsScalars) {
        scalarMap.set(name, scalar);
      }
      this.$.stats.scalarMap = scalarMap;

      const metricDiagnosticMap = new tr.v.d.DiagnosticMap();
      const metadataDiagnosticMap = new tr.v.d.DiagnosticMap();
      for (const [key, diagnostic] of this.histogram.diagnostics) {
        // Hide the 'mergedFrom' and 'mergedTo' diagnostics, which are
        // implementation details.
        if (key === tr.v.d.RESERVED_NAMES.MERGED_FROM) continue;
        if (key === tr.v.d.RESERVED_NAMES.MERGED_TO) continue;
        if (tr.v.d.RESERVED_NAMES_SET.has(key)) {
          metadataDiagnosticMap.set(key, diagnostic);
        } else {
          metricDiagnosticMap.set(key, diagnostic);
        }
      }

      const diagnosticTabs = [];
      if (metricDiagnosticMap.size) {
        this.$.metric_diagnostics.diagnosticMaps = [metricDiagnosticMap];
        diagnosticTabs.push(this.$.metric_diagnostics);
      }
      if (this.anySampleDiagnostics_) {
        diagnosticTabs.push(this.$.sample_diagnostics_container);
      }
      if (metadataDiagnosticMap.size) {
        this.$.metadata_diagnostics.diagnosticMaps = [metadataDiagnosticMap];
        diagnosticTabs.push(this.$.metadata_diagnostics);
      }
      this.$.diagnostics.resetSubViews(diagnosticTabs);
      this.$.diagnostics.set('tabsHidden', diagnosticTabs.length < 2);

      if (this.histogram.numValues <= 1) {
        await this.viewState.update({
          brushedBinRange: tr.b.math.Range.fromExplicitRange(
              0, this.histogram.allBins.length)});
        this.$.container.style.justifyContent = 'flex-end';
        return;
      }

      this.$.chart.style.display = 'block';
      this.$.drag_handle.style.display = 'block';

      if (this.histogram.allBins.length === 1) {
        if (this.histogram.min !== this.histogram.max) {
          this.chart_ = new tr.ui.b.BoxChart();
          Polymer.dom(this.$.chart).appendChild(this.chart_);
          this.chart_.graphWidth = this.graphWidth;
          this.chart_.graphHeight = this.graphHeight;
          this.chart_.hideXAxis = true;
          this.chart_.data = [
            {
              x: '',
              color: 'blue',
              percentile_0: this.histogram.running.min,
              percentile_25: this.histogram.getApproximatePercentile(0.25),
              percentile_50: this.histogram.getApproximatePercentile(0.5),
              percentile_75: this.histogram.getApproximatePercentile(0.75),
              percentile_100: this.histogram.running.max,
            }
          ];
        }
        this.$.stats_container.style.maxHeight =
          this.chart_.getBoundingClientRect().height + 'px';
        await this.viewState.update({
          brushedBinRange: tr.b.math.Range.fromExplicitRange(
              0, this.histogram.allBins.length)});
        return;
      }

      this.chart_ = new tr.ui.b.NameBarChart();
      Polymer.dom(this.$.chart).appendChild(this.chart_);
      this.chart_.graphWidth = this.graphWidth;
      this.chart_.graphHeight = this.graphHeight;
      this.chart_.addEventListener('item-mousedown',
          this.onMouseDown_.bind(this));
      this.chart_.addEventListener('item-mousemove',
          this.onMouseMove_.bind(this));
      this.chart_.addEventListener('item-mouseup',
          this.onMouseUp_.bind(this));
      this.chart_.hideLegend = true;
      this.chart_.getDataSeries('y').color = 'blue';
      this.chart_.xAxisLabel = '#';
      this.chart_.brushedRange = this.viewState.brushedBinRange;
      if (!this.viewState.brushedBinRange.isEmpty) {
        this.updateDiagnostics_();
      }

      const chartData = [];
      const binCounts = [];
      for (const bin of this.histogram.allBins) {
        let x = bin.range.min;
        if (x === -Number.MAX_VALUE) {
          x = '<' + new tr.b.Scalar(
              this.histogram.unit, bin.range.max).toString();
        } else {
          x = new tr.b.Scalar(this.histogram.unit, x).toString();
        }
        chartData.push({x, y: bin.count});
        binCounts.push(bin.count);
      }

      // If the largest 1 or 2 bins are more than twice as large as the next
      // largest bin, then set the dataRange max to TRUNCATE_BIN_MARGIN% more
      // than that next largest bin.
      binCounts.sort((x, y) => y - x);
      const dataRange = tr.b.math.Range.fromExplicitRange(0, binCounts[0]);
      if (binCounts[1] > 0 && binCounts[0] > (binCounts[1] * 2)) {
        dataRange.max = binCounts[1] * (1 + TRUNCATE_BIN_MARGIN);
      }
      if (binCounts[2] > 0 && binCounts[1] > (binCounts[2] * 2)) {
        dataRange.max = binCounts[2] * (1 + TRUNCATE_BIN_MARGIN);
      }
      this.chart_.overrideDataRange = dataRange;

      this.chart_.data = chartData;
      this.$.stats_container.style.maxHeight =
        this.chart_.getBoundingClientRect().height + 'px';
    }
  });
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const EVENT_FIELD = [
    {key: 'start', label: 'Start'},
    {key: 'cpuDuration', label: 'CPU Duration'},
    {key: 'duration', label: 'Duration'},
    {key: 'cpuSelfTime', label: 'CPU Self Time'},
    {key: 'selfTime', label: 'Self Time'}
  ];

  function buildDiagnostics_(slice) {
    const diagnostics = {};
    for (const item of EVENT_FIELD) {
      const fieldName = item.key;
      if (slice[fieldName] === undefined) continue;
      diagnostics[fieldName] = new tr.v.d.Scalar(new tr.b.Scalar(
        tr.b.Unit.byName.timeDurationInMs, slice[fieldName]));
    }
    diagnostics.args = new tr.v.d.GenericSet([slice.args]);
    diagnostics.event = new tr.v.d.RelatedEventSet(slice);
    return diagnostics;
  }

  Polymer({
    is: 'tr-ui-a-multi-event-sub-view',
    behaviors: [tr.ui.analysis.AnalysisSubView],

    created() {
      this.currentSelection_ = undefined;
      this.eventsHaveDuration_ = true;
      this.eventsHaveSubRows_ = true;
    },

    ready() {
      this.$.radioPicker.style.display = 'none';
      this.$.radioPicker.items = EVENT_FIELD;
      this.$.radioPicker.select('cpuSelfTime');
      this.$.radioPicker.addEventListener('change', () => {
        if (this.isAttached) this.updateContents_();
      });

      this.$.histogramSpan.graphWidth = 400;
      this.$.histogramSpan.canMergeSampleDiagnostics = false;
      this.$.histogramContainer.style.display = 'none';
    },

    attached() {
      if (this.currentSelection_ !== undefined) this.updateContents_();
    },

    set selection(selection) {
      if (selection.length <= 1) {
        throw new Error('Only supports multiple items');
      }
      this.setSelectionWithoutErrorChecks(selection);
    },

    get selection() {
      return this.currentSelection_;
    },

    setSelectionWithoutErrorChecks(selection) {
      this.currentSelection_ = selection;
      if (this.isAttached) this.updateContents_();
    },

    get eventsHaveDuration() {
      return this.eventsHaveDuration_;
    },

    set eventsHaveDuration(eventsHaveDuration) {
      this.eventsHaveDuration_ = eventsHaveDuration;
      if (this.isAttached) this.updateContents_();
    },

    get eventsHaveSubRows() {
      return this.eventsHaveSubRows_;
    },

    set eventsHaveSubRows(eventsHaveSubRows) {
      this.eventsHaveSubRows_ = eventsHaveSubRows;
      if (this.isAttached) this.updateContents_();
    },

    buildHistogram_(selectedKey) {
      let leftBoundary = Number.MAX_VALUE;
      let rightBoundary = tr.b.math.Statistics.percentile(
          this.currentSelection_, 0.95,
          function(value) {
            leftBoundary = Math.min(leftBoundary, value[selectedKey]);
            return value[selectedKey];
          });

      if (leftBoundary === rightBoundary) rightBoundary += 1;
      const histogram = new tr.v.Histogram(
        '',
        tr.b.Unit.byName.timeDurationInMs,
        tr.v.HistogramBinBoundaries.createLinear(
            leftBoundary, rightBoundary,
            Math.ceil(Math.sqrt(this.currentSelection_.length))));
      histogram.customizeSummaryOptions({sum: false});
      for (const slice of this.currentSelection_) {
        histogram.addSample(slice[selectedKey],
            buildDiagnostics_(slice));
      }

      return histogram;
    },

    updateContents_() {
      const selection = this.currentSelection_;
      if (!selection) return;

      const eventsByTitle = selection.getEventsOrganizedByTitle();
      const numTitles = Object.keys(eventsByTitle).length;

      this.$.eventSummaryTable.configure({
        showTotals: numTitles > 1,
        eventsByTitle,
        eventsHaveDuration: this.eventsHaveDuration_,
        eventsHaveSubRows: this.eventsHaveSubRows_
      });

      this.$.selectionSummaryTable.selection = this.currentSelection_;

      if (numTitles === 1) {
        this.$.radioPicker.style.display = 'block';
        this.$.histogramContainer.style.display = 'flex';
        this.$.histogramSpan.histogram =
          this.buildHistogram_(this.$.radioPicker.selectedKey);
        if (this.$.histogramSpan.histogram.numValues === 0) {
          this.$.histogramContainer.style.display = 'none';
        }
      } else {
        this.$.radioPicker.style.display = 'none';
        this.$.histogramContainer.style.display = 'none';
      }
    }
  });

  return {};
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const FLOW_IN = 0x1;
  const FLOW_OUT = 0x2;
  const FLOW_IN_OUT = FLOW_IN | FLOW_OUT;

  function FlowClassifier() {
    this.numEvents_ = 0;
    this.eventsByGUID_ = {};
  }

  FlowClassifier.prototype = {
    getFS_(event) {
      let fs = this.eventsByGUID_[event.guid];
      if (fs === undefined) {
        this.numEvents_++;
        fs = {
          state: 0,
          event
        };
        this.eventsByGUID_[event.guid] = fs;
      }
      return fs;
    },

    addInFlow(event) {
      const fs = this.getFS_(event);
      fs.state |= FLOW_IN;
      return event;
    },

    addOutFlow(event) {
      const fs = this.getFS_(event);
      fs.state |= FLOW_OUT;
      return event;
    },

    hasEvents() {
      return this.numEvents_ > 0;
    },

    get inFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN) {
          selection.push(fs.event);
        }
      }
      return selection;
    },

    get outFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_OUT) {
          selection.push(fs.event);
        }
      }
      return selection;
    },

    get internalFlowEvents() {
      const selection = new tr.model.EventSet();
      for (const guid in this.eventsByGUID_) {
        const fs = this.eventsByGUID_[guid];
        if (fs.state === FLOW_IN_OUT) {
          selection.push(fs.event);
        }
      }
      return selection;
    }
  };

  return {
    FlowClassifier,
  };
});


'use strict';

function* getEventInFlowEvents(event) {
  if (!event.inFlowEvents) return;
  yield* event.inFlowEvents;
}

function* getEventOutFlowEvents(event) {
  if (!event.outFlowEvents) return;
  yield* event.outFlowEvents;
}

function* getEventAncestors(event) {
  if (!event.enumerateAllAncestors) return;
  yield* event.enumerateAllAncestors();
}

function* getEventDescendents(event) {
  if (!event.enumerateAllDescendents) return;
  yield* event.enumerateAllDescendents();
}

Polymer({
  is: 'tr-ui-a-related-events',

  ready() {
    this.eventGroups_ = [];
    this.cancelFunctions_ = [];

    this.$.table.tableColumns = [
      {
        title: 'Event(s)',
        value(row) {
          const typeEl = document.createElement('span');
          typeEl.innerText = row.type;
          if (row.tooltip) {
            typeEl.title = row.tooltip;
          }
          return typeEl;
        },
        width: '150px'
      },
      {
        title: 'Link',
        width: '100%',
        value(row) {
          const linkEl = document.createElement('tr-ui-a-analysis-link');
          if (row.name) {
            linkEl.setSelectionAndContent(row.selection, row.name);
          } else {
            linkEl.selection = row.selection;
          }
          return linkEl;
        }
      }
    ];
  },

  hasRelatedEvents() {
    return (this.eventGroups_ && this.eventGroups_.length > 0);
  },

  setRelatedEvents(eventSet) {
    this.cancelAllTasks_();
    this.eventGroups_ = [];
    this.addRuntimeCallStats_(eventSet);
    this.addOverlappingV8ICStats_(eventSet);
    this.addV8GCObjectStats_(eventSet);
    this.addV8Slices_(eventSet);
    this.addConnectedFlows_(eventSet);
    this.addConnectedEvents_(eventSet);
    this.addOverlappingSamples_(eventSet);
    this.updateContents_();
  },

  addConnectedFlows_(eventSet) {
    const classifier = new tr.ui.analysis.FlowClassifier();
    eventSet.forEach(function(slice) {
      if (slice.inFlowEvents) {
        slice.inFlowEvents.forEach(function(flow) {
          classifier.addInFlow(flow);
        });
      }
      if (slice.outFlowEvents) {
        slice.outFlowEvents.forEach(function(flow) {
          classifier.addOutFlow(flow);
        });
      }
    });
    if (!classifier.hasEvents()) return;

    const addToEventGroups = function(type, flowEvent) {
      this.eventGroups_.push({
        type,
        selection: new tr.model.EventSet(flowEvent),
        name: flowEvent.title
      });
    };

    classifier.inFlowEvents.forEach(
        addToEventGroups.bind(this, 'Incoming flow'));
    classifier.outFlowEvents.forEach(
        addToEventGroups.bind(this, 'Outgoing flow'));
    classifier.internalFlowEvents.forEach(
        addToEventGroups.bind(this, 'Internal flow'));
  },

  cancelAllTasks_() {
    this.cancelFunctions_.forEach(function(cancelFunction) {
      cancelFunction();
    });
    this.cancelFunctions_ = [];
  },

  addConnectedEvents_(eventSet) {
    this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
        'Preceding events',
        'Add all events that have led to the selected one(s), connected by ' +
            'flow arrows or by call stack.',
        eventSet,
        function* (event) {
          yield* getEventInFlowEvents(event);
          yield* getEventAncestors(event);
          if (event.startSlice) {
            yield event.startSlice;
          }
        }.bind(this)));
    this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
        'Following events',
        'Add all events that have been caused by the selected one(s), ' +
            'connected by flow arrows or by call stack.',
        eventSet,
        function* (event) {
          yield* getEventOutFlowEvents(event);
          yield* getEventDescendents(event);
          if (event.endSlice) {
            yield event.endSlice;
          }
        }.bind(this)));
    this.cancelFunctions_.push(this.createEventsLinkIfNeeded_(
        'All connected events',
        'Add all events connected to the selected one(s) by flow arrows or ' +
            'by call stack.',
        eventSet,
        function* (event) {
          yield* getEventInFlowEvents(event);
          yield* getEventOutFlowEvents(event);
          yield* getEventAncestors(event);
          yield* getEventDescendents(event);
          if (event.startSlice) {
            yield event.startSlice;
          }
          if (event.endSlice) {
            yield event.endSlice;
          }
        }.bind(this)));
  },

  createEventsLinkIfNeeded_(title, tooltip, events, connectedFn) {
    events = new tr.model.EventSet(events);
    const eventsToProcess = new Set(events);
    // for (let event of events)
    //  eventsToProcess.add(event);
    let wasChanged = false;
    let task;
    let isCanceled = false;
    function addEventsUntilTimeout() {
      if (isCanceled) return;
      // Let's grant ourselves a budget of 8 ms. If time runs out, then
      // create another task to do the rest.
      const timeout = window.performance.now() + 8;
      // TODO(alexandermont): Don't check window.performance.now
      // every iteration.
      while (eventsToProcess.size > 0 &&
          window.performance.now() <= timeout) {
        // Get the next event.
        const nextEvent = tr.b.getFirstElement(eventsToProcess);
        eventsToProcess.delete(nextEvent);

        // Add the connected events to the list.
        for (const eventToAdd of connectedFn(nextEvent)) {
          if (!events.contains(eventToAdd)) {
            events.push(eventToAdd);
            eventsToProcess.add(eventToAdd);
            wasChanged = true;
          }
        }
      }
      if (eventsToProcess.size > 0) {
        // There are still events to process, but we ran out of time. Post
        // more work for later.
        const newTask = new tr.b.Task(
              addEventsUntilTimeout.bind(this), this);
        task.after(newTask);
        task = newTask;
        return;
      }
      // Went through all events, add the link.
      if (!wasChanged) return;
      this.eventGroups_.push({
        type: title,
        tooltip,
        selection: events
      });
      this.updateContents_();
    }
    function cancelTask() {
      isCanceled = true;
    }
    task = new tr.b.Task(addEventsUntilTimeout.bind(this), this);
    tr.b.Task.RunWhenIdle(task);
    return cancelTask;
  },

  addOverlappingSamples_(eventSet) {
    const samples = new tr.model.EventSet();
    for (const slice of eventSet) {
      if (!slice.parentContainer || !slice.parentContainer.samples) {
        continue;
      }
      const candidates = slice.parentContainer.samples;
      const range = tr.b.math.Range.fromExplicitRange(
          slice.start, slice.start + slice.duration);
      const filteredSamples = range.filterArray(
          candidates, function(value) {return value.start;});
      for (const sample of filteredSamples) {
        samples.push(sample);
      }
    }
    if (samples.length > 0) {
      this.eventGroups_.push({
        type: 'Overlapping samples',
        tooltip: 'All samples overlapping the selected slice(s).',
        selection: samples
      });
    }
  },

  addV8Slices_(eventSet) {
    const v8Slices = new tr.model.EventSet();
    for (const slice of eventSet) {
      if (slice.category === 'v8') {
        v8Slices.push(slice);
      }
    }
    if (v8Slices.length > 0) {
      this.eventGroups_.push({
        type: 'V8 Slices',
        tooltip: 'All V8 slices in the selected slice(s).',
        selection: v8Slices
      });
    }
  },

  addRuntimeCallStats_(eventSet) {
    const slices = eventSet.filter(function(slice) {
      return (slice.category === 'v8' ||
              slice.category === 'disabled-by-default-v8.runtime_stats') &&
        slice.runtimeCallStats;
    });
    if (slices.length > 0) {
      this.eventGroups_.push({
        type: 'Runtime call stats table',
        // eslint-disable-next-line
        tooltip: 'All V8 slices containing runtime call stats table in the selected slice(s).',
        selection: slices
      });
    }
  },

  addV8GCObjectStats_(eventSet) {
    const slices = new tr.model.EventSet();
    for (const slice of eventSet) {
      if (slice.title === 'V8.GC_Objects_Stats') {
        slices.push(slice);
      }
    }
    if (slices.length > 0) {
      this.eventGroups_.push({
        type: 'V8 GC stats table',
        tooltip: 'All V8 GC statistics slices in the selected set.',
        selection: slices
      });
    }
  },

  addOverlappingV8ICStats_(eventSet) {
    const slices = new tr.model.EventSet();
    for (const slice of eventSet) {
      if (!slice.parentContainer || !slice.parentContainer.sliceGroup) {
        continue;
      }
      const sliceGroup = slice.parentContainer.sliceGroup.slices;
      const range = tr.b.math.Range.fromExplicitRange(
          slice.start, slice.start + slice.duration);
      const filteredSlices = range.filterArray(
          sliceGroup, value => value.start);
      const icSlices = filteredSlices.filter(x => x.title === 'V8.ICStats');
      for (const icSlice of icSlices) {
        slices.push(icSlice);
      }
    }
    if (slices.length > 0) {
      this.eventGroups_.push({
        type: 'Overlapping V8 IC stats',
        tooltip: 'All V8 IC statistics overlapping the selected set.',
        selection: slices
      });
    }
  },

  updateContents_() {
    const table = this.$.table;
    if (this.eventGroups_ === undefined) {
      table.tableRows = [];
    } else {
      table.tableRows = this.eventGroups_.slice();
    }
    table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-multi-async-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.content.selection = selection;
    this.$.relatedEvents.setRelatedEvents(selection);
    if (this.$.relatedEvents.hasRelatedEvents()) {
      this.$.relatedEvents.style.display = '';
    } else {
      this.$.relatedEvents.style.display = 'none';
    }
  },

  get relatedEventsToHighlight() {
    if (!this.$.content.selection) return undefined;

    const selection = new tr.model.EventSet();
    this.$.content.selection.forEach(function(asyncEvent) {
      if (!asyncEvent.associatedEvents) return;

      asyncEvent.associatedEvents.forEach(function(event) {
        selection.push(event);
      });
    });
    if (selection.length) return selection;
    return undefined;
  }
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-async-slice-sub-view',
    tr.model.AsyncSlice,
    {
      multi: true,
      title: 'Async Slices',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-multi-cpu-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.$.content.eventsHaveSubRows = false;
  },

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.content.setSelectionWithoutErrorChecks(selection);
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-cpu-slice-sub-view',
    tr.model.CpuSlice,
    {
      multi: true,
      title: 'CPU Slices',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-multi-flow-event-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.$.content.eventsHaveDuration = false;
    this.$.content.eventsHaveSubRows = false;
  },

  set selection(selection) {
    this.$.content.selection = selection;
  },

  get selection() {
    return this.$.content.selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-flow-event-sub-view',
    tr.model.FlowEvent,
    {
      multi: true,
      title: 'Flow Events',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-multi-frame-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  set selection(selection) {
    Polymer.dom(this).textContent = '';
    const realView = document.createElement('tr-ui-a-multi-event-sub-view');
    realView.eventsHaveDuration = false;
    realView.eventsHaveSubRows = false;

    Polymer.dom(this).appendChild(realView);
    realView.setSelectionWithoutErrorChecks(selection);

    this.currentSelection_ = selection;
  },

  get selection() {
    return this.currentSelection_;
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;

    const selection = new tr.model.EventSet();
    this.currentSelection_.forEach(function(frameEvent) {
      frameEvent.associatedEvents.forEach(function(event) {
        selection.push(event);
      });
    });
    return selection;
  }
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-frame-sub-view',
    tr.model.Frame,
    {
      multi: true,
      title: 'Frames',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-multi-instant-event-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  set selection(selection) {
    Polymer.dom(this.$.content).textContent = '';
    const realView = document.createElement('tr-ui-a-multi-event-sub-view');
    realView.eventsHaveDuration = false;
    realView.eventsHaveSubRows = false;

    Polymer.dom(this.$.content).appendChild(realView);
    realView.setSelectionWithoutErrorChecks(selection);

    this.currentSelection_ = selection;
  },

  get selection() {
    return this.currentSelection_;
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-multi-object-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  ready() {
    this.$.content.showHeader = false;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;

    const objectEvents = Array.from(selection).sort(
        tr.b.math.Range.compareByMinTimes);

    const timeSpanConfig = {
      unit: tr.b.Unit.byName.timeStampInMs,
      ownerDocument: this.ownerDocument
    };
    const table = this.$.content;
    table.tableColumns = [
      {
        title: 'First',
        value(event) {
          if (event instanceof tr.model.ObjectSnapshot) {
            return tr.v.ui.createScalarSpan(event.ts, timeSpanConfig);
          }

          const spanEl = document.createElement('span');
          Polymer.dom(spanEl).appendChild(tr.v.ui.createScalarSpan(
              event.creationTs, timeSpanConfig));
          Polymer.dom(spanEl).appendChild(tr.ui.b.createSpan({
            textContent: '-',
            marginLeft: '4px',
            marginRight: '4px'
          }));
          if (event.deletionTs !== Number.MAX_VALUE) {
            Polymer.dom(spanEl).appendChild(tr.v.ui.createScalarSpan(
                event.deletionTs, timeSpanConfig));
          }
          return spanEl;
        },
        width: '200px'
      },
      {
        title: 'Second',
        value(event) {
          const linkEl = document.createElement('tr-ui-a-analysis-link');
          linkEl.setSelectionAndContent(function() {
            return new tr.model.EventSet(event);
          }, event.userFriendlyName);
          return linkEl;
        },
        width: '100%'
      }
    ];
    table.tableRows = objectEvents;
    table.rebuild();
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-object-sub-view',
    tr.model.ObjectInstance,
    {
      multi: true,
      title: 'Object Instances',
    });
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-object-sub-view',
    tr.model.ObjectSnapshot,
    {
      multi: true,
      title: 'Object Snapshots',
    });


'use strict';

const EventSet = tr.model.EventSet;

const CHART_TITLE = 'Power (W) by ms since vertical sync';

Polymer({
  is: 'tr-ui-a-frame-power-usage-chart',

  ready() {
    this.chart_ = undefined;
    this.samples_ = new EventSet();
    this.vSyncTimestamps_ = [];
  },

  attached() {
    if (this.samples_) this.updateContents_();
  },

  get chart() {
    return this.chart_;
  },

  get samples() {
    return this.samples_;
  },

  get vSyncTimestamps() {
    return this.vSyncTimestamps_;
  },

  /**
   * Sets the data that powers the chart. Vsync timestamps must be in
   * chronological order.
   */
  setData(samples, vSyncTimestamps) {
    this.samples_ = (samples === undefined) ? new EventSet() : samples;
    this.vSyncTimestamps_ =
        (vSyncTimestamps === undefined) ? [] : vSyncTimestamps;
    if (this.isAttached) this.updateContents_();
  },

  updateContents_() {
    this.clearChart_();

    const data = this.getDataForLineChart_();

    if (data.length === 0) return;

    this.chart_ = new tr.ui.b.LineChart();
    Polymer.dom(this.$.content).appendChild(this.chart_);
    this.chart_.chartTitle = CHART_TITLE;
    this.chart_.data = data;
  },

  clearChart_() {
    const content = this.$.content;
    while (Polymer.dom(content).firstChild) {
      Polymer.dom(content).removeChild(Polymer.dom(content).firstChild);
    }

    this.chart_ = undefined;
  },

  // TODO(charliea): Limit the ms since vsync to the median frame length. The
  // vertical syncs are not 100% regular and highlighting any sample that's
  // in one of these 'vertical sync lulls' makes the x-axis have a much larger
  // scale than it should, effectively squishing the other samples into the
  // left side of the chart.
  /**
   * Returns an array of data points for the chart. Each element in the array
   * is of the form { x: <ms since vsync>, f<frame#>: <power in mW> }.
   */
  getDataForLineChart_() {
    const sortedSamples = this.sortSamplesByTimestampAscending_(this.samples);
    const vSyncTimestamps = this.vSyncTimestamps.slice();

    let lastVSyncTimestamp = undefined;
    const points = [];

    // For each power sample, find and record the frame number that it belongs
    // to as well as the amount of time elapsed since that frame began.
    let frameNumber = 0;
    sortedSamples.forEach(function(sample) {
      while (vSyncTimestamps.length > 0 && vSyncTimestamps[0] <= sample.start) {
        lastVSyncTimestamp = vSyncTimestamps.shift();
        frameNumber++;
      }

      // If no vertical sync occurred before the power sample, don't use the
      // power sample.
      if (lastVSyncTimestamp === undefined) return;

      const point = { x: sample.start - lastVSyncTimestamp };
      point['f' + frameNumber] = sample.powerInW;
      points.push(point);
    });

    return points;
  },

  sortSamplesByTimestampAscending_(samples) {
    return samples.toArray().sort(function(smpl1, smpl2) {
      return smpl1.start - smpl2.start;
    });
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-power-sample-summary-table',

  ready() {
    this.$.table.tableColumns = [
      {
        title: 'Min power',
        width: '100px',
        value(row) {
          return tr.b.Unit.byName.powerInWatts.format(row.min);
        }
      },
      {
        title: 'Max power',
        width: '100px',
        value(row) {
          return tr.b.Unit.byName.powerInWatts.format(row.max);
        }
      },
      {
        title: 'Time-weighted average',
        width: '100px',
        value(row) {
          return tr.b.Unit.byName.powerInWatts.format(
              row.timeWeightedAverageInW);
        }
      },
      {
        title: 'Energy consumed',
        width: '100px',
        value(row) {
          return tr.b.Unit.byName.energyInJoules.format(row.energyConsumedInJ);
        }
      },
      {
        title: 'Sample count',
        width: '100%',
        value(row) { return row.sampleCount; }
      }
    ];
    this.samples = new tr.model.EventSet();
  },

  get samples() {
    return this.samples_;
  },

  set samples(samples) {
    if (samples === this.samples) return;

    this.samples_ =
        (samples === undefined) ? new tr.model.EventSet() : samples;
    this.updateContents_();
  },

  updateContents_() {
    if (this.samples.length === 0) {
      this.$.table.tableRows = [];
    } else {
      this.$.table.tableRows = [{
        min: this.getMin(),
        max: this.getMax(),
        timeWeightedAverageInW: this.getTimeWeightedAverageInW(),
        energyConsumedInJ: this.getEnergyConsumedInJ(),
        sampleCount: this.samples.length
      }];
    }

    this.$.table.rebuild();
  },

  getMin() {
    return Math.min.apply(null, this.samples.map(function(sample) {
      return sample.powerInW;
    }));
  },

  getMax() {
    return Math.max.apply(null, this.samples.map(function(sample) {
      return sample.powerInW;
    }));
  },

  /**
   * Returns a time-weighted average of the power consumption (Watts)
   * in between the first sample (inclusive) and last sample (exclusive).
   */
  getTimeWeightedAverageInW() {
    const energyConsumedInJ = this.getEnergyConsumedInJ();

    if (energyConsumedInJ === 'N/A') return 'N/A';

    const durationInS = tr.b.convertUnit(this.samples.bounds.duration,
        tr.b.UnitPrefixScale.METRIC.MILLI,
        tr.b.UnitPrefixScale.METRIC.NONE);

    return energyConsumedInJ / durationInS;
  },


  getEnergyConsumedInJ() {
    if (this.samples.length < 2) return 'N/A';

    const bounds = this.samples.bounds;
    const series = tr.b.getFirstElement(this.samples).series;
    return series.getEnergyConsumedInJ(bounds.min, bounds.max);
  }
});


'use strict';

// TODO(charliea): Add a dropdown that allows the user to select which type of
// power sample analysis view they want (e.g. table of samples, graph).
Polymer({
  is: 'tr-ui-a-multi-power-sample-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.updateContents_();
  },

  updateContents_() {
    const samples = this.selection;
    const vSyncTimestamps = (!samples ? [] :
        tr.b.getFirstElement(samples).series.device.vSyncTimestamps);

    this.$.summaryTable.samples = samples;
    this.$.chart.setData(this.selection, vSyncTimestamps);
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-power-sample-sub-view',
    tr.model.PowerSample,
    {
      multi: true,
      title: 'Power Samples',
    });


'use strict';

(function() {
  const MultiDimensionalViewBuilder = tr.b.MultiDimensionalViewBuilder;

  Polymer({
    is: 'tr-ui-a-multi-sample-sub-view',
    behaviors: [tr.ui.analysis.AnalysisSubView],

    created() {
      this.viewOption_ = undefined;
      this.selection_ = undefined;
    },

    ready() {
      const viewSelector = tr.ui.b.createSelector(
          this, 'viewOption', 'tracing.ui.analysis.multi_sample_sub_view',
          MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW,
          [
            {
              label: 'Top-down (Tree)',
              value: MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW
            },
            {
              label: 'Top-down (Heavy)',
              value: MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW
            },
            {
              label: 'Bottom-up (Heavy)',
              value: MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW
            }
          ]);
      Polymer.dom(this.$.control).appendChild(viewSelector);
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      this.selection_ = selection;
      this.updateContents_();
    },

    get viewOption() {
      return this.viewOption_;
    },

    set viewOption(viewOption) {
      this.viewOption_ = viewOption;
      this.updateContents_();
    },

    createSamplingSummary_(selection, viewOption) {
      const builder = new MultiDimensionalViewBuilder(
          1 /* dimensions */, 1 /* valueCount */);
      const samples = selection.filter(
          event => event instanceof tr.model.Sample);

      samples.forEach(function(sample) {
        builder.addPath([sample.userFriendlyStack.reverse()],
            [1], MultiDimensionalViewBuilder.ValueKind.SELF);
      });

      return builder.buildView(viewOption);
    },

    processSampleRows_(rows) {
      for (const row of rows) {
        let title = row.title[0];
        let results = /(.*) (Deoptimized reason: .*)/.exec(title);
        if (results !== null) {
          row.deoptReason = results[2];
          title = results[1];
        }
        results = /(.*) url: (.*)/.exec(title);
        if (results !== null) {
          row.functionName = results[1];
          row.url = results[2];
          if (row.functionName === '') {
            row.functionName = '(anonymous function)';
          }
          if (row.url === '') {
            row.url = 'unknown';
          }
        } else {
          row.functionName = title;
          row.url = 'unknown';
        }
        this.processSampleRows_(row.subRows);
      }
    },

    updateContents_() {
      if (this.selection === undefined) {
        this.$.table.tableColumns = [];
        this.$.table.tableRows = [];
        this.$.table.rebuild();
        return;
      }

      const samplingData = this.createSamplingSummary_(
          this.selection, this.viewOption);
      const total = samplingData.values[0].total;
      const columns = [
        this.createPercentColumn_('Total', total),
        this.createSamplesColumn_('Total'),
        this.createPercentColumn_('Self', total),
        this.createSamplesColumn_('Self'),
        {
          title: 'Function Name',
          value(row) {
            // For function that got deoptimized, show function name
            // as red italic with a tooltip
            if (row.deoptReason !== undefined) {
              const spanEl = tr.ui.b.createSpan({
                italic: true,
                color: '#F44336',
                tooltip: row.deoptReason
              });
              spanEl.innerText = row.functionName;
              return spanEl;
            }
            return row.functionName;
          },
          width: '150px',
          cmp: (a, b) => a.functionName.localeCompare(b.functionName),
          showExpandButtons: true
        },
        {
          title: 'Location',
          value(row) { return row.url; },
          width: '250px',
          cmp: (a, b) => a.url.localeCompare(b.url),
        }
      ];

      this.processSampleRows_(samplingData.subRows);
      this.$.table.tableColumns = columns;
      this.$.table.sortColumnIndex = 1; /* Total samples */
      this.$.table.sortDescending = true;
      this.$.table.tableRows = samplingData.subRows;
      this.$.table.rebuild();
    },

    createPercentColumn_(title, samplingDataTotal) {
      const field = title.toLowerCase();
      return {
        title: title + ' percent',
        value(row) {
          return tr.v.ui.createScalarSpan(
              row.values[0][field] / samplingDataTotal, {
                customContextRange: tr.b.math.Range.PERCENT_RANGE,
                unit: tr.b.Unit.byName.normalizedPercentage,
                context: { minimumFractionDigits: 2, maximumFractionDigits: 2 },
              });
        },
        width: '60px',
        cmp: (a, b) => a.values[0][field] - b.values[0][field]
      };
    },

    createSamplesColumn_(title) {
      const field = title.toLowerCase();
      return {
        title: title + ' samples',
        value(row) {
          return tr.v.ui.createScalarSpan(row.values[0][field], {
            unit: tr.b.Unit.byName.unitlessNumber,
            context: { maximumFractionDigits: 0 },
          });
        },
        width: '60px',
        cmp: (a, b) => a.values[0][field] - b.values[0][field]
      };
    }
  });

  tr.ui.analysis.AnalysisSubView.register(
      'tr-ui-a-multi-sample-sub-view',
      tr.model.Sample,
      {
        multi: true,
        title: 'Samples',
      });
})();


'use strict';

Polymer({
  is: 'tr-ui-a-multi-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.selection_ = undefined;
  },

  get selection() {
    return this.selection_;
  },

  set selection(selection) {
    this.selection_ = selection;

    // TODO(nduca): This is a gross hack for cc Frame Viewer, but its only
    // the frame viewer that needs this feature, so ~shrug~.
    // We check for its presence so that we do not have a hard dependency
    // on frame viewer.
    if (tr.isExported('tr.ui.e.chrome.cc.RasterTaskSelection')) {
      if (tr.ui.e.chrome.cc.RasterTaskSelection.supports(selection)) {
        const ltvSelection = new tr.ui.e.chrome.cc.RasterTaskSelection(
            selection);

        const ltv = new tr.ui.e.chrome.cc.LayerTreeHostImplSnapshotView();
        ltv.objectSnapshot = ltvSelection.containingSnapshot;
        ltv.selection = ltvSelection;
        ltv.extraHighlightsByLayerId = ltvSelection.extraHighlightsByLayerId;

        Polymer.dom(this.$.content).textContent = '';
        Polymer.dom(this.$.content).appendChild(ltv);

        this.requiresTallView_ = true;
        return;
      }
    }

    Polymer.dom(this.$.content).textContent = '';

    const mesv = document.createElement('tr-ui-a-multi-event-sub-view');
    mesv.selection = selection;
    Polymer.dom(this.$.content).appendChild(mesv);

    const relatedEvents = document.createElement('tr-ui-a-related-events');
    relatedEvents.setRelatedEvents(selection);

    if (relatedEvents.hasRelatedEvents()) {
      Polymer.dom(this.$.content).appendChild(relatedEvents);
    }
  },

  get requiresTallView() {
    if (this.$.content.children.length === 0) return false;
    const childTagName = this.$.content.children[0].tagName;
    if (childTagName === 'TR-UI-A-MULTI-EVENT-SUB-VIEW') {
      return false;
    }

    // Using raster task view.
    return true;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-thread-slice-sub-view',
    tr.model.ThreadSlice,
    {
      multi: true,
      title: 'Slices',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-multi-thread-time-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.$.content.eventsHaveSubRows = false;
  },

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.content.setSelectionWithoutErrorChecks(selection);
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-thread-time-slice-sub-view',
    tr.model.ThreadTimeSlice,
    {
      multi: true,
      title: 'Thread Timeslices',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-user-expectation-related-samples-table',

  ready() {
    this.samples_ = [];
    this.$.table.tableColumns = [
      {
        title: 'Event(s)',
        value(row) {
          const typeEl = document.createElement('span');
          typeEl.innerText = row.type;
          if (row.tooltip) {
            typeEl.title = row.tooltip;
          }
          return typeEl;
        },
        width: '150px'
      },
      {
        title: 'Link',
        width: '100%',
        value(row) {
          const linkEl = document.createElement('tr-ui-a-analysis-link');
          if (row.name) {
            linkEl.setSelectionAndContent(row.selection, row.name);
          } else {
            linkEl.selection = row.selection;
          }
          return linkEl;
        }
      }
    ];
  },

  hasRelatedSamples() {
    return (this.samples_ && this.samples_.length > 0);
  },

  set selection(eventSet) {
    this.samples_ = [];
    const samples = new tr.model.EventSet;
    eventSet.forEach(function(ue) {
      samples.addEventSet(ue.associatedSamples);
    }.bind(this));

    if (samples.length > 0) {
      this.samples_.push({
        type: 'Overlapping samples',
        tooltip: 'All samples overlapping the selected user expectation(s).',
        selection: samples
      });
    }
    this.updateContents_();
  },

  updateContents_() {
    const table = this.$.table;
    if (this.samples_ && this.samples_.length > 0) {
      table.tableRows = this.samples_.slice();
    } else {
      table.tableRows = [];
    }
    table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-multi-interaction-record-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.$.realView.setSelectionWithoutErrorChecks(selection);

    this.currentSelection_ = selection;

    this.$.relatedSamples.selection = selection;
    if (this.$.relatedSamples.hasRelatedSamples()) {
      this.$.events.style.display = '';
    } else {
      this.$.events.style.display = 'none';
    }
  },

  get selection() {
    return this.currentSelection_;
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;

    const selection = new tr.model.EventSet();
    this.currentSelection_.forEach(function(ir) {
      ir.associatedEvents.forEach(function(event) {
        selection.push(event);
      });
    });
    return selection;
  }
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-user-expectation-sub-view',
    tr.model.um.UserExpectation,
    {
      multi: true,
      title: 'User Expectations',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-stack-frame',

  ready() {
    this.stackFrame_ = undefined;
    this.$.table.tableColumns = [];
    this.$.table.showHeader = true;
  },

  get stackFrame() {
    return this.stackFrame_;
  },

  set stackFrame(stackFrame) {
    const table = this.$.table;

    this.stackFrame_ = stackFrame;
    if (stackFrame === undefined) {
      table.tableColumns = [];
      table.tableRows = [];
      table.rebuild();
      return;
    }

    let hasName = false;
    let hasTitle = false;

    table.tableRows = stackFrame.stackTrace;
    table.tableRows.forEach(function(row) {
      hasName |= row.name !== undefined;
      hasTitle |= row.title !== undefined;
    });

    const cols = [];
    if (hasName) {
      cols.push({
        title: 'Name',
        value(row) { return row.name; }
      });
    }

    if (hasTitle) {
      cols.push({
        title: 'Title',
        value(row) { return row.title; }
      });
    }

    table.tableColumns = cols;
    table.rebuild();
  },

  tableForTesting() {
    return this.$.table;
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-single-event-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  properties: {
    isFlow: {
      type: Boolean,
      value: false
    }
  },

  ready() {
    this.currentSelection_ = undefined;
    this.$.table.tableColumns = [
      {
        title: 'Label',
        value(row) { return row.name; },
        width: '150px'
      },
      {
        title: 'Value',
        width: '100%',
        value(row) { return row.value; }
      }
    ];
    this.$.table.showHeader = false;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    if (selection.length !== 1) {
      throw new Error('Only supports single slices');
    }
    this.setSelectionWithoutErrorChecks(selection);
  },

  setSelectionWithoutErrorChecks(selection) {
    this.currentSelection_ = selection;
    this.updateContents_();
  },

  getFlowEventRows_(event) {
    // TODO(nduca): Figure out if there is a cleaner way to do this.

    const rows = this.getEventRowsHelper_(event);

    // Put the ID up top.
    rows.splice(0, 0, {
      name: 'ID',
      value: event.id
    });

    function createLinkTo(slice) {
      const linkEl = document.createElement('tr-ui-a-analysis-link');
      linkEl.setSelectionAndContent(function() {
        return new tr.model.EventSet(slice);
      });
      Polymer.dom(linkEl).textContent = slice.userFriendlyName;
      return linkEl;
    }

    rows.push({
      name: 'From',
      value: createLinkTo(event.startSlice)
    });
    rows.push({
      name: 'To',
      value: createLinkTo(event.endSlice)
    });
    return rows;
  },

  getEventRowsHelper_(event) {
    const rows = [];

    if (event.error) {
      rows.push({ name: 'Error', value: event.error });
    }

    if (event.title) {
      rows.push({ name: 'Title', value: event.title });
    }

    if (event.category) {
      rows.push({ name: 'Category', value: event.category });
    }

    if (event.model !== undefined) {
      const ufc = event.model.getUserFriendlyCategoryFromEvent(event);
      if (ufc !== undefined) {
        rows.push({ name: 'User Friendly Category', value: ufc });
      }
    }

    if (event.name) {
      rows.push({ name: 'Name', value: event.name });
    }

    rows.push({
      name: 'Start',
      value: tr.v.ui.createScalarSpan(event.start, {
        unit: tr.b.Unit.byName.timeStampInMs
      })
    });

    if (event.duration) {
      rows.push({
        name: 'Wall Duration',
        value: tr.v.ui.createScalarSpan(event.duration, {
          unit: tr.b.Unit.byName.timeDurationInMs
        })
      });
    }

    if (event.cpuDuration) {
      rows.push({
        name: 'CPU Duration',
        value: tr.v.ui.createScalarSpan(event.cpuDuration, {
          unit: tr.b.Unit.byName.timeDurationInMs
        })
      });
    }

    if (event.subSlices !== undefined && event.subSlices.length !== 0) {
      if (event.selfTime) {
        rows.push({
          name: 'Self Time',
          value: tr.v.ui.createScalarSpan(event.selfTime, {
            unit: tr.b.Unit.byName.timeDurationInMs
          })
        });
      }

      if (event.cpuSelfTime) {
        const cpuSelfTimeEl = tr.v.ui.createScalarSpan(event.cpuSelfTime, {
          unit: tr.b.Unit.byName.timeDurationInMs
        });
        if (event.cpuSelfTime > event.selfTime) {
          cpuSelfTimeEl.warning =
              ' Note that CPU Self Time is larger than Self Time. ' +
              'This is a known limitation of this system, which occurs ' +
              'due to several subslices, rounding issues, and imprecise ' +
              'time at which we get cpu- and real-time.';
        }
        rows.push({ name: 'CPU Self Time', value: cpuSelfTimeEl });
      }
    }

    if (event.durationInUserTime) {
      rows.push({
        name: 'Duration (U)',
        value: tr.v.ui.createScalarSpan(event.durationInUserTime, {
          unit: tr.b.Unit.byName.timeDurationInMs
        })
      });
    }

    function createStackFrameEl(sf) {
      const sfEl = document.createElement('tr-ui-a-stack-frame');
      sfEl.stackFrame = sf;
      return sfEl;
    }
    if (event.startStackFrame && event.endStackFrame) {
      if (event.startStackFrame === event.endStackFrame) {
        rows.push({name: 'Start+End Stack Trace',
          value: createStackFrameEl(event.startStackFrame)});
      } else {
        rows.push({ name: 'Start Stack Trace',
          value: createStackFrameEl(event.startStackFrame)});
        rows.push({ name: 'End Stack Trace',
          value: createStackFrameEl(event.endStackFrame)});
      }
    } else if (event.startStackFrame) {
      rows.push({ name: 'Start Stack Trace',
        value: createStackFrameEl(event.startStackFrame)});
    } else if (event.endStackFrame) {
      rows.push({ name: 'End Stack Trace',
        value: createStackFrameEl(event.endStackFrame)});
    }

    if (event.info) {
      const descriptionEl = tr.ui.b.createDiv({
        textContent: event.info.description,
        maxWidth: '300px'
      });
      rows.push({
        name: 'Description',
        value: descriptionEl
      });


      if (event.info.docLinks) {
        event.info.docLinks.forEach(function(linkObject) {
          const linkEl = document.createElement('a');
          linkEl.target = '_blank';
          linkEl.href = linkObject.href;
          Polymer.dom(linkEl).textContent = Polymer.dom(linkObject).textContent;
          rows.push({
            name: linkObject.label,
            value: linkEl
          });
        });
      }
    }

    if (event.associatedAlerts.length) {
      const alertSubRows = [];
      event.associatedAlerts.forEach(function(alert) {
        const linkEl = document.createElement('tr-ui-a-analysis-link');
        linkEl.setSelectionAndContent(function() {
          return new tr.model.EventSet(alert);
        }, alert.info.description);
        alertSubRows.push({
          name: alert.title,
          value: linkEl
        });
      });

      rows.push({
        name: 'Alerts', value: '',
        isExpanded: true, subRows: alertSubRows
      });
    }
    return rows;
  },

  getEventRows_(event) {
    if (this.isFlow) {
      return this.getFlowEventRows_(event);
    }

    return this.getEventRowsHelper_(event);
  },

  addArgsToRows_(rows, args) {
    let n = 0;
    for (const argName in args) {
      n += 1;
    }
    if (n > 0) {
      const subRows = [];
      for (const argName in args) {
        n += 1;
      }
      if (n > 0) {
        const subRows = [];
        for (const argName in args) {
          const argView =
              document.createElement('tr-ui-a-generic-object-view');
          argView.object = args[argName];
          subRows.push({name: argName, value: argView});
        }
        rows.push({
          name: 'Args',
          value: '',
          isExpanded: true,
          subRows
        });
      }
    }
  },

  addContextsToRows_(rows, contexts) {
    if (contexts.length) {
      const subRows = contexts.map(function(context) {
        const contextView =
            document.createElement('tr-ui-a-generic-object-view');
        contextView.object = context;
        return {name: 'Context', value: contextView};
      });
      rows.push({
        name: 'Contexts',
        value: '',
        isExpanded: true,
        subRows
      });
    }
  },

  updateContents_() {
    if (this.currentSelection_ === undefined) {
      this.$.table.rows = [];
      this.$.table.rebuild();
      return;
    }

    const event = tr.b.getOnlyElement(this.currentSelection_);

    const rows = this.getEventRows_(event);
    if (event.argsStripped) {
      rows.push({ name: 'Args', value: 'Stripped' });
    } else {
      this.addArgsToRows_(rows, event.args);
    }
    this.addContextsToRows_(rows, event.contexts);

    const customizeRowsEvent = new tr.b.Event('customize-rows');
    customizeRowsEvent.rows = rows;
    this.dispatchEvent(customizeRowsEvent);

    this.$.table.tableRows = rows;
    this.$.table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-single-async-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    if (selection.length !== 1) {
      throw new Error('Only supports single slices');
    }
    this.$.content.setSelectionWithoutErrorChecks(selection);
    this.$.relatedEvents.setRelatedEvents(selection);
    if (this.$.relatedEvents.hasRelatedEvents()) {
      this.$.relatedEvents.style.display = '';
    } else {
      this.$.relatedEvents.style.display = 'none';
    }
  },

  getEventRows_(event) {
    // TODO(nduca): Figure out if there is a cleaner way to do this.
    const rows = this.__proto__.__proto__.getEventRows_(event);

    // Put the ID up top.
    rows.splice(0, 0, {
      name: 'ID',
      value: event.id
    });
    return rows;
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;
    return tr.b.getOnlyElement(this.currentSelection_).associatedEvents;
  }
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-async-slice-sub-view',
    tr.model.AsyncSlice,
    {
      multi: false,
      title: 'Async Slice',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-cpu-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    const cpuSlice = tr.b.getOnlyElement(selection);
    if (!(cpuSlice instanceof tr.model.CpuSlice)) {
      throw new Error('Only supports thread time slices');
    }

    this.currentSelection_ = selection;

    const thread = cpuSlice.threadThatWasRunning;

    const root = Polymer.dom(this.root);
    if (thread) {
      Polymer.dom(root.querySelector('#process-name')).textContent =
          thread.parent.userFriendlyName;
      Polymer.dom(root.querySelector('#thread-name')).textContent =
          thread.userFriendlyName;
    } else {
      root.querySelector('#process-name').parentElement.style.display =
          'none';
      Polymer.dom(root.querySelector('#thread-name')).textContent =
          cpuSlice.title;
    }

    root.querySelector('#start').setValueAndUnit(
        cpuSlice.start, tr.b.Unit.byName.timeStampInMs);
    root.querySelector('#duration').setValueAndUnit(
        cpuSlice.duration, tr.b.Unit.byName.timeDurationInMs);

    const runningThreadEl = root.querySelector('#running-thread');

    const timeSlice = cpuSlice.getAssociatedTimeslice();
    if (!timeSlice) {
      runningThreadEl.parentElement.style.display = 'none';
    } else {
      const threadLink = document.createElement('tr-ui-a-analysis-link');
      threadLink.selection = new tr.model.EventSet(timeSlice);
      Polymer.dom(threadLink).textContent = 'Click to select';
      runningThreadEl.parentElement.style.display = '';
      Polymer.dom(runningThreadEl).textContent = '';
      Polymer.dom(runningThreadEl).appendChild(threadLink);
    }

    root.querySelector('#args').object = cpuSlice.args;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-cpu-slice-sub-view',
    tr.model.CpuSlice,
    {
      multi: false,
      title: 'CPU Slice',
    });


'use strict';

function createAnalysisLinkTo(event) {
  const linkEl = document.createElement('tr-ui-a-analysis-link');
  linkEl.setSelectionAndContent(
      new tr.model.EventSet(event), event.userFriendlyName);
  return linkEl;
}

Polymer({
  is: 'tr-ui-a-single-flow-event-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  listeners: {
    'singleEventSubView.customize-rows': 'onCustomizeRows_'
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.$.singleEventSubView.setSelectionWithoutErrorChecks(selection);
  },

  get selection() {
    return this.currentSelection_;
  },

  /**
   * Event handler for an event that's fired after the single event sub view has
   * finished row construction. This hook gives us the opportunity to customize
   * the rows present in the sub view.
   */
  onCustomizeRows_(e) {
    const event = tr.b.getOnlyElement(this.currentSelection_);
    const rows = e.rows;

    rows.unshift({
      name: 'ID',
      value: event.id
    });
    rows.push({
      name: 'From',
      value: createAnalysisLinkTo(event.startSlice)
    });
    rows.push({
      name: 'To',
      value: createAnalysisLinkTo(event.endSlice)
    });
  }
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-flow-event-sub-view',
    tr.model.FlowEvent,
    {
      multi: false,
      title: 'Flow Event',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-frame-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.$.asv.selection = tr.b.getOnlyElement(selection).associatedAlerts;
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;
    return tr.b.getOnlyElement(this.currentSelection_).associatedEvents;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-frame-sub-view',
    tr.model.Frame,
    {
      multi: false,
      title: 'Frame',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-instant-event-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  set selection(selection) {
    Polymer.dom(this.$.content).textContent = '';
    const realView = document.createElement('tr-ui-a-single-event-sub-view');
    realView.setSelectionWithoutErrorChecks(selection);

    Polymer.dom(this.$.content).appendChild(realView);

    this.currentSelection_ = selection;
  },

  get selection() {
    return this.currentSelection_;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-instant-event-sub-view',
    tr.model.InstantEvent,
    {
      multi: false,
      title: 'Instant Event',
    });

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-multi-instant-event-sub-view',
    tr.model.InstantEvent,
    {
      multi: true,
      title: 'Instant Events',
    });



'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const ObjectInstanceView = tr.ui.b.define('object-instance-view');

  ObjectInstanceView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.objectInstance_ = undefined;
    },

    get requiresTallView() {
      return true;
    },

    set modelEvent(obj) {
      this.objectInstance = obj;
    },

    get modelEvent() {
      return this.objectInstance;
    },

    get objectInstance() {
      return this.objectInstance_;
    },

    set objectInstance(i) {
      this.objectInstance_ = i;
      this.updateContents();
    },

    updateContents() {
      throw new Error('Not implemented');
    }
  };

  const options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectInstanceView;
  options.defaultMetadata = {
    showInTrackView: true
  };
  tr.b.decorateExtensionRegistry(ObjectInstanceView, options);

  return {
    ObjectInstanceView,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-a-single-object-instance-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  get requiresTallView() {
    if (this.$.content.children.length === 0) {
      return false;
    }
    if (this.$.content.children[0] instanceof
        tr.ui.analysis.ObjectInstanceView) {
      return this.$.content.children[0].requiresTallView;
    }
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    const instance = tr.b.getOnlyElement(selection);
    if (!(instance instanceof tr.model.ObjectInstance)) {
      throw new Error('Only supports object instances');
    }

    Polymer.dom(this.$.content).textContent = '';
    this.currentSelection_ = selection;

    const typeInfo = tr.ui.analysis.ObjectInstanceView.getTypeInfo(
        instance.category, instance.typeName);
    if (typeInfo) {
      const customView = new typeInfo.constructor();
      Polymer.dom(this.$.content).appendChild(customView);
      customView.modelEvent = instance;
    } else {
      this.appendGenericAnalysis_(instance);
    }
  },

  appendGenericAnalysis_(instance) {
    let html = '';
    html += '<div class="title">' +
        instance.typeName + ' ' +
        instance.id + '</div>\n';
    html += '<table>';
    html += '<tr>';
    html += '<tr><td>creationTs:</td><td>' +
        instance.creationTs + '</td></tr>\n';
    if (instance.deletionTs !== Number.MAX_VALUE) {
      html += '<tr><td>deletionTs:</td><td>' +
          instance.deletionTs + '</td></tr>\n';
    } else {
      html += '<tr><td>deletionTs:</td><td>not deleted</td></tr>\n';
    }
    html += '<tr><td>snapshots:</td><td id="snapshots"></td></tr>\n';
    html += '</table>';
    Polymer.dom(this.$.content).innerHTML = html;
    const snapshotsEl = Polymer.dom(this.$.content).querySelector('#snapshots');
    instance.snapshots.forEach(function(snapshot) {
      const snapshotLink = document.createElement('tr-ui-a-analysis-link');
      snapshotLink.selection = new tr.model.EventSet(snapshot);
      Polymer.dom(snapshotsEl).appendChild(snapshotLink);
    });
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-object-instance-sub-view',
    tr.model.ObjectInstance,
    {
      multi: false,
      title: 'Object Instance',
    });


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  const ObjectSnapshotView = tr.ui.b.define('object-snapshot-view');

  ObjectSnapshotView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.objectSnapshot_ = undefined;
    },

    get requiresTallView() {
      return true;
    },

    set modelEvent(obj) {
      this.objectSnapshot = obj;
    },

    get modelEvent() {
      return this.objectSnapshot;
    },

    get objectSnapshot() {
      return this.objectSnapshot_;
    },

    set objectSnapshot(i) {
      this.objectSnapshot_ = i;
      this.updateContents();
    },

    updateContents() {
      throw new Error('Not implemented');
    }
  };

  const options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  options.mandatoryBaseClass = ObjectSnapshotView;
  options.defaultMetadata = {
    showInstances: true,
    showInTrackView: true
  };
  tr.b.decorateExtensionRegistry(ObjectSnapshotView, options);

  return {
    ObjectSnapshotView,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-a-single-object-snapshot-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  get requiresTallView() {
    if (this.children.length === 0) {
      return false;
    }
    if (this.children[0] instanceof tr.ui.analysis.ObjectSnapshotView) {
      return this.children[0].requiresTallView;
    }
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    const snapshot = tr.b.getOnlyElement(selection);
    if (!(snapshot instanceof tr.model.ObjectSnapshot)) {
      throw new Error('Only supports object instances');
    }

    Polymer.dom(this).textContent = '';
    this.currentSelection_ = selection;

    const typeInfo = tr.ui.analysis.ObjectSnapshotView.getTypeInfo(
        snapshot.objectInstance.category, snapshot.objectInstance.typeName);
    if (typeInfo) {
      const customView = new typeInfo.constructor();
      Polymer.dom(this).appendChild(customView);
      customView.modelEvent = snapshot;
    } else {
      this.appendGenericAnalysis_(snapshot);
    }
  },

  appendGenericAnalysis_(snapshot) {
    const instance = snapshot.objectInstance;

    Polymer.dom(this).textContent = '';

    const titleEl = document.createElement('div');
    Polymer.dom(titleEl).classList.add('title');
    Polymer.dom(titleEl).appendChild(document.createTextNode('Snapshot of '));
    Polymer.dom(this).appendChild(titleEl);

    const instanceLinkEl = document.createElement('tr-ui-a-analysis-link');
    instanceLinkEl.selection = new tr.model.EventSet(instance);
    Polymer.dom(titleEl).appendChild(instanceLinkEl);

    Polymer.dom(titleEl).appendChild(document.createTextNode(' @ '));

    Polymer.dom(titleEl).appendChild(tr.v.ui.createScalarSpan(snapshot.ts, {
      unit: tr.b.Unit.byName.timeStampInMs,
      ownerDocument: this.ownerDocument,
      inline: true,
    }));

    const tableEl = document.createElement('table');
    Polymer.dom(this).appendChild(tableEl);

    const rowEl = document.createElement('tr');
    Polymer.dom(tableEl).appendChild(rowEl);

    const labelEl = document.createElement('td');
    Polymer.dom(labelEl).textContent = 'args:';
    Polymer.dom(rowEl).appendChild(labelEl);

    const argsEl = document.createElement('td');
    argsEl.id = 'args';
    Polymer.dom(rowEl).appendChild(argsEl);

    const objectViewEl = document.createElement('tr-ui-a-generic-object-view');
    objectViewEl.object = snapshot.args;
    Polymer.dom(argsEl).appendChild(objectViewEl);
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-object-snapshot-sub-view',
    tr.model.ObjectSnapshot,
    {
      multi: false,
      title: 'Object Snapshot',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-power-sample-table',

  ready() {
    this.$.table.tableColumns = [
      {
        title: 'Time',
        width: '100px',
        value(row) {
          return tr.v.ui.createScalarSpan(row.start, {
            unit: tr.b.Unit.byName.timeStampInMs
          });
        }
      },
      {
        title: 'Power',
        width: '100%',
        value(row) {
          return tr.v.ui.createScalarSpan(row.powerInW, {
            unit: tr.b.Unit.byName.powerInWatts
          });
        }
      }
    ];
    this.sample = undefined;
  },

  get sample() {
    return this.sample_;
  },

  set sample(sample) {
    this.sample_ = sample;
    this.updateContents_();
  },

  updateContents_() {
    if (this.sample === undefined) {
      this.$.table.tableRows = [];
    } else {
      this.$.table.tableRows = [this.sample];
    }
    this.$.table.rebuild();
  }
});


'use strict';

Polymer({
  is: 'tr-ui-a-single-power-sample-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  ready() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;
    this.updateContents_();
  },

  updateContents_() {
    if (this.selection.length !== 1) {
      throw new Error('Cannot pass multiple samples to sample table.');
    }
    this.$.samplesTable.sample = tr.b.getOnlyElement(this.selection);
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-power-sample-sub-view',
    tr.model.PowerSample,
    {
      multi: false,
      title: 'Power Sample',
    });



'use strict';

Polymer({
  is: 'tr-ui-a-single-sample-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  ready() {
    this.$.content.tableColumns = [
      {
        title: '',
        value: row => row.title,
        width: '100px'
      },
      {
        title: '',
        value: row => row.value,
        width: '100%'
      }
    ];
    this.$.content.showHeader = false;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.currentSelection_ = selection;

    if (this.currentSelection_ === undefined) {
      this.$.content.tableRows = [];
      return;
    }

    const sample = tr.b.getOnlyElement(this.currentSelection_);
    const table = this.$.content;
    const rows = [];

    rows.push({
      title: 'Title',
      value: sample.title
    });

    rows.push({
      title: 'Sample time',
      value: tr.v.ui.createScalarSpan(sample.start, {
        unit: tr.b.Unit.byName.timeStampInMs,
        ownerDocument: this.ownerDocument
      })
    });

    const callStackTableEl = document.createElement('tr-ui-b-table');
    callStackTableEl.tableRows = sample.getNodesAsArray().reverse();
    callStackTableEl.tableColumns = [
      {
        title: 'function name',
        value: row => row.functionName || '(anonymous function)'
      },
      {
        title: 'location',
        value: row => row.url
      }
    ];
    callStackTableEl.rebuild();
    rows.push({
      title: 'Call stack',
      value: callStackTableEl
    });
    table.tableRows = rows;
    table.rebuild();
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-sample-sub-view',
    tr.model.Sample,
    {
      multi: false,
      title: 'Sample',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.content.selection = selection;
    this.$.relatedEvents.setRelatedEvents(selection);
    if (this.$.relatedEvents.hasRelatedEvents()) {
      this.$.relatedEvents.style.display = '';
    } else {
      this.$.relatedEvents.style.display = 'none';
    }
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-thread-slice-sub-view',
    tr.model.ThreadSlice,
    {
      multi: false,
      title: 'Slice',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-thread-time-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    const timeSlice = tr.b.getOnlyElement(selection);

    if (!(timeSlice instanceof tr.model.ThreadTimeSlice)) {
      throw new Error('Only supports thread time slices');
    }

    this.currentSelection_ = selection;

    const thread = timeSlice.thread;

    const root = Polymer.dom(this.root);
    Polymer.dom(root.querySelector('#state')).textContent =
        timeSlice.title;
    const stateColor = tr.b.ColorScheme.colorsAsStrings[timeSlice.colorId];
    root.querySelector('#state').style.backgroundColor = stateColor;

    Polymer.dom(root.querySelector('#process-name')).textContent =
        thread.parent.userFriendlyName;
    Polymer.dom(root.querySelector('#thread-name')).textContent =
        thread.userFriendlyName;

    root.querySelector('#start').setValueAndUnit(
        timeSlice.start, tr.b.Unit.byName.timeStampInMs);
    root.querySelector('#duration').setValueAndUnit(
        timeSlice.duration, tr.b.Unit.byName.timeDurationInMs);

    const onCpuEl = root.querySelector('#on-cpu');
    Polymer.dom(onCpuEl).textContent = '';
    const runningInsteadEl = root.querySelector('#running-instead');
    if (timeSlice.cpuOnWhichThreadWasRunning) {
      Polymer.dom(runningInsteadEl.parentElement).removeChild(runningInsteadEl);

      const cpuLink = document.createElement('tr-ui-a-analysis-link');
      cpuLink.selection = new tr.model.EventSet(
          timeSlice.getAssociatedCpuSlice());
      Polymer.dom(cpuLink).textContent =
          timeSlice.cpuOnWhichThreadWasRunning.userFriendlyName;
      Polymer.dom(onCpuEl).appendChild(cpuLink);
    } else {
      Polymer.dom(onCpuEl.parentElement).removeChild(onCpuEl);

      const cpuSliceThatTookCpu = timeSlice.getCpuSliceThatTookCpu();
      if (cpuSliceThatTookCpu) {
        const cpuLink = document.createElement('tr-ui-a-analysis-link');
        cpuLink.selection = new tr.model.EventSet(cpuSliceThatTookCpu);
        if (cpuSliceThatTookCpu.thread) {
          Polymer.dom(cpuLink).textContent =
              cpuSliceThatTookCpu.thread.userFriendlyName;
        } else {
          Polymer.dom(cpuLink).textContent = cpuSliceThatTookCpu.title;
        }
        Polymer.dom(runningInsteadEl).appendChild(cpuLink);
      } else {
        Polymer.dom(runningInsteadEl.parentElement).removeChild(
            runningInsteadEl);
      }
    }

    const argsEl = root.querySelector('#args');
    if (Object.keys(timeSlice.args).length > 0) {
      const argsView =
          document.createElement('tr-ui-a-generic-object-view');
      argsView.object = timeSlice.args;

      argsEl.parentElement.style.display = '';
      Polymer.dom(argsEl).textContent = '';
      Polymer.dom(argsEl).appendChild(argsView);
    } else {
      argsEl.parentElement.style.display = 'none';
    }
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-thread-time-slice-sub-view',
    tr.model.ThreadTimeSlice,
    {
      multi: false,
      title: 'Thread Timeslice',
    });


'use strict';

Polymer({
  is: 'tr-ui-a-single-user-expectation-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  created() {
    this.currentSelection_ = undefined;
  },

  get selection() {
    return this.currentSelection_;
  },

  set selection(selection) {
    this.$.realView.addEventListener('customize-rows',
        this.onCustomizeRows_.bind(this));

    this.currentSelection_ = selection;
    this.$.realView.setSelectionWithoutErrorChecks(selection);

    this.$.relatedSamples.selection = selection;
    if (this.$.relatedSamples.hasRelatedSamples()) {
      this.$.events.style.display = '';
    } else {
      this.$.events.style.display = 'none';
    }
  },

  get relatedEventsToHighlight() {
    if (!this.currentSelection_) return undefined;
    return tr.b.getOnlyElement(this.currentSelection_).associatedEvents;
  },

  onCustomizeRows_(event) {
    const ue = tr.b.getOnlyElement(this.selection);

    if (ue.rawCpuMs) {
      event.rows.push({
        name: 'Total CPU',
        value: tr.v.ui.createScalarSpan(ue.totalCpuMs, {
          unit: tr.b.Unit.byName.timeDurationInMs
        })
      });
    }
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-single-user-expectation-sub-view',
    tr.model.um.UserExpectation,
    {
      multi: false,
      title: 'User Expectation',
    });


'use strict';
(function() {
  const EventRegistry = tr.model.EventRegistry;

  /** Returns the label that goes next to the list of tabs. */
  function getTabStripLabel(numEvents) {
    if (numEvents === 0) {
      return 'Nothing selected. Tap stuff.';
    } else if (numEvents === 1) {
      return '1 item selected.';
    }
    return numEvents + ' items selected.';
  }

  function createSubView(subViewTypeInfo, selection) {
    let tagName;
    if (selection.length === 1) {
      tagName = subViewTypeInfo.singleTagName;
    } else {
      tagName = subViewTypeInfo.multiTagName;
    }

    if (tagName === undefined) {
      throw new Error('No view registered for ' +
                      subViewTypeInfo.eventConstructor.name);
    }
    const subView = document.createElement(tagName);

    let title;
    if (selection.length === 1) {
      title = subViewTypeInfo.singleTitle;
    } else {
      title = subViewTypeInfo.multiTitle;
    }
    title += ' (' + selection.length + ')';
    subView.tabLabel = title;

    subView.selection = selection;
    return subView;
  }

  Polymer({
    is: 'tr-ui-a-analysis-view',

    ready() {
      this.brushingStateController_ = undefined;
      this.lastSelection_ = undefined;
      this.tabView_ = document.createElement('tr-ui-b-tab-view');
      this.tabView_.addEventListener(
          'selected-tab-change', this.onSelectedSubViewChanged_.bind(this));

      Polymer.dom(this).appendChild(this.tabView_);
    },

    set tallMode(value) {
      Polymer.dom(this).classList.toggle('tall-mode', value);
    },

    get tallMode() {
      return Polymer.dom(this).classList.contains('tall-mode');
    },

    get tabView() {
      return this.tabView_;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    set brushingStateController(brushingStateController) {
      if (this.brushingStateController_) {
        this.brushingStateController_.removeEventListener(
            'change', this.onSelectionChanged_.bind(this));
      }

      this.brushingStateController_ = brushingStateController;
      if (this.brushingStateController) {
        this.brushingStateController_.addEventListener(
            'change', this.onSelectionChanged_.bind(this));
      }

      // The new brushing controller may have a different selection than the
      // last one, so we have to refresh the subview.
      this.onSelectionChanged_();
    },

    get selection() {
      return this.brushingStateController_.selection;
    },

    onSelectionChanged_(e) {
      if (this.lastSelection_ && this.selection.equals(this.lastSelection_)) {
        return;
      }
      this.lastSelection_ = this.selection;

      this.tallMode = false;

      this.tabView_.label = getTabStripLabel(this.selection.length);
      const eventsByBaseTypeName =
          this.selection.getEventsOrganizedByBaseType(true);

      const ASV = tr.ui.analysis.AnalysisSubView;
      const eventsByTagName = ASV.getEventsOrganizedByTypeInfo(this.selection);
      const newSubViews = [];
      eventsByTagName.forEach(function(events, typeInfo) {
        newSubViews.push(createSubView(typeInfo, events));
      });

      this.tabView_.resetSubViews(newSubViews);
    },

    onSelectedSubViewChanged_() {
      const selectedSubView = this.tabView_.selectedSubView;

      if (!selectedSubView) {
        this.tallMode = false;
        this.maybeChangeRelatedEvents_(undefined);
        return;
      }

      this.tallMode = selectedSubView.requiresTallView;
      this.maybeChangeRelatedEvents_(selectedSubView.relatedEventsToHighlight);
    },

    /** Changes the highlighted related events if possible. */
    maybeChangeRelatedEvents_(events) {
      if (this.brushingStateController) {
        this.brushingStateController.changeAnalysisViewRelatedEvents(events);
      }
    }
  });
})();


'use strict';

Polymer({
  is: 'tr-ui-b-dropdown',

  ready() {
    this.$.outer.tabIndex = 0;
  },

  get iconElement() {
    return this.$.icon;
  },

  onOuterKeyDown_(e) {
    if (e.keyCode === ' '.charCodeAt(0)) {
      this.toggle_();
      e.preventDefault();
      e.stopPropagation();
    }
  },

  onOuterClick_(e) {
    const or = this.$.outer.getBoundingClientRect();
    let inside = true;
    inside &= e.clientX >= or.left;
    inside &= e.clientX < or.right;
    inside &= e.clientY >= or.top;
    inside &= e.clientY < or.bottom;
    if (!inside) return;

    e.preventDefault();
    this.toggle_();
  },

  toggle_() {
    if (!this.isOpen) {
      this.show();
    } else {
      this.close();
    }
  },

  show() {
    if (this.isOpen) return;

    Polymer.dom(this.$.outer).classList.add('open');

    const ddr = this.$.outer.getBoundingClientRect();
    const rW = Math.max(ddr.width, 150);
    this.$.dialog.style.minWidth = rW + 'px';
    this.$.dialog.showModal();

    const ddw = this.$.outer.getBoundingClientRect().width;
    const w = this.$.dialog.getBoundingClientRect().width;
    this.$.dialog.style.top = ddr.bottom - 1 + 'px';
    this.$.dialog.style.left = ddr.left + 'px';
  },

  onDialogClick_(e) {
    if (!this.isOpen) return;
    if (e.srcElement !== this.$.dialog) return;
    e.preventDefault();
    this.close();
  },

  onDialogCancel_(e) {
    e.preventDefault();
    this.close();
  },

  close() {
    if (!this.isOpen) return;
    this.$.dialog.close();
    Polymer.dom(this.$.outer).classList.remove('open');
    this.$.outer.focus();
  },

  get isOpen() {
    return this.$.dialog.hasAttribute('open');
  }
});


'use strict';
tr.exportTo('tr.ui.b', function() {
  const FaviconsByHue = {
    blue: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAAC4CAYAAABQMybHAAAlrklEQVR4Ae2dCXwdVb3H5265yc3SpEk3ukEXCqVUBLT4Wm19oFKtaN0fKijy9CMguPBarIJsIiA8qsjTh7SllAoFeVBaEARkLV1ooXtL0yRdkqZp9u3uy/v/5uY/OZm75y659+acdnLOnP385zv/+58zZ2YMinTplIAhzsoDceaT2RKUQLwHIMFqh0V2ll0kn4XA6byv9/Vw834kX19e7keRQCzhRyk6bJJYRvD1YTXuhRdeqDj77LPPtNls400mU7HRaCzFFggEVJ/iSqhsicFgKIXUKL6bvB6fz9fj9/u7Kb4bPjaK67Xb7Q0HDhw49IUvfKEd2XUb7WpxHIYvXRgJ8AELkzRso1gmKrwkBfjG7373u5Zly5ZNKS8vn2G1Ws80m83YphPI0wnQUemQFp0IzQR9tdfrxXbI5XId6ujo+PCuu+6qXbNmjYfa9NMmngDoBmt+hIe944M53AUhwqwCvXTp0qJrr732opKSkk8XFhZ+imC+gIAryAZB0QnlJuB3OJ3Ot3p6el5/6KGHttxzzz0O6pse+GEP+3AGnKE2EhgG0tAFt99++4WkoT9tsVgW0DaH4guzAeg4+uD0eDxbaXuDNPzrt9xyy3bS8G4qB8BF6OOoKr+yDDfAB0B91VVXFf72t7+9lLT05QUFBZfQoYWtnA+ux+12v0ra/W+/+tWvXlq5cqWTBjUsYR8OgDPU8KGtjR9++OHHx4wZ8+2ioqKv0X4lbfnsWh0Ox9+bmprWzpgxYxsNFBpd1Op5bcbkM+AMtgr11q1bTz/zzDP/gy4Qv02zGtPzmehIY6MZmmq6UF176NChJ+bMmXOkD3QR9khFczY+HwEXwTbV1NTMI229FCYIXSTm43gTho8uUgMwYUir3zN16tR3qAIfbXkJej4dcIxF1dbkm44ePfqZqqqqpTT7MZf2pYsgAZqN2dTS0nLP5MmTX6EsDDrDHqFU7kTnA+Aa2BMmTDBv2bLliyNHjlxCZsgFuXMYhr6nZL7saGtru/eiiy7aUF9f76UeAfKcBz2XAUffVbgJbAuB/Y3KysoldONl5tDjkrs9oBtL+1tbWwH6UwS6/mZSzg0sVwHXTJG9e/deOGXKlOWksS/MOelncYdJo2+vra396axZs7ZTN0XTJYt7Hdq1XANc1dg0DNOqVatGLl68+DZa/3E1XTwCeOn6JLCly6ncU9+mNLnBZRLOYPAHHI5H2l5/8TdHbl3SRjUx6DkztZgrgKOfDLf5xIkT36moqLiLzJG0rAFJAomsKDp1W51S74IZnSIX8DcrXV3LlK/Oe5xqZPsckGc96LkAOPpowrZ79+5ZNK31BzkzQtKI4qxvV0dJTSLJ592kHKu7QfnPxXupFmhzbFkNeTb/tGsae/bs2Va6wr/lrLPO2izhTgLQZIuaaMp1yvTNyvNbb1HomFB1ZtrAUNYqymztGMNt2rhx44T58+evohs1n0r2+AyX8mnT4KIAvZ63lA82f1/55TX1FJ21tnk2As4zJObq6urP0BTgCmlri2TFDmcEcHQDtnlz4w+Uyz+Hm0Rsm2PuPGtcNpkomtZesGBBYXNz8210d+05CXfWsBLaEQNd5I+e8JyyYettCh0zyoBrpawyWbJFg2twv/jiixPnzZu3mhZFzQ2VqIyJRwIZ0+BiZzyeTcqebVcqS350nKKzxmTJBsDRB3WWZN++fXPpps060tpVouxkODEJDAng6GIg0KI0Hv+mcsXnN9FeVsyyDLWJwnCbadXfomnTpm2UcCcGc1blNhiqlNMmblT+9soi6hdmWKC4hlSJDiXgaBsCsNDKvysnTpz4JIWLaJMupyVgKFLGjHtSefrNK2kYFtpwjIeMs6FqWIOb7kr+Yty4cX+m2+0446XLBwkESHuPrPqz8uymX9BwhhTyoQBchZseQiigdcj30grAO+SDCPlAtW4MeLikdMQdyvqt9yp0rCl1SDR5pgFX4V64cGERvdhmRWlp6XU6scjdfJNAcfF1ysqNK5Q5C2F+ZhzyTF4AqHCPGjXKSjdwHqUHfr+ab8cyW8YzZLMo0QTgcj2jfO/S7ynNzS7KxtOI0UqkJC1TGlyFm3pccPDgwfsk3Ck5drlVidX6VWXFxvvAAG0Z0+SZAJzhtjQ2Ni6ld5D8KLeOjOxtyiRgK/6R8uy7S6m+jF14phtwmEBow3L8+PGr6FnJm1MmLFlRbkqgtOxm5am3rgITtIGNtJrJ6QQcHcdPkYUuKL9MsybLKSydlICijKxcrjz+0pdJFKzJ0wZ5ugBnuM27du2aT7ffV9JUIGCXTkqAJEAsjJ2wQlm1fj7tpPWOZzoAB9yo1/zSSy/NoLdJraMwFsdLJyUgSqBQGX/GOuX+FTMoEpCDmZRr8nQBbqIHgovnzp27mtaWlImjkmEpAU0CYGPmR1crF19cTHH4hU854KmuECcMOmo9derUAyNGjLiawtJlWAJZOQ8eTQb27keUyz7xM8qS8jnyVGpwNk0s+/fv/4qEO9oRlWkDJGArvVpZ89JXKC7lMyupApzhNm/YsGH6GWec8eCAAcgdKYFYEhhz2oPK3X+ZTtlSao+nEnDzxWRL0eNmj0q7O9bRlOkhEoA9ft6cR5WPq/Y4IE+J+ZyKSjS7m56jvK+srEzeqQw5epmNyDkbXBRPT8//Kl++6EaKSok9nqwG10yTHTt2fJpWB0q4xYMlw4lLoJhu5z/y3KepYEpMlWQBV7U3mSXFNN99H71YPfEByRJSAqIEwND4yfcpFyzgqcOkGE2mMGtvy2OPPXY9vZjnTLGfMiwlMGgJWCxnKktv/QmVT3pWZbCAM9zmxx9//IzRo0fj0STppARSJ4HykTcqN//3GVRhUqZKMoCrC6no6Zy7yTSxpW5ksiYpAZKA0WhTPj73dxRKakHWYABn7W3Zs2cPvjH5eXlApATSIoGi4i8oK56/tA9ysAr2EnKDARxlzJdddlkJ3dC5N6HWZGYpgUQlMH7SvbRWpYSKsamSUA2JAs7a2/ynP/3pOvrc9eSEWpOZpQQSlYDZPFn54a/xcDoDnpAWTxRw5DfRJ7DL6HUPP060rzK/lMCgJFA+8sfKZd/CqlRc9yXEbCKZWXtbli1b9gN6EX3loDorC0kJJCoBk6lS+ebVP6BiCU8bJgI48ppxU2fs2LHXJNpHmV9KICkJVFZdo3zsY7j5w6ZKXNXFCzhrb/PDDz/8HbK9x8ZVu8wkJZAqCZjNY5Wf3vkdqo4Bj8sWjxdw5DPRt3KKTjvtNNxhkk5KIPMSqBz1E2Xq7ITekBUP4Ky9LevWrfsGae9JmR+ZbFFKgCRgLpik3HL3NygUty0eD+Cq9h4/fnwBbTdIQUsJDKkERo+9QSkr47ubMfmNlQHaG5v56aef/ndaUDVtSAcnG5cSMFumKXc/fDGYpI35jCiXeADH3KOZ7lp+Sy6HjShHmZApCWA57dgJ3wKTtIFNQB7RxQIc6abLL7+cniEesTBiLTJBSiCTEiguWah8/isjqEkAHpXhaIk4M5BuXrp06ZfoOUtcvUonJTD0EjCaipSvff9L1JGYU4bRAEeaCjh9P+fr0jwZ+uMqe9AnAZgpo0Z/nfYY8IgcR0qA9sZmeuCBBybZbLZ/66taelIC2SEBKzF5zTJMWbMdDl5DXDTAVe29aNGib5D2jpQvpEIZISWQEQkYicm5C0QtnjDg6uwJPY72tYx0WDYiJZCoBMorGXDW4iE1hNPMOBMQb1qzZs0MmvueHlJKRmS1BCZYYZoOA2exTFd+dT/eTsuzKSFaPJwkNMDPO++8+fLiMvdA+Z8JJcqPN+9RGnocoZ0PBELjFF2cbjdYIEykvq4wWehd4APb05dBari4gaWCe/p8AT+uFOdT4j7aoJTB7oAGowFurqqqmicBV5QPmgLKX3b7lVbHANmRLLPVVSjnGT6hzFRa44dHHEqIHhQThXC8+YQiqQ66K9rnvakoD1O9DPiAJvSAo8vYjMXFxWZ6U9VFA3IP052fv+5VGntzBW4+SCYl4KtQ/L3tpCBJ0+WpC/hKLgKrvb29DDj41Q4WIvUOcaZHH310lslkGqlPHI77uQd38CgZTBbSVBVKXk+CGYwjS758/ywwS1sIz/oI1uCmmTNnflKaJ7l/OmuQG3migQ9xnvg0W2gaN/2TfYDzoLQDFw5wVYOT/T1XAq7JKacDKuS2csVg1B/unB6W2nkwaiiumEs7rMEBueZEG5zpN9Gt+QKyv+douWQg5yXAkPvtHYO78MxiCZisJXNsVRML7C3HndRN5li1w/WnNPaNDz744Ll0ZpRm8Zhk1wYhAYacjPJBlM7eIgHFUFryxZvPpR6q/Io9DavBJ0yYcJY0T0Qx5U84CDnNrtjb82dQZHqZysefRQPaRltEDc4JRlr7PS1/Ri9HopeAwWRWjLYKQiF/NLnBWgpmocGZY3XYoomCBOybaPXgNKnBVfnk7R8V8qLyvIAcrBoLiqaCXdoYcvXYMeB8KmPfSIBPUVPln7yWQD/kjEEOD7fABsBVfvtGoTIdYoOPHDnSXFhYODmHhyq7noAEgpCPUPyOTiql3QBMoIbsyGo0F04uInYdbW3RTZRbb711AnXZmh3dlr3IhAQYcpooz0RzaWmDTk1r0YLrwS4GwRaJuoMGmXrjOeecI5fHQiLDzKmQF9ILXFXIGYfc8q2jZ4JdBlyFnE9ZHolx1KhR8gJzmMHNw9Ugz8U7nrijWToyZCZFtMEBu7GoqGgiD1j6w08CKuTWUsXv6s65O56GApVdlWM+cnoNbqB3D+JzEdINYwkw5DlnkxvNYJetEdVEETU4Ioy0RLZEzoEPY7r7hh6EvIQ0eQ/FZP/sCpilPgNwKG0VbgyFdzTqCXC8ZFw6KQEAoxgLS3NoPbkR7GosIyxqcBxSgwQcYpCOJWDAOnIrKUbS5AH9M5GcKUt8OiEZcK1HbIMjQiVfAq7JRgb6JADIDQR5tpuuAaMGuGaisAbXIiTgkutwEujX5L2UnJ02uSEIOHdfZVpqcBaH9GNKIKjJQ6yAmOUylYHsa+6cprBZg3MfpA3OkpB+WAkENXmxEnDbs2+e3KABrvU9RINTih56LbMMSAlAAqomL7BRQFOU2SGYgMouOqV1jGHWIrxer50+8iofV8uOQ5a1vVA1OUEecOPtWdlhkxsUH/2saE5lmufBtVifz4erCOmkBGJKIKjJ8V0ETT/GLJPODAG/X8+uOg+O0087BaHB09kJWXd+SSCoyYuUgIceaB/qeXL/AA2uci3a4JB8QGrw/AIwE6NRNbmlcMht8oBftT40ZY2xsw2OsJogAYcopEtUAqomt5Am9w6dJg8ENPNagzysBs/2W7KJCl/mz4wE8OYsg3loNLnKbNAG1+DGqFmDI1LdpA2eGRjytRX19XAEecDr6kMqcyM1BNTrR41ltCxqcAYc6yOlkxIYtASCmhyP9WZ2doVmUXhtL1hWHWtw3lccDkcb1H22L6zROiwDWSmBoCa39mnyDHSRmPV7nG36lliDs1r3t7e31+kzyX0pgcFIQNPkGbrj6be3gV287Z95Vk0U7MCpkdXV1bXyIjMoEPk3eQmokJsKglOIAD1tm6J4Wo7UMsd9PQ+wBse+CvgzzzwjAe+TjvRSIwGGnB4qS02F4WohE8W58zk94CGzKP6XX3652+VyNdN6lFHh6pFxUgKDkQAgDygWxeDzDKZ47DJeV3PvvtfpVQChJgoKs80C+8Xf09NzRJopEIt0qZQAIFfou0GpXoUIVv0uxxHqq8ov+cxzyDShmsFut9elcmCyLikBloAKuZEm71Jsi/vdKrMi4GqTbIMz8cjgw0yK1OB8SKSfagkMgDwVlZMGDzg6oJR9tIFh5lmzwdEMR/pPnjxZiwjppATSJQHVJg/QRaffm3wT9Gvg624GswPgRsXhNLh//fr1u2nRFYCXTkogbRJQbybCXEl2diXgCzh2bthNFQHwAZAz4BgEgEaijz4C29zZ2VkjzRSIRbp0SiAIOT7MgCnExDeyThS/s7uma+vaZqpANFHUbusBZ8i9ra2tWyXgqozknzRLQIMcF56JOiLc19O6lYrB1hmgvVGVCDj2VQ1Ovq+mpmaLBBwikS4TElAhx7vJE55dIWhb6rZQH6G9WYNrXRYBh/ZmDe5buXLlVj85LacMSAmkWQIa5Im0Q4x2bXkUGpzhZo7VWsIBrp4JGzZsaCc7/KDU4olIW+ZNVgL9kMe2x4P2d+dB+86X8NFP1uARAUffWIPDnvHSdOE2CTjEIl0mJRCEPA57nAj3dzXj468qr+SzDa51V9TgiGTAcTZ4yQ7fLAHXZCUDGZSABnlUm5wgba3dDFZpE00Uraf6Bx5YveNM8C5fvnzbJZdc4iwuLqYH7Yavq+ytURq70rRIKIvEGlmZAYswDjZCRBchLUJ0ULeGqYzaQL8AfEj/PA5nz8u/Zw3O2ntAC+EAR0bVnnn33Xe7Gxsb35gyZcqlxhR9mGj/oU7liWfrlPZOd5jRZGfUbK9bmUnPGIYIeEB3B8i1PyUKBHTo+vPFEYrcfpR6orYfR6NZmiUQ8Cs9XU1vbDiyEysI2f5myLVe6wFHAqSlanDyPTt37nz+9NNPTxngv/3DHqW5lV4tkGPO67ErPi+9pgw/mYAGfjyO8zJo+vL6dH2dmc6vb1/fP31/9Pn1+7HK69P15fXt9eUP+LxKR/OB5yk7flrFOfABNehtcCSKgHuvu+66t2n5bGtk7TGgvpg7uQg3BmW22BSTGa8pIwehx+s4L3wxzOXFOM4j+sjHecSwmEcMi3nEsJhHDIt5ENY75IXjMhxWI+P4E6u8Pp3bYV/fHsWDRb/f1Vq3b9XblBzxAhNFowEOte+hlYWO+vr6f6QKcDSaq06F3FQYdeUEow9fDGfLmMU+ieFI/RPziOFU5Y9UT/T4gOJ2tP/D7e7Bmz+hwcNeYKKOcIAjHiaKZqa8+uqr6+l9KYgf9g6QG/sgxwHXbxAQgyCG9fmGal/skxiO1B8xjxhOVf5I9USLV8j+7mjd/Rz1RzRPwGuIiwQ4zBScFaDas3Tp0r0dHR2HpRYPyo8hD+7Jv5mUABj0eeyHjx58Yh+1y4CDVTAb4qIBzpCjEjfNiW+Qd+775dcPeTRdI9NCf+OSlQl98M3RvAFM0sbmCVhNCHAcSah8TYuvXr16PT2MjAql65OAapPjXXzRnP4iCnk5Llw5ToMvhsPlzYU4cQxiOFLfxTxiuC+/3+/xNB9/cz3tito7rHmCIpE0ONJwRrAd7l61alXjkSNHXpBaHKLpd5hZMfELJ3FA9Buy8oESw/p8vC/mEcOcnmu+OAYxHGkcYh4xTPlx38DtaHnhZP3rjZQEDR5xehBF4eIFXDVT1q5d+whp8YhnS7DK4fdXhdyEd/FJl04J+ANef3PDpkeoDTZPkgIcfR2gxe+7776aY8eO/VNq8dDD2A95sjamLE8/eSTggRsuLj2Otn821D5fQ4lxaW8cpWgaHOnQ1pqZQmHXU0899VePxxPWoEeB4ewYchwadhzmw4V4jhPDnJ6oL9YhhuOtRywjhuMtr88n1iGGOZ8YJ4Y5PZKv+H2BthOb/0pl8F5mEfCoFkUswNEHVICLTdVMufPOOw+QFn9TanGIJtTBHjeSucIHCjkQZsfhSOmcL14/2fqSLa/vZ6z6YqXr68M+1p24nK1vHq3++wHaZfMETEaFG2XjARzaWgOcwq4XX3zxYdLiKC9dGAkw5Pqf2czso0OMkRhGXG5u9N5vpb3p/YdpAKy9AR+YjGlJxAs4a3GcPa4lS5bsOnHixGapxUkaEVwQcnqrasYdw80wowMcl/HOJN0gtLfb1bH5yMHHd1FlDDhr75QAjk6yFsdVKyB3bty48UE5owLRRHYa5JgSY8dhniZDPMeJYU5P1BfrEMOR6hHzIBzLcV8j1aePR31cRgxzPjFODPel+xWvv6N5x4OUhCWoYA8MxqW9KV9cJgryAXBocQbcdeONN+6kd4k/J9eoQDyRnQq5se+Fk3yg2UcxDvcdULUmjotcbeQULhtvffr8XC6Sj5a5TORe9KdwXq5PXz5KOn0WUHH2nnyudt/qnVSMtXfMqcH+xuMHHGVYi6sXm2jwpptuWk4PJrfLNSqiSEPDGuShSTImggTUNSdee/uxA2uXUxaGO27bm6uNxwbnvKzF8fOABp2vvfZa89atW/8oLzhZRJF9zVyJnEWmCBKgb14qPZ01f2xv3o03VsE8AXNx295cVSKAo4yoxVXIFy9e/Aw91rZLXnCySCP7Jpo+NNLnPMQvHXAYfjz/UDuXEcNcVowTw5yeal9sQwxHakfMI4bF/HhiyuPq2LV/293PUB6GO2HtjfoHA7g4o4LGnWvWrLnL6XT6pKkCkUZ3gNxAL4HnA4rcCMfrOG+k8rHS420n3nyJthcrPxgK+D2+5oa37qI+qHyRj4vLhLU3xpAo4CjDgOOMUrX4HXfcse/AgQPr6I20SJcuhgQYcvVijS++pN938RpQHD0n1h378Cms99Zrb7CXkBsM4GiAIVenDGnfccMNNzzU0tLSKE2V+OSvmiuYXZFOkwDmvD2e7saa/X99iCLxOBoAF7W3ljfewGABZ1ucpw2d7733XusTTzxxE33+xCNNlfjED3vcqELON2WGr0+WCS03cXtaTmy6qbutppUkyHAnNO+tl/xgAUc9DLmmxWnacAeB/hDdANK3I/cjSCAIebi3d0QokKfRZHcrvZ01D9XtW72DhqjX3mBtUC5ZwGGqaFqcws5LL7109dGjR9+WN4DiPx7DHXLc0HE5Wt7es/m21WCob4PiTOimTjiJJwM46gPg2PiCE2ee/Wc/+9lvyB5vkvY4SSNO12+uxFkgT7LB7vZ6uptq9678DQ3JThsYggkAppgvCg7OJQs4WkUnMH2CMw6dc9ANoJNPPvnkL8ke90p7nCQSpzPS9CFscryHbzhsEEvA7/a2NLzzy46WXSdpV+WH/KQuLFEvu1QAzrY4mypqJ+lVE9u3bdv2Z9jjEnIWd2wfkBsM+W+T9813093K6j/X7l+9nSQjwp3UhaUo5VQAjvoY8gGmysKFC1fSgqxX3G6ckNLFKwEVcu3rY/k5swK729Hb9Mqed29fSXLRmyawCAZ9YSnKOVWAo06GHDTjQgGdti9atOjXdNH5noScpJGAU00VI74+ln+OXv2gOJ0t7x3cduevaXQqJ+TztGDK4IbkUg24aI+rkNNXIrquuOKKG+kBiYNyURZEHr/LR8j99OFXt6v94KH377/R4WjtImkAcBFuMJQS7Q1Jp0NFoHNiBw0Eube2tnbT/PnzFzz3UtMIA76mJV1cEjAYcIhInLgTkuMOZonH3XW8dvdff9zZur+JhtNLGwMO8zal2hviSgfgqBduAOhki7u6u7u3NHWO+yxNidkk5EEhxfM3CHmfSHN0zQq98Fjxunta6w+v+9GphneO0Wj0cKdUc7Nc0wW4qG608AcffNBrMlvfLx0x5XMGo7lAQs6HIbbfLytNnLELZUkOrO2mF2b2nDz64rX1hzccpG7p4YbmBuApd+kCHB3lI8G+2vnOlr0dBYVV+4tKxl1MswWW/gOX8rHlXYUsq+C8ChaeZv8/vOqYvo5hb2l48+d1+9fiNrwId8rmuyMd7HQCLrYJyDXQ20/tOGUxF+6wlU1aYDQWFPGBEwvIcHgJ9MtKE2f4jFkQq9rcnu72xrp//OTIgccx181wY8477XBDBJkGXAO9o2VPm+JzbioZMXWewVRQ2n/g0C3poklgoKyyc57cTxeUXnfHCVrXfU1D7fr9NJ4e2gA4w530OpNoMuK0TAGO9ljlaJB3tVd3u1yNb5ZVzPy40Wyt7L+Y4u5JP5IE+iFnsUbKmfl4zHN7nG3VdXtWXNvU8GYd9QBgZxxujDyTgKM9OAZc9e1dDY6ejoOvl1fNnm0yFY1TaApR/QhoMK/8G0UCGuQGEmUWKHK83jhA89z0gvoPDu1cfn1b864T1H29WZIRzc1iyzTgA+CmTqj7Lkeru6156xsVoy+cQk+fn44DJyHnQxTd1yBXRRk9bzpTsSrQ7/MoLvvJN/a/d9uSno5jLdQew40bOVghmFG4Md5MA4424UJA97rtvub6f71VPupcq9lSNttgNBLj8oZQUFzR/w6UU+ZVOeD2eV2B3u7ax/a9e/PvXI7OTuqxCDcuKDMON6Q2VICjbYacJ/jpHYte/8mjr35gtVUdLCwaPYfmyunDlFKbQ1ixXBByiDRzTl0RGPBiPXd7S8Pbyw68d+/TdAz5YlK8QzkkcEMSQwk42mfI4Wugt53c3uB0nHyttHz6THo4dywOnjRZIK7ojiHPxOw4lg4EYJI4mnfW7V95ff3h9bupd9DarLlhkohTgZk9+/pElS2AA27eVOjt3fW9p4699kr5qFkmc0HZR6TJ0nfEYngDzZUYmQeZrN6ZhEnSeXj1nk2/vr2nsw5vn4LGZrj1i6cG2VLyxYYacIyAz2zW4hro9HPnO3nstZ2FhZX7Cm1j5tCDAEWkyqU2j3HctV+7FJvjWE+CWRKvt6utpeGtX+7f/vv/6zNJGG7McfPFZNpuv8cY/oDkbAAcHRIhF0FXw21N2084HfWv2UonjaHPhEwJaikJ+oAjqdvRINfFD2ZXfSILF5I+Fz2kUP/akT0rlhyv2bCX6mKNDcD1N3CgqIbc4RzPJof+YOoEJx7eioNPl+FDlHSxqdgQnj77h5+oGPeJXxQUlE3Cg7qZ+EmmdnPWYYYjGRec/nMrbnfnsbaT2+6v2f3wZqoPJghDzVOAvNwVDbLCSqbplJTNNsAxKP5hBeR4OBGfSQDkDHpRYWFFyYzzf/Gd4oqpV5JGt+IZxlRqLGorr1zwmdjEmOMZEp/X4erpqFld/f4Djzud7ZghgabGBrDZ1sYsCa/lTqwhKphOly0min6MLCT42KAV2Kbzeb1Ob9Pxf+32utteLSqZOJ4++jRJmi16Efbv95/8rDsi++pzFX3mCM1kvXPkw7X/Vbd31eskc3H6D9pbhBvHJ7mfiv7upjSUjRpcHCD6xyYLa3PW6DBbVM0+4/yffKq88iPXmq0jJuOdf/J2vyjC/nBQk/fviyHRzva6u462N+96qHrng29RHtbUrLUx9cc3bljpsEISq8yKcLYDzkIC5Aw6bHNAzva5CrnZbC6c/pHrLykbefYVZmv5NAk6iy66PwBsV8fhrrYDj1Xv+uOr9GYyBpt9ntcWbe2s1NriiHMFcPSZtTlAhzZn0AE4ww7fOuP86z45ovLcKyzWkecEL0RN0kYnwYguaGP78MJLetl8277O1j2Pffj+n96mPAAZG8BmHxobYPMdSYCdtVqb+qa5XAKcO40+49qBQYc2Z42uAk77qj919tUfqxh1wZXWosrz6cEKslxQbPhOLwZNFKz4I7D9broL2fp+e/OO1TW7H3mPBMNgi75ojgBqvpCkYG64XAQckkW/sYlmCzQ6Ty2KoBeccc53Z5eP/uiXrIWjFpjNRTaD+no0FM1/2DWo6cIRb3D1eh12l7P5jY5TH6yv27cGt9cBsQg1wtDWvIl2dk5obeq75nIVcB4AQ86gs+nCoLNmV7V8YcnY4ikzvr3ANuKMz1mLqi4k0E3q+7nVu6OoIn+cOv9NUyJ4+ACfBKG3t263d9a9XPvh2jecPSdxg4a1M4BmyBlqnvaD1s4ZcyTc0ct1wHlMetBhi7CNziYM+6qmrzrtwtHjJi/6rK1k/OfoiblpAJ1hz0XNzpoai6AANTafu/uwvafh5cajG//ZcmL7KZIJA8xwiz7SoK1ZY+c02DQO1eUL4OJ4grZH0E6HRmetDsAZetE3T5q6eHr5mPPmWQurzjcXls8i0K20VFcx4iWYeA9JFpoyA4CmJatYI0JQu7zOjr0uZ8v7HU073zlW82w1dR7aGPAC5nA+0llj8z2HnDNFaAxhXb4BzoMMUtlvo0Ojs1bXA69qdEqHby4sLLeOm7p4Vln5tAsshRXnFxSMOJseirbgAhXPjAZvmrDYgn7/jRRuPjV+EGLUxbzRBSKWqdJ7RnChGKBPftAt9AMeZ/v7XR2HdzTWPLvX6eyAycFQA2jeGHBOY23NGhuNcEMUzA/HRyo/RhM6ChF0aHbRVhe1O0POceybiovH28ZNW/SR4pJJ55oLiieZzLZJJottPFY2BoHHWnWAT1Wr0owkUn18JJYoHv9xUQiQNd/roJfnNPi89mNed++x3p5jexoPb9zV29uAu4qAlDUx+ww2fI6Dz0CL9nWkzlD23HZ6qef2aKL3HmNl84VBZ83OQEfyOR98lDWOnjB3dFnFOZOttjGTLIWlk81m20RaMlBpUEw2Ay2QoRPARg1SffQXF7F9vtpFaOEgxbSrhuhDAV57gBZ+BBSf3e9ztXq99uMeZ/dRl73pWFf7vqOn6jfBhmYoRe0rwhsuLOZlu5p9tTv5/Gc4Ac7HEWMWN4ZW9AE6Q83Q8z6fHKKvQq+r10DmjrmoZEKx1Ta6yGItK7aYy7AiUvF4u+weV1evy37K4eip7yWzAmBCi4obwwyfta7oI8xAM8TYF/NwWbHevNXWNPYQNxwBF4Uggo4wg8q+CL0IuAg350Ec18H1oi0xjH3RMXiI4zBrVwZcDyxDy1DzPudnn+tjX2x32IQhfOmCEmBZMJDwGXQxLMYBbqSxz5AjDg4+b7wPH9DBMXz6fUCKOEAs+gwv+0gTw9jHBsd+cG+Y/uUDMUyHH3XYLBsGNJIvQq3PgwbEesQGGUDRR1i/Mez6eHEf9WJfOp0EWPi6aLkbQQIsLwYZ2aLFiekRqhwAJkPK8KJMtLhIdcr4PgnwwZECSU4Cejnq91G7Po7BFVvWx+n3xbwyHIcE/h9VLWRYHWXC/QAAAABJRU5ErkJggg==', // @suppress longLineCheck

    green: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAAC4CAYAAABQMybHAAAltklEQVR4Ae2dCXQcxZnHR3NoNDp8SD7kU7bxFXCchBhMYoLNmhCcOBBykGw2gYTkPV6AhGXD2sTZJQcJG3jsgw3hscuCsTEsOAQW1sbY+MAHxpYtHzI+5EOy5UMStnWPZkZzab9/j75WTWt6NKO5Z6r82lVdXV1d9e/ffPq6uro7zyBDIhXIi7DyngjLyWJRKhDpCYiy2pwoztrpxSwCb+d1bayFm9f1Yu3+cj2MAgOJH2bXnNnEGiHWppW8d999d/inPvWp6YWFheNMJlOR0WgswdLT06PElFdM+xbn5eWVQDXK76TI7vP57H6/v5PyOxFjobwuh8Nx4dixYye+9rWvtaK4ZqFVNY/TiGUIoQCfsBCbcjaLNVHgJRUQG3/4wx9ali1bNmXYsGEzrFbrdLPZjGUagTyNAB2ZCLXoh3CJoD/p9XqxnOju7j7R1tZ2/LHHHqtbtWqVh47pp0X8AaAZbPmRzvnAJzPXhRBhVoBeunSp7b777ruuuLj4xoKCghsI5s8TcPnpIBT9oNwE/D6Xy7Xdbrd/8Oyzz+5+/PHHndQ2LfA5D3suA85QGwmMPLLQ+b///e/nkIW+0WKxLKBlLuUXpAPQEbTB5fF4KmnZShb+g0ceeaSKLLyb9gPgIvQRVJVdRXIN8CCo77777oI//vGPt5CV/n5+fv5NdGrhK2dDsLvd7k1k3f/n17/+9frly5e7qFM5CXsuAM5QI4a1Nh4/fvza0aNH/4PNZvs2rZfRks2h2el0/u2TTz55dcaMGXuoo7DoolXPajcmmwFnsBWoKysrJ02fPv3v6QLxH2hUY1o2E63XNxqhOUkXqq+eOHHitblz557pBV2EXW/XjM3PRsBFsE21tbXXk7VeCheELhKzsb9Rw0cXqT1wYciqP37FFVd8SBX4aMlK0LPphKMvirWm2FRfX//lESNGLKXRj3m0LoOOAjQas/Py5cuPV1RUbKQiDDrDrrNX5mRnA+Aq2OPHjzfv3r3766WlpUvIDfl85pyG1LeU3Jd9LS0tT1x33XVrzp8/76UWAfKMBz2TAUfbFbgJbAuBfUdZWdkSuvFyZepxydwW0I2lo83NzQD9rwS69mZSxnUsUwFXXZHDhw/PmTJlytNksedknPpp3GCy6FV1dXX/OGvWrCpqpui6pHGr+zct0wBXLDZ1w/TSSy+V3n777b+j+R8/pYtHAC9DrwIO9xHD5c5XDF5fS0ya0MWo3+nwvrBx47nfLLlvKypj0DNmaDFTAEc7GW5zQ0PDD4YPH/4YuSMJmQMSExVpsPPxhjsMHt/FuLWkp8dwqb3dt2zhnD2vUKXsnwPytAc9EwBHG01YDh06NIuGtf5DjoyQGmHC4XMLwmwd/Caft2fnmXr3A3d8Zf9hqgXWHEtaQ57Of9pViz179mwrXeE/MnPmzF0S7sEDGuueJnPevCuusO76sPq6R2bPHm2l+sy0gKG0NZTp2jCG27R27drx8+fPf4lu1NwQ6wnKlf0TZcFF/bwe//Z9uxw/vvfuj89Tftr65ukIOI+QmE+ePPllGgJ8UfraIloDp5MBOFoB37zxQvdPvr5gP24SsW+OsfO0CenkoqhWe8GCBQWXLl36Hd1de1vCnTas9GtIXp5h5LgJ1re3H7z2dwsWjMTUYlwrpZXLki4WXIV73bp1E66//vqVNClK3mLvh1RkGcmy4GJr3B7/zkOVXXfd86PD5yg/bVyWdAAcbVBGSY4cOTKPbtqsJqs9QhRPpqNTIBWAo4U0l+1yw1nXd29duH8nrabFKEuqXRSG20yz/hZPnTp1rYQ7OpjTqTRNUhwxtsK69t3tcxZTuzDCAsOVUiOaSsBxbAhgoZl/d02YMOF1SttokSGDFSCabeVj819/v3LOXdQNCy04xynjLFUHVuGmu5K/HDNmzHN0ux2/eBmyQoEe84gRluc2V13zS+pOSiFPBeAK3PQQQj7NQ36CZgA+Kh9EyAqqgzpBQ4h5w4aZH6URlidwrmljSix5sgFX4F60aJGNXmzzYklJyf1BqsiVrFOgqNh0/5ubJr24aFEp3M+kQ57MCwAF7pEjR1rpBs4KeuD3W1l3NtOkQ6kaRQnXfZfL/+Y3bqz7Ed3f6KZyPIwYbpe4bEuWBVfgphbn19TUPCnhjsu5y6hKCgqM33pr4+QnwQAtSbPkyQCc4bY0NjYupXeQ3JNRZ0Y2Nm4KFBab7tlSdc1SqjBpF56JBhwuEI5hOXfu3N30rOS/xk0tWVFGKjB0mPlfN1bOuRtM0AI2EuomJxJwNBx/iix0QfkNupJ+mtIySAUMpSPyn16z5fPfICnYkicM8kQBznCbq6ur59Pt9+U0FAjYZZAK4J6+aczE/BffWn/1fJIjoXc8EwE44Ea95vXr18+gt0mtpjQmx8sgFVAVIEgKJkzJX/2fq66aQZmAHMzE3ZInCnATPRBcNG/evJU0t2SI2iuZkAoIChiNeUM+O6d45cLbxxVRNv7Cxx3weFeIHwwaar148eJTQ4cO/SmlZUiyAuk4Dh5Ogs5O3wsLPrfnQSoT9zHyeFpw/FhQn+Xo0aPflHCHO6Vym6hASYnpp29v+dw3wQ4tYChuhjdegDPc5jVr1kybPHnyM2IHZFoqMJAC48Zbn/nzi1dNo3Jx9cfjCbh54cKFRfS42Qrpdw90OuV2rQLwx6/9QvGKhQsVfxyQx8WKx6MS/EgUv5vmGTw5ZMgQeadSe/aSvJ5pPrgoj73D91/zr97zEOXFxR+P1YKrrsm+fftupNmBEm7xbMl01AoUlRjvWb1u9o20Y1xclVgBV6w3uSVFNN79JL3LLuoOyR2kAqICYKhisu3JBQvG8tBhTIzGsjNbb8vLL7/8C3oxz3SxoTItFRisAhaLcfqyP435Oe0f86jKYAFnuM2vvPLK5FGjRuHRJBmkAnFToLTM8tCfnpk5mSqMyVWJBXBcWFro6Zw/0Z+Vwrj1TFYkFSAFwNQX5w/5N0rGNCFrMICz9bZ8/PHH+MbkV+UZkQokQoGiQtPX/rb+M7f0Qg5WwV5UYTCAYx/zrbfeWkw3dJ6I6miysFQgSgXGV9ieWHjrqGLajV2VqGqIFnC23ua//OUv99PnriuiOposLBWIUgGLJa9iya8q8HA6Ax6VFY8WcJQ30Sewh9DrHn4WZVtlcanAoBQYXmr62fe+NwGzUnHdFxWz0RRm621ZtmzZT+hF9GWDaq3cSSoQpQImU17ZnfeO+gntFvWwYTSAo6wZN3XKy8vvjbKNsrhUICYFykZa7r1mwUjc/GFXJaL6IgWcrbf5+eef/wH53uUR1S4LSQXipIDZklf+m99N/AFVx4BH5ItHCjjKmehbObaxY8fiDpMMUoGkK0BW/OezZxdH9YasSABn621ZvXr1HWS9Jya9Z/KAUgFSID8/b+KjT02/g5IR++KRAK5Y73HjxuXT8oBUWiqQSgVGlVseoCnZfHdzQH4HKgDrjcX8xhtv/B1NqJqays7JY0sFLPl5U59bVbEQTNLCfOoKEwngGHs0013L78npsLo6yg1JUgAMjhlb8D0wSQvYBOS6YSDAsd30/e9/n54hHrpItxa5QSqQRAWKh5gWffWbY4bSIQF4WIbDbcQvA9vNS5cuvY2es8TVqwxSgZQrYDQabHffU34bNWTAIcNwgGObAjh9P+c70j1J+XmVDehVACyOLs//Dq0y4Loc621g59301FNPTSwsLPyiVFcqkE4K2ArzvvjPv52GIWv2w0P64uEAV6z34sWL76BfjF65dOqzbEsOKQAm5/9diWjFowZcGT2hx9G+nUO6ya5mkAL0WBsDzla8X+tDWWa+uDStWrVqBo19T+u3l8xIawUsplFp3b54NY7mik/703/MxNtpeTSlnxWHk64NKuCf/exn58uLS6086b8+3Pqg4WDNHw0O5yf9Gkuf9+sX6N3twXmaVWwMkUWv+Q7eLVShHk1mv310Kg9Vrt/h/PStQoN/PlVxhBYYa7AbVCwc4PQxzxHXS8ANhkZ7jaGq8W8Gh6ed9MuM4C2ebrD7Jhp6CIJsDr481/UGw4nnqY8MeFB3tYDjF6BY8KKiIjO9qeq6oNI5urL+1L8bOt2XM673PrPf4OjwZDXk/p6e68BqV1cXAx5kxUP54MgzrVixYpbJZCrNuLOagAZnItyQwWQ2GgppXlKeEec8OwON75V+/YErZlHv2A8P6qieBTddeeWVX5LuSZBWGbnCkDs7PQa/PyO7EL7RZI5HTCj+EhXaTwt7IKpfprXgintCBU3kf8+TgIfXNlO2AnJbicVAt7izLoBR2xDLPOoYW/CgP1eiBWf6TXRrPp/877lZp0YOd4ghhyUPNUKRydJYbaa5IyYU5l8+53BRP5hjxYprf9NYNz7zzDOfpl9GSSZ3Wra9vwIMORm9rArUn5Kbfzzt09QphV+xcyEt+Pjx42dK90SUKXvSDDksedYEwnrYyIKZ1J89tOhacN5gpLnfU7Om87Ij/RRgyLPJiFlsZjALC84cK/1GBgdswLqJZg9OzabOcwdl3KcAIC8oNuMtrn2ZGZpCHyxW0xXU/H4Xmgw49xLrRgJ8Sob2VTY7CgVUyLNgnLwXcIXfXgkUpvv54KWlpeaCgoKKKHSSRTNYAQXyIrPB1eXVzOLIrE5ZrcaK0lKbuaXFCbDZYCsuCfcEmcbf/va34ym2cqaMs18BhjyTZ/3TmKB17ncngV1Y8X6AM/XGq65SPsaZ/WdV9jBIAUBuLSSfnPFgIjIoHj2pCFO7xR6oFpy7YRw5cqS8wAw69bmz0gc5cMiwQE0uKrH0G0kRfXDFQbfZbBMyrGuyuXFUQIGc3p/Q7fSRT65O6YjjERJXVX6hCewqHPNRsILAFjyP3j2Iz0XIkMMKBCA3ZdwQosloBLsqyziFogXHBiNNkS3OhrFRdE6GwSsAyPPJkrvJkmeCHVeYNeUBcPbBlc7ziko9AY6XjMsgFVDmkysXnqAjAwIN54NdlWWkRQuOLuRJwCGDDKyA0ZRnsNrM5JOn/zi5yZzHgHPz1VEUZCjkS8BVbWSiVwGGXCEkjVUxGlXA1b85bMHVDAl4Gp/BFDaNIXe7vGk7uEL+iOheK0zzKAqkkxY8hQBlwqEBeX4BJmilZ2uNRuX6UeGYW8gWnNelD85KyDikAgy5uzv9xslNRvUiU217PwtOW7TQq4VlQioABRTIrTQzNc1MeU9eD9gNacHVPzper9dBH3mVj6tJlsMqwJB7yJKnyzg5vTXAITRaYZrHwdV8n8/Xpa7IhFQgjAKAnOZhp83gSo/foGVXGQfHD1D9EcKCh+mT3CQVCFKAIfe6yZKrFAUVSdqK39cjsqtwLfrgaEiPtOBJOx9ZcyBAbs7H3JUUd8mnWPCgn5l4QalskICn+CRl6OEVyMld8brp9VkpMuU9fj+7KCrkIS14v9fpZqjostnJVYDuJJIlJ6RSYMrBrK9HAVyFG71nC45MZZE+eHKhyLajMeQ+jz/phtzvy4MPrrIMbUULzoDbs0102Z/kKgDITRZj0g253+8Huwy40mm24KoCTqezBeZezglXJZGJQSgAyA0EOSx5MgLcfp+7p0V7LLbgTL2/tbX1tLaQXJcKDEYBtuSD2Xcw+zg6u8EuflHMs+KiYAVByTx58mSdvMgMCCL/j12BpEFO9Laed9Yxx70t72ELjnUF8DfffFMC3quOjOKjAEOeyMEVfOyqevtFLeD9RlH8GzZs6Ozu7r5E81FGxqd7shapAI1mwCen5zz93sT45H5Pz6UTey52ktb9XBTor1jv3o1+u91+RropkEWGeCoAyI0EebyHV8Bqt8t7htoKuEMCjn4AcqWAw+E4jQwZpALxVkCBnG7tK5DDZ4nT4nb5wawIuNJ09sFFC+7DSIq04PE+tbI+VoAhj5dPjiHCbrsXgNNTGMEWXBwHVyFvamqq48bIWCqQCAUAeQ8ZcJoBGHP1+KF0NHvALCw4c6zUG8qC+995551DNOkq9iPH3HRZQTYrgJuJmKQVa6CvOffUfNhwiOoRXRSFXwYcx0AGCvjoI7CX2tvba6WbAllkSKQCsUKuXGB2eWsr37twidopuihKs7WAM+Te5ubmSgl4Ik+trJsVYMgHMz0E/ndXm6eS6qI3E+m7KHwsxYLTiq+2tna3BJxlkXGiFQDceDe5EiMd6UIPzLU0OneD2d4FDKtBz4L7li9fXkmzs4IKq3vJhFQgAQow5NFUTYT696w5DwsuuieK/416QgGu/BLWrFnTSn54jbTi0cgty8aqgAo5rj0HWHB7vtvhqTnyUVMrlWYLDrhDAo62YQOsNvwZLw0X7pGAkxIyJFWBgHsy8CHhf9tb3Pj4q8IrxWBXhRs1iBYc6ww4fg1e8sN3ScAhiwzJVoAhJ1dc/2YnNaq5oWsXRQBcdFHU5oo3epAJwBly79NPP73npptuchUVFRWoe+RgwnXRZmh3YBQqu4OuMQuyiX0a6GQHCuhs1D1GX7VBKVhp7APgtfvSS4dcm1bUsQVn6x105FCAo6Diz3z00UedjY2NW6dMmXKL0ag19kHtiHil9nyj4b2dVYaOLvEVFhHvnpKCXs9XDUa3m44dpF1QW7TiB23UWdHdR+cw8DlDBlCgE/S30A5h9tOpLubsaG/r6JWnJ+gNrtbmrRdO7sYMQva/GXK1nVrAsQGaoCDMvufgwYP/N2nSpLgB/sJb6w0tHWhTZgV3t4teidBNjYbkkEhPem2/uCyjpt1fu127f7LLa4+vbZ+2Pdry2vWB9tdu1+6vPV6gvN/vMzTUHv8/Ku2hBaz2gxs1hTLLqIEB995///07aPpss661QS1RhEyEG93LtxbQKxH4+7gQPdLAZRGLad5fzOMyYoxyXEZMi2XEtFhGTItlxLRYBmltQFkE3ofTSmYE/w20v3Y7H4dj7fECrorP42mu2rZhB23VvcDEnuEAh9n30MxC5/nz59+LF+A4aKaGAOT5wbxpO6M9X9jOedqyqVjntujxo21Tostrjxfheldnx3tuu91JxWHBQ15goqpQgCMfFpytuGfTpk3v0PtSkJ/zAZBbLL2QMyRiDIUYCjEtlkllWmyTmNZrk1hGTMervF49YfL99JbNpvrat6k5onsCXvsFPcDhpuBXofjhS5cuPdzW1nZKWvGAfhaGvJ+cMiPRCoBBj8t16tCOTUfoWAw4WAWz/UKoi0wUQmGGHJW4aUx8TVlZ2YP0DR9sz/kAyBG8HsgjQ7IUAOD2jvY1dDwMa0F8hjsk4HoWHO2FyVet+MqVK9+hh5Hl2YQyvQGQm/PJXQkXcKcCge9YcFrJDPFftOVDVJFWWdH2Z4Dy9PpjT92R/e9QH8EiPAwwGtI9oXxdHxzb8ItgP9z90ksvNZ45c+ZdOf8K0vQFC42sKJAzwNoYRfmkiWltOV4Xy4hp3p5psdgHMa3XD7GMmKbyALKrs/3dMx8faKQkLDgAB6MhrTflRww4fi3uV1999QWy4rq/FlSYi0GB3GLJxa4ntc9+r9d/5tjHL9BB2T2JCXA0PsiKP/nkk7Vnz559X1rx/ueVIQ9z8a+OJMsygYGmaHTAXVdnZ+f7x/bsqO0FfEC4cZbC+eDYDmutuimU7v7rX//63x6PR/dPAnbK1QDITcoQYq/fDSHwp5hjMR3I7b9d70+3Xj7XPdj6Yt1f266B6htou7a+3nW6c9lTf/Lwf9PuuJ0suidhPYqBAEdzUAEcecVN+cMf/nCMrPg2acUhTf9goYtOk5ncFT5RKII0B07rbedykcax1hfr/tp2DlTfQNu19dE6Rk4c9o5th3d+cIxW2T0Je3HJ1UQCOKy1Cjilu9etW/c8WXGuQ8YaBVTINflydXAK+H007+TUyedpb7begA9MDuhJRAo4W3H8erqXLFlS3dDQsEtacVJDJ0jIdYSJMhvW29nVuevAtvXVtCsDztY7LoCjSWzF4dgDctfatWufkSMqkEY/AHIzja5gLjMHTgcm9AfyOQ9lOM3bo43FOsS0Xj1iGaQHCtG2D/XxPmKa2yPmiWne3uP3+Zvqjj9D21y0gD0wGJH1pnIDXmSiDAIAD7rYfOihhw7Su8TflnNUFH10/zPTRafJbFZOMp9ojrETp/mEinm6lYbZEG192vLcDr042vZp69fuH247psR2tDS/XbVl/UHaj613RKMnLFEkLgqXZSuuXGzigA8//PDT9GByK/6MyKCvAEOuX0Ju0SoAprzd3a3VO9Y/TdsY7oh9b64vWsDZF8cBXZs3b75UWVn5Z3nByXLqxwHI5c0gfYWCt8B6Nzde+HPj6dN4VhDuCZiL2Pfm2qIBHPuIVlyB/Pbbb3+THmurlhecLKl+DH9cHULkYuyfI45kwX68j5jmfcU8Mc3b4x2LxxDTescRy4hpoTwezXN1dVVvfeuVN6kIwx219Ub1gwGcrbhysYkGrFq16jGXy+WTrgokDR8UyE00iZNPKIojHWngsnr7D7Q90uNEWi7a4w1QHgz5vF5f3ZEDj1ETADdfXEZtvdGFaAHHPgw4flGKFX/00UePHDt2bDW9kRbbZRhAAYYcWMslWAMDPcxgb768mm7qYL631nqDvajCYADHARhytuLOBx544NnLly83SlclMv0BuZFGV2ToU6CH4HY7nI37Nr/3LOXicTSt9e4rHGFqsICzL66Oi+/du7f5tddee5g+f+KRrkpk6pvplr4CObsbORwDKBpy9pyuqX74YkN9M60y3FGNe2uVHyzgqIchV604DRvuI9CfpRtA2uPIdR0FFMjlU1L0pQcvjZo0PHvggw37SCqt9QZrgwqxAg5XRbXilHbdcsstK+vr63fIG0CRnw+GPFf9cbpbaejqaNuxZfXylWCod+G7lmAsJYDjDOLgWPiCE788x4MPPvgb8sc/kf44qRFhCECeez45/O5up/OTqo3v/oakwuvOwBBcADDFfFFycCEWC85HRCMwfIJfHBrnpBtATa+//vqvyB/3Sn+cFIkw4Ja+URxCzHKfHGaZ/tJ76SmdX9FrIJpoVeGHYrDEw4KUHHyIB+BoJxrDrorSSHrVRNWePXuegz8uIY/8BCmQG7P/zQVgAn735aYLz+3fsq6KFBLhjunCUlQ7HoCjPoY8yFVZtGjRcpqQtdGtvLhSPKxMh1MgYMkBefZ65TRJ0NDZ1rpxy2vLl1NHta4JDCaYijnEC3A0hCHnURU02rF48eJ/oYvOvRLy6M6ViVwVoymepye64yeytI8sd1dH+94tb6z4FzDSu/CwYNzgRh/iqSAAF/1xNNhBX4nouPPOOx+iByRq5KQsSB55YMizyRXHiEm3vbNm99o3HnJ2dHSQGgBchBsMxcV6Q+lEOHtonNjAPILcW1dXt3P+/PkLPth/eGgePqclQ0QK4L3synvBs2BKMmYIuhz2c/s2rf1ZY33tJyRAFy0MONzbuFpvCJwIwFEvQhDo5It3d3Z27naYCm6mGXWFPNE9UFT+H04B/vhAgPHM9Mv9fvpglNPZfGjnpntOHzl0lvqrhTuulpv1TBTgogVX0wcOHOiix7j2Dx899is0HJYvIefTMHCc1/uFjUwckcL9EHphpv34gY/uq9nzUU0IuGG5AXjcQ6IAR0MZbI6VxjfV17UVlQw5OqR0xEKah2GRkEd+TlXIIW2GGHK86tjtcjnqjx74pwNb38dteNFyx228W0/FRAIuHhOQq6BfqD1+0WIp2Dds1KgFNCRmkz65KFX4tAp5Bvjk8LndDkfriQN7fn5g6waMdTPcGPNOONxQMtmAq6DTnasWn8e1s7R8wvVkyEv4xKFRMoRXQDUIiiGnz16n4b8eGud2d9kbqnd+cC+9bu0o9chOCwBnuHEzJyF+N9WrhmQBjgOyBVchv9xwobOro3XbqPGTrjVZLGV8MaW2TiZ0FQhATlKyqrolk78B49z0HsGT+zatua/uyMHT1AKAnXS40fNkAo7jITDgStx++aKz+cLZD8onTZ1NryEeA59c+uUBoQb6X4UcBdPAJ8dwJt5CRTMDD+xY88YvGs+caqCWad2SpFhu1i7ZgAfBTY1Q1umdz+7zp45uHXfFjCn0AstJeUYJOZ+ggWLVXUmxKcesQHqWkm6/t2zd+saKJW0Xmy5T2xlu3MjBDMGkwg3tkg04jonQD3S60vbVVh/cPmbyFGu+rXA2+eRkyGGWZBhIAdYpYMST75H30Bg3fcqlp62p4eWNry7/N3rVWju1WYQbF5RJhxu6pQpwHJsh5wsN+nit13+quupA4ZChNSVDh881mkw0wiKtOcQaKEAnCJrMoMwIpJESj6Orlaa8Ltv2v6++QeeQLybFO5QpgRtapBJwHJ8hR6yCfuFUzQX6U7d5RPn4K8kvL5cuC6QaOKiQJ8EfJ2/bgItJR3vbwb1b1v3iaOX2Q9RCWG223HBJxKHAZP/+FMHSBXDAzYsCPV18dp06eGBjecVkk7Ww6DPSZVHO14D/sbsyYMEYCuDOpNfj7mlpOL9yw6oXf996sQFvn4LFZri1k6diOFpsu6YacLSef9lsxVXQ6c+d79ShqoN05/NI0TByWYxwWWjAQPrmYc96nz7xNeWBhxRofNvpbDl7rPpX2/73f97qdUkYboxx88Vkwm6/h+28ZmM6AI4miZCLoCvp86eON9ibWzYPHVk+mlyWKXBZMC7WdyI1vZKrvdqwrLEJArAxSoJvgna0XNpctXntkqOVHx6mWtliA3DtDRwYqpQHkJJOAe3BXFr88PCmSist+OKqjZZCpK+55bYvVEy78pcFRcUT8eRL3zAZbZWhnwIAM5bAw3/dXfaz9SeO/vve99fsovrggjDUPATI011xwPj8smJpeO++6QY4mhUwzwHI8Zg5vrQKyBl0W0FJSfENt/39D0pHj73LYrVayXWR1pwE0guBGYjRMaeOkNBDtc1NDSs/XLP6FVdnJ0ZIYKmxAGz2tTFKwnO5ozsQ7ZjIkC4uiraPLBJiLLAK7NP5vG63t/bQvkMOR8emoWWjx9Fr0CZKt0UrYd96nyvHtkM/xhwudkfsra0fHtz6/j/v2/zuB6S5OPwH6y3CjfMT25+KvubGNZWOFlzsINrHLgtbc7bocFsUyz7vq9+6oXzK9PsKCgsraE6L4rb0nVSxutxOByx5aA3Yz/aRn+1yOOobT598dte6N7dTabbUbLUx9Mc3btjosEEKXXkKc9MdcJYGkDPo8M0BOfvnCuRms7lg7uJv31Q+ruJOa1HxVLzcEv65BJ0lDB0z2LiAJD/7VNOF+pcr1/5tE72uhMHmmMe1RV87La222NNMARxtZmsO0GHNGXQAzrAjtn5x0Te/VD556p0FxSVX4Y1RmIorQSdlhKCAjfFsL1lse+eRptOnXv7ovbd2UBGAjAVgcwyLDbD5jiTATlurTW1TQyYBzo1Gm3HtwKDDmrNFVwCndSW+5uavXzNu8oy7CocMuRpfVgi8hiF3hxcDLgpm/GFilMfg6OjYf+H08ZU0MrKXNGOwxVh0RwA1X0hSMjNCJgIOZdFuLKLbAovOQ4si6PlXz7959tipM28rKhm2wGzNL8TrGHLlopShxoQo3Fr3drsdXZ1tWxtO1byzf9v7uL0OiEWokYa15kX0szPCalPb1ZCpgHMHGHIGnV0XBp0tu2Lli4eNKPrc/C8vKC0v/0phybA5NI5uogldivuSbePpGAkB3JifjU+CODrbqlqamjYc2LZxq73tMm7QsHUG0Aw5Q83DfrDaGeOOMBRinOmAc1+0oPONInZfxFix9BOmXjVq+py5Nw8rG/kVmp47lV+XFvDVM8+NUS11H9R0S91xqq350oYTVZXvnzt15CKJxQAz3GKMbbDWbLEzGmwRDE5nQ8ygIwbksOhs1QE54NbG5qu+cMO0cZOmXW8bMvTqgsLiWQS7FW95hc+ersAHA+1XXmRJlrqbXqxz2NnRvv/CmZMfHtm1/ST1F9YY8ALmUDG2s8WGC5IVYFM/lJAtFpz7wzH6xbADdF4AuBZ4xaJTvrKtoLjYOuvaL80qGzPx8wVDSq622Yo/ZTSbLLhbqjwzqsxPp9JKCMiXqBGaAMQ4UMD1xU0Y8jsMmM2HJ9ZpLprH6bQfc3V07m9uPLvv8J4dh112O1wOhhpA88KA8za21myxldqpfFaFbAWcT5IIOvx00VcXrTtDznkcm4aWlRXOuGbeZ4aXjfm0xVYwMT/fOtFsLRhnwsMYyvCjUQG/76KVD62NtVIHoNWWUiAmoHFRCJAVX5pi+oKdk+zzBbe7+6zH6Trb2tz48fG9O6vbm5txVxGQsiXmmMFGzHmIGWjRvw7dGCqc6UGreqb3J1z70VcAzjFbddGVYbC1sVhW+aFUzPzMqNETJ1YUDyubaLUVVeRbrRNMFnOZyWguzAvAj9fToZ6AmwPLjxUKCk1EMltoir30OJOjhyD2+b0On8fb7O7uPtft7Kq3tzWf/eTs2fr6mmr40AylaH1FeEOlxbLsfnCstCeb/2PNs7mP2r6hz+ICeNmycwwwGWqGnde5jBgjjUWsN4/cHfPQ0lFF9PidzVpUWFRgK8KMSIPL2eXo7qLRuvZWZ3vLxS5yKwAmuwgcM8yI2eqKMdIMNEOMdbEM78t1ckzFciPkIuDimQ0CkjYwqByL8IuAY7u4jcujPqS5XkoGpbEuBhE4TrN1ZcC1wDK0DDWvc3mOuT6OxePmTDrXARdPNGvBcCLWgsvrDDEgRzmOOT9UXTgW5wM6BIZPuw5IkQeIxZjh5RjbxDTWsSBwHFjL0f9Z8BztfthuszaIwy0i1NpyOIBYj3hABlCMkdYuDLs2X1xHvViXQaMAi6/Jlqs6CrBeDDKKhcsTt+tUGQQmQ8rwYp9weXp1yvxeBfjkSEFiU0Cro3YdtWvzGFzxyNo87bpYVqYjUOD/AZrbm7Ts1rpFAAAAAElFTkSuQmCC', // @suppress longLineCheck

    red: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAAC4CAYAAABQMybHAAAk/0lEQVR4Ae2dCZxUxZ3Hq8/pnhkGmOEQuQS5VCTxWHEDBlyNkciakMMkxujGuOvHO24IKCae0UQlKwmyroocoqtozGpA4oFiVAQU5IaRcchwDsPczNF39/5/b+bfVL/p7ume6bur+DyqXt31r2//5//q1XvPIJRLpgQMMVYeiDGfyhanBGKdgDirzYvsLLtIPguB0/lc7+vh5vNIvr68Oo8ige6EH6Vo3iSxjODrw1rcm2++2f+MM84YV1hYONRkMhUZjcY+OAKBgOZTXDGVLTYYDH0gNYpvIa/V5/O1+v3+FopvgY+D4tra29uP7N27d98VV1zRiOy6g06DcRyGr1wYCfCEhUnK2yiWiQYvSQG+8ac//all3rx5o/v16ze+oKBgnNlsxjGWQB5LgA5MhrToh1BL0Fd4vV4c+1wu176mpqYvHnnkkf0rVqzwUJt+OuQfALrBmh/hvHc8mfkuCBlmDei5c+fab7nllguLi4svttlsXyeYzyPgrJkgKPpBuQn4LU6n88PW1tZ1ixYt2vjoo486qG964PMe9nwGnKE2EhgG0tDWBx988HzS0BdbLJbpdEymeFsmAB1DH5wej2cTHR+Qhl937733biYN76ZyAFyGPoaqcitLvgEeAvX1119ve/jhhy8nLX211Wq9lKYWtnIuuFa3272WtPv/3nPPPW8tWbLESYPKS9jzAXCGGj60tfGLL764YPDgwT+x2+3fp/MyOnLZ1Tscjj/X1NS8OH78+E9poNDoslbPaTMmlwFnsDWoN23adNq4ceN+TBeIP6FVjbG5THSksdEKTQVdqL64b9++lyZPnlzVCboMe6SiWRufi4DLYJsqKyunkraeCxOELhJzcbxxw0cXqQGYMKTVHz399NM/pgp8dOQk6Lk04RiLpq3JNx04cOAbAwYMmEurH1PoXLkIEqDVmPV1dXWPjhw58l3KwqAz7BFKZU90LgAeBHvYsGHmjRs3/mtpaekcMkPOy55pSH9PyXzZ0tDQ8NiFF1646vDhw17qESDPetCzGXD0XYObwLYQ2FeVlZXNoRsvZ6Yfl+ztAd1Y2lNfXw/QXyHQ9TeTsm5g2Qp40BTZtWvX+aNHj15AGvv8rJN+BneYNPrm/fv3/2LixImbqZuy6ZLBve7atWwDXNPYNAzT0qVLS2fNmvUA7f+4gS4eAbxynRIwHN8ozDseFQZHTW9l4m/3BBa/8nnDfT97vKqBKmPQs2ZpMVsARz8ZbvPRo0ev6d+//yNkjiRlD0hvqUh3ecsrpwtD2+GEdcMfELUNbWLewNniBaqU7XNAnvGgZwPg6KMJx44dOybSstYf1coISSOKsy4tiJLa8ySPX6wvrxN3TLpX7KJaoM1xZDTkmfynPaixJ02aVEBX+PdOmDBhg4K754D2tqTFKKacPVhsOPEnce+kSQK/IjMdYChjFWWmdozhNq1evXrYtGnTltKNmq/3doLypXyyNLgsP49XfPhOpfjZzCcEbKGMtc0zEXBeITFXVFR8g5YAn1O2toxW9+FUAI5ewDY/UC9+PvrXAjeJ2DbH2nnGuEwyUYJae/r06bba2toH6O7a6wrujGGlS0eMBjFw1ADxetMT4oHpZ2lbi3GtlFEmS6Zo8CDca9asGT516tTltClK3WLvglRsEanS4HJvXF6x/v0vxHXfWigOUXzGmCyZADj6oK2S7N69ewrdtFlJWnuALDwVjk8C6QAcPSSTpa6iTvxwwm/EejrNiFWWdJsoDLeZdv3NHDNmzGoFd3wwZ1JuMlkGjBsoVlf9TsykfmGFBYorrUo0nYCjbQjAQjv/rhs+fPjLFLbToVwWS4Boto/sL14++ri4joZhoQNznDbO0tVwEG66K/nLIUOGPEW32/GLVy43JGAeUiKeqvsv8UsaTlohTwfgGtz0EIKV9iE/RjsAH1IPIuQG1SGjCAhDWaF4qHmBeGzwYIG3EaRFk6cacA3uGTNm2OnFNs/16dPn1hChqJOck0CJTdxaeY94bsZkzfxMOeSpvADQ4B44cGAB3cBZRg/8fi/nZjNDBpSuVZRow3d4xGsjHxT/VlsrXJSPlxGjFUlIWqo0uAY39dhaXl4+X8GdkLnLqkrsFvE90uTzwQAdKdPkqQCc4bZUV1fPpXeQ3JhVM6M6mzAJ9LGJG+v/IOZShSm78Ew24DCB0Ibl0KFD19Ozkr9JmLRURVkpgdIi8Zvqx8X1YIIOsJFUMzmZgKPj+FNkoQvK79CqyQIKK6ckIE4pEQsqHxbfIVGwJk8a5MkCnOE2b9++fRrdfl9CS4GAXTklATwiYRpVJp7bfb+YRuJI6h3PZAAOuFGv+a233hpPb5NaSeHkPGJCFSuXnRIgSGwTBomVb/2nGE8jAORgJuGaPFmAm+iB4KIpU6Ysp70lJdk5BarXyZaA0ShKLh4tls+6QBRRW/gLn3DAE10hfjDoaMHx48ef6Nu37w0UVi7FEsjEdfBoImh2iMX97hR3Up6Er5EnUoPjx4L6LHv27PmugjvalKo0WQJ97eKGLx8U3wU7dIChhCneRAHOcJtXrVo1dtSoUQvlAaiwkkB3EqAngxauuk2MpXwJtccTCbj5kksuKaLHzZYpu7u76VTpegnAHr9svFh2yQTNHgfkCdHiiagEPxLN7qbnKOeXlJSoO5X62UvxebbZ4LJ4yB5/muzx2RSXEHu8txo8aJps2bLlYtodqOCWZ0uF45YA7T68cfu94mIqmBBTpbeAa9qbzJIiWu+eTy9Wj3tAqoCSgCwBIETr4/OnjwsuHfaK0d4UZu1tef7552+nF/OMkzuqwkoCPZWA1SzGvXS9uI3K93pVpaeAM9zmF154YdSgQYPwaJJySgIJk8DgvmL2C/8hRlGFvTJVegM4Liwt9HTO78k0KUzYyFRFSgIkATJVCq88S/yOgr3akNUTwFl7W3bu3IlvTH5LzYiSQDIk0KdAXEEbsi7vhBysgr24XE8ARxnzlVdeWUw3dB6LqzWVWUkgTgmMHSgeu3Ky9oFeNlXiqiFewFl7m5988slb6XPXI+NqTWVWEohTAhaTGPnMLIGH0xnwuLR4vIAjv4k+gV1Cr3u4Kc6+quxKAj2SwIA+4qbrpwjsSsV1X1zMxpOZtbdl3rx5P6cX0Zf1qLeqkJJAnBIwmUTZ/TPFz6lY3MuG8QCOvGbc1DnllFNujrOPKruSQK8kQG/Kuple0Yx942yqxFRfrICz9jY/88wz15DtfUpMtatMSgIJkoDZJE5Z9mNxDVXHgMdki8cKOPKZ6Fs59lNPPRV3mJRTEki5BIb0FbdNOj2+N2TFAjhrb8vKlSuvIu09IuUjUw0qCZAErBYx4i/XiasoGLMtHgvgmvYeOnSolY47lKSVBNIpgWH9xR0lJcG7m93y210GaG8c5ldfffVfaEPVmHQOTrWtJEAbsca8f7O4BEzSwXxGFEwsgGPt0Ux3LX+ktsNGlKNKSJEEsJ121CDxIzBJB9gE5BFdd4Aj3XT11VfTM8R9Z0SsRSUoCaRQAn0LxIyrvyb6UpMAPCrD0RLxy0C6ee7cud+m5yzV50VIGMqlXwL0/Kb9nsvEt6kn3S4ZRgMcaRrg9P2cHyjzJP0Tq3rQIQGYKSP6iR/QGQMekeNICdDeOExPPPHEiMLCwq91VK3+VxLIDAkUWcXXnrhaYMma7XDw2sVFA1zT3jNnzryKtHekfF0qVBFKAqmQABFpnDUxRIvHDbi2ekKPo30/FR1WbSgJxCuBwcVBwFmLd6kinGbGLwHxphUrVoynte+xXUqpiIyWQKBoWEb3L1GdozXxsS/9u/Z2Wl5N6aLFYaTrXRDwr371q9PUxaVePJl/3nzef4uaN28S7hNHunQ2EOgSRa/r1rkuEXild1enr6unecJVHktd9OlwaOJp1LPddEApg92QotEANw8YMGCqApwktmen8K9cIURTI8kv810BdXGI72JR73LR9+ND5jvzOx9nD80u11QhVj1DxRjwkBr0gOMXoGnwoqIiM72p6sKQ3Hl64nv0fhGoPZ5Vo8ff7P5+v2jw+Eil5S7kfQKBC8FqW1sbAx6ixRGpd4gzLVu2bKLJZCrVJ+bjebbBzXNkoTsipfRQo0HTWRybWz7BWvqHkYMn0qjYDg8ZoB5w1uCmM8888yJlnoTIKitPGHIj3R3hyc0lHwCPLbRdRB4A56EF5yoc4Igzkf09RQEelFNWBwB5f3okJhfnE2MqNZumgFk6wC4gDzoZcKbfRLfmrWR/Tw7mUoGsl0Ao5DzVueEXmUyThxcW8heUeVDanMmAIwLnxoULF55Nv4w+Wg71X85IgCE3AoEccjScPr8ZderZNCSNX3lo8ioKk28aNmzYhFz8cyYPPF/DHZAbRKPXmzNrK6B6qM0ygbxP6WCOtaUjWYNzgpH2fo/JVwDyYdxmUuH9zWZN3eXKePuYjGAWPDPH2tD0GhwZTLR7cIzS4Jp8cvY/QN6PIG/KAU0OVouMxtPBLh0MuTZ3rMFBPRzOjQT4aO1M/ZfTEmDIc8Emt5s0wDV+OydNY5oBR5ym2ktLS802m21kTs+sGlxQAoC8r4nMFZp9DQAGIct8m9EwstRuh0XCw9DGqAfceP/992MrGrYzKJcnEjgJOdjIUhcQBbcPHQx2wXRwIGyDM/XGs846S22PzdI57k23AXkJmbAnfNm5dwUAn1mkbe3+ohNwRAVYgwcBHzhwoLrA7A0pWVxWg5xe5Wo8qQCzZjQAuNRs7rKSwhocAwHsRrvdPhwnyuWnBAB5H9LkLZomzy4ZFJmNYFfjmHuu1+AGevdgMScqPz8loEGuafLsGr/ZYAC7bI3A1x6751EgwkhbZIvVGjiLJH99QF5Mmrw1SzQ5mKVFcAAOpa3BjdnjkyD1BDheMq6ckoDQNDntQsQSYjY4ghzsBllGWLbBMQaDAhxiUI4lYCLNWEzmiqbJM/zBIKvByIBz9zUNzica+QpwFofyWQIMObGe0c4kAgx4sKeswYMRCvCMnsO0dY4hb/P5M/YZT7NJ0+AsI41pXkVBJCKUicLiUX4XCQDyIhNWyYP6sEuedEZE0+DcLwU4S0L5YSXAkLdrmjxslrRFGmOxwal3bLakraOq4cyWACAv1DR5ZvWTVlHArmaJcM/YRAn+zfF6ve2cqHwlgUgSYMi7rDNTASYs1b7PH5DZ1Zjm/gXH4fP52oInKqAkEEUCgJz2YWeMRU6Xv3p2NZWO1c3gCqfS4FFmVCV1kQBD7qS3aKX7LXE+v1/W4BrXbKJwxwNKg7MolB+rBAC5jd69Ql5anS8goMGDyhqdkS8otQQFeFrnKGsb1zQ5Qa5p8jSNwm8ImihByMNq8EC6/9akSUCq2d5JAK+H0zR576rpUWkwSyuXETW4Zq9QzQFlg/dIvqpQpwQYche9vDvVb7X1BgRs8CDL6JKswbUEAry1s6/KUxLokQQAeQFtQUz1HU96FzrYZcC1vss2uBbhcDgaoO7VnvAeza0q1CmBDsiFcPlTIxJQ7aTXoetbYw3O1PsbGxv/oc+kzpUEeiKBk5q8J6XjL9Pk9YBd/KSYZ81EwQmcFllRUbFfXWR2CET933sJAHKrZq4k9w4nelrldOwnLwg3wqzBka4lvPbaawpwSEO5hEkgCHkS18kB72v1zXrAg+vgTL3/7bffbnG5XLVms3lgwkaoKsp7CQByC0nBo+nRxIvD7ffXrjve1EI1dzFR0FoQcGRobW2tUmYKxKJcIiWgQU6gJ1qRg9U2X6CK+gq4wwKOcQByLUN7e/s/EKGckkCiJQDI6fUOCd9x2O7zgVkZcK3rbIPLGtyHlRSlwRM9tao+loAMOcf1xge8TT4vAPfREaLB5XXwIOTHjh3b35sGVVklge4kAMhhqngTsC0E9dR6fGA2BG70IZwG97/xxhs7aNMVgFdOSSBpEsDNxA5zpXdWuY/MjVW1zTuoowA8BHIGHIMA0Ej00Udga5ubmyuVmQKxKJdMCQByE/ENfd6Tf6C2xR+ofPFITS31UzZRtG7rAWfIvfX19ZsU4MmcWlU3SyAIeQ8UOYCt93g3keelI0R7o34ZcJxrGpx8X2Vl5UYFOESiXCokAMgBI3lxHTDkqxyujVQU2ps1eLDLMuD4MbAG9y1ZsmSTn1wwpwooCSRZAgx5PM3Qg3L+JTX10OAMN3OsVRMOcO2XsGrVqkayw8uVFo9H3CpvbyXAkMNa6e7AQ6DNXl/5W8fqGyk7a/CIgKNvrMFhz3hpufBTBTjEolwqJQDIAXd3DrDWuj34+KvGK/lsgweLyhockQw4fg1essM3KMCDslKBFEqAIY+mxdGdynbPBvIAuGyiIElz8o0eRLB6xy/Bu2DBgk8vvfRSZ1FRkU3Lnaf/VRaVCM/xmpwffSRlBijCuUjxyBsxLUJCpMfbkB39AvD6/jn8fufjh46wBmftHdJCOMCRUbNnPvnkk5bq6uoPRo8efbmRnphOhGvbWiGO/c9fhaeuORHVpaQOt+8rwlmCb7uHyC6k7UgpUctEKBStTEijnSf6iZfzRGhCyxJvO3K96Q7T42mi2nnig21N5dhByPY3Qx7snh5wJEAmmgYn37Nt27a/nnbaaQkDfP+dTwp3dT3aySrn9HtEu9+r2YYQUCw2IgbIeRk0lOO4cOmIk12q88ttI8x9jdR/fX79eXfl9en68pHG7w34xW5nzV8pv4cOeQ08pIpwahltMuDeW2+99SPaPlsfTUuE1NjNSTbCjSEVGS2i0NihD2KFG+U4L3w5jDQ4OY7zyL6cRw7LeeSwnEcOy3nksJwHYb1DXjguw2EtMob/uiuvT+d22Ne3h3iw6Az46he37PyITiNeYKJsNMCh9j20s9Bx+PDhvyUKcDSarQ6Q2wnyaNf4nMa3nTFWjsuEcXNfYu1fsvP3RCbQwLU+598a3W4HBaHBw15gou5wgCMeGpy1uGft2rVv0OskEJ/3DpDbjCYNWoZE9iEghkIOy3nSGZb7JIcj9UnOI4cTlT9SPdHiAeZ2Z93r5MnmCaK7uEiA40eCXwWo9sydO3dXU1PTl0qLd8iPIe84U/+nUgJgsC3g+XJJ8+7d1C4DDlbBbBcX7iITmZCZIUclbloTX1VWVnYnfcMH6XnvADmcKwDZKpcqCUBN13jbVpHnpoPNE+a1SzciaXBkRF1BLb58+fI36GFkVKhcpwQ0Td7lS4xKPMmUgFv4PG+3HXmD2pC1d1jzBP2IBjh+FSgIM8W9dOnS6qqqqjfV/iuShuSwsmJTkEsSSV4Qa9+1Pseb77ZWVVMr0OBgE4yC1bAuVsA1M+XFF19cTFo84q8lbAt5EKkgT80kuwMB/7q2I4upNTZPegU4eh2ixefPn1958ODBd5QW7zqhDHm0q3+V1nMJkPIW9f72d149UVHZCXi3cGOWomlwpENbB80UCrteeeWVZz0eT8Q/CSiUr64DciwhnnQcjnbjArk5PV6fy3KL+va6q6+35fX1d1dfd+n6+vjcL/yBjx3Vz1J5Fx2yeRLVougOcPQHFeBiUzNTfvvb3+4lLf53pcUhmq4ON4IKDB2QY3Lg2JfDPHFyHMLxOq67p/X1try+v93V1126vj6cd9jezr+vaCrfS6dsnoDJqHCjbCyAQ1sHAaewa82aNc+QFkd55cJIQA85w5cKH91hiORwKtpOVhs+4nij89gzNB7W3oAPTHZrScQKOGtx/Hpcc+bM2X706NENSouTNCI4QG4lTZ5qx3AzbGif41Ldl0S0B+1d73dtWNy4ezvVx4Cz9k4I4Ogna3EY9oDcuXr16oVqRQWiiexOavKTiOEyC44vtzisRXbGcxznicfnsrHWp8/P5SL5+v531zd9/fry3aV7aOVkk+P4QsrnpAPsgcGYtDfli8lEQT4ADi3OgLtmz569jd4l/rraowLxRHY2TZPjY6kd/5CTJ1kOR0qPXHP4FK471vr0+blcJF/uc/gehMbq69eXj5buoy2xR31trz/duGMblWPtHdPqCfciFhOF87IW1y420eBdd921gB5MblR7VFhE4X2GPHyqig0ngY49J97GxU27FlA6wx2z7c11xgs42+Jo0Pnee+/Vbtq06U/qgpPFGdkH5FhdUS42CeD5qb2exj997qzFG6tgnoC5mG1vbiUewFFG1uIa5LNmzXqNHmvbri44WaSR/QLaZstLiJyLrXP4sRwox2XkMJeV4+Qwpyfal9uQw5HakfPIYTk/tHej37X9vuMbX6M8DHfc2hv19wRw1uLaxSY6sGLFikecTifegYg6lYsiAUCO1RWeUGRFOFbHeSOV7y491nZizRdve93lB0Nu+qD8O22HH6E+AG6+uIxbe2MM8QKOMgw4flGaFn/ooYd27927dyW9kRbpynUjgSDkeP+HOkJkEKBfwCF/68oXmvdgv7dee4O9uFxPAEcDDDlrcccdd9yxqK6urlqZKrHJH5BbeqRfYqs/G3NhzftEwF39ZNPORdR/PI6m195xD6ungLMtzsuGzs8++6z+pZdeuos+f0JLl8pUiWUmGHL82c73A69hcwm/5/3WQ3eVOxrw2gWGO651b73cewo46mHIg1qclg23EOiL6AaQvh11HkECgNysNDltdPKLfe6GRU837d5CotJr7x5rzN4CDlMlqMUp7Lz88suXHzhw4CN1AygC0WGi8x1y3NCp8To++lXN+uVgqPPgu5ZgLC2AY6rQOA6+4MQvr/3OO++8j+zxGmWPkzRidJq5YuiNvomxoQzLBru72e+pWdS46z7qWjsdYAgmAJhivijYM5cIiaITWD7BLw6dc9ANoGMvv/zy3WSP0zeGevzjo6ryy2H50EKQR7pNnmvx0MvugN/7vuPw3Vucx47RbGv8kA+WeFmwVxAkAnAQjM6wqaJ1kl41sfnTTz99Cva4gjz2OQLk+DBTrjswAbt7r6fhqacbdm6m8cpw9+rCUpZdIgBHfQx5iKkyY8aMJbQh6123Gz9I5WKVwElNnrurK16C+4i39d05NeuXkFz0pgkUZkL+9CcKcMwdQw6acaGATrfPnDnz13TR+ZmCnKQRh4OpYs5Rm9yjXVS2f3ZX3YZfk0g0TsjnZcGEwQ1xJxpw2R7XIKevRJy49tprZ9MDEuVqUxZEHrtjyHNpjRwrJvU+R/nDjZtn13scJ0gaAFyGGwwlRHtD0snY3obOyR00EOTe/fv3r582bdr0pmXv9MVXbpWLTQImklWHQGWRxlY203IB7kaf69CC5p037XDU4osCbXQw4DBvE6q9Mf5kAI564UJAJ1vc1dLSsnFUZctltKOuUEHeIaRY/gfkcBBotq6k+KnzJwKe+mUnym9c13roIA1FD3dCNTfkBZcswGV1Ewxv3bq1rcBk+Xycpd836c+vVUHeMQmx/M+yCgozlkIZkoe2mYrWgKf19ROVt/y55cty6pYebmhuAJ5wlyzA0VGeC/a1zm9z1jaVme17hluKL6HVAgtPXMJHloMVsqxCBJrh4+yA292+tv3Ifz7btAu34WW4E7beHUkMyQRcbhNzEpyXTY5jx+kJly2jrSXTSZPbeeLkAiocXgIsq6Aww2fLiFjY3Cf8nsbX2/bf9mzjLqx1M9xY80463BBCqgEPgr7VWdvQbvCuH28tnUo2eR+eOHRKuegSCMqKTHOY55l44F0mDQHn0eXNX9z8yomKPTSiVjoAOMONmzlJsbup3qBLFeBokJVOEPJyV2PLUW/738+2DbjAZjCV8cVUsHcqEFECgDwoyIi50pOAde46n6NiYePuW9a2HfgH9QJgpxxujD6VgKM9OJ4XzT/gOeHY7W5Yd65t0CS70TRE24nRuWrQkV39H0kCDHmmrK1gZnH7/ZjXsfWRhs23b3HUHKW+682SlGhullmqAQ+Bmzqhndd6He5PHDUfTC48ZXShwXyagpynp3ufzRUIMp0OuwLpWUq6/d72wd21G+fsdzfVUX8YbtzIwQ7BlMINeaQacLQJ1wX0Fr/b9zfnwQ/PKxhUUGKyTjIJo4Enr6OI+j+SBGQ5YcU81Qfgdga8gQpP0/O/qP/4d41eB77yK8ONC8qUww15pQtwtM2Q84VGwEsbyN9srdo60FRYPsRin2wxmOzYS4AHc5WLLoGT5kr0fIlMxY5AvL+k2e9ufK/98Lz7aje9SnPIF5PyHcq0wI2xphNwtM+Qww+CvsFRfaTa2/beuILSM+0G0ynKZIGounephJxNkhpf+7aFjTtvp5WSHdRDaG3W3DBJ5KVAzHHKXaYADrj50KCv8rS0rXFUvXtOwSBTX5P1K8pkiY0NNleSSRNu3sAkKfc0L7+j9sMH97ua8fYpaGyGW795KrbOJyFXugHHkHgu4DPkmjanP3e+Na1V2waa7buHmAsn0/ZRu7YXQ5ksUVE4adIlducKcU0mCW7euBvWOo7c/UDtxr90miQMN9a4+WIyabffow5el5gJgKNLMuQy6Fp4g+PY0cNksoyylgymz4SM7nioS9nmurkMOT0JeUh0j05ga/toiuj78OKQr/W9RY3b57x64stdVBlrbACuv4EDJZV2l2lXb+gPrivxw8OXVgvosNFhp6MQ4TvKzvnni+yn/rLUaB2BJ1/4TzKlKRdGArCVe+PY1m70uw9+7Kz+wx/rt26g+mCCMNS8BMjbXbW/vr1pM5FlMw1wjA19wgHI8SVmKx2AnEG39zfbiu8vu+CasdZ+19HHWAvM2ESqzBYSUXgHDRwv5rxC0ub3uCrI1n6w/tMXGr1OrJBAU+MA2GxrY5WE93LH2xQVTZ7LFBNFP0IWEnwc0Aps0/mcfq/3rbYDO+r9zrUjLMVDaePWCGW26EV48px//Kw5ovl4wxSbI/Ty+Y+fa97zq0WNO9aRzOXlP2hvGW7MT0aYJCdH3RHCWDPZoX9ssrA2Z40Os0XT7HMGnP/1C2yDbulrtI7E64nx7lae1EweXKr7Bq0cybGd7SI7m9a1D3zmqln0WN3nH1J+1tSstbH0xzduWOlErjhSgymKz3TAWQyAnEGHbQ7I2T7XIDebzba7+p1z6STbgGv7GwvGKNBZdNF9GWx6J/eXO5x1z/++aetaejMZg80+r2vLtnZGam15xNkCOPrM2hygQ5sz6ACcYYdf8Kuy8y86zz7g2jKj7SwFOkkkjJPBJlNv9xZH3fOP12/+iLICZBwAm31obIDNdyQBdsZqbepb0GUT4Nxp9BnXDgw6tDlrdA1wOtf828rO+afJtkHXDTLZz7XiNQxUBIXz1XwB1KASa9n0Rilx3Of4fJPz+PKF9Vs/o2gGW/ZlcwRQ84UkBbPDZSPgkKzGKfmy2QKNzkuLMujWG0rPmnRhwZBvDzbbp9sN5kLAni8XpQy1n9AG1I6At51edPnBRlf1G4sbduP2OiCWoUYY2poP2c7OCq1NfQ+6bAWcB4D+A3IGnU0XBp01u6blh5qLi27od8b0Mdb+3xxosp9PoJvwch3Anmvr6Vi/BtRegprA9tX6HJu/dDe+vbhp7wf0RincoGHtDKAZcoaal/2gtbPGHKG+dnHZDjgPSA86TBi20dmEYV/T9FMKTx00q3j0ZSOsfb5ZYrCO0UyYLNbssqbuhBpfS/jyoLvl7f9r3f/O+vajx0kmDDDDLftIg7ZmjZ3VYNM4NJcrgMvjgTbHuAA5NDprdQDO0Mu++Yf9xo2dXDB4Kmn1c/uZCibShWkBPi+CR+gy1ZSRgcbmJzxJQ0t8riafaxdp6883uWo+Xtm0r4LGDG0MeAFzOB/prLFhguQE2DQOzeUa4PK4WKsDdD4Ath54TaNTvJbWz2wr+FHfsRMnWErPG2iyndvfVHAGwW7BBSqA7/jX0QwLL1kXrYAYjg1f+LhMBNC4UCSoPfSmqL21Pufn5Z6GLS83V+xq8jphcjDUAJoPBpzTWFuzxu6ongrkkuM5yqUxyWPB+Bh0va0ua3eGnOPYNw21FRX+oHDcV06zlpxdQvtfCg2mEYVGy1CrMNpZw7Mvwy93AmG9oBlafT6GGPYzQGbfLfyOdr/nSHvAd5B28x2scp/Y+Wr7vu1HnG24qwhIWROzz2DD5zj4DLRsX0fqDmXPbqeXe3aPJnrvGXT2WavLpgyDrfflvNoP5eLiYYMmWctGDjEVj+hrtowsMliG01cayugppEK6k2qnbWCFlNGMxhh81vRsXkAbgywizUuvWWinW+QOT8DX7vL76tsCnkPNXs+Bal/rwR3u+gPrWg/DhmYoZe0rwxsuLOdl84P96BLLgdR8Apynq4O5DqWKMOAFtLIPwBlqhp3P9Xk14DvrCKmbzB3zSGtx0RBjob2fuaCoj8GKHZGiJeBub/K62qr97Y4D7tY2MisAZofyPukzzPBZ68o+wgw0Q4xzOQ+X1ddN2fLD5SPg8syGAEkJMqx6kGXA9WlcDvUhzPWiLTmMc9kxeIjjMGtXBlwPLEPLUPM552ef62NfbjdvwhC+ch0SYFkwkPD14PI5QwzokY99jg9XF1rheEAHx/DpzwEp4gCx7DO87CNNDuMcBxz7HWd5+j8LPE+HH3XYLBv40Q4Zan0+NCDXIzfIAMo+wvqDYdfHy+eoF+fK6STAwtdFq9MIEmB5McjIFi1OTo9QZQiYDCnDizLR4iLVqeI7JcCTowTSOwno5ag/R+36OAZXblkfpz+X86pwDBL4fwN/IZwMBwH5AAAAAElFTkSuQmCC', // @suppress longLineCheck

    yellow: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALcAAAC4CAYAAAChOH1KAAAlaElEQVR4Ae2dCZhUxbXHTy+zL8ywDDsSVhEVJQoCkoSIIr4kvohLxO2ZfC8an0mQrCQm+uJ7qHkv5hE/xSQaNokBogkxigaUuLDIpsiOMA4MOwyz7zPd7/yLOZfqnu7p7umeXut83+2qW7du3apTv3v63Lr31rWRkUhowOZViPc6Nutpbq/8WPVO8173sYtJ6kgDusI7yme2nYdTdIZQj0NH1vrgwYNtc+bMyb344otzCgsL87KysnLT0tKym5ub6+rr62vKy8urd+7cWfv444/XlJSUAGSB2VfoKw3HM9KBBqQzOsiSspsEXgmhCMTtDGT2TTfdNDwvL28kQzvC6XSOcDgcQ2w2Wzfenme323M5nuN2uwPql/O5OF+dy+Wq4X2rOV7Z2tpa3NLSsp9Pgv3V1dX7XnnllU/4RKnj7S5edNARl4WjRnQNBFS+njnJ4wKxHtp37NgxpG/fvlPY6l7CAI/kZTgv/YMBN1L64hPAzcAf5eUTXvax9d9x/PjxtZdcckkxH0OAF8gljNThE7acVIdbQLZzDyJuX7du3YChQ4dOycnJ+QJb5M+zFR4Qr73L1v4IW/h3amtr/3nw4MG1kyZNOsJ1FdglBOwpKakItwfQTz31VN4dd9wxnd2LL7J1/hzDPCxRSWDYD7BVf5fdmbeXLl26avbs2dXcFsCdkqCnCtwCNEL7gAEDnBs2bPh8QUHBnenp6TdyWi4vySY1TU1NKysqKl6cMGHCO0eOHGnhBuqQJ71FT3a4FczcqQgdu3btGtWvX787MzMzv8YWun+y0eyvPWzRjzY0NPzp2LFjL44ePXoP52vlRbfo/nZN6PRkhdvyoX/7299245GNe9iHvoMvBC9P6N6KQOX5gvRD9tGX8gjMovvuu6+SixRrjjCpJJngRluwAGz78uXLu0+dOvXbDPW3eL2QFyOeGihnyOevWbPm6VtvvfUsbwLcAnpSuCzJALcH1KtXr+4zduzYWbm5uf/OnZWMvrQnouGv1bD8ftu2bf937bXXnmgDPCkgT3S4lZXmDrGvX79+0EUXXTSbRz3u5fXM8Ps85Upo4FGWBbt3735q4sSJh7n1YskRJqQkKtyoN8B2vPzyyz2uueaaX2RnZ9/NN1bSE7IX4qjSfMOoqa6ubvFbb7318xkzZpRx1XDxKZY8jmoauCqJBjfqi8WB4bzNmzf/W/fu3R/j9R6Bm5o6OWyuErK1fMiKwuhfJ8VNZWUVtT/77MTHFrYNI8oIS8L444kEt7ggju3bt182bNiweXwHcXwnuy5pdwPYzrofMdiR8SaaW9wffFLc+N3RE/7xEStNrHhkCu/iXkgEuFFHBfb8+fMLb7vttkf4YvGb7II4u1g3CVm8vXEpORtfiGzdbbaWmpqW3724ou4/v/WDj8u5cMAd965KvMMt1tp56NCh24qKip7gmy99IttzyVWao3ERYekKcbnpxKmy5h/3HbVpGZcvdzzj1ooDnngUnHQOLI8++mhBZWXlC3369FlowI5tV9lt1KdPz7SFdaUTXnj00REF0kccxqWRjMdKWWBv2rTpUn7YfwnfWRwZ225NnKN3peXWtdDion0799TedfkXPvqY0+GLywWnni2m8Xiz3KgPLLbz6NGj3xgzZsw7BuyY8uH34E47jRxzUc47J/eN/wb6ixf0W1zxFC+VEWvtnDt3biE/ybagZ8+ez7CysngxEqcasNkoq6i785m6w1ctmDt3GB5xEMjjwiOIh0qgDjjJMG49hp9ae5Gt9fA47c+4r1a03BJvRbS43J/s3FN3R5ubIhebMR0Tj7XlFoudtm/fvmsuvfTSNQZsb2wSY91ptw0fMzrnrYObr7iGa5zGC9yUmBrPWMItYGOY7xZ+W/wvrIw8XowkqAa4Q/M+MzjjL0d2jL+FmxBzFyVWcOO4OLPT+AH6b/ELuAs5bp4LYSUkujDg6f37Ohee3ncVHjUWCx4TzmJxUAE7/eTJk4/06NHjKb7bGIt6JDpH8Vt/N9l7dnc8dfaTcY9wJWG0YjKSEm2oFNh80ZhRVlb2NL/D+KP47SFTs3A1UFiQ9qOakglPjx7dKyMWgEcTbgX2+PHjs3j6hCX8fMjXw1We2T/+NZCTY//65jeGLRk/vjuGdaNqwaN1NavA5salnz179jl+9evO+O+WxKxhrIYCA2mrtq71xdwLNt7P+Zp4kacLA+0W1vZoWG4BO4197McM2GH1V8LunJPtuLP84FWPcQOidpHZ1XCjfCxppaWl32Ef+6GE7R1T8bA1UJDveOjUnvHfAQ+8CBthl+uvgK6EGy6PAru4uPj23r17z/VXCZOeOhro1cs5t3T7uNu5xQJ4l7nGXQU3KqzGsfmF0+v79+8/P5oTR6YOKgnYUjfZ+vdLm7/vg7HXtwEOTroE8K6AWyy2kx9ZHTdkyJAlbY1IwJ4wVe4KDTAgacMHZy3Z9vbl47h83MkEhxEHvCvgRpnOefPmFfF49lLMU83rRowGPDRgs1POpRdlLZ33xJAi3iCAe+QJdyXSZ4sCmyuVwY+truA5RKaFW0Gzf2gaiNehQH+tqKt3vZkzaAOeRWnkRZ4m9Jc9pPRIWm6cKMrPPnz48HcN2CH1Q8pmzs6yTzux+8rvsgJkiDBiBjdScAvY8LOv4hd58UyBEaOBoDRQ1DPtEfa/r+LMEX2SMFJwoxzHE0880Yv97AXsZ6OSRowGgtIAeLl0VNaCJx4d0ot3wL9/RLiMxF8AKgKY4WcvY3dkOseNxEgDieZz62qqq29dlTNo422cFhH/O9wzBCeHgptfOHjAgK13lYmHqoHsLMf0ozvHPcD7yehJWMY3HLgtsBcvXnwB34F8ONTGmPxGA94a6FuU9vDiZy6+gNPDBjxcuNXoyA033PA4+01mLmzvnjLrIWuA36jP/dcb8h7nHcMePeks3JbV3rp167X8sVF8NMmI0UBENJCXa7/xo3fGXsuFhWW9Ows39nNed911uRdeeOEvI9IiU4jRgKaBi0Zk/vK663rDGxDAta3BRTsDt2W1n3/++Vk8jfDQ4A5lchkNBK+BNKdt6OJfD5rFewjcIV9chgq3BTZ/UGkY36wxz2cH318mZ4ga4Js7Dy1fMHpYZwHvDNzqIpI/1fEkX0Sab8+E2GEme/AasNltmdO/kP8k79Gpi8tQ4Las9rvvvjuBXxe7LvhqmpxGA53TQE6O7bp1r4+RW/PgNWj3JFS4ldXmW+zfY6vdudqavYwGQtAAOONb89/nXUK23sHCbVnt119//TKelmFqCPUzWY0GwtJAbq596j9eueQyLiSki8tQ4IbVdl555ZWzOTRmO6zuMjuHpgGbbfxlOeAOcIPDoPgLBm7LavM3H0fl5+d/KbSKmdxGA+FrID/P/qWXXxw1iksK2noHC7ey2pMnT8bQXzD7hN8aU4LRgIcGbPYpV3UDf0Fb70CgitV2LFq0aAhb7RkexzMrRgNR1ADPezJj0fyLhvAhYWzBbofuSbBwO6dOnfogX7miUCNGAzHRAA+cOP5lSt6DfPCgXJNg4HawO5LDs0XdFJMWmYMaDWgaKChw3DR5ck/MqBDwwrIjuMUlwTQN0/lzHvjuoBGjgZhqwG6ngmfnDsTbXgGtd0dwY5u6kBwwYMCt5qZNTPvUHLxNA+BwYP/0W3lVLiz9MuxvA6w2FsecOXN68fPaX2wr2wRGAzHXQF6O44tzZlsvEwur7erVEdzY5rz77rtv5s9S49anEaOBuNCA3W5L+/rt3W/mynTomnQEt3JJ+JvrmA3IiNFAXGmgX1FawC+m+YJbzLxjyZIlI/mNdtzTN2I0EFcayMqyXfbS7y4cyZWSURNw6yH+4MYOjokTJ95iLiQ99BX3K271Tx331Qy7guBy0vg8WG/FKoft4IbP4i3IpPztwsLCz3tvNOvxrYEW23iqKPs9VxKfnUlc4fncPSrvtUpYb2lygU+/frc33JZLcs899xSwS3KpxxFSdMVWv4dsle+Qzd0c9xqAGevm/AJVVBSTy+ViCDwhQQN8JLVLc1P7/bz39VXOuTye+/rK5zvNcz+U1ZG4XO5Lb5teWbBs1QHMUCXsWoV4w42yYLUd99133yQ2/dBVSoutbhc5997MmkscS4hOK2hxU1mlb7h9daj3f7r3uq99Yp3GJ67jnqktk5atopVcF3Dr0UnecKNNCu5+/fpNNv42m4PyN8jWdDTW/Rjy8TF22yPLTWeriFyWLQu5mLjeAbD26eaezMHfeQG3SLJaiwRdsK7g5icAJ+kbUjVuc+OziYkpPD0Cdc/nDk0EM9xJFedn2ybyrvizEnatknS4oQIsjlmzZvXMzs6+0MplIgmrAQHcwT0tHZxMYXaGe9QDX03vCW55kaap/vIFt33mzJlXt2VUmcxPYmsAgBfmsWkD4Nz9SbbYvnq1G7yC5Q7hRgYH35W82vjbiQ20d+11wL23JfI6OO1TSIBbXBMArsTbciu4eU4Sc1dSNJREoQKcZ9+DBY+U4F8AIv8GEleJUfrJyiTw2g5uGS0R2hXcPL79mSjVyxwmyhpwwkXJdVNFTeRGUQRwNEXiEkajedkZBF4FblUN/nHr5zDi9p/85Cd92NSzh2YkWTUAwAtgwcWkJXhD+UTKm3VLWh9uhmJYmiNwo5lY7Pw8yXDZaMLk1YAArkZRuOdhaRN5mXSxDdyCZ2FZrUgPKrj55s1QczEpKknuEIB347cRYcGFiEQMUf++3V1DubcEbtVx7Sw3v3UzLLm71LRO14AADqudyJKbaQO3ArdqjQ434naeB3CIsdyJ3M2h110Aj+QoSui16Pwe4DUnm4ZwCYphDhXcGC2Rcxahg0dKkMlIimkAgOdnu6mqzvdTg/Gujqx0G7jFiInFM0iHIME+atSo9MzMzAEqxfyknAbOAc4gMBWJdnGZke4eMOozmengmBcFuA63bdq0aYV4jDDletU02NIAAM/LOge3lZgYEceUMa2FXFWAbcEtKzaen4RHP42kugYE8M6Mg8uFqVh+6FLSfOlVtnU2v+yHcFCRG/xaPOt3KG29evUyN2989UAKpgHwXH4evKZee0A6SD0IsMgucQl9FaFvk7iEgfLr27vnucGvwK38E9lu42FAY7lFGyYkZcGz2YkFLgkg+TkOsdyqtjJaomjnZ7gN3AnQidGsosOhWXDrHZdo1iC4YwHgzEzfbglKsBm4g1NkquUSwGsb4neYEG5MTjp5WG6P0RIeBswxN3BSDd3g2gvAc/irox35wsGV1DW5UK/0DDemNlZeCI5ijQkikT91jY1GjAZ8asAX4AI7Qj3us4BOJOpl6nFfRaU77AI3Ntv00RK+gDBw+1KaSTuvgXOAu6mOZwqRuUcEOuSSuITn9+x8TC9L4hLqpTqdynIjCdbbc+6t1tbWFiQaMRroSAMAnF/MpXoA3lHGKG9rddk8+BWfG9WwNTU11fqaoSjKdTSHSwANAPCsjDYTGQf1xb9IYzPVclWU1UaVdLipoaEBG40YDQSlAR1wuYrzDlGQRZuPUmWb937+1r3L0/fnuQM9+NXhdhu4fWjfJHWoAQtwocwrtyQHC6vX7u1WvctDBkmrb7YBbstTErhVQl1dHb82asRoIDQNAHA8j+frIi+0ksLLzRe5wq/iGaMlQrq7oqLCw6yHdyizdypp4JwFd1MDzz4noyjRbD9OrMpaD8vtlqFAAO4uLy8X8qNZL3OsJNEAf6uGLfg5wKPdJMBdXuMCv4plHF/cElWX06dPV5vREqUK89NJDZwDPPouCv4tTpVTtV5tgVvRvnv37hoDt64eE++MBgB4Bs+hDGvqvaA8pIlIXPIhXdIkjx7KNskvIa4q9xyyA24Py40ViHvlypXVPNbNMzobMRoITwMW4F7FeMOJzZKmxwVa71DPg7hIczNVvba+SdwSJFszTgntbh4xKTHWW1RmwnA0AMDTYcG5kK5ccAXLIyUlfBiLY9Rb3BLEscFVW1tbghUjRgOR0IAFuOaKRKJc7zJqG2wlnObiRTwRBbfQjg0uHg781Fhu1oSRiGkAgKfxuJy3ixGpdVS0qtb9KQeKYQ4V02K5BXA3j5gUI7MRo4FIakAAj2SZelmnKuggr1scYxvg1hNaecTkoLHcUI2RSGtAAI+UxZZyUM89h1wwyviamcWzWG5sVyZ94cKFn/L3CxE3YjQQcQ0AcCfPjAMwIyVMq2vhasenXJ5iWMoVuIV2165duxp4xOSYZDCh0UCkNaADLtY3nLC+yXZs14EmfsPTuqAEz9ZoiQU3p7XW1NQY1wTaMdJlGsC7urDg4Qpc6JoGN/xtuCSw3MKyB9xi0l0nTpzYbPzucNVu9g+kAQE8lDFwlOnh0TDKJ8tsmznZ4pfjHpYb+yABGVq3bNmywbjdUImRrtYAAHeE4IML2HJC4OvIW/e3buB66pZbVbudz41MP/3pT3fziwvmNnxX96wpX2kAgHd2ZtnGFqr68QuO3eCWF59uCQ5iWe7q6uqms2fPbjWuCdRiJBoaEMBDORb4LKugLYwrvmGuw62KEcuNFQtujrccO3bsAwO30pH5iZIGBPBgR05QrWNltk0c4K33gHADcGRq2bBhw3rjd7MmjERVAwAccAcj8LfX7Wxdz3kFbvCLRYleDOIYnOEX9tWca93OnDmznmd+7aFypuiP48jjhMVIdDUQjNdQVecuK7iheSLXrJIXPO7KM6ko46wAl9fMOE0Rj0Q1YsJhC8O9mT+Vfb09Ub8EhFaFKc2taVReYRmDMEszu4eigY4Ad7HZPnyKMAQoVtvjYhLH0eHGusCNHVr27du3euDAgRGF21axm2zH1pLN3Yzjxb3YG89Qel02PzIM3bUXf9jjtSdf4i8def3s4veFW39l+StHHaODjaGW5zd/R8fw08pQy2ppddOuva2rGVPFKrdN4EYzlehuCRKwDuB5Pk/KGzlyZM/169e/z5/vi8gXFwC28x9fZrDh1ieOVNW7cBcscSqcAjWtbXRXf/l/K6/ed6rpDDcXr5fh9jtAtzrKl+XGRtDXzJa77siRI6tHjBhxUyRcE9vhV8lWe4SLTizJR3XZLtRiwMlIzDWAx/qOn6HV+04Rf1iQ4AKAV3Brgc1x6/Y74iIw71hwFjTxqMlKniBTtoUV2lyJS0c+f+GLJzc3EgcaYI+EthyilVwVAAVOhVmP2unj3LJBLLfyZe6///5NVVVVRzty7mXHZA8BeC6PJcF3M0tsdADbzF94OPq9P5OMb4NTsdweCPqDWwCHyW8uKSl5zcB9Tm95fDWSg8FSIzHRAC48SyvoNT64YpNDARvMeogvuJEBZh474axo5ikf/trM784bOacBATzYO2kmH1t5/quLxNLCCK/aSX8Fl7yI1Qav7cQf3DgLLL/7ySefLC4rK9turPd5/QHwbOODn1dIFGKw2uW1tP3/3qZiPpzub7ez2qhOMHDj7GjasWPHSy1qSBG7GYEGlAVnwI3/HR0dtLK53XWCXmLVC9hgE0Y4JLg5v9oBO8L8N82cOfM1nvah1FhvqOa85BoLfl4ZXRiD1a6sp9L7lil/G3CDS79goyr+LDe24Wyw/G5+9axh+/btf4jUsCAOkCwigEfCpzRl+PbN8ZDUzhP0h5oadbNG97d9Wm2wFQhuAVxZ729+85t/raysPGmsd/vTEoBn8dRhRiKvAWW1G+jk7OXqQlKstt9REqlBR3AjD8w+CgHcjUePHq3duXPnImO9WRs+xFhw31Y33H8jWO29J2jR0Qr1QSc8+QcewSX49CuB4IblRgHqopLDxm9/+9sr+E2dMmO9fesUY+DGgvvWTWdSYbVrmqjsxytpBfjjRS4mO/S3caxAcCOPWG8FOD9vUrVnz54XjfWGanyLAG5GUcIfRcFzJPtP0ov7jhPe6RWwA1pt9EwwcIv1Vn4379M4Z86cl9h6VxrrDRX6FgW4GQf3rZwgU2G1qxup8ud/V8N/YrXBYUCrjUMEAzfyifVWvvfGjRvLN2/e/LS5awnV+Bfc5MnCOHiE7s6lWjktTN22Unp6awmVs5aD9rWlR4KF29t6N8yYMWMFT96z07xnKar0HQLwTDOK4ls5HaTCHTlVTTvvWqR8bTyrLaMkQVltFB0s3MjrYb358yL1y5Ytm8vzm7iMewL1+BcB3PjgwfnguMPC85G4Xt5Gc3nShnrWbMhWG70RCtztrPfDDz/88f79+/9sLi79gy1bBHBZN6F/DeA2+4Ez9OdfvE4fc65OWW2UHgrcyC/WG38ROJsavv/97/+Gb8ufNdYb6ulY4H/DRUk13zmU9kKDlY109sd/pd9wFGDLhWRQIyTYXyRUuGG9cRAMC+Kg9e+9914ZX2D+mt0UXjUSSAMAPMP75b5AO6XQ9iama0sJ/XrjQSrjZotLAt7AHfgLWkKFGwUL4GrkhNfr+eJyJd+93Gbck+D0LoCHYtFSIS/uRJ6oom23v6BeIROwwVnIYKMnOgs33BPrriXHG+bNm/cIv45WY0ZPoNbAIoAHznk+By5IIXJhKnGV2JYuaXpe2R4o1PfR4/720/PocX/5O0rH6EhlA9U88096hPPp7gg4A28hWW0cqzNwYz/xvS3r/dxzzx1cvXr1L3j0hOfZCLkeKDPlBP43XBSAEcwCBQlEelz21dP0uGwPFOr76HF/++l59Li//P7S20ZHaO0++sXv31cfbvK22uAtZOks3DgQDijWG2da/V133fXm3r17l5ubO1BPcALA01PcB29mp4OnaVj+jcX0JmsNYMsIiVjt4JTplSscuGGeAbhYb1So7pZbbvnV8ePH9xr/20vTHaxaFpxNWyr41nob4WefrKG9dy6kX4EfXsQlAVfgq9NuQAS+SsKHPy829rt5gquWDydMmPCVjIyMdMzaKWI/8S5hMdJeA+r7MNyN6GwR0Zy/v/NIp+O4ckw9LsfR0/S4bA81xAx1VQ1U+8s19K1/7qVjXGYtL7Dc8oCUpg0cMTQJx3LjSDi4t3tSN3/+fPjfjxn/O7TOyGAXJQ2f0ODdsEAkPLfWtb9yLH/HD7Q9lNrhsqyBnY639tJjv39X+dlitQXssKw26hIu3ChDABf3BGdeHfvfq/jR2BVm/BsqCl4E8OD3SMycGM/ec4JW3LuYVnELADa4wb2TsN0RLkNJJOBGQTjLMBbpAfj06dOfLC4uft8ADhUFLwAcF5m6b5pMcVxAlpyl9298jp5krXiDDY7AU9gSKbhREVhwffSkjt+3rLn55pt/WFpa+rEZQQmtrwA3XJRkE4B9pJw+/trz9MPKOjVhvLc7Ao4iIpGGW/xv/L2o0ZMDBw5U8HyDD/HjscUteEDXSNAaEMCTxWrjgaiT1VT84Ev00IFTVMGKELDBiwz7RQzurrYNqqKHDh1q4tvzGyZfmHVNbsUHufz5byNBasDRZn7kvpiuOokj9LXgEJJHj/vKK/kk7Ex+7KOLlIUQdyBP19CJOa/Q/W/soSOchJERwB1RP5vLs6Qr4PZ55vHFZb2r1b1lXNHRa/muXKYB3OqDgBFfgOvg+CtAz6PHuyo/jqEvOA7WYbF5GrSKX71NDyzaQAc4SYb88O+O67SI+dlcliVdATcKB+CyyMFsH+w6WsnTAO+8pD9dx4CnGcBFNYFDAVwfBw+8V+xzAGyeKar+D+vpu798k7ZzjWCtxR3Rh/0iXtmugluvqECO0MbPD5zpmUs7RvamKQx4Rgp/S0rXUVBxAVwpkk1ivPviAPtsPVUv2Uizfvaq+jgToBarDbBhsdGcLpFowo0GqIas3kOnud0fjBlAk/nWc450Wpe0MMkKFV3BB9ddgHiLtzC27GOfmvcWPTj3DfqIuwFQY4ErolvshIab22KdnWiIasyGYqrkZwreu/ICmsivYBVIpyGzkY41IP92cpHZce7ob23icY/jVXToZ3+jB55fR59wDfCNSN1iR3xkxFcro2G55bhyhlqAf3yEanccp7WfG05j+XszRQAcf7VGAmsgHgHHyQawedqzXQ8up/949WNrVEQHO2J3IANpKZpwS10EbhV+eoYaV++lt68dRaPyM2mAAVzUFDgUwJEz1v436oBb6p+W0cZbX6CHNn1KpzkJUMPP1h+GYo/U+ifnaNdJtOHWwZZGus/UUMufPqS114+mfvkZNNxpLHjQPS6Ax9JFwRh2Hdtjnqzy9WnP0k9Ky9QNmpiCDQVGG27pNB1yxF31jeT63Xu07ooLqLx3N7oy3UFO6TjZyYS+NaAPqUbbgquhvkZq5FGwX13/ND3L/YgPnsLH9jXch76OmsQKbjRQQd0WWrAv30r7bXbaOLIPXZHppG7GTQmOBQ/AeZeuHj1B7/HEOXSikg4/vZZmzV5Ba/mwsNbiX8uoiNygQR9HVWIJtzQUjYaLYrkp6w5QOfvhb04aSn3YDx9m3BRRVcehAN7VFCk3hAfz9p6kN29fQD9Y+REd4poJ2GKx9TuPXV0ln4qJNdxotPeiQD9dTc3sprw39gI60zufxsFNkb9cny0xiUoDMtrUFTTBr1e30huo8e399D/TfkPPcj9V8oF1/1qeFRGLHbOeiTXcaLj0g1hvPXSv2EqfuG20bngRXc43fAod/H8rHRgzrcX5gS39tOlKjEI4IcDGmzPHKql43ts0i7/g+y6rQe44yoiIgC19GFNNwTWLF0FdcLJh4cf1Cd/p5Q9SqyW7ex7lLL2X7vjsILq3WyZ/vIBzWZ3ImYy01wDch3AFUOMZbJ5TpH7rYVrAs64uPVvtYan1N2hgrbGIwQr38GHtHw+WW28AlCKLnP0IW+ubyLX0A9pxqIzWXNib+vLk7oPlYtNArqvwfDwcvYgLUsu2eP9pemfOSvrBwyvpHe4HuCAyGgKwvZ/siwuwoYV4styojwieYsaCGT14dj1lxfl7YZYlz3j2drr6Xy6m2T3zqD+PqpAZNmTt+BGAiiVYgcWHC8L3H46+toOeenAZvc/7wuUAzAI01vVnRCLwP8ElRlDiFW40EXUTwAVyAG4tA3tR3oI76J4xA+mOvHTKgKtiIIfq2kswcANquCDVTdTIj0YsvXcpLSo9rcatYZ31RaDmU8Aa5Wp/0BinxDPcUA3qhwXuEwCHLw5LbgGO+MyraNCDk+nuEb1pOrsr6TyyYiBnxXiLP8ABNW6dswvStP8UrXrmPVr8x410mPfXgUYcUGOID1CLbx3CfwLvFUWJd7hFFagnrLhALq4KLjoF9IyvXkb9Zk+lmSOK6Cv8XfZMfl7cQC4a9BECatyIqW6gBob6b0+toT/+5SM1OQ5cDgEbcd0FAdRwQeIWaq6bkkSBG5VFXQVyWHFxVQC4QK7iU4ZTr4e/RLeN7kdfzcugXAU57xnOBRYfIykE1htv8yioG6lm1zH6y3/9nZat/UQ96CQgA2yJ+3JB4h5sdFYiwS1wCeDe/jjAFosOa57+2c9Q4X9/mW4Z3Zdm8J3OQszJJ3c7Uwl0AI0Fkw80sFPBU5iV7zpOL//0VVqx9VP1pTAALEAjrltq8asTwlpz3S1JRLil8gI5XBUs8MdlfFwgV8AX5lHW4zfSxCsG0vUDu9NEfnY8Xax5Ml+Awu0QK13bRE2lZ2n9llJ6g4f11pdXW4+h6hYacfjUcus8YVwQrnM7SWS40RjUXyAXn1wgB+ACucTTxw2mbj+cRlNH9aZp/QroYobcpmZ3QkFcUiJbdLHQ8Bnw0gC7Hu5jFbRzDz8Dwi/nrtlUom6VwzLLIhYa6zrUsNJiqRPCBeH6tpNEh1sa5AtyfXQFcAN6gVydAHdNoAF3j6PpQ3rQlIIcGoxRFoCubg5x5niHXYcZz3wAaIx6VNRSSXEZrV28iVYt2UBHuCkCrkCNdT0O10OsdMJDzW1Rkixw6+0R0MVd0V0WuQgV0MXKO798CRV9bRxdMbQHje3TjS7n0Za+cF0wdq7DjgPFwroDZIgCmkPAjDHpttGO4/zo6YcHy2jbnzbRlld30CnOAmB1qAVoPR1Ay4IjyMLRxJdkg1vvEbQNroq4KwI7ABeovUNsQz7nzHHU78YxdMWQnjSWn0q8LDuNemIObVyQAnbrwpQzQ3Tg9fi5rYF/BV7klLgijX9wIQiYEeKtcn7r5czJKvqo+AxtW7mdtvxxkxq+E+urwytwSyh5BGgu0XI/AlcywXIkM9zSFWLJBXSEFsQcB+BYF+glriBvS7dPGU6FUy+iwcOKaFBRPg3qlkUD89NpIFv4fmzdnQAez1OLK6POLK91bBPLq0IGFxd8AjHSsN5mlVt4/PlYVROV8qQ2paeq6DDPr3d4zW4q4WE7fAsdYAJWAVbiANk7DpiRJjAjVIflMGkFfZAqgrbqC+AF6Ahl8QU20mS7vo86WXIzyfm1K6jfZQNpQEEm5fP0w1lZaZTNw47Z7L9ns4XPZl8+i61+NsOdwQA3svWtY9+4ni1xHfvJdTw8V1fPS2Mz1Vc0UNVHpXTkT1voWE2DB5AAFFCK1RVgBWR9Xc8j+wjMEnJRyS2pBLfekzrkiCtQOdThFaB9wS0nhYRShne5so5jIy4CwCACmncolhWQCpwIJS7wAmyJ+8rrXS5nTx3RFZ46rfZsqQCohwK7Hgr4HaXpZUgcR9PjWBfo9LikIRSQBWZ93V8a0vUyJI5jpKRA6UY8NSAgeoeAGmmBQu/9UDrSvAXwQQRCPRRQA4X6PhI/V6r59al0oxZPDQisSPUVlzQ9lLx6iLi3AEiIHgqk3qHk886rCjA/7TWADjESugZ0vUncO5RSJV3W9VBAlTRZ9w6xXdIkrwkDaKAjxQfY1WwOoIFQdGvADaDMzmz+f6SMYEX4z7hMAAAAAElFTkSuQmCC' // @suppress longLineCheck
  };

  return {
    FaviconsByHue,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  function HotKey(dict) {
    if (dict.eventType === undefined) {
      throw new Error('eventType must be given');
    }
    if (dict.keyCode === undefined && dict.keyCodes === undefined) {
      throw new Error('keyCode or keyCodes must be given');
    }
    if (dict.keyCode !== undefined && dict.keyCodes !== undefined) {
      throw new Error('Only keyCode or keyCodes can be given');
    }
    if (dict.callback === undefined) {
      throw new Error('callback must be given');
    }

    this.eventType_ = dict.eventType;
    this.keyCodes_ = [];

    if (dict.keyCode) {
      this.pushKeyCode_(dict.keyCode);
    } else if (dict.keyCodes) {
      dict.keyCodes.forEach(this.pushKeyCode_, this);
    }

    this.useCapture_ = !!dict.useCapture;
    this.callback_ = dict.callback;
    this.thisArg_ = dict.thisArg !== undefined ? dict.thisArg : undefined;

    this.helpText_ = dict.helpText !== undefined ? dict.helpText : undefined;
  }

  HotKey.prototype = {
    get eventType() {
      return this.eventType_;
    },

    get keyCodes() {
      return this.keyCodes_;
    },

    get helpText() {
      return this.helpText_;
    },

    call(e) {
      this.callback_.call(this.thisArg_, e);
    },

    pushKeyCode_(keyCode) {
      this.keyCodes_.push(keyCode);
    }
  };

  return {
    HotKey,
  };
});


'use strict';
Polymer({
  is: 'tv-ui-b-hotkey-controller',

  created() {
    this.isAttached_ = false;
    this.globalMode_ = false;
    this.slavedToParentController_ = undefined;
    this.curHost_ = undefined;
    this.childControllers_ = [];

    this.bubblingKeyDownHotKeys_ = {};
    this.capturingKeyDownHotKeys_ = {};
    this.bubblingKeyPressHotKeys_ = {};
    this.capturingKeyPressHotKeys_ = {};

    this.onBubblingKeyDown_ = this.onKey_.bind(this, false);
    this.onCapturingKeyDown_ = this.onKey_.bind(this, true);
    this.onBubblingKeyPress_ = this.onKey_.bind(this, false);
    this.onCapturingKeyPress_ = this.onKey_.bind(this, true);
  },

  attached() {
    this.isAttached_ = true;

    const host = this.findHost_();
    if (host.__hotkeyController) {
      throw new Error('Multiple hotkey controllers attached to this host');
    }

    host.__hotkeyController = this;
    this.curHost_ = host;

    let parentElement;
    if (host.parentElement) {
      parentElement = host.parentElement;
    } else {
      parentElement = Polymer.dom(host).parentNode.host;
    }
    const parentController = tr.b.getHotkeyControllerForElement(
        parentElement);

    if (parentController) {
      this.slavedToParentController_ = parentController;
      parentController.addChildController_(this);
      return;
    }

    host.addEventListener('keydown', this.onBubblingKeyDown_, false);
    host.addEventListener('keydown', this.onCapturingKeyDown_, true);
    host.addEventListener('keypress', this.onBubblingKeyPress_, false);
    host.addEventListener('keypress', this.onCapturingKeyPress_, true);
  },

  detached() {
    this.isAttached_ = false;

    const host = this.curHost_;
    if (!host) return;

    delete host.__hotkeyController;
    this.curHost_ = undefined;

    if (this.slavedToParentController_) {
      this.slavedToParentController_.removeChildController_(this);
      this.slavedToParentController_ = undefined;
      return;
    }

    host.removeEventListener('keydown', this.onBubblingKeyDown_, false);
    host.removeEventListener('keydown', this.onCapturingKeyDown_, true);
    host.removeEventListener('keypress', this.onBubblingKeyPress_, false);
    host.removeEventListener('keypress', this.onCapturingKeyPress_, true);
  },

  addChildController_(controller) {
    const i = this.childControllers_.indexOf(controller);
    if (i !== -1) {
      throw new Error('Controller already registered');
    }
    this.childControllers_.push(controller);
  },

  removeChildController_(controller) {
    const i = this.childControllers_.indexOf(controller);
    if (i === -1) {
      throw new Error('Controller not registered');
    }
    this.childControllers_.splice(i, 1);
    return controller;
  },

  getKeyMapForEventType_(eventType, useCapture) {
    if (eventType === 'keydown') {
      if (!useCapture) {
        return this.bubblingKeyDownHotKeys_;
      }
      return this.capturingKeyDownHotKeys_;
    }
    if (eventType === 'keypress') {
      if (!useCapture) {
        return this.bubblingKeyPressHotKeys_;
      }
      return this.capturingKeyPressHotKeys_;
    }

    throw new Error('Unsupported key event');
  },

  addHotKey(hotKey) {
    if (!(hotKey instanceof tr.ui.b.HotKey)) {
      throw new Error('hotKey must be a tr.ui.b.HotKey');
    }

    const keyMap = this.getKeyMapForEventType_(
        hotKey.eventType, hotKey.useCapture);

    for (let i = 0; i < hotKey.keyCodes.length; i++) {
      const keyCode = hotKey.keyCodes[i];
      if (keyMap[keyCode]) {
        throw new Error('Key is already bound for keyCode=' + keyCode);
      }
    }

    for (let i = 0; i < hotKey.keyCodes.length; i++) {
      const keyCode = hotKey.keyCodes[i];
      keyMap[keyCode] = hotKey;
    }
    return hotKey;
  },

  removeHotKey(hotKey) {
    if (!(hotKey instanceof tr.ui.b.HotKey)) {
      throw new Error('hotKey must be a tr.ui.b.HotKey');
    }

    const keyMap = this.getKeyMapForEventType_(
        hotKey.eventType, hotKey.useCapture);

    for (let i = 0; i < hotKey.keyCodes.length; i++) {
      const keyCode = hotKey.keyCodes[i];
      if (!keyMap[keyCode]) {
        throw new Error('Key is not bound for keyCode=' + keyCode);
      }
      keyMap[keyCode] = hotKey;
    }
    for (let i = 0; i < hotKey.keyCodes.length; i++) {
      const keyCode = hotKey.keyCodes[i];
      delete keyMap[keyCode];
    }
    return hotKey;
  },

  get globalMode() {
    return this.globalMode_;
  },

  set globalMode(globalMode) {
    const wasAttached = this.isAttached_;
    if (wasAttached) {
      this.detached();
    }
    this.globalMode_ = !!globalMode;
    if (wasAttached) {
      this.attached();
    }
  },

  get topmostConroller_() {
    if (this.slavedToParentController_) {
      return this.slavedToParentController_.topmostConroller_;
    }
    return this;
  },

  childRequestsGeneralFocus(child) {
    const topmost = this.topmostConroller_;
    if (topmost.curHost_) {
      if (topmost.curHost_.hasAttribute('tabIndex')) {
        topmost.curHost_.focus();
      } else {
        if (document.activeElement) {
          document.activeElement.blur();
        }
      }
    } else {
      if (document.activeElement) {
        document.activeElement.blur();
      }
    }
  },

  childRequestsBlur(child) {
    child.blur();

    const topmost = this.topmostConroller_;
    if (topmost.curHost_) {
      topmost.curHost_.focus();
    }
  },

  findHost_() {
    if (this.globalMode_) return document.body;
    if (this.parentElement) return this.parentElement;
    if (!Polymer.dom(this).parentNode) return this.host;

    let node = this.parentNode;
    while (Polymer.dom(node).parentNode) node = Polymer.dom(node).parentNode;
    return node.host;
  },

  appendMatchingHotKeysTo_(matchedHotKeys,
      useCapture, e) {
    const localKeyMap = this.getKeyMapForEventType_(e.type, useCapture);
    const localHotKey = localKeyMap[e.keyCode];
    if (localHotKey) {
      matchedHotKeys.push(localHotKey);
    }

    for (let i = 0; i < this.childControllers_.length; i++) {
      const controller = this.childControllers_[i];
      controller.appendMatchingHotKeysTo_(matchedHotKeys,
          useCapture, e);
    }
  },

  onKey_(useCapture, e) {
    // Keys dispatched to INPUT elements still bubble, even when they're
    // handled. So, skip any events that targeted the input element.
    if (!useCapture && e.path[0].tagName === 'INPUT') return;

    let sortedControllers;

    const matchedHotKeys = [];
    this.appendMatchingHotKeysTo_(matchedHotKeys, useCapture, e);

    if (matchedHotKeys.length === 0) return false;

    if (matchedHotKeys.length > 1) {
      // TODO(nduca): To do support for coddling hotKeys, we need to
      // sort the listeners by their capturing/bubbling order and then pick
      // the one that would topologically win the tie, per DOM dispatch rules.
      throw new Error('More than one hotKey is currently unsupported');
    }


    const hotKey = matchedHotKeys[0];

    let prevented = 0;
    prevented |= hotKey.call(e);

    // We want to return false if preventDefaulted, or one of the handlers
    // return false. But otherwise, we want to return undefiend.
    return !prevented && e.defaultPrevented;
  }
});


'use strict';
tr.exportTo('tr.b', function() {
  function getHotkeyControllerForElement(refElement) {
    let curElement = refElement;
    while (curElement) {
      if (curElement.tagName === 'tv-ui-b-hotkey-controller') {
        return curElement;
      }

      if (curElement.__hotkeyController) {
        return curElement.__hotkeyController;
      }

      if (curElement.parentElement) {
        curElement = curElement.parentElement;
        continue;
      }

      // Probably inside a shadow
      curElement = findHost(curElement);
    }
    return undefined;
  }

  function findHost(initialNode) {
    let node = initialNode;
    while (Polymer.dom(node).parentNode) {
      node = Polymer.dom(node).parentNode;
    }
    return node.host;
  }

  return {
    getHotkeyControllerForElement,
  };
});


'use strict';
Polymer({
  is: 'tr-ui-b-info-bar-group',

  ready() {
    this.messages_ = [];
  },

  clearMessages() {
    this.messages_ = [];
    this.updateContents_();
  },

  addMessage(text, opt_buttons) {
    opt_buttons = opt_buttons || [];
    for (let i = 0; i < opt_buttons.length; i++) {
      if (opt_buttons[i].buttonText === undefined) {
        throw new Error('buttonText must be provided');
      }
      if (opt_buttons[i].onClick === undefined) {
        throw new Error('onClick must be provided');
      }
    }

    this.messages_.push({
      text,
      buttons: opt_buttons || []
    });
    this.updateContents_();
  },

  updateContents_() {
    Polymer.dom(this.$.messages).textContent = '';
    this.messages_.forEach(function(message) {
      const bar = document.createElement('tr-ui-b-info-bar');
      bar.message = message.text;
      bar.visible = true;

      message.buttons.forEach(function(button) {
        bar.addButton(button.buttonText, button.onClick);
      }, this);

      Polymer.dom(this.$.messages).appendChild(bar);
    }, this);
  }
});


'use strict';

/**
 * @fileoverview Implements an element that is hidden by default, but
 * when shown, dims and (attempts to) disable the main document.
 *
 * You can turn any div into an overlay. Note that while an
 * overlay element is shown, its parent is changed. Hiding the overlay
 * restores its original parentage.
 *
 */
tr.exportTo('tr.ui.b', function() {
  if (tr.isHeadless) return {};

  const THIS_DOC = document.currentScript.ownerDocument;

  /**
   * Creates a new overlay element. It will not be visible until shown.
   * @constructor
   * @extends {HTMLDivElement}
   */
  const Overlay = tr.ui.b.define('overlay');

  Overlay.prototype = {
    __proto__: HTMLDivElement.prototype,

    /**
     * Initializes the overlay element.
     */
    decorate() {
      Polymer.dom(this).classList.add('overlay');

      this.parentEl_ = this.ownerDocument.body;

      this.visible_ = false;
      this.userCanClose_ = true;

      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.onClick_ = this.onClick_.bind(this);
      this.onFocusIn_ = this.onFocusIn_.bind(this);
      this.onDocumentClick_ = this.onDocumentClick_.bind(this);
      this.onClose_ = this.onClose_.bind(this);

      this.addEventListener('visible-change',
          tr.ui.b.Overlay.prototype.onVisibleChange_.bind(this), true);

      // Setup the shadow root
      const createShadowRoot = this.createShadowRoot ||
          this.webkitCreateShadowRoot;
      this.shadow_ = createShadowRoot.call(this);
      Polymer.dom(this.shadow_).appendChild(
          tr.ui.b.instantiateTemplate('#overlay-template', THIS_DOC));

      this.closeBtn_ = Polymer.dom(this.shadow_).querySelector('close-button');
      this.closeBtn_.addEventListener('click', this.onClose_);

      Polymer.dom(this.shadow_)
          .querySelector('overlay-frame')
          .addEventListener('click', this.onClick_);

      this.observer_ = new WebKitMutationObserver(
          this.didButtonBarMutate_.bind(this));
      this.observer_.observe(
          Polymer.dom(this.shadow_).querySelector('button-bar'),
          { childList: true });

      // title is a variable on regular HTMLElements. However, we want to
      // use it for something more useful.
      Object.defineProperty(
          this, 'title', {
            get() {
              return Polymer.dom(Polymer.dom(this.shadow_)
                  .querySelector('title')).textContent;
            },
            set(title) {
              Polymer.dom(Polymer.dom(this.shadow_).querySelector('title'))
                  .textContent = title;
            }
          });
    },

    set userCanClose(userCanClose) {
      this.userCanClose_ = userCanClose;
      this.closeBtn_.style.display =
          userCanClose ? 'block' : 'none';
    },

    get buttons() {
      return Polymer.dom(this.shadow_).querySelector('button-bar');
    },

    get visible() {
      return this.visible_;
    },

    set visible(newValue) {
      if (this.visible_ === newValue) return;

      this.visible_ = newValue;
      const e = new tr.b.Event('visible-change');
      this.dispatchEvent(e);
    },

    onVisibleChange_() {
      this.visible_ ? this.show_() : this.hide_();
    },

    show_() {
      Polymer.dom(this.parentEl_).appendChild(this);

      if (this.userCanClose_) {
        this.addEventListener('keydown', this.onKeyDown_.bind(this));
        this.addEventListener('click', this.onDocumentClick_.bind(this));
        this.closeBtn_.addEventListener('click', this.onClose_);
      }

      this.parentEl_.addEventListener('focusin', this.onFocusIn_);
      this.tabIndex = 0;

      // Focus the first thing we find that makes sense. (Skip the close button
      // as it doesn't make sense as the first thing to focus.)
      const elList =
          Polymer.dom(this).querySelectorAll('button, input, list, select, a');
      if (elList.length > 0) {
        if (elList[0] === this.closeBtn_) {
          if (elList.length > 1) return elList[1].focus();
        } else {
          return elList[0].focus();
        }
      }
      this.focus();
    },

    hide_() {
      Polymer.dom(this.parentEl_).removeChild(this);

      this.parentEl_.removeEventListener('focusin', this.onFocusIn_);

      if (this.closeBtn_) {
        this.closeBtn_.removeEventListener('click', this.onClose_);
      }

      document.removeEventListener('keydown', this.onKeyDown_);
      document.removeEventListener('click', this.onDocumentClick_);
    },

    onClose_(e) {
      this.visible = false;
      if ((e.type !== 'keydown') ||
          (e.type === 'keydown' && e.keyCode === 27)) {
        e.stopPropagation();
      }
      e.preventDefault();
      tr.b.dispatchSimpleEvent(this, 'closeclick');
    },

    onFocusIn_(e) {
      // Prevent focus from leaving the overlay.

      let node = e.target;
      while (node) {
        if (node === this) {
          // |this| contains |e.target|, so nothing needs to be done. Allow
          // focus to move from |this| to |e.target|.
          return;
        }
        node = node.parentNode;
      }

      // |e.target| is outside of |this|, so focus |this|.
      tr.b.timeout(0).then(() => this.focus());
      e.preventDefault();
      e.stopPropagation();
    },

    didButtonBarMutate_(e) {
      const hasButtons = this.buttons.children.length > 0;
      if (hasButtons) {
        Polymer.dom(this.shadow_).querySelector('button-bar').style.display =
            undefined;
      } else {
        Polymer.dom(this.shadow_).querySelector('button-bar').style.display =
            'none';
      }
    },

    onKeyDown_(e) {
      // Disallow shift-tab back to another element.
      if (e.keyCode === 9 &&  // tab
          e.shiftKey &&
          e.target === this) {
        e.preventDefault();
        return;
      }

      if (e.keyCode !== 27) return;  // escape

      this.onClose_(e);
    },

    onClick_(e) {
      e.stopPropagation();
    },

    onDocumentClick_(e) {
      if (!this.userCanClose_) return;

      this.onClose_(e);
    }
  };

  Overlay.showError = function(msg, opt_err) {
    const o = new Overlay();
    o.title = 'Error';
    Polymer.dom(o).textContent = msg;
    if (opt_err) {
      const e = tr.b.normalizeException(opt_err);

      const stackDiv = document.createElement('pre');
      Polymer.dom(stackDiv).textContent = e.stack;
      stackDiv.style.paddingLeft = '8px';
      stackDiv.style.margin = 0;
      Polymer.dom(o).appendChild(stackDiv);
    }
    const b = document.createElement('button');
    Polymer.dom(b).textContent = 'OK';
    b.addEventListener('click', function() {
      o.visible = false;
    });
    Polymer.dom(o.buttons).appendChild(b);
    o.visible = true;
    return o;
  };

  return {
    Overlay,
  };
});


  'use strict';
  Polymer({ is: 'tr-ui-b-toolbar-button' });


'use strict';

/**
 * @fileoverview FindController.
 */
tr.exportTo('tr.ui', function() {
  const Task = tr.b.Task;

  function FindController(brushingStateController) {
    this.brushingStateController_ = brushingStateController;
    this.filterHits_ = [];
    this.currentHitIndex_ = -1;
    this.activePromise_ = Promise.resolve();
    this.activeTask_ = undefined;
  }

  FindController.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.brushingStateController_.model;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    enqueueOperation_(operation) {
      let task;
      if (operation instanceof tr.b.Task) {
        task = operation;
      } else {
        task = new tr.b.Task(operation, this);
      }
      if (this.activeTask_) {
        this.activeTask_ = this.activeTask_.enqueue(task);
      } else {
        // We're enqueuing the first task, schedule it.
        this.activeTask_ = task;
        this.activePromise_ = Task.RunWhenIdle(this.activeTask_);
        this.activePromise_.then(function() {
          this.activePromise_ = undefined;
          this.activeTask_ = undefined;
        }.bind(this));
      }
    },

    /**
     * Updates the filter hits based on the provided |filterText|. Returns a
     * promise which resolves when |filterHits| has been refreshed.
     */
    startFiltering(filterText) {
      const sc = this.brushingStateController_;
      if (!sc) return;

      // TODO(beaudoin): Cancel anything left in the task queue, without
      // invalidating the promise.
      this.enqueueOperation_(function() {
        this.filterHits_ = [];
        this.currentHitIndex_ = -1;
      }.bind(this));

      // Try constructing a UIState from the filterText.
      // UIState.fromUserFriendlyString will throw an error only if the string
      // is syntactically correct to a UI state string but with invalid values.
      // It will return undefined if there is no syntactic match.
      let stateFromString;
      try {
        stateFromString = sc.uiStateFromString(filterText);
      } catch (e) {
        this.enqueueOperation_(function() {
          const overlay = new tr.ui.b.Overlay();
          Polymer.dom(overlay).textContent = e.message;
          overlay.title = 'UI State Navigation Error';
          overlay.visible = true;
        });
        return this.activePromise_;
      }

      if (stateFromString !== undefined) {
        this.enqueueOperation_(
            sc.navToPosition.bind(this, stateFromString, true));
      } else {
        // filterText is not a navString here -- proceed with find and filter.
        if (filterText.length === 0) {
          this.enqueueOperation_(sc.findTextCleared.bind(sc));
        } else {
          const filter = new tr.c.FullTextFilter(filterText);
          const filterHitSet = new tr.model.EventSet();
          this.enqueueOperation_(sc.addAllEventsMatchingFilterToSelectionAsTask(
              filter, filterHitSet));
          this.enqueueOperation_(function() {
            this.filterHits_ = filterHitSet.toArray();
            sc.findTextChangedTo(filterHitSet);
          }.bind(this));
        }
      }
      return this.activePromise_;
    },

    /**
     * Returns the most recent filter hits as an array. Call
     * |startFiltering| to ensure this is up to date after the filter settings
     * have been changed.
     */
    get filterHits() {
      return this.filterHits_;
    },

    get currentHitIndex() {
      return this.currentHitIndex_;
    },

    find_(dir) {
      const firstHit = this.currentHitIndex_ === -1;
      if (firstHit && dir < 0) {
        this.currentHitIndex_ = 0;
      }

      const N = this.filterHits.length;
      this.currentHitIndex_ = (this.currentHitIndex_ + dir + N) % N;

      if (!this.brushingStateController_) return;

      this.brushingStateController_.findFocusChangedTo(
          new tr.model.EventSet(this.filterHits[this.currentHitIndex]));
    },

    findNext() {
      this.find_(1);
    },

    findPrevious() {
      this.find_(-1);
    }
  };

  return {
    FindController,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * Annotation is a base class that represents all annotation objects that
   * can be drawn on the timeline.
   *
   * @constructor
   */
  function Annotation() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.view_ = undefined;
  }

  Annotation.fromDictIfPossible = function(args) {
    if (args.typeName === undefined) {
      throw new Error('Missing typeName argument');
    }

    const typeInfo = Annotation.findTypeInfoMatching(function(typeInfo) {
      return typeInfo.metadata.typeName === args.typeName;
    });

    if (typeInfo === undefined) return undefined;

    return typeInfo.constructor.fromDict(args);
  };

  Annotation.fromDict = function() {
    throw new Error('Not implemented');
  };

  Annotation.prototype = {
    get guid() {
      return this.guid_;
    },

    // Invoked by trace model when this annotation is removed.
    onRemove() {
    },

    toDict() {
      throw new Error('Not implemented');
    },

    getOrCreateView(viewport) {
      if (!this.view_) {
        this.view_ = this.createView_(viewport);
      }
      return this.view_;
    },

    createView_() {
      throw new Error('Not implemented');
    }
  };

  const options = new tr.b.ExtensionRegistryOptions(tr.b. BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(Annotation, options);

  Annotation.addEventListener('will-register', function(e) {
    if (!e.typeInfo.constructor.hasOwnProperty('fromDict')) {
      throw new Error('Must have fromDict method');
    }

    if (!e.typeInfo.metadata.typeName) {
      throw new Error('Registered Annotations must provide typeName');
    }
  });

  return {
    Annotation,
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A base class for all annotation views.
   * @constructor
   */
  function AnnotationView(viewport, annotation) {
  }

  AnnotationView.prototype = {
    draw(ctx) {
      throw new Error('Not implemented');
    }
  };

  return {
    AnnotationView,
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view that draws a vertical line on the timeline at a specific timestamp.
   * @extends {AnnotationView}
   * @constructor
   */
  function XMarkerAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  XMarkerAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw(ctx) {
      const dt = this.viewport_.currentDisplayTransform;
      const viewX = dt.xWorldToView(this.annotation_.timestamp);

      ctx.beginPath();
      tr.ui.b.drawLine(ctx, viewX, 0, viewX, ctx.canvas.height);
      ctx.strokeStyle = this.annotation_.strokeStyle;
      ctx.stroke();
    }
  };

  return {
    XMarkerAnnotationView,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function XMarkerAnnotation(timestamp) {
    tr.model.Annotation.apply(this, arguments);

    this.timestamp = timestamp;
    this.strokeStyle = 'rgba(0, 0, 255, 0.5)';
  }

  XMarkerAnnotation.fromDict = function(dict) {
    return new XMarkerAnnotation(dict.args.timestamp);
  };

  XMarkerAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    toDict() {
      return {
        typeName: 'xmarker',
        args: {
          timestamp: this.timestamp
        }
      };
    },

    createView_(viewport) {
      return new tr.ui.annotations.XMarkerAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(
      XMarkerAnnotation, {typeName: 'xmarker'});

  return {
    XMarkerAnnotation,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const MOUSE_SELECTOR_MODE = {};
  MOUSE_SELECTOR_MODE.SELECTION = 0x1;
  MOUSE_SELECTOR_MODE.PANSCAN = 0x2;
  MOUSE_SELECTOR_MODE.ZOOM = 0x4;
  MOUSE_SELECTOR_MODE.TIMING = 0x8;
  MOUSE_SELECTOR_MODE.ROTATE = 0x10;
  MOUSE_SELECTOR_MODE.ALL_MODES = 0x1F;

  const MOUSE_SELECTOR_MODE_INFOS = {};
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.PANSCAN] = {
    name: 'PANSCAN',
    mode: MOUSE_SELECTOR_MODE.PANSCAN,
    title: 'pan',
    eventNames: {
      enter: 'enterpan',
      begin: 'beginpan',
      update: 'updatepan',
      end: 'endpan',
      exit: 'exitpan'
    },
    activeBackgroundPosition: '-30px -10px',
    defaultBackgroundPosition: '0 -10px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.SELECTION] = {
    name: 'SELECTION',
    mode: MOUSE_SELECTOR_MODE.SELECTION,
    title: 'selection',
    eventNames: {
      enter: 'enterselection',
      begin: 'beginselection',
      update: 'updateselection',
      end: 'endselection',
      exit: 'exitselection'
    },
    activeBackgroundPosition: '-30px -40px',
    defaultBackgroundPosition: '0 -40px'
  };

  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.ZOOM] = {
    name: 'ZOOM',
    mode: MOUSE_SELECTOR_MODE.ZOOM,
    title: 'zoom',
    eventNames: {
      enter: 'enterzoom',
      begin: 'beginzoom',
      update: 'updatezoom',
      end: 'endzoom',
      exit: 'exitzoom'
    },
    activeBackgroundPosition: '-30px -70px',
    defaultBackgroundPosition: '0 -70px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.TIMING] = {
    name: 'TIMING',
    mode: MOUSE_SELECTOR_MODE.TIMING,
    title: 'timing',
    eventNames: {
      enter: 'entertiming',
      begin: 'begintiming',
      update: 'updatetiming',
      end: 'endtiming',
      exit: 'exittiming'
    },
    activeBackgroundPosition: '-30px -100px',
    defaultBackgroundPosition: '0 -100px'
  };
  MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.ROTATE] = {
    name: 'ROTATE',
    mode: MOUSE_SELECTOR_MODE.ROTATE,
    title: 'rotate',
    eventNames: {
      enter: 'enterrotate',
      begin: 'beginrotate',
      update: 'updaterotate',
      end: 'endrotate',
      exit: 'exitrotate'
    },
    activeBackgroundPosition: '-30px -130px',
    defaultBackgroundPosition: '0 -130px'
  };

  return {
    MOUSE_SELECTOR_MODE_INFOS,
    MOUSE_SELECTOR_MODE,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-b-mouse-mode-icon',

  properties: {
    modeName: {
      type: String,
      reflectToAttribute: true,
      observer: 'modeNameChanged'
    },
  },

  created() {
    this.active_ = false;
    this.acceleratorKey_ = undefined;
  },

  ready() {
    this.updateContents_();
  },

  get mode() {
    return tr.ui.b.MOUSE_SELECTOR_MODE[this.modeName];
  },

  set mode(mode) {
    const modeInfo = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS[mode];
    if (modeInfo === undefined) {
      throw new Error('Unknown mode');
    }
    this.modeName = modeInfo.name;
  },

  modeNameChanged() {
    this.updateContents_();
  },

  get active() {
    return this.active_;
  },

  set active(active) {
    this.active_ = !!active;
    if (this.active_) {
      Polymer.dom(this).classList.add('active');
    } else {
      Polymer.dom(this).classList.remove('active');
    }
    this.updateContents_();
  },

  get acceleratorKey() {
    return this.acceleratorKey_;
  },

  set acceleratorKey(acceleratorKey) {
    this.acceleratorKey_ = acceleratorKey;
    this.updateContents_();
  },

  updateContents_() {
    if (this.modeName === undefined) return;

    const mode = this.mode;
    if (mode === undefined) {
      throw new Error('Invalid mode');
    }

    const modeInfo = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS[mode];
    if (!modeInfo) {
      throw new Error('Invalid mode');
    }

    let title = modeInfo.title;
    if (this.acceleratorKey_) {
      title = title + ' (' + this.acceleratorKey_ + ')';
    }
    this.title = title;

    let bp;
    if (this.active_) {
      bp = modeInfo.activeBackgroundPosition;
    } else {
      bp = modeInfo.defaultBackgroundPosition;
    }
    this.style.backgroundPosition = bp;
  }
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const MOUSE_SELECTOR_MODE = tr.ui.b.MOUSE_SELECTOR_MODE;
  const MOUSE_SELECTOR_MODE_INFOS = tr.ui.b.MOUSE_SELECTOR_MODE_INFOS;


  const MIN_MOUSE_SELECTION_DISTANCE = 4;

  const MODIFIER = {
    SHIFT: 0x1,
    SPACE: 0x2,
    CMD_OR_CTRL: 0x4
  };

  function isCmdOrCtrlPressed(event) {
    if (tr.isMac) return event.metaKey;
    return event.ctrlKey;
  }

  /**
   * Provides a panel for switching the interaction mode of the mouse.
   * It handles the user interaction and dispatches events for the various
   * modes.
   */
  Polymer({
    is: 'tr-ui-b-mouse-mode-selector',

    created() {
      this.supportedModeMask_ = MOUSE_SELECTOR_MODE.ALL_MODES;

      this.initialRelativeMouseDownPos_ = {x: 0, y: 0};

      this.defaultMode_ = MOUSE_SELECTOR_MODE.PANSCAN;
      this.settingsKey_ = undefined;
      this.mousePos_ = {x: 0, y: 0};
      this.mouseDownPos_ = {x: 0, y: 0};

      this.onMouseDown_ = this.onMouseDown_.bind(this);
      this.onMouseMove_ = this.onMouseMove_.bind(this);
      this.onMouseUp_ = this.onMouseUp_.bind(this);

      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.onKeyUp_ = this.onKeyUp_.bind(this);

      this.mode_ = undefined;
      this.modeToKeyCodeMap_ = {};
      this.modifierToModeMap_ = {};

      this.targetElement_ = undefined;
      this.modeBeforeAlternativeModeActivated_ = null;

      this.isInteracting_ = false;
      this.isClick_ = false;
    },

    ready() {
      this.buttonsEl_ = Polymer.dom(this.root).querySelector('.buttons');
      this.dragHandleEl_ = Polymer.dom(this.root).querySelector(
          '.drag-handle');
      this.supportedModeMask = MOUSE_SELECTOR_MODE.ALL_MODES;

      this.dragHandleEl_.addEventListener('mousedown',
          this.onDragHandleMouseDown_.bind(this));

      this.buttonsEl_.addEventListener('mouseup', this.onButtonMouseUp_);
      this.buttonsEl_.addEventListener('mousedown', this.onButtonMouseDown_);
      this.buttonsEl_.addEventListener('click', this.onButtonPress_.bind(this));
    },

    attached() {
      document.addEventListener('keydown', this.onKeyDown_);
      document.addEventListener('keyup', this.onKeyUp_);
    },

    detached() {
      document.removeEventListener('keydown', this.onKeyDown_);
      document.removeEventListener('keyup', this.onKeyUp_);
    },

    get targetElement() {
      return this.targetElement_;
    },

    set targetElement(target) {
      if (this.targetElement_) {
        this.targetElement_.removeEventListener('mousedown', this.onMouseDown_);
      }
      this.targetElement_ = target;
      if (this.targetElement_) {
        this.targetElement_.addEventListener('mousedown', this.onMouseDown_);
      }
    },

    get defaultMode() {
      return this.defaultMode_;
    },

    set defaultMode(defaultMode) {
      this.defaultMode_ = defaultMode;
    },

    get settingsKey() {
      return this.settingsKey_;
    },

    set settingsKey(settingsKey) {
      this.settingsKey_ = settingsKey;
      if (!this.settingsKey_) return;

      let mode = tr.b.Settings.get(this.settingsKey_ + '.mode', undefined);
      // Modes changed from 1,2,3,4 to 0x1, 0x2, 0x4, 0x8. Fix any stray
      // settings to the best of our abilities.
      if (MOUSE_SELECTOR_MODE_INFOS[mode] === undefined) {
        mode = undefined;
      }

      // Restoring settings against unsupported modes should just go back to the
      // default mode.
      if ((mode & this.supportedModeMask_) === 0) {
        mode = undefined;
      }

      if (!mode) mode = this.defaultMode_;
      this.mode = mode;

      const pos = tr.b.Settings.get(this.settingsKey_ + '.pos', undefined);
      if (pos) this.pos = pos;
    },

    get supportedModeMask() {
      return this.supportedModeMask_;
    },

    /**
     * Sets the supported modes. Should be an OR-ing of MOUSE_SELECTOR_MODE
     * values.
     */
    set supportedModeMask(supportedModeMask) {
      if (this.mode && (supportedModeMask & this.mode) === 0) {
        throw new Error('supportedModeMask must include current mode.');
      }

      function createButtonForMode(mode) {
        return button;
      }

      this.supportedModeMask_ = supportedModeMask;
      Polymer.dom(this.buttonsEl_).textContent = '';
      for (const modeName in MOUSE_SELECTOR_MODE) {
        if (modeName === 'ALL_MODES') continue;

        const mode = MOUSE_SELECTOR_MODE[modeName];
        if ((this.supportedModeMask_ & mode) === 0) continue;

        const button = document.createElement('tr-ui-b-mouse-mode-icon');
        button.mode = mode;
        Polymer.dom(button).classList.add('tool-button');

        Polymer.dom(this.buttonsEl_).appendChild(button);
      }
    },

    getButtonForMode_(mode) {
      for (let i = 0; i < this.buttonsEl_.children.length; i++) {
        const buttonEl = this.buttonsEl_.children[i];
        if (buttonEl.mode === mode) {
          return buttonEl;
        }
      }
      return undefined;
    },

    get mode() {
      return this.currentMode_;
    },

    set mode(newMode) {
      if (newMode !== undefined) {
        if (typeof newMode !== 'number') {
          throw new Error('Mode must be a number');
        }
        if ((newMode & this.supportedModeMask_) === 0) {
          throw new Error('Cannot switch to this mode, it is not supported');
        }
        if (MOUSE_SELECTOR_MODE_INFOS[newMode] === undefined) {
          throw new Error('Unrecognized mode');
        }
      }

      let modeInfo;

      if (this.currentMode_ === newMode) return;

      if (this.currentMode_) {
        const buttonEl = this.getButtonForMode_(this.currentMode_);
        if (buttonEl) buttonEl.active = false;

        // End event.
        if (this.isInteracting_) {
          const mouseEvent = this.createEvent_(
              MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.end);
          this.dispatchEvent(mouseEvent);
        }

        // Exit event.
        modeInfo = MOUSE_SELECTOR_MODE_INFOS[this.currentMode_];
        tr.b.dispatchSimpleEvent(this, modeInfo.eventNames.exit, true);
      }

      this.currentMode_ = newMode;

      if (this.currentMode_) {
        const buttonEl = this.getButtonForMode_(this.currentMode_);
        if (buttonEl) buttonEl.active = true;

        // Entering a new mode resets mouse down pos.
        this.mouseDownPos_.x = this.mousePos_.x;
        this.mouseDownPos_.y = this.mousePos_.y;

        // Enter event.
        modeInfo = MOUSE_SELECTOR_MODE_INFOS[this.currentMode_];
        if (!this.isInAlternativeMode_) {
          tr.b.dispatchSimpleEvent(this, modeInfo.eventNames.enter, true);
        }

        // Begin event.
        if (this.isInteracting_) {
          const mouseEvent = this.createEvent_(
              MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.begin);
          this.dispatchEvent(mouseEvent);
        }
      }

      if (this.settingsKey_ && !this.isInAlternativeMode_) {
        tr.b.Settings.set(this.settingsKey_ + '.mode', this.mode);
      }
    },

    setKeyCodeForMode(mode, keyCode) {
      if ((mode & this.supportedModeMask_) === 0) {
        throw new Error('Mode not supported');
      }
      this.modeToKeyCodeMap_[mode] = keyCode;

      if (!this.buttonsEl_) return;

      const buttonEl = this.getButtonForMode_(mode);
      if (buttonEl) {
        buttonEl.acceleratorKey = String.fromCharCode(keyCode);
      }
    },

    setCurrentMousePosFromEvent_(e) {
      this.mousePos_.x = e.clientX;
      this.mousePos_.y = e.clientY;
    },

    createEvent_(eventName, sourceEvent) {
      const event = new tr.b.Event(eventName, true);
      event.clientX = this.mousePos_.x;
      event.clientY = this.mousePos_.y;
      event.deltaX = this.mousePos_.x - this.mouseDownPos_.x;
      event.deltaY = this.mousePos_.y - this.mouseDownPos_.y;
      event.mouseDownX = this.mouseDownPos_.x;
      event.mouseDownY = this.mouseDownPos_.y;
      event.didPreventDefault = false;
      event.preventDefault = function() {
        event.didPreventDefault = true;
        if (sourceEvent) {
          sourceEvent.preventDefault();
        }
      };
      event.stopPropagation = function() {
        sourceEvent.stopPropagation();
      };
      event.stopImmediatePropagation = function() {
        throw new Error('Not implemented');
      };
      return event;
    },

    onMouseDown_(e) {
      if (e.button !== 0) return;
      this.setCurrentMousePosFromEvent_(e);
      const mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.begin, e);
      if (this.mode === MOUSE_SELECTOR_MODE.SELECTION) {
        mouseEvent.appendSelection = isCmdOrCtrlPressed(e);
      }
      this.dispatchEvent(mouseEvent);
      this.isInteracting_ = true;
      this.isClick_ = true;
      tr.ui.b.trackMouseMovesUntilMouseUp(this.onMouseMove_, this.onMouseUp_);
    },

    onMouseMove_(e) {
      this.setCurrentMousePosFromEvent_(e);

      const mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.update, e);
      this.dispatchEvent(mouseEvent);

      if (this.isInteracting_) {
        this.checkIsClick_(e);
      }
    },

    onMouseUp_(e) {
      if (e.button !== 0) return;

      const mouseEvent = this.createEvent_(
          MOUSE_SELECTOR_MODE_INFOS[this.mode].eventNames.end, e);
      mouseEvent.isClick = this.isClick_;
      this.dispatchEvent(mouseEvent);

      if (this.isClick_ && !mouseEvent.didPreventDefault) {
        this.dispatchClickEvents_(e);
      }

      this.isInteracting_ = false;
      this.updateAlternativeModeState_(e);
    },

    onButtonMouseDown_(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    },

    onButtonMouseUp_(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    },

    onButtonPress_(e) {
      this.modeBeforeAlternativeModeActivated_ = undefined;
      this.mode = e.target.mode;
      e.preventDefault();
    },

    onKeyDown_(e) {
      // Keys dispatched to INPUT elements still bubble, even when they're
      // handled. So, skip any events that targeted the input element.
      if (e.path[0].tagName === 'INPUT') return;

      if (e.keyCode === ' '.charCodeAt(0)) {
        this.spacePressed_ = true;
      }
      this.updateAlternativeModeState_(e);
    },

    onKeyUp_(e) {
      // Keys dispatched to INPUT elements still bubble, even when they're
      // handled. So, skip any events that targeted the input element.
      if (e.path[0].tagName === 'INPUT') return;

      if (e.keyCode === ' '.charCodeAt(0)) {
        this.spacePressed_ = false;
      }

      let didHandleKey = false;
      for (const [modeStr, keyCode] of Object.entries(this.modeToKeyCodeMap_)) {
        if (e.keyCode === keyCode) {
          this.modeBeforeAlternativeModeActivated_ = undefined;
          const mode = parseInt(modeStr);
          this.mode = mode;
          didHandleKey = true;
        }
      }

      if (didHandleKey) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      this.updateAlternativeModeState_(e);
    },

    updateAlternativeModeState_(e) {
      const shiftPressed = e.shiftKey;
      const spacePressed = this.spacePressed_;
      const cmdOrCtrlPressed = isCmdOrCtrlPressed(e);

      // Figure out the new mode
      const smm = this.supportedModeMask_;
      let newMode;
      let isNewModeAnAlternativeMode = false;
      if (shiftPressed &&
          (this.modifierToModeMap_[MODIFIER.SHIFT] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.SHIFT];
        isNewModeAnAlternativeMode = true;
      } else if (spacePressed &&
                 (this.modifierToModeMap_[MODIFIER.SPACE] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.SPACE];
        isNewModeAnAlternativeMode = true;
      } else if (cmdOrCtrlPressed &&
                 (this.modifierToModeMap_[MODIFIER.CMD_OR_CTRL] & smm) !== 0) {
        newMode = this.modifierToModeMap_[MODIFIER.CMD_OR_CTRL];
        isNewModeAnAlternativeMode = true;
      } else {
        // Go to the old mode, if there is one.
        if (this.isInAlternativeMode_) {
          newMode = this.modeBeforeAlternativeModeActivated_;
          isNewModeAnAlternativeMode = false;
        } else {
          newMode = undefined;
        }
      }

      // Maybe a mode change isn't needed.
      if (this.mode === newMode || newMode === undefined) return;

      // Okay, we're changing.
      if (isNewModeAnAlternativeMode) {
        this.modeBeforeAlternativeModeActivated_ = this.mode;
      }
      this.mode = newMode;
    },

    get isInAlternativeMode_() {
      return !!this.modeBeforeAlternativeModeActivated_;
    },

    setModifierForAlternateMode(mode, modifier) {
      this.modifierToModeMap_[modifier] = mode;
    },

    get pos() {
      return {
        x: parseInt(this.style.left),
        y: parseInt(this.style.top)
      };
    },

    set pos(pos) {
      pos = this.constrainPositionToBounds_(pos);

      this.style.left = pos.x + 'px';
      this.style.top = pos.y + 'px';

      if (this.settingsKey_) {
        tr.b.Settings.set(this.settingsKey_ + '.pos', this.pos);
      }
    },

    constrainPositionToBounds_(pos) {
      const parent = this.offsetParent || document.body;
      const parentRect = tr.ui.b.windowRectForElement(parent);

      const top = 0;
      const bottom = parentRect.height - this.offsetHeight;
      const left = 0;
      const right = parentRect.width - this.offsetWidth;

      const res = {};
      res.x = Math.max(pos.x, left);
      res.x = Math.min(res.x, right);

      res.y = Math.max(pos.y, top);
      res.y = Math.min(res.y, bottom);
      return res;
    },

    onDragHandleMouseDown_(e) {
      e.preventDefault();
      e.stopImmediatePropagation();

      const mouseDownPos = {
        x: e.clientX - this.offsetLeft,
        y: e.clientY - this.offsetTop
      };
      tr.ui.b.trackMouseMovesUntilMouseUp(function(e) {
        const pos = {};
        pos.x = e.clientX - mouseDownPos.x;
        pos.y = e.clientY - mouseDownPos.y;
        this.pos = pos;
      }.bind(this));
    },

    checkIsClick_(e) {
      if (!this.isInteracting_ || !this.isClick_) return;

      const deltaX = this.mousePos_.x - this.mouseDownPos_.x;
      const deltaY = this.mousePos_.y - this.mouseDownPos_.y;
      const minDist = MIN_MOUSE_SELECTION_DISTANCE;

      if (deltaX * deltaX + deltaY * deltaY > minDist * minDist) {
        this.isClick_ = false;
      }
    },

    dispatchClickEvents_(e) {
      if (!this.isClick_) return;

      const modeInfo = MOUSE_SELECTOR_MODE_INFOS[MOUSE_SELECTOR_MODE.SELECTION];
      const eventNames = modeInfo.eventNames;

      let mouseEvent = this.createEvent_(eventNames.begin);
      mouseEvent.appendSelection = isCmdOrCtrlPressed(e);
      this.dispatchEvent(mouseEvent);

      mouseEvent = this.createEvent_(eventNames.end);
      this.dispatchEvent(mouseEvent);
    }
  });

  return {
    MIN_MOUSE_SELECTION_DISTANCE,
    MODIFIER,
  };
});


'use strict';

/**
 * @fileoverview Provides the TimingTool class.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * Tool for taking time measurements in the TimelineTrackView using
   * Viewportmarkers.
   * @constructor
   */
  function TimingTool(viewport, targetElement) {
    this.viewport_ = viewport;

    // Prepare the event handlers to be added and removed repeatedly.
    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.onDblClick_ = this.onDblClick_.bind(this);
    this.targetElement_ = targetElement;

    // Valid only during mousedown.
    this.isMovingLeftEdge_ = false;
  }

  TimingTool.prototype = {

    onEnterTiming(e) {
      this.targetElement_.addEventListener('mousemove', this.onMouseMove_);
      this.targetElement_.addEventListener('dblclick', this.onDblClick_);
    },

    onBeginTiming(e) {
      if (!this.isTouchPointInsideTrackBounds_(e.clientX, e.clientY)) {
        return;
      }

      const pt = this.getSnappedToEventPosition_(e);
      this.mouseDownAt_(pt.x, pt.y);

      this.updateSnapIndicators_(pt);
    },

    updateSnapIndicators_(pt) {
      if (!pt.snapped) return;

      const ir = this.viewport_.interestRange;
      if (ir.min === pt.x) {
        ir.leftSnapIndicator = new tr.ui.SnapIndicator(pt.y, pt.height);
      }
      if (ir.max === pt.x) {
        ir.rightSnapIndicator = new tr.ui.SnapIndicator(pt.y, pt.height);
      }
    },

    onUpdateTiming(e) {
      const pt = this.getSnappedToEventPosition_(e);
      this.mouseMoveAt_(pt.x, pt.y, true);
      this.updateSnapIndicators_(pt);
    },

    onEndTiming(e) {
      this.mouseUp_();
    },

    onExitTiming(e) {
      this.targetElement_.removeEventListener('mousemove', this.onMouseMove_);
      this.targetElement_.removeEventListener('dblclick', this.onDblClick_);
    },

    onMouseMove_(e) {
      if (e.button) return;

      const worldX = this.getWorldXFromEvent_(e);
      this.mouseMoveAt_(worldX, e.clientY, false);
    },

    onDblClick_(e) {
      // TODO(nduca): Implement dobuleclicking.
    },

    ////////////////////////////////////////////////////////////////////////////

    isTouchPointInsideTrackBounds_(clientX, clientY) {
      if (!this.viewport_ ||
          !this.viewport_.modelTrackContainer ||
          !this.viewport_.modelTrackContainer.canvas) {
        return false;
      }

      const canvas = this.viewport_.modelTrackContainer.canvas;
      const canvasRect = canvas.getBoundingClientRect();
      if (clientX >= canvasRect.left && clientX <= canvasRect.right &&
          clientY >= canvasRect.top && clientY <= canvasRect.bottom) {
        return true;
      }

      return false;
    },

    mouseDownAt_(worldX, y) {
      const ir = this.viewport_.interestRange;
      const dt = this.viewport_.currentDisplayTransform;

      const pixelRatio = window.devicePixelRatio || 1;
      const nearnessThresholdWorld = dt.xViewVectorToWorld(6 * pixelRatio);

      if (ir.isEmpty) {
        ir.setMinAndMax(worldX, worldX);
        ir.rightSelected = true;
        this.isMovingLeftEdge_ = false;
        return;
      }


      // Left edge test.
      if (Math.abs(worldX - ir.min) < nearnessThresholdWorld) {
        ir.leftSelected = true;
        ir.min = worldX;
        this.isMovingLeftEdge_ = true;
        return;
      }

      // Right edge test.
      if (Math.abs(worldX - ir.max) < nearnessThresholdWorld) {
        ir.rightSelected = true;
        ir.max = worldX;
        this.isMovingLeftEdge_ = false;
        return;
      }

      ir.setMinAndMax(worldX, worldX);
      ir.rightSelected = true;
      this.isMovingLeftEdge_ = false;
    },

    mouseMoveAt_(worldX, y, mouseDown) {
      if (mouseDown) {
        this.updateMovingEdge_(worldX);
        return;
      }

      const ir = this.viewport_.interestRange;
      const dt = this.viewport_.currentDisplayTransform;

      const pixelRatio = window.devicePixelRatio || 1;
      const nearnessThresholdWorld = dt.xViewVectorToWorld(6 * pixelRatio);

      // Left edge test.
      if (Math.abs(worldX - ir.min) < nearnessThresholdWorld) {
        ir.leftSelected = true;
        ir.rightSelected = false;
        return;
      }

      // Right edge test.
      if (Math.abs(worldX - ir.max) < nearnessThresholdWorld) {
        ir.leftSelected = false;
        ir.rightSelected = true;
        return;
      }

      ir.leftSelected = false;
      ir.rightSelected = false;
      return;
    },

    updateMovingEdge_(newWorldX) {
      const ir = this.viewport_.interestRange;
      let a = ir.min;
      let b = ir.max;
      if (this.isMovingLeftEdge_) {
        a = newWorldX;
      } else {
        b = newWorldX;
      }

      if (a <= b) {
        ir.setMinAndMax(a, b);
      } else {
        ir.setMinAndMax(b, a);
      }

      if (ir.min === newWorldX) {
        this.isMovingLeftEdge_ = true;
        ir.leftSelected = true;
        ir.rightSelected = false;
      } else {
        this.isMovingLeftEdge_ = false;
        ir.leftSelected = false;
        ir.rightSelected = true;
      }
    },

    mouseUp_() {
      const dt = this.viewport_.currentDisplayTransform;
      const ir = this.viewport_.interestRange;

      ir.leftSelected = false;
      ir.rightSelected = false;

      const pixelRatio = window.devicePixelRatio || 1;
      const minWidthValue = dt.xViewVectorToWorld(2 * pixelRatio);
      if (ir.range < minWidthValue) {
        ir.reset();
      }
    },

    getWorldXFromEvent_(e) {
      const pixelRatio = window.devicePixelRatio || 1;
      const canvas = this.viewport_.modelTrackContainer.canvas;
      const worldOffset = canvas.getBoundingClientRect().left;
      const viewX = (e.clientX - worldOffset) * pixelRatio;
      return this.viewport_.currentDisplayTransform.xViewToWorld(viewX);
    },


    /**
     * Get the closest position of an event within a vertical range of the mouse
     * position if possible, otherwise use the position of the mouse pointer.
     * @param {MouseEvent} e Mouse event with the current mouse coordinates.
     * @return {
     *   {Number} x, The x coordinate in world space.
     *   {Number} y, The y coordinate in world space.
     *   {Number} height, The height of the event.
     *   {boolean} snapped Whether the coordinates are from a snapped event or
     *     the mouse position.
     * }
     */
    getSnappedToEventPosition_(e) {
      const pixelRatio = window.devicePixelRatio || 1;
      const EVENT_SNAP_RANGE = 16 * pixelRatio;

      const modelTrackContainer = this.viewport_.modelTrackContainer;
      const modelTrackContainerRect =
        modelTrackContainer.getBoundingClientRect();

      const viewport = this.viewport_;
      const dt = viewport.currentDisplayTransform;
      const worldMaxDist = dt.xViewVectorToWorld(EVENT_SNAP_RANGE);

      const worldX = this.getWorldXFromEvent_(e);
      const mouseY = e.clientY;

      const selection = new tr.model.EventSet();

      // Look at the track under mouse position first for better performance.
      modelTrackContainer.addClosestEventToSelection(
          worldX, worldMaxDist, mouseY, mouseY, selection);

      // Look at all tracks visible on screen.
      if (!selection.length) {
        modelTrackContainer.addClosestEventToSelection(
            worldX, worldMaxDist,
            modelTrackContainerRect.top, modelTrackContainerRect.bottom,
            selection);
      }

      let minDistX = worldMaxDist;
      let minDistY = Infinity;
      const pixWidth = dt.xViewVectorToWorld(1);

      // Create result object with the mouse coordinates.
      const result = {
        x: worldX,
        y: mouseY - modelTrackContainerRect.top,
        height: 0,
        snapped: false
      };

      const eventBounds = new tr.b.math.Range();
      for (const event of selection) {
        const track = viewport.trackForEvent(event);
        const trackRect = track.getBoundingClientRect();

        eventBounds.reset();
        event.addBoundsToRange(eventBounds);
        let eventX;
        if (Math.abs(eventBounds.min - worldX) <
            Math.abs(eventBounds.max - worldX)) {
          eventX = eventBounds.min;
        } else {
          eventX = eventBounds.max;
        }

        const distX = eventX - worldX;

        const eventY = trackRect.top;
        const eventHeight = trackRect.height;
        const distY = Math.abs(eventY + eventHeight / 2 - mouseY);

        // Prefer events with a closer y position if their x difference is below
        // the width of a pixel.
        if ((distX <= minDistX || Math.abs(distX - minDistX) < pixWidth) &&
            distY < minDistY) {
          minDistX = distX;
          minDistY = distY;

          // Retrieve the event position from the hit.
          result.x = eventX;
          result.y = eventY +
              modelTrackContainer.scrollTop - modelTrackContainerRect.top;
          result.height = eventHeight;
          result.snapped = true;
        }
      }

      return result;
    }
  };

  return {
    TimingTool,
  };
});


'use strict';

tr.exportTo('tr.ui', function() {
  const kDefaultPanAnimationDurationMs = 100.0;
  const lerp = tr.b.math.lerp;

  /**
   * Pans a TimelineDisplayTransform by a given amount.
   * @constructor
   * @extends {tr.ui.b.Animation}
   * @param {Number} deltaX The total amount of change to the transform's panX.
   * @param {Number} deltaY The total amount of change to the transform's panY.
   * @param {Number=} opt_durationMs How long the pan animation should run.
   * Defaults to kDefaultPanAnimationDurationMs.
   */
  function TimelineDisplayTransformPanAnimation(
      deltaX, deltaY, opt_durationMs) {
    this.deltaX = deltaX;
    this.deltaY = deltaY;
    if (opt_durationMs === undefined) {
      this.durationMs = kDefaultPanAnimationDurationMs;
    } else {
      this.durationMs = opt_durationMs;
    }

    this.startPanX = undefined;
    this.startPanY = undefined;
    this.startTimeMs = undefined;
  }

  TimelineDisplayTransformPanAnimation.prototype = {
    __proto__: tr.ui.b.Animation.prototype,

    get affectsPanY() {
      return this.deltaY !== 0;
    },

    canTakeOverFor(existingAnimation) {
      return existingAnimation instanceof TimelineDisplayTransformPanAnimation;
    },

    takeOverFor(existing, timestamp, target) {
      const remainingDeltaXOnExisting = existing.goalPanX - target.panX;
      const remainingDeltaYOnExisting = existing.goalPanY - target.panY;
      let remainingTimeOnExisting = timestamp - (
          existing.startTimeMs + existing.durationMs);
      remainingTimeOnExisting = Math.max(remainingTimeOnExisting, 0);

      this.deltaX += remainingDeltaXOnExisting;
      this.deltaY += remainingDeltaYOnExisting;
      this.durationMs += remainingTimeOnExisting;
    },

    start(timestamp, target) {
      this.startTimeMs = timestamp;
      this.startPanX = target.panX;
      this.startPanY = target.panY;
    },

    tick(timestamp, target) {
      let percentDone = (timestamp - this.startTimeMs) / this.durationMs;
      percentDone = tr.b.math.clamp(percentDone, 0, 1);

      target.panX = lerp(percentDone, this.startPanX, this.goalPanX);
      if (this.affectsPanY) {
        target.panY = lerp(percentDone, this.startPanY, this.goalPanY);
      }
      return timestamp >= this.startTimeMs + this.durationMs;
    },

    get goalPanX() {
      return this.startPanX + this.deltaX;
    },

    get goalPanY() {
      return this.startPanY + this.deltaY;
    }
  };

  /**
   * Zooms in/out on a specified location in the world.
   *
   * Zooming in and out is all about keeping the area under the mouse cursor,
   * here called the "focal point" in the same place under the zoom. If one
   * simply changes the scale, the area under the mouse cursor will change. To
   * keep the focal point from moving during the zoom, the pan needs to change
   * in order to compensate. Thus, a ZoomTo animation is given both a focal
   * point in addition to the amount by which to zoom.
   *
   * @constructor
   * @extends {tr.ui.b.Animation}
   * @param {Number} goalFocalPointXWorld The X coordinate in the world which is
   * of interest.
   * @param {Number} goalFocalPointXView Where on the screen the
   * goalFocalPointXWorld should stay centered during the zoom.
   * @param {Number} goalFocalPointY Where the panY should be when the zoom
   * completes.
   * @param {Number} zoomInRatioX The ratio of the current scaleX to the goal
   * scaleX.
   */
  function TimelineDisplayTransformZoomToAnimation(
      goalFocalPointXWorld,
      goalFocalPointXView,
      goalFocalPointY,
      zoomInRatioX,
      opt_durationMs) {
    this.goalFocalPointXWorld = goalFocalPointXWorld;
    this.goalFocalPointXView = goalFocalPointXView;
    this.goalFocalPointY = goalFocalPointY;
    this.zoomInRatioX = zoomInRatioX;
    if (opt_durationMs === undefined) {
      this.durationMs = kDefaultPanAnimationDurationMs;
    } else {
      this.durationMs = opt_durationMs;
    }

    this.startTimeMs = undefined;
    this.startScaleX = undefined;
    this.goalScaleX = undefined;
    this.startPanY = undefined;
  }

  TimelineDisplayTransformZoomToAnimation.prototype = {
    __proto__: tr.ui.b.Animation.prototype,

    get affectsPanY() {
      return this.startPanY !== this.goalFocalPointY;
    },

    canTakeOverFor(existingAnimation) {
      return false;
    },

    takeOverFor(existingAnimation, timestamp, target) {
      this.goalScaleX = target.scaleX * this.zoomInRatioX;
    },

    start(timestamp, target) {
      this.startTimeMs = timestamp;
      this.startScaleX = target.scaleX;
      this.goalScaleX = this.zoomInRatioX * target.scaleX;
      this.startPanY = target.panY;
    },

    tick(timestamp, target) {
      let percentDone = (timestamp - this.startTimeMs) / this.durationMs;
      percentDone = tr.b.math.clamp(percentDone, 0, 1);

      target.scaleX = lerp(percentDone, this.startScaleX, this.goalScaleX);
      if (this.affectsPanY) {
        target.panY = lerp(percentDone, this.startPanY, this.goalFocalPointY);
      }

      target.xPanWorldPosToViewPos(
          this.goalFocalPointXWorld, this.goalFocalPointXView);
      return timestamp >= this.startTimeMs + this.durationMs;
    }
  };

  return {
    TimelineDisplayTransformPanAnimation,
    TimelineDisplayTransformZoomToAnimation,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const constants = {
    HEADING_WIDTH: 250
  };

  return {
    constants,
  };
});


'use strict';

/**
 * @fileoverview Container that decorates its children.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * @constructor
   */
  const ContainerThatDecoratesItsChildren = tr.ui.b.define('div');

  ContainerThatDecoratesItsChildren.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.observer_ = new WebKitMutationObserver(this.didMutate_.bind(this));
      this.observer_.observe(this, { childList: true });

      // textContent is a variable on regular HTMLElements. However, we want to
      // hook and prevent writes to it.
      Object.defineProperty(
          this, 'textContent',
          { get: undefined, set: this.onSetTextContent_});
    },

    appendChild(x) {
      HTMLDivElement.prototype.appendChild.call(this, x);
      this.didMutate_(this.observer_.takeRecords());
    },

    insertBefore(x, y) {
      HTMLDivElement.prototype.insertBefore.call(this, x, y);
      this.didMutate_(this.observer_.takeRecords());
    },

    removeChild(x) {
      HTMLDivElement.prototype.removeChild.call(this, x);
      this.didMutate_(this.observer_.takeRecords());
    },

    replaceChild(x, y) {
      HTMLDivElement.prototype.replaceChild.call(this, x, y);
      this.didMutate_(this.observer_.takeRecords());
    },

    onSetTextContent_(textContent) {
      if (textContent !== '') {
        throw new Error('textContent can only be set to \'\'.');
      }
      this.clear();
    },

    clear() {
      while (Polymer.dom(this).lastChild) {
        HTMLDivElement.prototype.removeChild.call(
            this, Polymer.dom(this).lastChild);
      }
      this.didMutate_(this.observer_.takeRecords());
    },

    didMutate_(records) {
      this.beginDecorating_();
      for (let i = 0; i < records.length; i++) {
        const addedNodes = records[i].addedNodes;
        if (addedNodes) {
          for (let j = 0; j < addedNodes.length; j++) {
            this.decorateChild_(addedNodes[j]);
          }
        }
        const removedNodes = records[i].removedNodes;
        if (removedNodes) {
          for (let j = 0; j < removedNodes.length; j++) {
            this.undecorateChild_(removedNodes[j]);
          }
        }
      }
      this.doneDecoratingForNow_();
    },

    decorateChild_(child) {
      throw new Error('Not implemented');
    },

    undecorateChild_(child) {
      throw new Error('Not implemented');
    },

    beginDecorating_() {
    },

    doneDecoratingForNow_() {
    }
  };

  return {
    ContainerThatDecoratesItsChildren,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * The base class for all tracks, which render data into a provided div.
   * @constructor
   */
  const Track = tr.ui.b.define('track',
      tr.ui.b.ContainerThatDecoratesItsChildren);
  Track.prototype = {
    __proto__: tr.ui.b.ContainerThatDecoratesItsChildren.prototype,

    decorate(viewport) {
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.decorate.call(this);
      if (viewport === undefined) {
        throw new Error('viewport is required when creating a Track.');
      }

      this.viewport_ = viewport;
      Polymer.dom(this).classList.add('track');
    },

    get viewport() {
      return this.viewport_;
    },

    get drawingContainer() {
      if (this instanceof tr.ui.tracks.DrawingContainer) return this;
      let cur = this.parentElement;
      while (cur) {
        if (cur instanceof tr.ui.tracks.DrawingContainer) return cur;
        cur = cur.parentElement;
      }
      return undefined;
    },

    get eventContainer() {
    },

    invalidateDrawingContainer() {
      const dc = this.drawingContainer;
      if (dc) dc.invalidate();
    },

    context() {
      // This is a little weird here, but we have to be able to walk up the
      // parent tree to get the context.
      if (!Polymer.dom(this).parentNode) return undefined;

      if (!Polymer.dom(this).parentNode.context) {
        throw new Error('Parent container does not support context() method.');
      }
      return Polymer.dom(this).parentNode.context();
    },

    decorateChild_(childTrack) {
    },

    undecorateChild_(childTrack) {
      if (childTrack.detach) {
        childTrack.detach();
      }
    },

    updateContents_() {
    },

    /**
     * Wrapper function around draw() that performs transformations on the
     * context necessary for the track's contents to be drawn in the right place
     * given the current pan and zoom.
     */
    drawTrack(type) {
      const ctx = this.context();

      const pixelRatio = window.devicePixelRatio || 1;
      const bounds = this.getBoundingClientRect();
      const canvasBounds = ctx.canvas.getBoundingClientRect();

      ctx.save();
      ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

      const dt = this.viewport.currentDisplayTransform;
      const viewLWorld = dt.xViewToWorld(0);
      const viewRWorld = dt.xViewToWorld(canvasBounds.width * pixelRatio);

      this.draw(type, viewLWorld, viewRWorld);
      ctx.restore();
    },

    draw(type, viewLWorld, viewRWorld) {
    },

    addEventsToTrackMap(eventToTrackMap) {
    },

    addContainersToTrackMap(containerToTrackMap) {
    },

    addIntersectingEventsInRangeToSelection(
        loVX, hiVX, loVY, hiVY, selection) {
      const pixelRatio = window.devicePixelRatio || 1;
      const dt = this.viewport.currentDisplayTransform;
      const viewPixWidthWorld = dt.xViewVectorToWorld(1);
      const loWX = dt.xViewToWorld(loVX * pixelRatio);
      const hiWX = dt.xViewToWorld(hiVX * pixelRatio);

      const clientRect = this.getBoundingClientRect();
      const a = Math.max(loVY, clientRect.top);
      const b = Math.min(hiVY, clientRect.bottom);
      if (a > b) return;

      this.addIntersectingEventsInRangeToSelectionInWorldSpace(
          loWX, hiWX, viewPixWidthWorld, selection);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
    },

    /**
     * Gets implemented by supporting track types. The method adds the event
     * closest to worldX to the selection.
     *
     * @param {number} worldX The position that is looked for.
     * @param {number} worldMaxDist The maximum distance allowed from worldX to
     *     the event.
     * @param {number} loY Lower Y bound of the search interval in view space.
     * @param {number} hiY Upper Y bound of the search interval in view space.
     * @param {Selection} selection Selection to which to add hits.
     */
    addClosestEventToSelection(
        worldX, worldMaxDist, loY, hiY, selection) {
    },

    addClosestInstantEventToSelection(instantEvents, worldX,
        worldMaxDist, selection) {
      const instantEvent = tr.b.findClosestElementInSortedArray(
          instantEvents,
          function(x) { return x.start; },
          worldX,
          worldMaxDist);

      if (!instantEvent) return;

      selection.push(instantEvent);
    }
  };

  return {
    Track,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const DrawType = {
    GENERAL_EVENT: 1,
    INSTANT_EVENT: 2,
    BACKGROUND: 3,
    GRID: 4,
    FLOW_ARROWS: 5,
    MARKERS: 6,
    HIGHLIGHTS: 7,
    ANNOTATIONS: 8
  };

  // Must be > 1.0. This is the maximum multiple by which the size
  // of the canvas can exceed the window dimensions. For example
  // if window.innerHeight is 1000 and this is 1.4, then the
  // largest the canvas height can be set to is 1400px assuming a
  // window.devicePixelRatio of 1.
  // Currently this value is set rather large to mostly match
  // previous behavior & performance. This should be reduced to
  // be as small as possible once raw drawing performance is improved
  // such that a repaint doesn't incur a large jank
  const MAX_OVERSIZE_MULTIPLE = 3.0;
  const REDRAW_SLOP = (MAX_OVERSIZE_MULTIPLE - 1) / 2;

  const DrawingContainer = tr.ui.b.define('drawing-container',
      tr.ui.tracks.Track);

  DrawingContainer.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('drawing-container');

      this.canvas_ = document.createElement('canvas');
      this.canvas_.className = 'drawing-container-canvas';
      this.canvas_.style.left = tr.ui.b.constants.HEADING_WIDTH + 'px';
      Polymer.dom(this).appendChild(this.canvas_);

      this.ctx_ = this.canvas_.getContext('2d');
      this.offsetY_ = 0;

      this.viewportChange_ = this.viewportChange_.bind(this);
      this.viewport.addEventListener('change', this.viewportChange_);

      window.addEventListener('resize', this.windowResized_.bind(this));
      this.addEventListener('scroll', this.scrollChanged_.bind(this));
    },

    // Needed to support the calls in TimelineTrackView.
    get canvas() {
      return this.canvas_;
    },

    context() {
      return this.ctx_;
    },

    viewportChange_() {
      this.invalidate();
    },

    windowResized_() {
      this.invalidate();
    },

    scrollChanged_() {
      if (this.updateOffsetY_()) {
        this.invalidate();
      }
    },

    invalidate() {
      if (this.rafPending_) return;

      this.rafPending_ = true;

      tr.b.requestPreAnimationFrame(this.preDraw_, this);
    },

    preDraw_() {
      this.rafPending_ = false;
      this.updateCanvasSizeIfNeeded_();

      tr.b.requestAnimationFrameInThisFrameIfPossible(this.draw_, this);
    },

    draw_() {
      this.ctx_.clearRect(0, 0, this.canvas_.width, this.canvas_.height);

      const typesToDraw = [
        DrawType.BACKGROUND,
        DrawType.HIGHLIGHTS,
        DrawType.GRID,
        DrawType.INSTANT_EVENT,
        DrawType.GENERAL_EVENT,
        DrawType.MARKERS,
        DrawType.ANNOTATIONS,
        DrawType.FLOW_ARROWS
      ];

      for (const idx in typesToDraw) {
        for (let i = 0; i < this.children.length; ++i) {
          if (!(this.children[i] instanceof tr.ui.tracks.Track)) {
            continue;
          }
          this.children[i].drawTrack(typesToDraw[idx]);
        }
      }

      const pixelRatio = window.devicePixelRatio || 1;
      const bounds = this.canvas_.getBoundingClientRect();
      const dt = this.viewport.currentDisplayTransform;
      const viewLWorld = dt.xViewToWorld(0);
      const viewRWorld = dt.xViewToWorld(
          bounds.width * pixelRatio);

      this.viewport.drawGridLines(this.ctx_, viewLWorld, viewRWorld);
    },

    // Update's this.offsetY_, returning true if the value has changed
    // and thus a redraw is needed, or false if it did not change.
    updateOffsetY_() {
      const maxYDelta = window.innerHeight * REDRAW_SLOP;
      let newOffset = this.scrollTop - maxYDelta;
      if (Math.abs(newOffset - this.offsetY_) <= maxYDelta) return false;
      // Now clamp to the valid range.
      const maxOffset = this.scrollHeight -
          this.canvas_.getBoundingClientRect().height;
      newOffset = Math.max(0, Math.min(newOffset, maxOffset));
      if (newOffset !== this.offsetY_) {
        this.offsetY_ = newOffset;
        return true;
      }
      return false;
    },

    updateCanvasSizeIfNeeded_() {
      const visibleChildTracks =
          Array.from(this.children).filter(this.visibleFilter_);

      if (visibleChildTracks.length === 0) {
        return;
      }

      const thisBounds = this.getBoundingClientRect();

      const firstChildTrackBounds =
        visibleChildTracks[0].getBoundingClientRect();
      const lastChildTrackBounds =
          visibleChildTracks[visibleChildTracks.length - 1].
              getBoundingClientRect();

      const innerWidth = firstChildTrackBounds.width -
          tr.ui.b.constants.HEADING_WIDTH;
      const innerHeight = Math.min(
          lastChildTrackBounds.bottom - firstChildTrackBounds.top,
          Math.floor(window.innerHeight * MAX_OVERSIZE_MULTIPLE));

      const pixelRatio = window.devicePixelRatio || 1;
      if (this.canvas_.width !== innerWidth * pixelRatio) {
        this.canvas_.width = innerWidth * pixelRatio;
        this.canvas_.style.width = innerWidth + 'px';
      }

      if (this.canvas_.height !== innerHeight * pixelRatio) {
        this.canvas_.height = innerHeight * pixelRatio;
        this.canvas_.style.height = innerHeight + 'px';
      }

      if (this.canvas_.top !== this.offsetY_) {
        this.canvas_.top = this.offsetY_;
        this.canvas_.style.top = this.offsetY_ + 'px';
      }
    },

    visibleFilter_(element) {
      if (!(element instanceof tr.ui.tracks.Track)) return false;

      return window.getComputedStyle(element).display !== 'none';
    },

    addClosestEventToSelection(
        worldX, worldMaxDist, loY, hiY, selection) {
      for (let i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track)) {
          continue;
        }
        const trackClientRect = this.children[i].getBoundingClientRect();
        const a = Math.max(loY, trackClientRect.top);
        const b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b) {
          this.children[i].addClosestEventToSelection(
              worldX, worldMaxDist, loY, hiY, selection);
        }
      }

      tr.ui.tracks.Track.prototype.addClosestEventToSelection.
          apply(this, arguments);
    },

    addEventsToTrackMap(eventToTrackMap) {
      for (let i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track)) {
          continue;
        }
        this.children[i].addEventsToTrackMap(eventToTrackMap);
      }
    }
  };

  return {
    DrawingContainer,
    DrawType,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const SelectableItem = tr.model.SelectableItem;
  const SelectionState = tr.model.SelectionState;

  /**
   * A ProxySelectableItem is a selectable item which is not a model item itself
   * but instead acts as a proxy for a model item.
   *
   * @constructor
   * @extends {SelectableItem}
   */
  function ProxySelectableItem(modelItem) {
    SelectableItem.call(this, modelItem);
  }

  ProxySelectableItem.prototype = {
    __proto__: SelectableItem.prototype,

    get selectionState() {
      const modelItem = this.modelItem_;
      if (modelItem === undefined) {
        return SelectionState.NONE;
      }
      return modelItem.selectionState;
    }
  };

  return {
    ProxySelectableItem,
  };
});


'use strict';
Polymer({
  is: 'tr-ui-b-heading',

  DOWN_ARROW: String.fromCharCode(0x25BE),
  RIGHT_ARROW: String.fromCharCode(0x25B8),

  ready(viewport) {
    // Minus 6 === 1px border + 5px padding right.
    this.style.width = (tr.ui.b.constants.HEADING_WIDTH - 6) + 'px';

    this.heading_ = '';
    this.expanded_ = true;
    this.arrowVisible_ = false;
    this.selectionGenerator_ = undefined;

    this.updateContents_();
  },

  get heading() {
    return this.heading_;
  },

  set heading(text) {
    if (this.heading_ === text) return;

    this.heading_ = text;
    this.updateContents_();
  },

  set arrowVisible(val) {
    if (this.arrowVisible_ === val) return;

    this.arrowVisible_ = !!val;
    this.updateContents_();
  },

  set tooltip(text) {
    this.$.heading.title = text;
  },

  set selectionGenerator(generator) {
    if (this.selectionGenerator_ === generator) return;

    this.selectionGenerator_ = generator;
    this.updateContents_();
  },

  get expanded() {
    return this.expanded_;
  },

  set expanded(expanded) {
    if (this.expanded_ === expanded) return;

    this.expanded_ = !!expanded;
    this.updateContents_();
  },

  onHeadingDivClicked_() {
    this.dispatchEvent(new tr.b.Event('heading-clicked', true));
  },

  updateContents_() {
    if (this.arrowVisible_) {
      this.$.arrow.style.display = '';
    } else {
      this.$.arrow.style.display = 'none';
      this.$.heading.style.display = this.expanded_ ? '' : 'none';
    }

    if (this.arrowVisible_) {
      Polymer.dom(this.$.arrow).textContent =
          this.expanded_ ? this.DOWN_ARROW : this.RIGHT_ARROW;
    }

    this.$.link.style.display = 'none';
    this.$.heading_content.style.display = 'none';

    if (this.selectionGenerator_) {
      this.$.link.style.display = 'inline-block';
      this.$.link.selection = this.selectionGenerator_;
      Polymer.dom(this.$.link).textContent = this.heading_;
    } else {
      this.$.heading_content.style.display = 'inline-block';
      Polymer.dom(this.$.heading_content).textContent = this.heading_;
    }
  }
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const EventPresenter = tr.ui.b.EventPresenter;
  const SelectionState = tr.model.SelectionState;

  /**
   * A track that displays an array of dots with filled letters inside them.
   * @constructor
   * @extends {Track}
   */
  const LetterDotTrack = tr.ui.b.define(
      'letter-dot-track', tr.ui.tracks.Track);

  LetterDotTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('letter-dot-track');
      this.items_ = undefined;

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get items() {
      return this.items_;
    },

    set items(items) {
      this.items_ = items;
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    get dumpRadiusView() {
      return 7 * (window.devicePixelRatio || 1);
    },

    draw(type, viewLWorld, viewRWorld) {
      if (this.items_ === undefined) return;

      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawLetterDots_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawLetterDots_(viewLWorld, viewRWorld) {
      const ctx = this.context();
      const pixelRatio = window.devicePixelRatio || 1;

      const bounds = this.getBoundingClientRect();
      const height = bounds.height * pixelRatio;
      const halfHeight = height * 0.5;
      const twoPi = Math.PI * 2;

      // Culling parameters.
      const dt = this.viewport.currentDisplayTransform;
      const dumpRadiusView = this.dumpRadiusView;
      const itemRadiusWorld = dt.xViewVectorToWorld(height);

      // Draw the memory dumps.
      const items = this.items_;
      const loI = tr.b.findLowIndexInSortedArray(
          items,
          function(item) { return item.start; },
          viewLWorld);

      const oldFont = ctx.font;
      ctx.font = '400 ' + Math.floor(9 * pixelRatio) + 'px Arial';
      ctx.strokeStyle = 'rgb(0,0,0)';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';

      const drawItems = function(selected) {
        for (let i = loI; i < items.length; ++i) {
          const item = items[i];
          const x = item.start;
          if (x - itemRadiusWorld > viewRWorld) break;

          if (item.selected !== selected) continue;

          const xView = dt.xWorldToView(x);

          ctx.fillStyle = EventPresenter.getSelectableItemColorAsString(item);
          ctx.beginPath();
          ctx.arc(xView, halfHeight, dumpRadiusView + 0.5, 0, twoPi);
          ctx.fill();
          if (item.selected) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'rgb(100,100,0)';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(xView, halfHeight, dumpRadiusView, 0, twoPi);
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgb(255,255,0)';
            ctx.stroke();
          } else {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgb(0,0,0)';
            ctx.stroke();
          }

          ctx.fillStyle = 'rgb(255, 255, 255)';
          ctx.fillText(item.dotLetter, xView, halfHeight);
        }
      };

      // Draw unselected items first to make sure they don't occlude selected
      // items.
      drawItems(false);
      drawItems(true);

      ctx.lineWidth = 1;
      ctx.font = oldFont;
    },

    addEventsToTrackMap(eventToTrackMap) {
      if (this.items_ === undefined) return;

      this.items_.forEach(function(item) {
        item.addToTrackMap(eventToTrackMap, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      if (this.items_ === undefined) return;

      const itemRadiusWorld = viewPixWidthWorld * this.dumpRadiusView;
      tr.b.iterateOverIntersectingIntervals(
          this.items_,
          function(x) { return x.start - itemRadiusWorld; },
          function(x) { return 2 * itemRadiusWorld; },
          loWX, hiWX,
          function(item) {
            item.addToSelection(selection);
          }.bind(this));
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {event} The current event item.
     * @param {Number} offset Number of slices away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection(event, offset, selection) {
      if (this.items_ === undefined) return;

      const index = this.items_.findIndex(item => item.modelItem === event);
      if (index === -1) return false;

      const newIndex = index + offset;
      if (newIndex >= 0 && newIndex < this.items_.length) {
        this.items_[newIndex].addToSelection(selection);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      if (this.items_ === undefined) return;

      const item = tr.b.findClosestElementInSortedArray(
          this.items_,
          function(x) { return x.start; },
          worldX,
          worldMaxDist);

      if (!item) return;

      item.addToSelection(selection);
    }
  };

  /**
   * A filled dot with a letter inside it.
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function LetterDot(modelItem, dotLetter, colorId, start) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.dotLetter = dotLetter;
    this.colorId = colorId;
    this.start = start;
  }

  LetterDot.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype
  };

  return {
    LetterDotTrack,
    LetterDot,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of alert objects.
   * @constructor
   * @extends {LetterDotTrack}
   */
  const AlertTrack = tr.ui.b.define(
      'alert-track', tr.ui.tracks.LetterDotTrack);

  AlertTrack.prototype = {
    __proto__: tr.ui.tracks.LetterDotTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.LetterDotTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Alerts';
      this.alerts_ = undefined;
    },

    get alerts() {
      return this.alerts_;
    },

    set alerts(alerts) {
      this.alerts_ = alerts;
      if (alerts === undefined) {
        this.items = undefined;
        return;
      }
      this.items = this.alerts_.map(function(alert) {
        return new tr.ui.tracks.LetterDot(
            alert, String.fromCharCode(9888), alert.colorId, alert.start);
      });
    }
  };

  return {
    AlertTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const Task = tr.b.Task;

  /**
   * A generic track that contains other tracks as its children.
   * @constructor
   */
  const ContainerTrack = tr.ui.b.define('container-track', tr.ui.tracks.Track);
  ContainerTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
    },

    detach() {
      Polymer.dom(this).textContent = '';
    },

    get tracks_() {
      const tracks = [];
      for (let i = 0; i < this.children.length; i++) {
        if (this.children[i] instanceof tr.ui.tracks.Track) {
          tracks.push(this.children[i]);
        }
      }
      return tracks;
    },

    drawTrack(type) {
      this.tracks_.forEach(function(track) {
        track.drawTrack(type);
      });
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loY Lower Y bound of the interval to search, in
     *     viewspace space.
     * @param {number} hiY Upper Y bound of the interval to search, in
     *     viewspace space.
     * @param {Selection} selection Selection to which to add results.
     */
    addIntersectingEventsInRangeToSelection(
        loVX, hiVX, loY, hiY, selection) {
      for (let i = 0; i < this.tracks_.length; i++) {
        const trackClientRect = this.tracks_[i].getBoundingClientRect();
        const a = Math.max(loY, trackClientRect.top);
        const b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b) {
          this.tracks_[i].addIntersectingEventsInRangeToSelection(
              loVX, hiVX, loY, hiY, selection);
        }
      }

      tr.ui.tracks.Track.prototype.addIntersectingEventsInRangeToSelection.
          apply(this, arguments);
    },

    addEventsToTrackMap(eventToTrackMap) {
      for (const track of this.tracks_) {
        track.addEventsToTrackMap(eventToTrackMap);
      }
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
      for (let i = 0; i < this.tracks_.length; i++) {
        this.tracks_[i].addAllEventsMatchingFilterToSelection(
            filter, selection);
      }
    },

    addAllEventsMatchingFilterToSelectionAsTask(filter, selection) {
      const task = new Task();
      for (let i = 0; i < this.tracks_.length; i++) {
        task.subTask(function(i) {
          return function() {
            this.tracks_[i].addAllEventsMatchingFilterToSelection(
                filter, selection);
          };
        }(i), this);
      }
      return task;
    },

    addClosestEventToSelection(
        worldX, worldMaxDist, loY, hiY, selection) {
      for (let i = 0; i < this.tracks_.length; i++) {
        const trackClientRect = this.tracks_[i].getBoundingClientRect();
        const a = Math.max(loY, trackClientRect.top);
        const b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b) {
          this.tracks_[i].addClosestEventToSelection(
              worldX, worldMaxDist, loY, hiY, selection);
        }
      }

      tr.ui.tracks.Track.prototype.addClosestEventToSelection.
          apply(this, arguments);
    },

    addContainersToTrackMap(containerToTrackMap) {
      this.tracks_.forEach(function(track) {
        track.addContainersToTrackMap(containerToTrackMap);
      });
    },

    clearTracks_() {
      this.tracks_.forEach(function(track) {
        Polymer.dom(this).removeChild(track);
      }, this);
    }
  };

  return {
    ContainerTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A point in a chart series with x (timestamp) and y (value) coordinates
   * and an associated model item. The point can optionally also have a base
   * y coordinate (which for example corresponds to the bottom edge of the
   * associated bar in a bar chart).
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function ChartPoint(modelItem, x, y, opt_yBase) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.x = x;
    this.y = y;
    this.dotLetter = undefined;

    // If the base y-coordinate is undefined, the bottom edge of the associated
    // bar in a bar chart will start at the outer bottom edge (which is most
    // likely slightly below zero).
    this.yBase = opt_yBase;
  }

  ChartPoint.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype,
  };

  return {
    ChartPoint,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;
  const EventPresenter = tr.ui.b.EventPresenter;
  const SelectionState = tr.model.SelectionState;

  /**
   * The type of a chart series.
   * @enum
   */
  const ChartSeriesType = {
    LINE: 0,
    AREA: 1
  };

  // The default rendering configuration for ChartSeries.
  const DEFAULT_RENDERING_CONFIG = {
    // The type of the chart series.
    chartType: ChartSeriesType.LINE,

    // The size of a selected point dot in device-independent pixels (circle
    // diameter).
    selectedPointSize: 4,

    // The size of an unselected point dot in device-independent pixels (square
    // width/height).
    unselectedPointSize: 3,

    // Whether the selected dots should be solid circles of the line color, or
    // filled with the background's selection color.
    solidSelectedDots: false,

    // The color of the chart.
    colorId: 0,

    // The width of the top line in device-independent pixels.
    lineWidth: 1,

    // Minimum distance between points in physical pixels. Points which are
    // closer than this distance will be skipped.
    skipDistance: 1,

    // Density in points per physical pixel at which unselected point dots
    // become transparent.
    unselectedPointDensityTransparent: 0.10,

    // Density in points per physical pixel at which unselected point dots
    // become fully opaque.
    unselectedPointDensityOpaque: 0.05,

    // Opacity of area chart background.
    backgroundOpacity: 0.5,

    // Whether to graph steps between points. Set to false for lines instead.
    stepGraph: true
  };

  // The virtual width of the last point in a series (whose rectangle has zero
  // width) in world timestamps difference for the purposes of selection.
  const LAST_POINT_WIDTH = 16;

  // Constants for sizing and font of points with dot letters.
  const DOT_LETTER_RADIUS_PX = 7;
  const DOT_LETTER_RADIUS_PADDING_PX = 0.5;
  const DOT_LETTER_SELECTED_OUTLINE_WIDTH_PX = 3;
  const DOT_LETTER_SELECTED_OUTLINE_DETAIL_WIDTH_PX = 1.5;
  const DOT_LETTER_UNSELECTED_OUTLINE_WIDTH_PX = 1;
  const DOT_LETTER_FONT_WEIGHT = 400;
  const DOT_LETTER_FONT_SIZE_PX = 9;
  const DOT_LETTER_FONT = 'Arial';

  /**
   * Visual components of a ChartSeries.
   * @enum
   */
  const ChartSeriesComponent = {
    BACKGROUND: 0,
    LINE: 1,
    DOTS: 2
  };

  /**
   * A series of points corresponding to a single chart on a chart track.
   * This class is responsible for drawing the actual chart onto canvas.
   *
   * @constructor
   */
  function ChartSeries(points, seriesYAxis, opt_renderingConfig) {
    this.points = points;
    this.seriesYAxis = seriesYAxis;

    this.useRenderingConfig_(opt_renderingConfig);
  }

  ChartSeries.prototype = {
    useRenderingConfig_(opt_renderingConfig) {
      const config = opt_renderingConfig || {};

      // Store all configuration flags as private properties.
      for (const [key, defaultValue] of
          Object.entries(DEFAULT_RENDERING_CONFIG)) {
        let value = config[key];
        if (value === undefined) {
          value = defaultValue;
        }
        this[key + '_'] = value;
      }

      // Avoid unnecessary recomputation in getters.
      this.topPadding = this.bottomPadding = Math.max(
          this.selectedPointSize_, this.unselectedPointSize_) / 2;
    },

    get range() {
      const range = new tr.b.math.Range();
      this.points.forEach(function(point) {
        range.addValue(point.y);
      }, this);
      return range;
    },

    draw(ctx, transform, highDetails) {
      if (this.points === undefined || this.points.length === 0) {
        return;
      }

      // Draw the background.
      if (this.chartType_ === ChartSeriesType.AREA) {
        this.drawComponent_(ctx, transform, ChartSeriesComponent.BACKGROUND,
            highDetails);
      }

      // Draw the line at the top.
      if (this.chartType_ === ChartSeriesType.LINE || highDetails) {
        this.drawComponent_(ctx, transform, ChartSeriesComponent.LINE,
            highDetails);
      }

      // Draw the points.
      this.drawComponent_(ctx, transform, ChartSeriesComponent.DOTS,
          highDetails);
    },

    drawComponent_(ctx, transform, component, highDetails) {
      // We need to consider extra pixels outside the visible area to avoid
      // visual glitches due to non-zero width of dots.
      let extraPixels = 0;
      if (component === ChartSeriesComponent.DOTS) {
        extraPixels = Math.max(
            this.selectedPointSize_, this.unselectedPointSize_);
      }
      const pixelRatio = transform.pixelRatio;
      const leftViewX = transform.leftViewX - extraPixels * pixelRatio;
      const rightViewX = transform.rightViewX + extraPixels * pixelRatio;
      const leftTimestamp = transform.leftTimestamp - extraPixels;
      const rightTimestamp = transform.rightTimestamp + extraPixels;

      // Find the index of the first and last (partially) visible points.
      const firstVisibleIndex = tr.b.findLowIndexInSortedArray(
          this.points,
          function(point) { return point.x; },
          leftTimestamp);
      let lastVisibleIndex = tr.b.findLowIndexInSortedArray(
          this.points,
          function(point) { return point.x; },
          rightTimestamp);
      if (lastVisibleIndex >= this.points.length ||
          this.points[lastVisibleIndex].x > rightTimestamp) {
        lastVisibleIndex--;
      }

      // Pre-calculate component style which does not depend on individual
      // points:
      //   * Skip distance between points,
      //   * Selected (circle) and unselected (square) dot size,
      //   * Unselected dot opacity,
      //   * Selected dot edge color and width, and
      //   * Line component color and width.
      const viewSkipDistance = this.skipDistance_ * pixelRatio;
      let selectedCircleRadius;
      let letterDotRadius;
      let squareSize;
      let squareHalfSize;
      let squareOpacity;
      let unselectedSeriesColor;
      let currentStateSeriesColor;

      ctx.save();
      ctx.font =
          DOT_LETTER_FONT_WEIGHT + ' ' +
          Math.floor(DOT_LETTER_FONT_SIZE_PX * pixelRatio) + 'px ' +
          DOT_LETTER_FONT;
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';

      switch (component) {
        case ChartSeriesComponent.DOTS: {
          // Selected (circle) and unselected (square) dot size.
          selectedCircleRadius =
              (this.selectedPointSize_ / 2) * pixelRatio;
          letterDotRadius =
              Math.max(selectedCircleRadius, DOT_LETTER_RADIUS_PX * pixelRatio);
          squareSize = this.unselectedPointSize_ * pixelRatio;
          squareHalfSize = squareSize / 2;
          unselectedSeriesColor = EventPresenter.getCounterSeriesColor(
              this.colorId_, SelectionState.NONE);

          // Unselected dot opacity.
          if (!highDetails) {
            // Unselected dots are not displayed in 'low details' mode.
            squareOpacity = 0;
            break;
          }
          const visibleIndexRange = lastVisibleIndex - firstVisibleIndex;
          if (visibleIndexRange <= 0) {
            // There is at most one visible point.
            squareOpacity = 1;
            break;
          }
          const visibleViewXRange =
              transform.worldXToViewX(this.points[lastVisibleIndex].x) -
              transform.worldXToViewX(this.points[firstVisibleIndex].x);
          if (visibleViewXRange === 0) {
            // Multiple visible points which all have the same timestamp.
            squareOpacity = 1;
            break;
          }
          const density = visibleIndexRange / visibleViewXRange;
          const clampedDensity = tr.b.math.clamp(density,
              this.unselectedPointDensityOpaque_,
              this.unselectedPointDensityTransparent_);
          const densityRange = this.unselectedPointDensityTransparent_ -
              this.unselectedPointDensityOpaque_;
          squareOpacity =
              (this.unselectedPointDensityTransparent_ - clampedDensity) /
              densityRange;
          break;
        }

        case ChartSeriesComponent.LINE:
          // Line component color and width.
          ctx.strokeStyle = EventPresenter.getCounterSeriesColor(
              this.colorId_, SelectionState.NONE);
          ctx.lineWidth = this.lineWidth_ * pixelRatio;
          break;

        case ChartSeriesComponent.BACKGROUND:
          // Style depends on the selection state of individual points.
          break;

        default:
          throw new Error('Invalid component: ' + component);
      }

      // The main loop which draws the given component of visible points from
      // left to right. Given the potentially large number of points to draw,
      // it should be considered performance-critical and function calls should
      // be avoided when possible.
      //
      // Note that the background and line components are drawn in a delayed
      // fashion: the rectangle/line that we draw in an iteration corresponds
      // to the *previous* point. This does not apply to the dots, whose
      // position is independent of the surrounding dots.
      let previousViewX = undefined;
      let previousViewY = undefined;
      let previousViewYBase = undefined;
      let lastSelectionState = undefined;
      let baseSteps = undefined;
      const startIndex = Math.max(firstVisibleIndex - 1, 0);
      let currentViewX;

      for (let i = startIndex; i < this.points.length; i++) {
        const currentPoint = this.points[i];
        currentViewX = transform.worldXToViewX(currentPoint.x);

        // Stop drawing the points once we are to the right of the visible area.
        if (currentViewX > rightViewX) {
          if (previousViewX !== undefined) {
            previousViewX = currentViewX = rightViewX;
            if (component === ChartSeriesComponent.BACKGROUND ||
                component === ChartSeriesComponent.LINE) {
              ctx.lineTo(currentViewX, previousViewY);
            }
          }
          break;
        }

        if (i + 1 < this.points.length) {
          const nextPoint = this.points[i + 1];
          const nextViewX = transform.worldXToViewX(nextPoint.x);

          // Skip points that are too close to each other.
          if (previousViewX !== undefined &&
              nextViewX - previousViewX <= viewSkipDistance &&
              nextViewX < rightViewX) {
            continue;
          }

          // Start drawing right at the left side of the visible are (instead
          // of potentially very far to the left).
          if (currentViewX < leftViewX) {
            currentViewX = leftViewX;
          }
        }

        if (previousViewX !== undefined &&
            currentViewX - previousViewX < viewSkipDistance) {
          // We know that nextViewX > previousViewX + viewSkipDistance, so we
          // can safely move this points's x over that much without passing
          // nextViewX. This ensures that the previous point is visible when
          // zoomed out very far.
          currentViewX = previousViewX + viewSkipDistance;
        }

        const currentViewY = Math.round(transform.worldYToViewY(
            currentPoint.y));
        let currentViewYBase;
        if (currentPoint.yBase === undefined) {
          currentViewYBase = transform.outerBottomViewY;
        } else {
          currentViewYBase = Math.round(
              transform.worldYToViewY(currentPoint.yBase));
        }
        const currentSelectionState = currentPoint.selectionState;
        if (currentSelectionState !== lastSelectionState) {
          const opacity = currentSelectionState === SelectionState.SELECTED ?
              1 : squareOpacity;
          currentStateSeriesColor = EventPresenter.getCounterSeriesColor(
              this.colorId_, currentSelectionState, opacity);
        }

        // Actually draw the given component of the point.
        switch (component) {
          case ChartSeriesComponent.DOTS:
            // Draw the dot for the current point.
            if (currentPoint.dotLetter) {
              ctx.fillStyle = unselectedSeriesColor;
              ctx.strokeStyle =
                  ColorScheme.getColorForReservedNameAsString('black');
              ctx.beginPath();
              ctx.arc(currentViewX, currentViewY,
                  letterDotRadius + DOT_LETTER_RADIUS_PADDING_PX, 0,
                  2 * Math.PI);
              ctx.fill();
              if (currentSelectionState === SelectionState.SELECTED) {
                ctx.lineWidth = DOT_LETTER_SELECTED_OUTLINE_WIDTH_PX;
                ctx.strokeStyle =
                    ColorScheme.getColorForReservedNameAsString('olive');
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(currentViewX, currentViewY, letterDotRadius, 0,
                    2 * Math.PI);
                ctx.lineWidth = DOT_LETTER_SELECTED_OUTLINE_DETAIL_WIDTH_PX;
                ctx.strokeStyle =
                    ColorScheme.getColorForReservedNameAsString('yellow');
                ctx.stroke();
              } else {
                ctx.lineWidth = DOT_LETTER_UNSELECTED_OUTLINE_WIDTH_PX;
                ctx.strokeStyle =
                    ColorScheme.getColorForReservedNameAsString('black');
                ctx.stroke();
              }
              ctx.fillStyle =
                  ColorScheme.getColorForReservedNameAsString('white');
              ctx.fillText(currentPoint.dotLetter, currentViewX, currentViewY);
            } else {
              ctx.strokeStyle = unselectedSeriesColor;
              ctx.lineWidth = pixelRatio;
              if (currentSelectionState === SelectionState.SELECTED) {
                if (this.solidSelectedDots_) {
                  ctx.fillStyle = ctx.strokeStyle;
                } else {
                  ctx.fillStyle = currentStateSeriesColor;
                }

                ctx.beginPath();
                ctx.arc(currentViewX, currentViewY, selectedCircleRadius, 0,
                    2 * Math.PI);
                ctx.fill();
                ctx.stroke();
              } else if (squareOpacity > 0) {
                ctx.fillStyle = currentStateSeriesColor;
                ctx.fillRect(currentViewX - squareHalfSize,
                    currentViewY - squareHalfSize, squareSize, squareSize);
              }
            }
            break;

          case ChartSeriesComponent.LINE:
            // Draw the top line for the previous point (if applicable), or
            // prepare for drawing the top line of the current point in the next
            // iteration.
            if (previousViewX === undefined) {
              ctx.beginPath();
              ctx.moveTo(currentViewX, currentViewY);
            } else if (this.stepGraph_) {
              ctx.lineTo(currentViewX, previousViewY);
            }

            // Move to the current point coordinate.
            ctx.lineTo(currentViewX, currentViewY);
            break;

          case ChartSeriesComponent.BACKGROUND:
            // Draw the background for the previous point (if applicable).
            if (previousViewX !== undefined && this.stepGraph_) {
              ctx.lineTo(currentViewX, previousViewY);
            } else {
              ctx.lineTo(currentViewX, currentViewY);
            }

            // Finish the bottom part of the backgound polygon, change
            // background color and start a new polygon when the selection state
            // changes (and at the beginning).
            if (currentSelectionState !== lastSelectionState) {
              if (previousViewX !== undefined) {
                let previousBaseStepViewX = currentViewX;
                for (let j = baseSteps.length - 1; j >= 0; j--) {
                  const baseStep = baseSteps[j];
                  const baseStepViewX = baseStep.viewX;
                  const baseStepViewY = baseStep.viewY;
                  ctx.lineTo(previousBaseStepViewX, baseStepViewY);
                  ctx.lineTo(baseStepViewX, baseStepViewY);
                  previousBaseStepViewX = baseStepViewX;
                }
                ctx.closePath();
                ctx.fill();
              }
              ctx.beginPath();
              ctx.fillStyle = EventPresenter.getCounterSeriesColor(
                  this.colorId_, currentSelectionState,
                  this.backgroundOpacity_);
              ctx.moveTo(currentViewX, currentViewYBase);
              baseSteps = [];
            }

            if (currentViewYBase !== previousViewYBase ||
                currentSelectionState !== lastSelectionState) {
              baseSteps.push({viewX: currentViewX, viewY: currentViewYBase});
            }

            // Move to the current point coordinate.
            ctx.lineTo(currentViewX, currentViewY);
            break;

          default:
            throw new Error('Not reachable');
        }

        previousViewX = currentViewX;
        previousViewY = currentViewY;
        previousViewYBase = currentViewYBase;
        lastSelectionState = currentSelectionState;
      }

      // If we still have an open background or top line polygon (which is
      // always the case once we have started drawing due to the delayed fashion
      // of drawing), we must close it.
      if (previousViewX !== undefined) {
        switch (component) {
          case ChartSeriesComponent.DOTS:
            // All dots were drawn in the main loop.
            break;

          case ChartSeriesComponent.LINE:
            ctx.stroke();
            break;

          case ChartSeriesComponent.BACKGROUND: {
            let previousBaseStepViewX = currentViewX;
            for (let j = baseSteps.length - 1; j >= 0; j--) {
              const baseStep = baseSteps[j];
              const baseStepViewX = baseStep.viewX;
              const baseStepViewY = baseStep.viewY;
              ctx.lineTo(previousBaseStepViewX, baseStepViewY);
              ctx.lineTo(baseStepViewX, baseStepViewY);
              previousBaseStepViewX = baseStepViewX;
            }
            ctx.closePath();
            ctx.fill();
            break;
          }

          default:
            throw new Error('Not reachable');
        }
      }
      ctx.restore();
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      const points = this.points;

      function getPointWidth(point, i) {
        if (i === points.length - 1) {
          return LAST_POINT_WIDTH * viewPixWidthWorld;
        }
        const nextPoint = points[i + 1];
        return nextPoint.x - point.x;
      }

      function selectPoint(point) {
        point.addToSelection(selection);
      }

      tr.b.iterateOverIntersectingIntervals(
          this.points,
          function(point) { return point.x; },
          getPointWidth,
          loWX,
          hiWX,
          selectPoint);
    },

    addEventNearToProvidedEventToSelection(event, offset, selection) {
      if (this.points === undefined) return false;

      const index = this.points.findIndex(point => point.modelItem === event);
      if (index === -1) return false;

      const newIndex = index + offset;
      if (newIndex < 0 || newIndex >= this.points.length) return false;

      this.points[newIndex].addToSelection(selection);
      return true;
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      if (this.points === undefined) return;

      const item = tr.b.findClosestElementInSortedArray(
          this.points,
          function(point) { return point.x; },
          worldX,
          worldMaxDist);

      if (!item) return;

      item.addToSelection(selection);
    }
  };

  return {
    ChartSeries,
    ChartSeriesType,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;
  const IDEAL_MAJOR_MARK_HEIGHT_PX = 30;
  const AXIS_LABLE_MARGIN_PX = 10;
  const AXIS_LABLE_FONT_SIZE_PX = 9;
  const AXIS_LABLE_FONT = 'Arial';

  /**
   * A vertical axis for a (set of) chart series which maps an arbitrary range
   * of values [min, max] to the unit range [0, 1].
   *
   * @constructor
   */
  function ChartSeriesYAxis(opt_min, opt_max) {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.bounds = new tr.b.math.Range();
    if (opt_min !== undefined) this.bounds.addValue(opt_min);
    if (opt_max !== undefined) this.bounds.addValue(opt_max);
  }

  ChartSeriesYAxis.prototype = {
    get guid() {
      return this.guid_;
    },

    valueToUnitRange(value) {
      if (this.bounds.isEmpty) {
        throw new Error('Chart series y-axis bounds are empty');
      }
      const bounds = this.bounds;
      if (bounds.range === 0) return 0;
      return (value - bounds.min) / bounds.range;
    },

    unitRangeToValue(unitRange) {
      if (this.bounds.isEmpty) {
        throw new Error('Chart series y-axis bounds are empty');
      }
      return unitRange * this.bounds.range + this.bounds.min;
    },

    /**
     * Automatically set the y-axis bounds from the range of values of all
     * series in a list.
     *
     * See the description of autoSetFromRange for the optional configuration
     * argument flags.
     */
    autoSetFromSeries(series, opt_config) {
      const range = new tr.b.math.Range();
      series.forEach(function(s) {
        range.addRange(s.range);
      }, this);
      this.autoSetFromRange(range, opt_config);
    },

    /**
     * Automatically set the y-axis bound from a range of values.
     *
     * The following four flags, which affect the behavior of this method with
     * respect to already defined bounds, can be present in the optional
     * configuration (a flag is assumed to be false if it is not provided or if
     * the configuration is not provided):
     *
     *   - expandMin: allow decreasing the min bound (if range.min < this.min)
     *   - shrinkMin: allow increasing the min bound (if range.min > this.min)
     *   - expandMax: allow increasing the max bound (if range.max > this.max)
     *   - shrinkMax: allow decreasing the max bound (if range.max < this.max)
     *
     * This method will ensure that the resulting bounds are defined and valid
     * (i.e. min <= max) provided that they were valid or empty before and the
     * value range is non-empty and valid.
     *
     * Note that unless expanding/shrinking a bound is explicitly enabled in
     * the configuration, non-empty bounds will not be changed under any
     * circumstances.
     *
     * Observe that if no configuration is provided (or all flags are set to
     * false), this method will only modify the y-axis bounds if they are empty.
     */
    autoSetFromRange(range, opt_config) {
      if (range.isEmpty) return;

      const bounds = this.bounds;
      if (bounds.isEmpty) {
        bounds.addRange(range);
        return;
      }

      if (!opt_config) return;

      const useRangeMin = (opt_config.expandMin && range.min < bounds.min ||
                         opt_config.shrinkMin && range.min > bounds.min);
      const useRangeMax = (opt_config.expandMax && range.max > bounds.max ||
                         opt_config.shrinkMax && range.max < bounds.max);

      // Neither bound is modified.
      if (!useRangeMin && !useRangeMax) return;

      // Both bounds are modified. Assuming the range argument is a valid
      // range, no extra checks are necessary.
      if (useRangeMin && useRangeMax) {
        bounds.min = range.min;
        bounds.max = range.max;
        return;
      }

      // Only one bound is modified. We must ensure that it doesn't go
      // over/under the other (unmodified) bound.
      if (useRangeMin) {
        bounds.min = Math.min(range.min, bounds.max);
      } else {
        bounds.max = Math.max(range.max, bounds.min);
      }
    },


    majorMarkHeightWorld_(transform, pixelRatio) {
      const idealMajorMarkHeightPx = IDEAL_MAJOR_MARK_HEIGHT_PX * pixelRatio;
      const idealMajorMarkHeightWorld =
          transform.vectorToWorldDistance(idealMajorMarkHeightPx);

      return tr.b.math.preferredNumberLargerThanMin(idealMajorMarkHeightWorld);
    },

    draw(ctx, transform, showYAxisLabels, showYGridLines) {
      if (!showYAxisLabels && !showYGridLines) return;

      const pixelRatio = transform.pixelRatio;
      const viewTop = transform.outerTopViewY;
      const worldTop = transform.viewYToWorldY(viewTop);
      const viewBottom = transform.outerBottomViewY;
      const viewHeight = viewBottom - viewTop;
      const viewLeft = transform.leftViewX;
      const viewRight = transform.rightViewX;
      const labelLeft = transform.leftYLabel;

      ctx.save();
      ctx.lineWidth = pixelRatio;
      ctx.fillStyle = ColorScheme.getColorForReservedNameAsString('black');
      ctx.textAlign = 'left';
      ctx.textBaseline = 'center';

      ctx.font =
          (AXIS_LABLE_FONT_SIZE_PX * pixelRatio) + 'px ' + AXIS_LABLE_FONT;

      // Draw left edge of chart series.
      ctx.beginPath();
      ctx.strokeStyle = ColorScheme.getColorForReservedNameAsString('black');
      tr.ui.b.drawLine(
          ctx, viewLeft, viewTop, viewLeft, viewBottom, viewLeft);
      ctx.stroke();
      ctx.closePath();

      // Draw y-axis ticks and gridlines.
      ctx.beginPath();
      ctx.strokeStyle = ColorScheme.getColorForReservedNameAsString('grey');

      const majorMarkHeight = this.majorMarkHeightWorld_(transform, pixelRatio);
      const maxMajorMark = Math.max(transform.viewYToWorldY(viewTop),
          Math.abs(transform.viewYToWorldY(viewBottom)));
      for (let curWorldY = 0;
          curWorldY <= maxMajorMark;
          curWorldY += majorMarkHeight) {
        const roundedUnitValue = Math.floor(curWorldY * 1000000) / 1000000;
        const curViewYPositive = transform.worldYToViewY(curWorldY);
        if (curViewYPositive >= viewTop) {
          if (showYAxisLabels) {
            ctx.fillText(roundedUnitValue, viewLeft + AXIS_LABLE_MARGIN_PX,
                curViewYPositive - AXIS_LABLE_MARGIN_PX);
          }
          if (showYGridLines) {
            tr.ui.b.drawLine(
                ctx, viewLeft, curViewYPositive, viewRight, curViewYPositive);
          }
        }

        const curViewYNegative = transform.worldYToViewY(-1 * curWorldY);
        if (curViewYNegative <= viewBottom) {
          if (showYAxisLabels) {
            ctx.fillText(roundedUnitValue, viewLeft + AXIS_LABLE_MARGIN_PX,
                curViewYNegative - AXIS_LABLE_MARGIN_PX);
          }
          if (showYGridLines) {
            tr.ui.b.drawLine(
                ctx, viewLeft, curViewYNegative, viewRight, curViewYNegative);
          }
        }
      }
      ctx.stroke();
      ctx.restore();
    }
  };

  return {
    ChartSeriesYAxis,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A helper object encapsulating all parameters necessary to draw a chart
   * series and provides conversion between world coordinates and physical
   * pixels.
   *
   * All parameters (except for pixelRatio) are assumed to be in physical pixels
   * (i.e. already pre-multiplied with pixelRatio).
   *
   * The diagram below explains the meaning of the resulting fields with
   * respect to a chart track:
   *
   *      outerTopViewY -> +--------------------/-\------+ <- Top padding
   *      innerTopViewY -> + - - - - - - - - - -| |- - - + <- Axis max
   *                       |  ..              ==\-/==    |
   *                       |  ===      Series       ===  |
   *                       |     ==/-\==              .. |
   *   innerBottomViewY -> + - - -Point- - - - - - - - - + <- Axis min
   *   outerBottomViewY -> +-------\-/-------------------+ <- Bottom padding
   *                       ^                             ^
   *                    leftViewX                    rightViewX
   *                  leftTimeStamp                rightTimestamp
   *
   * Labels starting with a lower case letter are the resulting fields of the
   * transform object. Labels starting with an upper case letter correspond
   * to the relevant chart track concepts.
   *
   * @constructor
   */
  function ChartTransform(displayTransform, axis, trackWidth,
      trackHeight, topPadding, bottomPadding, pixelRatio) {
    this.pixelRatio = pixelRatio;

    // X axis.
    this.leftViewX = 0;
    this.rightViewX = trackWidth;
    this.leftTimestamp = displayTransform.xViewToWorld(this.leftViewX);
    this.rightTimestamp = displayTransform.xViewToWorld(this.rightViewX);

    this.displayTransform_ = displayTransform;

    // Y axis.
    this.outerTopViewY = 0;
    this.innerTopViewY = topPadding;
    this.innerBottomViewY = trackHeight - bottomPadding;
    this.outerBottomViewY = trackHeight;

    this.axis_ = axis;
    this.innerHeight_ = this.innerBottomViewY - this.innerTopViewY;
  }

  ChartTransform.prototype = {
    worldXToViewX(worldX) {
      return this.displayTransform_.xWorldToView(worldX);
    },

    viewXToWorldX(viewX) {
      return this.displayTransform_.xViewToWorld(viewX);
    },

    vectorToWorldDistance(viewY) {
      return this.axis_.bounds.range * Math.abs(viewY / this.innerHeight_);
    },

    viewYToWorldY(viewY) {
      return this.axis_.unitRangeToValue(
          1 - (viewY - this.innerTopViewY) / this.innerHeight_);
    },

    worldYToViewY(worldY) {
      const innerHeightCoefficient = 1 - this.axis_.valueToUnitRange(worldY);
      return innerHeightCoefficient * this.innerHeight_ + this.innerTopViewY;
    }
  };

  return {
    ChartTransform,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a chart.
   *
   * @constructor
   * @extends {Track}
   */
  const ChartTrack =
      tr.ui.b.define('chart-track', tr.ui.tracks.Track);

  ChartTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('chart-track');
      this.series_ = undefined;
      this.axes_ = undefined;

      // GUID -> {axis: ChartSeriesYAxis, series: [ChartSeries]}.
      this.axisGuidToAxisData_ = undefined;

      // The maximum top and bottom padding of all series.
      this.topPadding_ = undefined;
      this.bottomPadding_ = undefined;

      this.showYAxisLabels_ = undefined;
      this.showGridLines_ = undefined;

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get series() {
      return this.series_;
    },

    /**
     * Set the list of chart series to be displayed on this track. The list
     * is assumed to be sorted in increasing z-order (i.e. the last series in
     * the list will be drawn at the top).
     */
    set series(series) {
      this.series_ = series;
      this.calculateAxisDataAndPadding_();
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
      this.invalidateDrawingContainer();
    },

    get showYAxisLabels() {
      return this.showYAxisLabels_;
    },

    set showYAxisLabels(showYAxisLabels) {
      this.showYAxisLabels_ = showYAxisLabels;
      this.invalidateDrawingContainer();
    },

    get showGridLines() {
      return this.showGridLines_;
    },

    set showGridLines(showGridLines) {
      this.showGridLines_ = showGridLines;
      this.invalidateDrawingContainer();
    },

    get hasVisibleContent() {
      return !!this.series && this.series.length > 0;
    },

    calculateAxisDataAndPadding_() {
      if (!this.series_) {
        this.axes_ = undefined;
        this.axisGuidToAxisData_ = undefined;
        this.topPadding_ = undefined;
        this.bottomPadding_ = undefined;
        return;
      }

      const axisGuidToAxisData = {};
      let topPadding = 0;
      let bottomPadding = 0;

      this.series_.forEach(function(series) {
        const seriesYAxis = series.seriesYAxis;
        const axisGuid = seriesYAxis.guid;
        if (!(axisGuid in axisGuidToAxisData)) {
          axisGuidToAxisData[axisGuid] = {
            axis: seriesYAxis,
            series: []
          };
          if (!this.axes_) this.axes_ = [];
          this.axes_.push(seriesYAxis);
        }
        axisGuidToAxisData[axisGuid].series.push(series);
        topPadding = Math.max(topPadding, series.topPadding);
        bottomPadding = Math.max(bottomPadding, series.bottomPadding);
      }, this);

      this.axisGuidToAxisData_ = axisGuidToAxisData;
      this.topPadding_ = topPadding;
      this.bottomPadding_ = bottomPadding;
    },

    draw(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawChart_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawChart_(viewLWorld, viewRWorld) {
      if (!this.series_) return;

      const ctx = this.context();

      // Get track drawing parameters.
      const displayTransform = this.viewport.currentDisplayTransform;
      const pixelRatio = window.devicePixelRatio || 1;
      const bounds = this.getBoundingClientRect();
      const highDetails = this.viewport.highDetails;

      // Pre-multiply all device-independent pixel parameters with the pixel
      // ratio to avoid unnecessary recomputation in the performance-critical
      // drawing code.
      const width = bounds.width * pixelRatio;
      const height = bounds.height * pixelRatio;
      const topPadding = this.topPadding_ * pixelRatio;
      const bottomPadding = this.bottomPadding_ * pixelRatio;

      // Set up clipping.
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, width, height);
      ctx.clip();

      // TODO(aiolos): Add support for secondary y-axis on right side of chart.
      // https://github.com/catapult-project/catapult/issues/3008
      // Draw y-axis grid lines.
      if (this.axes_) {
        if ((this.showGridLines_ || this.showYAxisLabels_) &&
            this.axes_.length > 1) {
          throw new Error('Only one axis allowed when showing grid lines.');
        }
        for (const yAxis of this.axes_) {
          const chartTransform = new tr.ui.tracks.ChartTransform(
              displayTransform, yAxis, width, height,
              topPadding, bottomPadding, pixelRatio);
          yAxis.draw(
              ctx, chartTransform, this.showYAxisLabels_, this.showGridLines_);
        }
      }

      // Draw all series in the increasing z-order.
      for (const series of this.series) {
        const chartTransform = new tr.ui.tracks.ChartTransform(
            displayTransform, series.seriesYAxis, width, height, topPadding,
            bottomPadding, pixelRatio);
        series.draw(ctx, chartTransform, highDetails);
      }

      // Stop clipping.
      ctx.restore();
    },

    addEventsToTrackMap(eventToTrackMap) {
      // TODO(petrcermak): Consider adding the series to the track map instead
      // of the track (a potential performance optimization).
      this.series_.forEach(function(series) {
        series.points.forEach(function(point) {
          point.addToTrackMap(eventToTrackMap, this);
        }, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      this.series_.forEach(function(series) {
        series.addIntersectingEventsInRangeToSelectionInWorldSpace(
            loWX, hiWX, viewPixWidthWorld, selection);
      }, this);
    },

    addEventNearToProvidedEventToSelection(event, offset, selection) {
      let foundItem = false;
      this.series_.forEach(function(series) {
        foundItem = foundItem || series.addEventNearToProvidedEventToSelection(
            event, offset, selection);
      }, this);
      return foundItem;
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
      // Do nothing.
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      this.series_.forEach(function(series) {
        series.addClosestEventToSelection(
            worldX, worldMaxDist, loY, hiY, selection);
      }, this);
    },

    /**
     * Automatically set the bounds of all axes on this track from the range of
     * values of all series (in this track) associated with each of them.
     *
     * See the description of ChartSeriesYAxis.autoSetFromRange for the optional
     * configuration argument flags.
     */
    autoSetAllAxes(opt_config) {
      for (const axisData of Object.values(this.axisGuidToAxisData_)) {
        const seriesYAxis = axisData.axis;
        const series = axisData.series;
        seriesYAxis.autoSetFromSeries(series, opt_config);
      }
    },

    /**
     * Automatically set the bounds of the provided axis from the range of
     * values of all series (in this track) associated with it.
     *
     * See the description of ChartSeriesYAxis.autoSetFromRange for the optional
     * configuration argument flags.
     */
    autoSetAxis(seriesYAxis, opt_config) {
      const series = this.axisGuidToAxisData_[seriesYAxis.guid].series;
      seriesYAxis.autoSetFromSeries(series, opt_config);
    }
  };

  return {
    ChartTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;
  const ChartTrack = tr.ui.tracks.ChartTrack;

  /**
   * A track that displays the cpu usage of a process.
   *
   * @constructor
   * @extends {tr.ui.tracks.ChartTrack}
   */
  const CpuUsageTrack = tr.ui.b.define('cpu-usage-track', ChartTrack);

  CpuUsageTrack.prototype = {
    __proto__: ChartTrack.prototype,

    decorate(viewport) {
      ChartTrack.prototype.decorate.call(this, viewport);
      this.classList.add('cpu-usage-track');
      this.heading = 'CPU usage';
      this.cpuUsageSeries_ = undefined;
    },

    // Given a tr.Model, it creates a cpu usage series and a graph.
    initialize(model) {
      if (model !== undefined) {
        this.cpuUsageSeries_ = model.device.cpuUsageSeries;
      } else {
        this.cpuUsageSeries_ = undefined;
      }
      this.series = this.buildChartSeries_();
      this.autoSetAllAxes({expandMax: true});
    },

    get hasVisibleContent() {
      return !!this.cpuUsageSeries_ &&
          this.cpuUsageSeries_.samples.length > 0;
    },

    addContainersToTrackMap(containerToTrackMap) {
      containerToTrackMap.addContainer(this.series_, this);
    },

    buildChartSeries_(yAxis, color) {
      if (!this.hasVisibleContent) return [];

      yAxis = new tr.ui.tracks.ChartSeriesYAxis(0, undefined);
      const usageSamples = this.cpuUsageSeries_.samples;
      const pts = new Array(usageSamples.length + 1);
      for (let i = 0; i < usageSamples.length; i++) {
        pts[i] = new tr.ui.tracks.ChartPoint(undefined,
            usageSamples[i].start, usageSamples[i].usage);
      }
      pts[usageSamples.length] = new tr.ui.tracks.ChartPoint(undefined,
          usageSamples[usageSamples.length - 1].start, 0);
      const renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: color
      };

      return [new tr.ui.tracks.ChartSeries(pts, yAxis, renderingConfig)];
    },
  };

  return {
    CpuUsageTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;
  const ChartTrack = tr.ui.tracks.ChartTrack;

  /**
   * A track that displays a PowerSeries.
   *
   * @constructor
   * @extends {ChartTrack}
   */
  const PowerSeriesTrack = tr.ui.b.define('power-series-track', ChartTrack);

  PowerSeriesTrack.prototype = {
    __proto__: ChartTrack.prototype,

    decorate(viewport) {
      ChartTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('power-series-track');
      this.heading = 'Power';
      this.powerSeries_ = undefined;
    },

    set powerSeries(powerSeries) {
      this.powerSeries_ = powerSeries;

      this.series = this.buildChartSeries_();
      this.autoSetAllAxes({expandMax: true});
    },

    get hasVisibleContent() {
      return (this.powerSeries_ && this.powerSeries_.samples.length > 0);
    },

    addContainersToTrackMap(containerToTrackMap) {
      containerToTrackMap.addContainer(this.powerSeries_, this);
    },

    buildChartSeries_() {
      if (!this.hasVisibleContent) return [];

      const seriesYAxis = new tr.ui.tracks.ChartSeriesYAxis(0, undefined);
      const pts = this.powerSeries_.samples.map(function(smpl) {
        return new tr.ui.tracks.ChartPoint(smpl, smpl.start, smpl.powerInW);
      });
      const renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: ColorScheme.getColorIdForGeneralPurposeString(this.heading)
      };

      return [new tr.ui.tracks.ChartSeries(pts, seriesYAxis, renderingConfig)];
    }
  };

  return {
    PowerSeriesTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track used to provide whitespace between the tracks above and below it.
   *
   * @constructor
   * @extends {tr.ui.tracks.Track}
   */
  const SpacingTrack = tr.ui.b.define('spacing-track', tr.ui.tracks.Track);

  SpacingTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('spacing-track');

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
    }
  };

  return {
    SpacingTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ContainerTrack = tr.ui.tracks.ContainerTrack;

  // TODO(charliea): Make this track collapsible.
  /**
   * Track to visualize the device model.
   *
   * @constructor
   * @extends {ContainerTrack}
   */
  const DeviceTrack = tr.ui.b.define('device-track', ContainerTrack);

  DeviceTrack.prototype = {

    __proto__: ContainerTrack.prototype,

    decorate(viewport) {
      ContainerTrack.prototype.decorate.call(this, viewport);

      Polymer.dom(this).classList.add('device-track');
      this.device_ = undefined;
      this.powerSeriesTrack_ = undefined;
    },

    get device() {
      return this.device_;
    },

    set device(device) {
      this.device_ = device;
      this.updateContents_();
    },

    get powerSeriesTrack() {
      return this.powerSeriesTrack_;
    },

    get hasVisibleContent() {
      return (this.powerSeriesTrack_ &&
          this.powerSeriesTrack_.hasVisibleContent);
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.ContainerTrack.prototype.addContainersToTrackMap.call(
          this, containerToTrackMap);
      containerToTrackMap.addContainer(this.device, this);
    },

    addEventsToTrackMap(eventToTrackMap) {
      this.tracks_.forEach(function(track) {
        track.addEventsToTrackMap(eventToTrackMap);
      });
    },

    appendPowerSeriesTrack_() {
      this.powerSeriesTrack_ = new tr.ui.tracks.PowerSeriesTrack(this.viewport);
      this.powerSeriesTrack_.powerSeries = this.device.powerSeries;

      if (this.powerSeriesTrack_.hasVisibleContent) {
        Polymer.dom(this).appendChild(this.powerSeriesTrack_);
        Polymer.dom(this).appendChild(
            new tr.ui.tracks.SpacingTrack(this.viewport));
      }
    },

    updateContents_() {
      this.clearTracks_();
      this.appendPowerSeriesTrack_();
    }
  };

  return {
    DeviceTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;

  const DISPLAYED_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;
  const BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
  const LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
  const DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;

  const SYSTEM_MEMORY_CHART_RENDERING_CONFIG = {
    chartType: tr.ui.tracks.ChartSeriesType.AREA,
    colorId: ColorScheme.getColorIdForGeneralPurposeString('systemMemory'),
    backgroundOpacity: 0.8
  };
  const SYSTEM_MEMORY_SERIES_NAMES = ['Used (KB)', 'Swapped (KB)'];

  /** Extract PSS values of processes in a global memory dump. */
  function extractGlobalMemoryDumpUsedSizes(globalMemoryDump, addSize) {
    for (const [pid, pmd] of
        Object.entries(globalMemoryDump.processMemoryDumps)) {
      const mostRecentVmRegions = pmd.mostRecentVmRegions;
      if (mostRecentVmRegions === undefined) continue;
      addSize(pid, mostRecentVmRegions.byteStats.proportionalResident || 0,
          pmd.process.userFriendlyName);
    }
  }

  /** Extract sizes of root allocators in a process memory dump. */
  function extractProcessMemoryDumpAllocatorSizes(processMemoryDump, addSize) {
    const allocatorDumps = processMemoryDump.memoryAllocatorDumps;
    if (allocatorDumps === undefined) return;

    allocatorDumps.forEach(function(allocatorDump) {
      // Don't show tracing overhead in the charts.
      // TODO(petrcermak): Find a less hacky way to do this.
      if (allocatorDump.fullName === 'tracing') return;

      const allocatorSize = allocatorDump.numerics[DISPLAYED_SIZE_NUMERIC_NAME];
      if (allocatorSize === undefined) return;

      const allocatorSizeValue = allocatorSize.value;
      if (allocatorSizeValue === undefined) return;

      addSize(allocatorDump.fullName, allocatorSizeValue);
    });
  }

  /** Extract sizes of root allocators in a global memory dump. */
  function extractGlobalMemoryDumpAllocatorSizes(globalMemoryDump, addSize) {
    for (const pmd of Object.values(globalMemoryDump.processMemoryDumps)) {
      extractProcessMemoryDumpAllocatorSizes(pmd, addSize);
    }
  }

  /**
   * A generic function which converts a list of memory dumps to a list of
   * chart series.
   *
   * @param {!Array<!tr.model.ContainerMemoryDump>} memoryDumps List of
   *     container memory dumps.
   * @param {!function(
   *     !tr.model.ContainerMemoryDump,
   *     !function(string, number, string=))} dumpSizeExtractor Callback for
   *     extracting sizes from a container memory dump.
   * @return {(!Array<!tr.ui.tracks.ChartSeries>|undefined)} List of chart
   *     series (or undefined if no size is extracted from any container memory
   *     dump).
   */
  function buildMemoryChartSeries(memoryDumps, dumpSizeExtractor) {
    const dumpCount = memoryDumps.length;
    const idToTimestampToPoint = {};
    const idToName = {};

    // Extract the sizes of all components from each memory dump.
    memoryDumps.forEach(function(dump, index) {
      dumpSizeExtractor(dump, function addSize(id, size, opt_name) {
        let timestampToPoint = idToTimestampToPoint[id];
        if (timestampToPoint === undefined) {
          idToTimestampToPoint[id] = timestampToPoint = new Array(dumpCount);
          for (let i = 0; i < dumpCount; i++) {
            const modelItem = memoryDumps[i];
            timestampToPoint[i] = new tr.ui.tracks.ChartPoint(
                modelItem, modelItem.start, 0);
          }
        }
        timestampToPoint[index].y += size;
        if (opt_name !== undefined) idToName[id] = opt_name;
      });
    });

    // Do not generate any chart series if no sizes were extracted.
    const ids = Object.keys(idToTimestampToPoint);
    if (ids.length === 0) return undefined;

    ids.sort();
    for (let i = 0; i < dumpCount; i++) {
      let baseSize = 0;
      // Traverse |ids| in reverse (alphabetical) order so that the first id is
      // at the top of the chart.
      for (let j = ids.length - 1; j >= 0; j--) {
        const point = idToTimestampToPoint[ids[j]][i];
        point.yBase = baseSize;
        point.y += baseSize;
        baseSize = point.y;
      }
    }

    // Create one common axis for all memory chart series.
    const seriesYAxis = new tr.ui.tracks.ChartSeriesYAxis(0);

    // Build a chart series for each id.
    const series = ids.map(function(id) {
      const colorId = ColorScheme.getColorIdForGeneralPurposeString(
          idToName[id] || id);
      const renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId,
        backgroundOpacity: 0.8
      };
      return new tr.ui.tracks.ChartSeries(idToTimestampToPoint[id],
          seriesYAxis, renderingConfig);
    });

    // Ensure that the series at the top of the chart are drawn last.
    series.reverse();

    return series;
  }

  /**
   * Transform a list of memory dumps to a list of letter dots (with letter 'M'
   * inside).
   */
  function buildMemoryLetterDots(memoryDumps) {
    const backgroundMemoryColorId =
        ColorScheme.getColorIdForReservedName('background_memory_dump');
    const lightMemoryColorId =
        ColorScheme.getColorIdForReservedName('light_memory_dump');
    const detailedMemoryColorId =
        ColorScheme.getColorIdForReservedName('detailed_memory_dump');
    return memoryDumps.map(function(memoryDump) {
      let memoryColorId;
      switch (memoryDump.levelOfDetail) {
        case BACKGROUND:
          memoryColorId = backgroundMemoryColorId;
          break;
        case DETAILED:
          memoryColorId = detailedMemoryColorId;
          break;
        case LIGHT:
        default:
          memoryColorId = lightMemoryColorId;
      }
      return new tr.ui.tracks.LetterDot(
          memoryDump, 'M', memoryColorId, memoryDump.start);
    });
  }

  /**
   * Convert a list of global memory dumps to a list of chart series (one per
   * process). Each series represents the evolution of the memory used by the
   * process over time.
   */
  function buildGlobalUsedMemoryChartSeries(globalMemoryDumps) {
    return buildMemoryChartSeries(globalMemoryDumps,
        extractGlobalMemoryDumpUsedSizes);
  }

  /**
   * Convert a list of process memory dumps to a list of chart series (one per
   * root allocator). Each series represents the evolution of the size of a the
   * corresponding root allocator (e.g. 'v8') over time.
   */
  function buildProcessAllocatedMemoryChartSeries(processMemoryDumps) {
    return buildMemoryChartSeries(processMemoryDumps,
        extractProcessMemoryDumpAllocatorSizes);
  }

  /**
   * Convert a list of global memory dumps to a list of chart series (one per
   * root allocator). Each series represents the evolution of the size of a the
   * corresponding root allocator (e.g. 'v8') over time.
   */
  function buildGlobalAllocatedMemoryChartSeries(globalMemoryDumps) {
    return buildMemoryChartSeries(globalMemoryDumps,
        extractGlobalMemoryDumpAllocatorSizes);
  }

  /**
   * Converts system memory counters in the model to a list of
   * {'name': trackName, 'series': ChartSeries}.
   */
  function buildSystemMemoryChartSeries(model) {
    if (model.kernel.counters === undefined) return;
    const memoryCounter = model.kernel.counters['global.SystemMemory'];
    if (memoryCounter === undefined) return;

    const tracks = [];
    for (const name of SYSTEM_MEMORY_SERIES_NAMES) {
      const series = memoryCounter.series.find(series => series.name === name);
      if (series === undefined || series.samples.length === 0) return;

      const chartPoints = [];
      const valueRange = new tr.b.math.Range();
      for (const sample of series.samples) {
        chartPoints.push(new tr.ui.tracks.ChartPoint(
                         sample, sample.timestamp, sample.value, 0));
        valueRange.addValue(sample.value);
      }
      // Stretch min to max range over the top half of a chart for readability.
      const baseLine = Math.max(0, valueRange.min - valueRange.range);
      const axisY = new tr.ui.tracks.ChartSeriesYAxis(baseLine, valueRange.max);
      const chartSeries =
          [new tr.ui.tracks.ChartSeries(chartPoints, axisY,
                                        SYSTEM_MEMORY_CHART_RENDERING_CONFIG)];
      tracks.push({
        name: 'System Memory ' + name,
        series: chartSeries
      });
    }
    return tracks;
  }

  return {
    buildMemoryLetterDots,
    buildGlobalUsedMemoryChartSeries,
    buildProcessAllocatedMemoryChartSeries,
    buildGlobalAllocatedMemoryChartSeries,
    buildSystemMemoryChartSeries,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const USED_MEMORY_TRACK_HEIGHT = 50;
  const ALLOCATED_MEMORY_TRACK_HEIGHT = 50;

  /**
   * A track that displays an array of GlobalMemoryDump objects.
   * @constructor
   * @extends {ContainerTrack}
   */
  const GlobalMemoryDumpTrack = tr.ui.b.define(
      'global-memory-dump-track', tr.ui.tracks.ContainerTrack);

  GlobalMemoryDumpTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;
      this.updateContents_();
    },

    updateContents_() {
      this.clearTracks_();

      // Show no tracks if there are no dumps.
      if (!this.memoryDumps_ || !this.memoryDumps_.length) return;

      this.appendDumpDotsTrack_();
      this.appendUsedMemoryTrack_();
      this.appendAllocatedMemoryTrack_();
    },

    appendDumpDotsTrack_() {
      const items = tr.ui.tracks.buildMemoryLetterDots(this.memoryDumps_);
      if (!items) return;

      const track = new tr.ui.tracks.LetterDotTrack(this.viewport);
      track.heading = 'Memory Dumps';
      track.items = items;
      Polymer.dom(this).appendChild(track);
    },

    appendUsedMemoryTrack_() {
      const tracks = [];
      const perProcessSeries =
          tr.ui.tracks.buildGlobalUsedMemoryChartSeries(this.memoryDumps_);
      if (perProcessSeries !== undefined) {
        tracks.push({name: 'Memory per process', series: perProcessSeries});
      } else {
        tracks.push.apply(tracks, tr.ui.tracks.buildSystemMemoryChartSeries(
            this.memoryDumps_[0].model));
      }

      for (const {name, series} of tracks) {
        const track = new tr.ui.tracks.ChartTrack(this.viewport);
        track.heading = name;
        track.height = USED_MEMORY_TRACK_HEIGHT + 'px';
        track.series = series;
        track.autoSetAllAxes({expandMax: true});
        Polymer.dom(this).appendChild(track);
      }
    },

    appendAllocatedMemoryTrack_() {
      const series = tr.ui.tracks.buildGlobalAllocatedMemoryChartSeries(
          this.memoryDumps_);
      if (!series) return;

      const track = new tr.ui.tracks.ChartTrack(this.viewport);
      track.heading = 'Memory per component';
      track.height = ALLOCATED_MEMORY_TRACK_HEIGHT + 'px';
      track.series = series;
      track.autoSetAllAxes({expandMax: true});
      Polymer.dom(this).appendChild(track);
    }
  };

  return {
    GlobalMemoryDumpTrack,
  };
});


'use strict';

/**
 * @fileoverview Provides a mechanism for drawing massive numbers of
 * colored rectangles into a canvas in an efficient manner, provided
 * they are drawn left to right with fixed y and height throughout.
 *
 * The basic idea used here is to fuse subpixel rectangles together so that
 * we never issue a canvas fillRect for them. It turns out Javascript can
 * do this quite efficiently, compared to asking Canvas2D to do the same.
 *
 * Rather than expending compute cycles trying to figure out an average
 * color for fused rectangles from css strings, you instead draw using
 * palettized colors. The fused rect color is chosen from the rectangle with
 * the higher alpha value, if equal the max palette index encountered.
 *
 * Make sure to flush the trackRenderer before finishing drawing in order
 * to commit any queued drawing operations.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * Creates a fast rect renderer with a specific set of culling rules
   * and color palette.
   *
   * Rectangles that are drawn will be clipped horizontally to the range
   * [xMin, xMax]; this is done because CanvasRenderingContext2D does not draw
   * rectangles with coordinates of very large magnitude correctly.
   *
   * @param {GraphicsContext2D} ctx Canvas2D drawing context.
   * @param {number} xMin Left border of the viewport (pre-transformation).
   * @param {number} xMax Right border of the viewport (pre-transformation).
   * @param {number} minRectSize Only rectangles with width < minRectSize are
   *    considered for merging.
   * @param {number} maxMergeDist Only rectangles that are at most this far
        apart are considered for merging.
   * @param {Array} palette The color palette for drawing. Palette slots
   *    should map to valid Canvas fillStyle strings.
   *
   * @constructor
   */
  function FastRectRenderer(
      ctx, xMin, xMax, minRectSize, maxMergeDist, palette) {
    this.ctx_ = ctx;
    this.xMin_ = xMin;
    this.xMax_ = xMax;
    this.minRectSize_ = minRectSize;
    this.maxMergeDist_ = maxMergeDist;
    this.palette_ = palette;
  }

  FastRectRenderer.prototype = {
    y_: 0,
    h_: 0,
    merging_: false,
    mergeStartX_: 0,
    mergeCurRight_: 0,
    mergedColorId_: 0,
    mergedAlpha_: 0,

    /**
     * Changes the y position and height for subsequent fillRect
     * calls. x and width are specified on the fillRect calls.
     */
    setYandH(y, h) {
      if (this.y_ === y &&
          this.h_ === h) {
        return;
      }
      this.flush();
      this.y_ = y;
      this.h_ = h;
    },

    /**
     * Fills rectangle at the specified location, if visible. If the
     * rectangle is subpixel, it will be merged with adjacent rectangles.
     * The drawing operation may not take effect until flush is called.
     * @param {number} colorId The color of this rectangle, as an index
     *     in the renderer's color palette.
     * @param {number} alpha The opacity of the rectangle as 0.0-1.0 number.
     */
    fillRect(x, w, colorId, alpha) {
      const r = x + w;
      if (w < this.minRectSize_) {
        if (r - this.mergeStartX_ > this.maxMergeDist_) {
          this.flush();
        }
        if (!this.merging_) {
          this.merging_ = true;
          this.mergeStartX_ = x;
          this.mergeCurRight_ = r;
          this.mergedColorId_ = colorId;
          this.mergedAlpha_ = alpha;
        } else {
          this.mergeCurRight_ = r;

          if (this.mergedAlpha_ < alpha ||
              (this.mergedAlpha_ === alpha && this.mergedColorId_ < colorId)) {
            this.mergedAlpha_ = alpha;
            this.mergedColorId_ = colorId;
          }
        }
      } else {
        if (this.merging_) {
          this.flush();
        }
        this.ctx_.fillStyle = this.palette_[colorId];
        this.ctx_.globalAlpha = alpha;
        const xLeft = Math.max(x, this.xMin_);
        const xRight = Math.min(r, this.xMax_);
        if (xLeft < xRight) {
          this.ctx_.fillRect(xLeft, this.y_, xRight - xLeft, this.h_);
        }
      }
    },

    /**
     * Commits any pending fillRect operations to the underlying graphics
     * context.
     */
    flush() {
      if (this.merging_) {
        this.ctx_.fillStyle = this.palette_[this.mergedColorId_];
        this.ctx_.globalAlpha = this.mergedAlpha_;
        const xLeft = Math.max(this.mergeStartX_, this.xMin_);
        const xRight = Math.min(this.mergeCurRight_, this.xMax_);
        if (xLeft < xRight) {
          this.ctx_.fillRect(xLeft, this.y_, xRight - xLeft, this.h_);
        }
        this.merging_ = false;
      }
    }
  };

  return {
    FastRectRenderer,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of Rect objects.
   * @constructor
   * @extends {Track}
   */
  const RectTrack = tr.ui.b.define(
      'rect-track', tr.ui.tracks.Track);

  RectTrack.prototype = {

    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('rect-track');
      this.asyncStyle_ = false;
      this.rects_ = null;

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    set selectionGenerator(generator) {
      this.heading_.selectionGenerator = generator;
    },

    set expanded(expanded) {
      this.heading_.expanded = !!expanded;
    },

    set arrowVisible(arrowVisible) {
      this.heading_.arrowVisible = !!arrowVisible;
    },

    get expanded() {
      return this.heading_.expanded;
    },

    get asyncStyle() {
      return this.asyncStyle_;
    },

    set asyncStyle(v) {
      this.asyncStyle_ = !!v;
    },

    get rects() {
      return this.rects_;
    },

    set rects(rects) {
      this.rects_ = rects || [];
      this.invalidateDrawingContainer();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
      this.invalidateDrawingContainer();
    },

    get hasVisibleContent() {
      return this.rects_.length > 0;
    },

    draw(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawRects_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawRects_(viewLWorld, viewRWorld) {
      const ctx = this.context();

      ctx.save();
      const bounds = this.getBoundingClientRect();
      tr.ui.b.drawSlices(
          ctx,
          this.viewport.currentDisplayTransform,
          viewLWorld,
          viewRWorld,
          bounds.height,
          this.rects_,
          this.asyncStyle_);
      ctx.restore();

      if (bounds.height <= 6) return;

      let fontSize;
      let yOffset;
      if (bounds.height < 15) {
        fontSize = 6;
        yOffset = 1.0;
      } else {
        fontSize = 10;
        yOffset = 2.5;
      }
      tr.ui.b.drawLabels(
          ctx,
          this.viewport.currentDisplayTransform,
          viewLWorld,
          viewRWorld,
          this.rects_,
          this.asyncStyle_,
          fontSize,
          yOffset);
    },

    addEventsToTrackMap(eventToTrackMap) {
      if (this.rects_ === undefined || this.rects_ === null) {
        return;
      }

      this.rects_.forEach(function(rect) {
        rect.addToTrackMap(eventToTrackMap, this);
      }, this);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onRect(rect) {
        rect.addToSelection(selection);
      }
      onRect = onRect.bind(this);
      const instantEventWidth = 2 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.rects_,
          function(x) { return x.start; },
          function(x) {
            return x.duration === 0 ?
              x.duration + instantEventWidth :
              x.duration;
          },
          loWX, hiWX,
          onRect);
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {rect} The current rect.
     * @param {Number} offset Number of rects away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection(event, offset, selection) {
      const index = this.rects_.findIndex(rect => rect.modelItem === event);
      if (index === -1) return false;

      const newIndex = index + offset;
      if (newIndex < 0 || newIndex >= this.rects_.length) return false;

      this.rects_[newIndex].addToSelection(selection);
      return true;
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
      for (let i = 0; i < this.rects_.length; ++i) {
        // TODO(petrcermak): Rather than unpacking the proxy item here,
        // we should probably add an addToSelectionIfMatching(selection, filter)
        // method to SelectableItem (#900).
        const modelItem = this.rects_[i].modelItem;
        if (!modelItem) continue;

        if (filter.matchSlice(modelItem)) {
          selection.push(modelItem);
        }
      }
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      const rect = tr.b.findClosestIntervalInSortedIntervals(
          this.rects_,
          function(x) { return x.start; },
          function(x) { return x.end; },
          worldX,
          worldMaxDist);

      if (!rect) return;

      rect.addToSelection(selection);
    }
  };

  /**
   * A filled rectangle with a title.
   *
   * @constructor
   * @extends {ProxySelectableItem}
   */
  function Rect(modelItem, title, colorId, start, duration) {
    tr.model.ProxySelectableItem.call(this, modelItem);
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.duration = duration;
    this.end = start + duration;
  }

  Rect.prototype = {
    __proto__: tr.model.ProxySelectableItem.prototype
  };

  return {
    RectTrack,
    Rect,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of Slice objects.
   * @constructor
   * @extends {RectTrack}
   */
  const SliceTrack = tr.ui.b.define(
      'slice-track', tr.ui.tracks.RectTrack);

  SliceTrack.prototype = {

    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get slices() {
      return this.rects;
    },

    set slices(slices) {
      this.rects = slices;
    }
  };

  return {
    SliceTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * Visualizes a Cpu using a series of SliceTracks.
   * @constructor
   */
  const CpuTrack =
      tr.ui.b.define('cpu-track', tr.ui.tracks.ContainerTrack);
  CpuTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('cpu-track');
      this.detailedMode_ = true;
    },

    get cpu() {
      return this.cpu_;
    },

    set cpu(cpu) {
      this.cpu_ = cpu;
      this.updateContents_();
    },

    get detailedMode() {
      return this.detailedMode_;
    },

    set detailedMode(detailedMode) {
      this.detailedMode_ = detailedMode;
      this.updateContents_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(value) {
      this.tooltip_ = value;
      this.updateContents_();
    },

    get hasVisibleContent() {
      if (this.cpu_ === undefined) return false;

      const cpu = this.cpu_;
      if (cpu.slices.length) return true;

      if (cpu.samples && cpu.samples.length) return true;

      if (Object.keys(cpu.counters).length > 0) return true;

      return false;
    },

    updateContents_() {
      this.detach();
      if (!this.cpu_) return;

      const slices = this.cpu_.slices;
      if (slices.length) {
        const track = new tr.ui.tracks.SliceTrack(this.viewport);
        track.slices = slices;
        track.heading = this.cpu_.userFriendlyName + ':';
        Polymer.dom(this).appendChild(track);
      }

      if (this.detailedMode_) {
        this.appendSamplesTracks_();

        for (const counterName in this.cpu_.counters) {
          const counter = this.cpu_.counters[counterName];
          const track = new tr.ui.tracks.CounterTrack(this.viewport);
          track.heading = this.cpu_.userFriendlyName + ' ' +
              counter.name + ':';
          track.counter = counter;
          Polymer.dom(this).appendChild(track);
        }
      }
    },

    appendSamplesTracks_() {
      const samples = this.cpu_.samples;
      if (samples === undefined || samples.length === 0) {
        return;
      }
      const samplesByTitle = {};
      samples.forEach(function(sample) {
        if (samplesByTitle[sample.title] === undefined) {
          samplesByTitle[sample.title] = [];
        }
        samplesByTitle[sample.title].push(sample);
      });

      const sampleTitles = Object.keys(samplesByTitle);
      sampleTitles.sort();

      sampleTitles.forEach(function(sampleTitle) {
        const samples = samplesByTitle[sampleTitle];
        const samplesTrack = new tr.ui.tracks.SliceTrack(this.viewport);
        samplesTrack.group = this.cpu_;
        samplesTrack.slices = samples;
        samplesTrack.heading = this.cpu_.userFriendlyName + ': ' +
            sampleTitle;
        samplesTrack.tooltip = this.cpu_.userFriendlyDetails;
        samplesTrack.selectionGenerator = function() {
          const selection = new tr.model.EventSet();
          for (let i = 0; i < samplesTrack.slices.length; i++) {
            selection.push(samplesTrack.slices[i]);
          }
          return selection;
        };
        Polymer.dom(this).appendChild(samplesTrack);
      }, this);
    }
  };

  return {
    CpuTrack,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const Settings = tr.b.Settings;

  /**
   * A way to persist settings specific to parts of a trace model.
   *
   * This object should not be persisted because it builds up internal data
   * structures that map model objects to settings keys. It should thus be
   * created for the duration of whatever interaction(s) you're going to do with
   * model settings, and then discarded.
   *
   * This system works on a notion of an object key: for an object's key, it
   * considers all the other keys in the model. If it is unique, then the key is
   * persisted to tr.b.Settings. However, if it is not unique, then the
   * setting is stored on the object itself. Thus, objects with unique keys will
   * be persisted across page reloads, whereas objects with nonunique keys will
   * not.
   */
  function ModelSettings(model) {
    this.model = model;
    this.objectsByKey_ = [];
    this.nonuniqueKeys_ = [];
    this.buildObjectsByKeyMap_();
    this.removeNonuniqueKeysFromSettings_();
    this.ephemeralSettingsByGUID_ = {};
  }

  ModelSettings.prototype = {
    buildObjectsByKeyMap_() {
      const objects = [];
      this.model.iterateAllPersistableObjects(function(o) {
        objects.push(o);
      });

      const objectsByKey = {};
      const NONUNIQUE_KEY = 'nonuniqueKey';
      for (let i = 0; i < objects.length; i++) {
        const object = objects[i];
        const objectKey = object.getSettingsKey();
        if (!objectKey) continue;
        if (objectsByKey[objectKey] === undefined) {
          objectsByKey[objectKey] = object;
          continue;
        }
        objectsByKey[objectKey] = NONUNIQUE_KEY;
      }

      const nonuniqueKeys = {};
      Object.keys(objectsByKey).forEach(function(objectKey) {
        if (objectsByKey[objectKey] !== NONUNIQUE_KEY) {
          return;
        }
        delete objectsByKey[objectKey];
        nonuniqueKeys[objectKey] = true;
      });

      this.nonuniqueKeys = nonuniqueKeys;
      this.objectsByKey_ = objectsByKey;
    },

    removeNonuniqueKeysFromSettings_() {
      const settings = Settings.get('trace_model_settings', {});
      let settingsChanged = false;
      Object.keys(settings).forEach(function(objectKey) {
        if (!this.nonuniqueKeys[objectKey]) {
          return;
        }
        settingsChanged = true;
        delete settings[objectKey];
      }, this);
      if (settingsChanged) {
        Settings.set('trace_model_settings', settings);
      }
    },

    hasUniqueSettingKey(object) {
      const objectKey = object.getSettingsKey();
      if (!objectKey) return false;
      return this.objectsByKey_[objectKey] !== undefined;
    },

    getSettingFor(object, objectLevelKey, defaultValue) {
      const objectKey = object.getSettingsKey();
      if (!objectKey || !this.objectsByKey_[objectKey]) {
        const settings = this.getEphemeralSettingsFor_(object);
        const ephemeralValue = settings[objectLevelKey];
        if (ephemeralValue !== undefined) {
          return ephemeralValue;
        }
        return defaultValue;
      }

      const settings = Settings.get('trace_model_settings', {});
      if (!settings[objectKey]) {
        settings[objectKey] = {};
      }
      const value = settings[objectKey][objectLevelKey];
      if (value !== undefined) {
        return value;
      }
      return defaultValue;
    },

    setSettingFor(object, objectLevelKey, value) {
      const objectKey = object.getSettingsKey();
      if (!objectKey || !this.objectsByKey_[objectKey]) {
        this.getEphemeralSettingsFor_(object)[objectLevelKey] = value;
        return;
      }

      const settings = Settings.get('trace_model_settings', {});
      if (!settings[objectKey]) {
        settings[objectKey] = {};
      }
      if (settings[objectKey][objectLevelKey] === value) {
        return;
      }
      settings[objectKey][objectLevelKey] = value;
      Settings.set('trace_model_settings', settings);
    },

    getEphemeralSettingsFor_(object) {
      if (object.guid === undefined) {
        throw new Error('Only objects with GUIDs can be persisted');
      }
      if (this.ephemeralSettingsByGUID_[object.guid] === undefined) {
        this.ephemeralSettingsByGUID_[object.guid] = {};
      }
      return this.ephemeralSettingsByGUID_[object.guid];
    }
  };

  return {
    ModelSettings,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a Counter object.
   * @constructor
   * @extends {ChartTrack}
   */
  const CounterTrack = tr.ui.b.define('counter-track', tr.ui.tracks.ChartTrack);

  CounterTrack.prototype = {
    __proto__: tr.ui.tracks.ChartTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ChartTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('counter-track');
    },

    get counter() {
      return this.chart;
    },

    set counter(counter) {
      this.heading = counter.name + ': ';
      this.series = CounterTrack.buildChartSeriesFromCounter(counter);
      this.autoSetAllAxes({expandMax: true});
    },

    getModelEventFromItem(chartValue) {
      return chartValue;
    }
  };

  CounterTrack.buildChartSeriesFromCounter = function(counter) {
    const numSeries = counter.series.length;
    const totals = counter.totals;

    // Create one common axis for all series.
    const seriesYAxis = new tr.ui.tracks.ChartSeriesYAxis(0, undefined);

    // Build one chart series for each counter series.
    const chartSeries = counter.series.map(function(series, seriesIndex) {
      const chartPoints = series.samples.map(function(sample, sampleIndex) {
        const total = totals[sampleIndex * numSeries + seriesIndex];
        return new tr.ui.tracks.ChartPoint(sample, sample.timestamp, total);
      });
      const renderingConfig = {
        chartType: tr.ui.tracks.ChartSeriesType.AREA,
        colorId: series.color
      };
      return new tr.ui.tracks.ChartSeries(
          chartPoints, seriesYAxis, renderingConfig);
    });

    // Show the first series (with the smallest cumulative value) at the top.
    chartSeries.reverse();

    return chartSeries;
  };

  return {
    CounterTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const startCompare = function(x, y) { return x.start - y.start; };

  /**
   * Track enabling quick selection of frame slices/events.
   * @constructor
   */
  const FrameTrack = tr.ui.b.define(
      'frame-track', tr.ui.tracks.LetterDotTrack);

  FrameTrack.prototype = {
    __proto__: tr.ui.tracks.LetterDotTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.LetterDotTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Frames';

      this.frames_ = undefined;
      this.items = undefined;
    },

    get frames() {
      return this.frames_;
    },

    set frames(frames) {
      this.frames_ = frames;
      if (frames === undefined) return;

      this.frames_ = this.frames_.slice();
      this.frames_.sort(startCompare);

      // letter dots
      this.items = this.frames_.map(function(frame) {
        return new FrameDot(frame);
      });
    }
  };

  /**
   * @constructor
   * @extends {LetterDot}
   */
  function FrameDot(frame) {
    tr.ui.tracks.LetterDot.call(this, frame, 'F', frame.colorId, frame.start);
  }

  FrameDot.prototype = {
    __proto__: tr.ui.tracks.LetterDot.prototype
  };

  return {
    FrameTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a group of objects in multiple rows.
   * @constructor
   * @extends {ContainerTrack}
   */
  const MultiRowTrack = tr.ui.b.define(
      'multi-row-track', tr.ui.tracks.ContainerTrack);

  MultiRowTrack.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.tooltip_ = '';
      this.heading_ = '';

      this.groupingSource_ = undefined;
      this.itemsToGroup_ = undefined;

      this.defaultToCollapsedWhenSubRowCountMoreThan = 1;

      this.itemsGroupedOnLastUpdateContents_ = undefined;

      this.currentSubRows_ = [];
      this.expanded_ = true;
    },

    get itemsToGroup() {
      return this.itemsToGroup_;
    },

    setItemsToGroup(itemsToGroup, opt_groupingSource) {
      this.itemsToGroup_ = itemsToGroup;
      this.groupingSource_ = opt_groupingSource;
      this.updateContents_();
      this.updateExpandedStateFromGroupingSource_();
    },

    get heading() {
      return this.heading_;
    },

    set heading(h) {
      this.heading_ = h;
      this.updateContents_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(t) {
      this.tooltip_ = t;
      this.updateContents_();
    },

    get subRows() {
      return this.currentSubRows_;
    },

    get hasVisibleContent() {
      return this.children.length > 0;
    },

    get expanded() {
      return this.expanded_;
    },

    set expanded(expanded) {
      if (this.expanded_ === expanded) return;

      this.expanded_ = expanded;
      this.expandedStateChanged_();
    },

    onHeadingClicked_(e) {
      if (this.subRows.length <= 1) return;

      this.expanded = !this.expanded;

      if (this.groupingSource_) {
        const modelSettings = new tr.model.ModelSettings(
            this.groupingSource_.model);
        modelSettings.setSettingFor(this.groupingSource_, 'expanded',
            this.expanded);
      }

      e.stopPropagation();
    },

    updateExpandedStateFromGroupingSource_() {
      if (this.groupingSource_) {
        const numSubRows = this.subRows.length;
        const modelSettings = new tr.model.ModelSettings(
            this.groupingSource_.model);
        if (numSubRows > 1) {
          let defaultExpanded;
          if (numSubRows > this.defaultToCollapsedWhenSubRowCountMoreThan) {
            defaultExpanded = false;
          } else {
            defaultExpanded = true;
          }
          this.expanded = modelSettings.getSettingFor(
              this.groupingSource_, 'expanded', defaultExpanded);
        } else {
          this.expanded = undefined;
        }
      }
    },

    expandedStateChanged_() {
      const minH = Math.max(2, Math.ceil(18 / this.children.length));
      const h = (this.expanded_ ? 18 : minH) + 'px';

      for (let i = 0; i < this.children.length; i++) {
        this.children[i].height = h;
        if (i === 0) {
          this.children[i].arrowVisible = true;
        }
        this.children[i].expanded = this.expanded;
      }

      if (this.children.length === 1) {
        this.children[0].expanded = true;
        this.children[0].arrowVisible = false;
      }
    },

    updateContents_() {
      tr.ui.tracks.ContainerTrack.prototype.updateContents_.call(this);
      if (!this.itemsToGroup_) {
        this.updateHeadingAndTooltip_();
        this.currentSubRows_ = [];
        return;
      }

      if (this.areArrayContentsSame_(this.itemsGroupedOnLastUpdateContents_,
          this.itemsToGroup_)) {
        this.updateHeadingAndTooltip_();
        return;
      }

      this.itemsGroupedOnLastUpdateContents_ = this.itemsToGroup_;

      this.detach();
      if (!this.itemsToGroup_.length) {
        this.currentSubRows_ = [];
        return;
      }
      const subRows = this.buildSubRows_(this.itemsToGroup_);
      this.currentSubRows_ = subRows;
      for (let srI = 0; srI < subRows.length; srI++) {
        const subRow = subRows[srI];
        if (!subRow.length) continue;

        const track = this.addSubTrack_(subRow);
        track.addEventListener(
            'heading-clicked', this.onHeadingClicked_.bind(this));
      }
      this.updateHeadingAndTooltip_();
      this.expandedStateChanged_();
    },

    updateHeadingAndTooltip_() {
      if (!Polymer.dom(this).firstChild) return;

      Polymer.dom(this).firstChild.heading = this.heading_;
      Polymer.dom(this).firstChild.tooltip = this.tooltip_;
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     */
    buildSubRows_(itemsToGroup) {
      throw new Error('Not implemented');
    },

    addSubTrack_(subRowItems) {
      throw new Error('Not implemented');
    },

    areArrayContentsSame_(a, b) {
      if (!a || !b) return false;

      if (!a.length || !b.length) return false;

      if (a.length !== b.length) return false;

      for (let i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
  };

  return {
    MultiRowTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const SelectionState = tr.model.SelectionState;
  const EventPresenter = tr.ui.b.EventPresenter;

  /**
   * A track that displays an array of Slice objects.
   * @constructor
   * @extends {Track}
   */
  const ObjectInstanceTrack = tr.ui.b.define(
      'object-instance-track', tr.ui.tracks.Track);

  ObjectInstanceTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('object-instance-track');
      this.objectInstances_ = [];
      this.objectSnapshots_ = [];

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    get objectInstances() {
      return this.objectInstances_;
    },

    set objectInstances(objectInstances) {
      if (!objectInstances || objectInstances.length === 0) {
        this.heading = '';
        this.objectInstances_ = [];
        this.objectSnapshots_ = [];
        return;
      }
      this.heading = objectInstances[0].baseTypeName;
      this.objectInstances_ = objectInstances;
      this.objectSnapshots_ = [];
      this.objectInstances_.forEach(function(instance) {
        this.objectSnapshots_.push.apply(
            this.objectSnapshots_, instance.snapshots);
      }, this);
      this.objectSnapshots_.sort(function(a, b) {
        return a.ts - b.ts;
      });
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    get snapshotRadiusView() {
      return 7 * (window.devicePixelRatio || 1);
    },

    draw(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawObjectInstances_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawObjectInstances_(viewLWorld, viewRWorld) {
      const ctx = this.context();
      const pixelRatio = window.devicePixelRatio || 1;

      const bounds = this.getBoundingClientRect();
      const height = bounds.height * pixelRatio;
      const halfHeight = height * 0.5;
      const twoPi = Math.PI * 2;

      // Culling parameters.
      const dt = this.viewport.currentDisplayTransform;
      const snapshotRadiusView = this.snapshotRadiusView;
      const snapshotRadiusWorld = dt.xViewVectorToWorld(height);

      // Instances
      const objectInstances = this.objectInstances_;
      let loI = tr.b.findLowIndexInSortedArray(
          objectInstances,
          function(instance) {
            return instance.deletionTs;
          },
          viewLWorld);
      ctx.save();
      ctx.strokeStyle = 'rgb(0,0,0)';
      for (let i = loI; i < objectInstances.length; ++i) {
        const instance = objectInstances[i];
        const x = instance.creationTs;
        if (x > viewRWorld) break;

        const right = instance.deletionTs === Number.MAX_VALUE ?
            viewRWorld : instance.deletionTs;
        const xView = dt.xWorldToView(x);
        const widthView = dt.xWorldVectorToView(right - x);
        ctx.fillStyle = EventPresenter.getObjectInstanceColor(instance);
        ctx.fillRect(xView, pixelRatio, widthView, height - 2 * pixelRatio);
      }
      ctx.restore();

      // Snapshots. Has to run in worldspace because ctx.arc gets transformed.
      const objectSnapshots = this.objectSnapshots_;
      loI = tr.b.findLowIndexInSortedArray(
          objectSnapshots,
          function(snapshot) {
            return snapshot.ts + snapshotRadiusWorld;
          },
          viewLWorld);
      for (let i = loI; i < objectSnapshots.length; ++i) {
        const snapshot = objectSnapshots[i];
        const x = snapshot.ts;
        if (x - snapshotRadiusWorld > viewRWorld) break;

        const xView = dt.xWorldToView(x);

        ctx.fillStyle = EventPresenter.getObjectSnapshotColor(snapshot);
        ctx.beginPath();
        ctx.arc(xView, halfHeight, snapshotRadiusView, 0, twoPi);
        ctx.fill();
        if (snapshot.selected) {
          ctx.lineWidth = 5;
          ctx.strokeStyle = 'rgb(100,100,0)';
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(xView, halfHeight, snapshotRadiusView - 1, 0, twoPi);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgb(255,255,0)';
          ctx.stroke();
        } else {
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgb(0,0,0)';
          ctx.stroke();
        }
      }
      ctx.lineWidth = 1;

      // For performance reasons we only check the SelectionState of the first
      // instance. If it's DIMMED we assume that all are DIMMED.
      // TODO(egraether): Allow partial highlight.
      let selectionState = SelectionState.NONE;
      if (objectInstances.length &&
          objectInstances[0].selectionState === SelectionState.DIMMED) {
        selectionState = SelectionState.DIMMED;
      }

      // Dim the track when there is an active highlight.
      if (selectionState === SelectionState.DIMMED) {
        const width = bounds.width * pixelRatio;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    },

    addEventsToTrackMap(eventToTrackMap) {
      if (this.objectInstance_ !== undefined) {
        this.objectInstance_.forEach(function(obj) {
          eventToTrackMap.addEvent(obj, this);
        }, this);
      }

      if (this.objectSnapshots_ !== undefined) {
        this.objectSnapshots_.forEach(function(obj) {
          eventToTrackMap.addEvent(obj, this);
        }, this);
      }
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      // Pick snapshots first.
      let foundSnapshot = false;
      function onSnapshot(snapshot) {
        selection.push(snapshot);
        foundSnapshot = true;
      }
      const snapshotRadiusView = this.snapshotRadiusView;
      const snapshotRadiusWorld = viewPixWidthWorld * snapshotRadiusView;
      tr.b.iterateOverIntersectingIntervals(
          this.objectSnapshots_,
          function(x) { return x.ts - snapshotRadiusWorld; },
          function(x) { return 2 * snapshotRadiusWorld; },
          loWX, hiWX,
          onSnapshot);
      if (foundSnapshot) return;

      // Try picking instances.
      tr.b.iterateOverIntersectingIntervals(
          this.objectInstances_,
          function(x) { return x.creationTs; },
          function(x) { return x.deletionTs - x.creationTs; },
          loWX, hiWX,
          (value) => { selection.push(value); });
    },

    /**
     * Add the item to the left or right of the provided event, if any, to the
     * selection.
     * @param {event} The current event item.
     * @param {Number} offset Number of slices away from the event to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection(event, offset, selection) {
      let events;
      if (event instanceof tr.model.ObjectSnapshot) {
        events = this.objectSnapshots_;
      } else if (event instanceof tr.model.ObjectInstance) {
        events = this.objectInstances_;
      } else {
        throw new Error('Unrecognized event');
      }

      const index = events.indexOf(event);
      const newIndex = index + offset;
      if (newIndex >= 0 && newIndex < events.length) {
        selection.push(events[newIndex]);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      const snapshot = tr.b.findClosestElementInSortedArray(
          this.objectSnapshots_,
          function(x) { return x.ts; },
          worldX,
          worldMaxDist);

      if (!snapshot) return;

      selection.push(snapshot);

      // TODO(egraether): Search for object instances as well, which was not
      // implemented because it makes little sense with the current visual and
      // needs to take care of overlapping intervals.
    }
  };


  const options = new tr.b.ExtensionRegistryOptions(
      tr.b.TYPE_BASED_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(ObjectInstanceTrack, options);

  return {
    ObjectInstanceTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a ObjectInstanceGroup.
   * @constructor
   * @extends {ContainerTrack}
   */
  const ObjectInstanceGroupTrack = tr.ui.b.define(
      'object-instance-group-track', tr.ui.tracks.MultiRowTrack);

  ObjectInstanceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('object-instance-group-track');
      this.objectInstances_ = undefined;
    },

    get objectInstances() {
      return this.itemsToGroup;
    },

    set objectInstances(objectInstances) {
      this.setItemsToGroup(objectInstances);
    },

    addSubTrack_(objectInstances) {
      const hasMultipleRows = this.subRows.length > 1;
      const track = new tr.ui.tracks.ObjectInstanceTrack(this.viewport);
      track.objectInstances = objectInstances;
      Polymer.dom(this).appendChild(track);
      return track;
    },

    buildSubRows_(objectInstances) {
      objectInstances.sort(function(x, y) {
        return x.creationTs - y.creationTs;
      });

      const subRows = [];
      for (let i = 0; i < objectInstances.length; i++) {
        const objectInstance = objectInstances[i];

        let found = false;
        for (let j = 0; j < subRows.length; j++) {
          const subRow = subRows[j];
          const lastItemInSubRow = subRow[subRow.length - 1];
          if (objectInstance.creationTs >= lastItemInSubRow.deletionTs) {
            found = true;
            subRow.push(objectInstance);
            break;
          }
        }
        if (!found) {
          subRows.push([objectInstance]);
        }
      }
      return subRows;
    },
    updateHeadingAndTooltip_() {
    }
  };

  return {
    ObjectInstanceGroupTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a AsyncSliceGroup.
   * @constructor
   * @extends {MultiRowTrack}
   */
  const AsyncSliceGroupTrack = tr.ui.b.define(
      'async-slice-group-track',
      tr.ui.tracks.MultiRowTrack);

  AsyncSliceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('async-slice-group-track');
      this.group_ = undefined;
    },

    addSubTrack_(slices) {
      const track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      Polymer.dom(this).appendChild(track);
      track.asyncStyle = true;
      return track;
    },

    get group() {
      return this.group_;
    },

    set group(group) {
      this.group_ = group;

      // Hide top-level slices that contain 1 sub-slice, which are used to group
      // the sub-slices into a single track, but provide no information
      // themselves.
      const slices = [];
      for (const slice of this.group_.slices) {
        if (slice.subSlices.length === 1 &&
            tr.b.math.approximately(slice.subSlices[0].start, slice.start, 1) &&
            tr.b.math.approximately(
                slice.subSlices[0].duration, slice.duration, 1)) {
          slices.push(slice.subSlices[0]);
        } else {
          slices.push(slice);
        }
      }

      this.setItemsToGroup(slices, this.group_);
    },

    get eventContainer() {
      return this.group;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.MultiRowTrack.prototype.addContainersToTrackMap.apply(
          this, arguments);
      containerToTrackMap.addContainer(this.group, this);
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     *
     * It uses a very simple approach: walk through the slices in sorted order
     * by start time. For each slice, try to fit it in an existing subRow. If
     * it doesn't fit in any subrow, make another subRow. It then fits nested
     * subSlices recursively into rows below parent slice according to which
     * nested level the child is in.
     */
    buildSubRows_(slices, opt_skipSort) {
      if (!opt_skipSort) {
        slices.sort(function(x, y) {
          return x.start - y.start;
        });
      }

      // Helper function that returns true if it can put the slice on row n.
      const findLevel = function(sliceToPut, rows, n) {
        if (n >= rows.length) {
          return true; // We always can make empty rows to put the slice.
        }
        const subRow = rows[n];
        const lastSliceInSubRow = subRow[subRow.length - 1];
        if (sliceToPut.start >= lastSliceInSubRow.end) {
          if (sliceToPut.subSlices === undefined ||
              sliceToPut.subSlices.length === 0) {
            return true;
          }
          // Make sure nested sub slices can be fitted in as well.
          for (const subSlice of sliceToPut.subSlices) {
            if (!findLevel(subSlice, rows, n + 1)) {
              return false;
            }
          }
          return true;
        }
        return false;
      };

      const subRows = [];
      for (const slice of slices) {
        let found = false;
        let index = subRows.length;
        for (let j = 0; j < subRows.length; j++) {
          if (findLevel(slice, subRows, j)) {
            found = true;
            index = j;
            break;
          }
        }
        if (!found) {
          subRows.push([]);
        }
        subRows[index].push(slice);

        // Fit subSlices recursively into rows below parent.
        const fitSubSlicesRecursively = function(subSlices, level, rows) {
          if (subSlices === undefined || subSlices.length === 0) {
            return;
          }
          if (level === rows.length) {
            rows.push([]);
          }
          for (const subSlice of subSlices) {
            rows[level].push(subSlice);
            fitSubSlicesRecursively(subSlice.subSlices, level + 1, rows);
          }
        };
        fitSubSlicesRecursively(slice.subSlices, index + 1, subRows);
      }
      return subRows;
    }
  };

  return {
    AsyncSliceGroupTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of Sample objects.
   * @constructor
   * @extends {RectTrack}
   */
  const SampleTrack = tr.ui.b.define(
      'sample-track', tr.ui.tracks.RectTrack);

  SampleTrack.prototype = {

    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get samples() {
      return this.rects;
    },

    set samples(samples) {
      this.rects = samples;
    }
  };

  return {
    SampleTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays a SliceGroup.
   * @constructor
   * @extends {MultiRowTrack}
   */
  const SliceGroupTrack = tr.ui.b.define(
      'slice-group-track', tr.ui.tracks.MultiRowTrack);

  SliceGroupTrack.prototype = {

    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('slice-group-track');
      this.group_ = undefined;
      // Set the collapse threshold so we don't collapse by default, but the
      // user can explicitly collapse if they want it.
      this.defaultToCollapsedWhenSubRowCountMoreThan = 100;
    },

    addSubTrack_(slices) {
      const track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      Polymer.dom(this).appendChild(track);
      return track;
    },

    get group() {
      return this.group_;
    },

    set group(group) {
      this.group_ = group;
      this.setItemsToGroup(this.group_.slices, this.group_);
    },

    get eventContainer() {
      return this.group;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.MultiRowTrack.prototype.addContainersToTrackMap.apply(
          this, arguments);
      containerToTrackMap.addContainer(this.group, this);
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     */
    buildSubRows_(slices) {
      const precisionUnit = this.group.model.intrinsicTimeUnit;

      // This function works by walking through slices by start time.
      //
      // The basic idea here is to insert each slice as deep into the subrow
      // list as it can go such that every subSlice is fully contained by its
      // parent slice.
      //
      // Visually, if we start with this:
      //  0:  [    a       ]
      //  1:    [  b  ]
      //  2:    [c][d]
      //
      // To place this slice:
      //               [e]
      // We first check row 2's last item, [d]. [e] wont fit into [d] (they dont
      // even intersect). So we go to row 1. That gives us [b], and [d] wont fit
      // into that either. So, we go to row 0 and its last slice, [a]. That can
      // completely contain [e], so that means we should add [e] as a subchild
      // of [a]. That puts it on row 1, yielding:
      //  0:  [    a       ]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      //
      // If we then get this slice:
      //                      [f]
      // We do the same deepest-to-shallowest walk of the subrows trying to fit
      // it. This time, it doesn't fit in any open slice. So, we simply append
      // it to row 0:
      //  0:  [    a       ]  [f]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      if (!slices.length) return [];

      const ops = [];
      for (let i = 0; i < slices.length; i++) {
        if (slices[i].subSlices) {
          slices[i].subSlices.splice(0,
              slices[i].subSlices.length);
        }
        ops.push(i);
      }

      ops.sort(function(ix, iy) {
        const x = slices[ix];
        const y = slices[iy];
        if (x.start !== y.start) return x.start - y.start;

        // Elements get inserted into the slices array in order of when the
        // slices start. Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier in
        // the slices array (and thus ending earlier) start earlier.
        return ix - iy;
      });

      const subRows = [[]];
      this.badSlices_ = [];  // TODO(simonjam): Connect this again.

      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const slice = slices[op];

        // Try to fit the slice into the existing subrows.
        let inserted = false;
        for (let j = subRows.length - 1; j >= 0; j--) {
          if (subRows[j].length === 0) continue;

          const insertedSlice = subRows[j][subRows[j].length - 1];
          if (slice.start < insertedSlice.start) {
            this.badSlices_.push(slice);
            inserted = true;
          }
          if (insertedSlice.bounds(slice, precisionUnit)) {
            // Insert it into subRow j + 1.
            while (subRows.length <= j + 1) {
              subRows.push([]);
            }
            subRows[j + 1].push(slice);
            if (insertedSlice.subSlices) {
              insertedSlice.subSlices.push(slice);
            }
            inserted = true;
            break;
          }
        }
        if (inserted) continue;

        // Append it to subRow[0] as a root.
        subRows[0].push(slice);
      }

      return subRows;
    }
  };

  return {
    SliceGroupTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * Visualizes a Thread using a series of SliceTracks.
   * @constructor
   */
  const ThreadTrack = tr.ui.b.define('thread-track',
      tr.ui.tracks.ContainerTrack);
  ThreadTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('thread-track');
      this.heading_ = document.createElement('tr-ui-b-heading');
    },

    get thread() {
      return this.thread_;
    },

    set thread(thread) {
      this.thread_ = thread;
      this.updateContents_();
    },

    get hasVisibleContent() {
      return this.tracks_.length > 0;
    },

    get hasSlices() {
      return this.thread_.asyncSliceGroup.length > 0 ||
          this.thread_.sliceGroup.length > 0;
    },

    get hasTimeSlices() {
      return this.thread_.timeSlices;
    },

    get eventContainer() {
      return this.thread;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.ContainerTrack.prototype.addContainersToTrackMap.apply(
          this, arguments);
      containerToTrackMap.addContainer(this.thread, this);
    },

    updateContents_() {
      this.detach();

      if (!this.thread_) return;

      this.heading_.heading = this.thread_.userFriendlyName;
      this.heading_.tooltip = this.thread_.userFriendlyDetails;

      if (this.thread_.asyncSliceGroup.length) {
        this.appendAsyncSliceTracks_();
      }

      this.appendThreadSamplesTracks_();

      let needsHeading = false;
      if (this.thread_.timeSlices) {
        const timeSlicesTrack = new tr.ui.tracks.SliceTrack(this.viewport);
        timeSlicesTrack.heading = '';
        timeSlicesTrack.height = tr.ui.b.THIN_SLICE_HEIGHT + 'px';
        timeSlicesTrack.slices = this.thread_.timeSlices;
        if (timeSlicesTrack.hasVisibleContent) {
          needsHeading = true;
          Polymer.dom(this).appendChild(timeSlicesTrack);
        }
      }

      if (this.thread_.sliceGroup.length) {
        const track = new tr.ui.tracks.SliceGroupTrack(this.viewport);
        track.heading = this.thread_.userFriendlyName;
        track.tooltip = this.thread_.userFriendlyDetails;
        track.group = this.thread_.sliceGroup;
        if (track.hasVisibleContent) {
          needsHeading = false;
          Polymer.dom(this).appendChild(track);
        }
      }

      if (needsHeading) {
        Polymer.dom(this).appendChild(this.heading_);
      }
    },

    appendAsyncSliceTracks_() {
      const subGroups = this.thread_.asyncSliceGroup.viewSubGroups;
      subGroups.forEach(function(subGroup) {
        const asyncTrack = new tr.ui.tracks.AsyncSliceGroupTrack(this.viewport);
        const title = subGroup.slices[0].viewSubGroupTitle;
        asyncTrack.group = subGroup;
        asyncTrack.heading = title;
        if (asyncTrack.hasVisibleContent) {
          Polymer.dom(this).appendChild(asyncTrack);
        }
      }, this);
    },

    appendThreadSamplesTracks_() {
      const threadSamples = this.thread_.samples;
      if (threadSamples === undefined || threadSamples.length === 0) {
        return;
      }
      const samplesByTitle = {};
      threadSamples.forEach(function(sample) {
        if (samplesByTitle[sample.title] === undefined) {
          samplesByTitle[sample.title] = [];
        }
        samplesByTitle[sample.title].push(sample);
      });

      const sampleTitles = Object.keys(samplesByTitle);
      sampleTitles.sort();

      sampleTitles.forEach(function(sampleTitle) {
        const samples = samplesByTitle[sampleTitle];
        const samplesTrack = new tr.ui.tracks.SampleTrack(this.viewport);
        samplesTrack.group = this.thread_;
        samplesTrack.samples = samples;
        samplesTrack.heading = this.thread_.userFriendlyName + ': ' +
            sampleTitle;
        samplesTrack.tooltip = this.thread_.userFriendlyDetails;
        samplesTrack.selectionGenerator = function() {
          const selection = new tr.model.EventSet();
          for (let i = 0; i < samplesTrack.samples.length; i++) {
            selection.push(samplesTrack.samples[i]);
          }
          return selection;
        };
        Polymer.dom(this).appendChild(samplesTrack);
      }, this);
    },

    collapsedDidChange(collapsed) {
      if (collapsed) {
        let h = parseInt(this.tracks[0].height);
        for (let i = 0; i < this.tracks.length; ++i) {
          if (h > 2) {
            this.tracks[i].height = Math.floor(h) + 'px';
          } else {
            this.tracks[i].style.display = 'none';
          }
          h = h * 0.5;
        }
      } else {
        for (let i = 0; i < this.tracks.length; ++i) {
          this.tracks[i].height = this.tracks[0].height;
          this.tracks[i].style.display = '';
        }
      }
    }
  };

  return {
    ThreadTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays threads with only scheduling information but no
   * slices. By default it's collapsed to minimize initial visual difference
   * while allowing the user to drill-down into whatever process is
   * interesting to them.
   * @constructor
   * @extends {ContainerTrack}
   */
  const OtherThreadsTrack = tr.ui.b.define(
      'other-threads-track', tr.ui.tracks.OtherThreadsTrack);

  const SpacingTrack = tr.ui.tracks.SpacingTrack;

  OtherThreadsTrack.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);

      this.header_ = document.createElement('tr-ui-b-heading');
      this.header_.addEventListener('click', this.onHeaderClick_.bind(this));
      this.header_.heading = 'Other Threads';
      this.header_.tooltip = 'Threads with only scheduling information';
      this.header_.arrowVisible = true;

      this.threads_ = [];
      this.expanded = false;
      this.collapsible_ = true;
    },

    set threads(threads) {
      this.threads_ = threads;
      this.updateContents_();
    },

    set collapsible(collapsible) {
      this.collapsible_ = collapsible;
      this.updateContents_();
    },

    onHeaderClick_(e) {
      e.stopPropagation();
      e.preventDefault();
      this.expanded = !this.expanded;
    },

    get expanded() {
      return this.header_.expanded;
    },

    set expanded(expanded) {
      expanded = !!expanded;

      if (this.expanded === expanded) return;

      this.header_.expanded = expanded;

      // Expanding and collapsing tracks is, essentially, growing and shrinking
      // the viewport. We dispatch a change event to trigger any processing
      // to happen.
      this.viewport_.dispatchChangeEvent();

      this.updateContents_();
    },

    updateContents_() {
      this.detach();
      if (this.collapsible_) {
        Polymer.dom(this).appendChild(this.header_);
      }
      if (this.expanded || !this.collapsible_) {
        for (const thread of this.threads_) {
          const track = new tr.ui.tracks.ThreadTrack(this.viewport);
          track.thread = thread;
          if (!track.hasVisibleContent) return;

          Polymer.dom(this).appendChild(track);
          Polymer.dom(this).appendChild(new SpacingTrack(this.viewport));
        }
      }
    }
  };

  return {
    OtherThreadsTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;

  /**
   * Visualizes a Process's state using a series of rects to represent activity.
   * @constructor
   */
  const ProcessSummaryTrack = tr.ui.b.define('process-summary-track',
      tr.ui.tracks.RectTrack);

  ProcessSummaryTrack.buildRectsFromProcess = function(process) {
    if (!process) return [];

    const ops = [];
    // build list of start/end ops for each top level or important slice
    const pushOp = function(isStart, time, slice) {
      ops.push({
        isStart,
        time,
        slice
      });
    };
    for (const tid in process.threads) {
      const sliceGroup = process.threads[tid].sliceGroup;

      sliceGroup.topLevelSlices.forEach(function(slice) {
        pushOp(true, slice.start, undefined);
        pushOp(false, slice.end, undefined);
      });
      sliceGroup.slices.forEach(function(slice) {
        if (slice.important) {
          pushOp(true, slice.start, slice);
          pushOp(false, slice.end, slice);
        }
      });
    }
    ops.sort(function(a, b) { return a.time - b.time; });

    const rects = [];
    /**
     * Build a row of rects which display one way for unimportant activity,
     * and during important slices, show up as those important slices.
     *
     * If an important slice starts in the middle of another,
     * just drop it on the floor.
     */
    const genericColorId = ColorScheme.getColorIdForReservedName(
        'generic_work');
    const pushRect = function(start, end, slice) {
      rects.push(new tr.ui.tracks.Rect(
          slice, /* modelItem: show selection state of slice if present */
          slice ? slice.title : '', /* title */
          slice ? slice.colorId : genericColorId, /* colorId */
          start, /* start */
          end - start /* duration */));
    };
    let depth = 0;
    let currentSlice = undefined;
    let lastStart = undefined;
    ops.forEach(function(op) {
      depth += op.isStart ? 1 : -1;

      if (currentSlice) {
        // simply find end of current important slice
        if (!op.isStart && op.slice === currentSlice) {
          // important slice has ended
          pushRect(lastStart, op.time, currentSlice);
          lastStart = depth >= 1 ? op.time : undefined;
          currentSlice = undefined;
        }
      } else {
        if (op.isStart) {
          if (depth === 1) {
            lastStart = op.time;
            currentSlice = op.slice;
          } else if (op.slice) {
            // switch to slice
            if (op.time !== lastStart) {
              pushRect(lastStart, op.time, undefined);
              lastStart = op.time;
            }
            currentSlice = op.slice;
          }
        } else {
          if (depth === 0) {
            pushRect(lastStart, op.time, undefined);
            lastStart = undefined;
          }
        }
      }
    });
    return rects;
  };

  ProcessSummaryTrack.prototype = {
    __proto__: tr.ui.tracks.RectTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.RectTrack.prototype.decorate.call(this, viewport);
    },

    get process() {
      return this.process_;
    },

    set process(process) {
      this.process_ = process;
      this.rects = ProcessSummaryTrack.buildRectsFromProcess(process);
    }
  };

  return {
    ProcessSummaryTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ObjectSnapshotView = tr.ui.analysis.ObjectSnapshotView;
  const ObjectInstanceView = tr.ui.analysis.ObjectInstanceView;
  const SpacingTrack = tr.ui.tracks.SpacingTrack;

  /**
   * Visualizes a Process by building ThreadTracks and CounterTracks.
   * @constructor
   */
  const ProcessTrackBase =
      tr.ui.b.define('process-track-base', tr.ui.tracks.ContainerTrack);

  ProcessTrackBase.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);

      this.processBase_ = undefined;

      Polymer.dom(this).classList.add('process-track-base');
      Polymer.dom(this).classList.add('expanded');

      this.processNameEl_ = tr.ui.b.createSpan();
      Polymer.dom(this.processNameEl_).classList.add('process-track-name');

      this.headerEl_ = tr.ui.b.createDiv({className: 'process-track-header'});
      Polymer.dom(this.headerEl_).appendChild(this.processNameEl_);
      this.headerEl_.addEventListener('click', this.onHeaderClick_.bind(this));

      Polymer.dom(this).appendChild(this.headerEl_);
    },

    get processBase() {
      return this.processBase_;
    },

    set processBase(processBase) {
      this.processBase_ = processBase;

      if (this.processBase_) {
        const modelSettings = new tr.model.ModelSettings(
            this.processBase_.model);
        const defaultValue = this.processBase_.important;
        this.expanded = modelSettings.getSettingFor(
            this.processBase_, 'expanded', defaultValue);
      }

      this.updateContents_();
    },

    get expanded() {
      return Polymer.dom(this).classList.contains('expanded');
    },

    set expanded(expanded) {
      expanded = !!expanded;

      if (this.expanded === expanded) return;

      Polymer.dom(this).classList.toggle('expanded');

      // Expanding and collapsing tracks is, essentially, growing and shrinking
      // the viewport. We dispatch a change event to trigger any processing
      // to happen.
      this.viewport_.dispatchChangeEvent();

      if (!this.processBase_) return;

      const modelSettings = new tr.model.ModelSettings(this.processBase_.model);
      modelSettings.setSettingFor(this.processBase_, 'expanded', expanded);
      this.updateContents_();
      this.viewport.rebuildEventToTrackMap();
      this.viewport.rebuildContainerToTrackMap();
    },

    get hasVisibleContent() {
      if (this.expanded) {
        return this.children.length > 1;
      }
      return true;
    },

    onHeaderClick_(e) {
      e.stopPropagation();
      e.preventDefault();
      this.expanded = !this.expanded;
    },

    updateContents_() {
      this.clearTracks_();

      if (!this.processBase_) return;

      Polymer.dom(this.processNameEl_).textContent =
          this.processBase_.userFriendlyName;
      this.headerEl_.title = this.processBase_.userFriendlyDetails;

      // Create the object instance tracks for this process.
      this.willAppendTracks_();
      if (this.expanded) {
        this.appendMemoryDumpTrack_();
        this.appendObjectInstanceTracks_();
        this.appendCounterTracks_();
        this.appendFrameTrack_();
        this.appendThreadTracks_();
      } else {
        this.appendSummaryTrack_();
      }
      this.didAppendTracks_();
    },

    willAppendTracks_() {
    },

    didAppendTracks_() {
    },

    appendMemoryDumpTrack_() {
    },

    appendSummaryTrack_() {
      const track = new tr.ui.tracks.ProcessSummaryTrack(this.viewport);
      track.process = this.process;
      if (!track.hasVisibleContent) return;
      Polymer.dom(this).appendChild(track);
      // no spacing track, since this track only shown in collapsed state
    },

    appendFrameTrack_() {
      const frames = this.process ? this.process.frames : undefined;
      if (!frames || !frames.length) return;

      const track = new tr.ui.tracks.FrameTrack(this.viewport);
      track.frames = frames;
      Polymer.dom(this).appendChild(track);
    },

    appendObjectInstanceTracks_() {
      const instancesByTypeName =
          this.processBase_.objects.getAllInstancesByTypeName();
      const instanceTypeNames = Object.keys(instancesByTypeName);
      instanceTypeNames.sort();

      let didAppendAtLeastOneTrack = false;
      instanceTypeNames.forEach(function(typeName) {
        const allInstances = instancesByTypeName[typeName];

        // If a object snapshot has a view it will be shown,
        // unless the view asked for it to not be shown.
        let instanceViewInfo = ObjectInstanceView.getTypeInfo(
            undefined, typeName);
        let snapshotViewInfo = ObjectSnapshotView.getTypeInfo(
            undefined, typeName);
        if (instanceViewInfo && !instanceViewInfo.metadata.showInTrackView) {
          instanceViewInfo = undefined;
        }
        if (snapshotViewInfo && !snapshotViewInfo.metadata.showInTrackView) {
          snapshotViewInfo = undefined;
        }
        const hasViewInfo = instanceViewInfo || snapshotViewInfo;

        // There are some instances that don't merit their own track in
        // the UI. Filter them out.
        const visibleInstances = [];
        for (let i = 0; i < allInstances.length; i++) {
          const instance = allInstances[i];

          // Do not create tracks for instances that have no snapshots.
          if (instance.snapshots.length === 0) continue;

          // Do not create tracks for instances that have implicit snapshots
          // and don't have a view.
          if (instance.hasImplicitSnapshots && !hasViewInfo) continue;

          visibleInstances.push(instance);
        }
        if (visibleInstances.length === 0) return;

        // Look up the constructor for this track, or use the default
        // constructor if none exists.
        let trackConstructor =
            tr.ui.tracks.ObjectInstanceTrack.getConstructor(
                undefined, typeName);
        if (!trackConstructor) {
          snapshotViewInfo = ObjectSnapshotView.getTypeInfo(
              undefined, typeName);
          if (snapshotViewInfo && snapshotViewInfo.metadata.showInstances) {
            trackConstructor = tr.ui.tracks.ObjectInstanceGroupTrack;
          } else {
            trackConstructor = tr.ui.tracks.ObjectInstanceTrack;
          }
        }
        const track = new trackConstructor(this.viewport);
        track.objectInstances = visibleInstances;
        Polymer.dom(this).appendChild(track);
        didAppendAtLeastOneTrack = true;
      }, this);
      if (didAppendAtLeastOneTrack) {
        Polymer.dom(this).appendChild(new SpacingTrack(this.viewport));
      }
    },

    appendCounterTracks_() {
      // Add counter tracks for this process.
      const counters = Object.values(this.processBase.counters);
      counters.sort(tr.model.Counter.compare);

      // Create the counters for this process.
      counters.forEach(function(counter) {
        const track = new tr.ui.tracks.CounterTrack(this.viewport);
        track.counter = counter;
        Polymer.dom(this).appendChild(track);
        Polymer.dom(this).appendChild(new SpacingTrack(this.viewport));
      }.bind(this));
    },

    appendThreadTracks_() {
      // Get a sorted list of threads.
      const threads = Object.values(this.processBase.threads);
      threads.sort(tr.model.Thread.compare);

      // Create the threads.
      const otherThreads = [];
      let hasVisibleThreads = false;
      threads.forEach(function(thread) {
        const track = new tr.ui.tracks.ThreadTrack(this.viewport);
        track.thread = thread;
        if (!track.hasVisibleContent) return;

        if (track.hasSlices) {
          hasVisibleThreads = true;
          Polymer.dom(this).appendChild(track);
          Polymer.dom(this).appendChild(new SpacingTrack(this.viewport));
        } else if (track.hasTimeSlices) {
          otherThreads.push(thread);
        }
      }.bind(this));

      if (otherThreads.length > 0) {
        // If there's only 1 thread with scheduling-only information don't
        // bother making a group, just display it directly
        // Similarly if we are a process with only scheduling-only threads
        // don't bother making a group as the process itself serves
        // as the collapsable group
        const track = new tr.ui.tracks.OtherThreadsTrack(this.viewport);
        track.threads = otherThreads;
        track.collapsible = otherThreads.length > 1 && hasVisibleThreads;
        Polymer.dom(this).appendChild(track);
      }
    }
  };

  return {
    ProcessTrackBase,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const Cpu = tr.model.Cpu;
  const CpuTrack = tr.ui.tracks.cpu_track;
  const ProcessTrackBase = tr.ui.tracks.ProcessTrackBase;
  const SpacingTrack = tr.ui.tracks.SpacingTrack;

  /**
   * @constructor
   */
  const KernelTrack = tr.ui.b.define('kernel-track', ProcessTrackBase);

  KernelTrack.prototype = {
    __proto__: ProcessTrackBase.prototype,

    decorate(viewport) {
      ProcessTrackBase.prototype.decorate.call(this, viewport);
    },


    // Kernel maps to processBase because we derive from ProcessTrackBase.
    set kernel(kernel) {
      this.processBase = kernel;
    },

    get kernel() {
      return this.processBase;
    },

    get eventContainer() {
      return this.kernel;
    },

    get hasVisibleContent() {
      return this.children.length > 1;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.ProcessTrackBase.prototype.addContainersToTrackMap.call(
          this, containerToTrackMap);
      containerToTrackMap.addContainer(this.kernel, this);
    },

    willAppendTracks_() {
      const cpus = Object.values(this.kernel.cpus);
      cpus.sort(tr.model.Cpu.compare);

      let didAppendAtLeastOneTrack = false;
      for (let i = 0; i < cpus.length; ++i) {
        const cpu = cpus[i];
        const track = new tr.ui.tracks.CpuTrack(this.viewport);
        track.detailedMode = this.expanded;
        track.cpu = cpu;
        if (!track.hasVisibleContent) continue;
        Polymer.dom(this).appendChild(track);
        didAppendAtLeastOneTrack = true;
      }
      if (didAppendAtLeastOneTrack) {
        Polymer.dom(this).appendChild(new SpacingTrack(this.viewport));
      }
    }
  };


  return {
    KernelTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays an array of interaction records.
   * @constructor
   * @extends {MultiRowTrack}
   */
  const InteractionTrack = tr.ui.b.define(
      'interaction-track', tr.ui.tracks.MultiRowTrack);

  InteractionTrack.prototype = {
    __proto__: tr.ui.tracks.MultiRowTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.MultiRowTrack.prototype.decorate.call(this, viewport);
      this.heading = 'Interactions';
      this.subRows_ = [];
    },

    set model(model) {
      this.setItemsToGroup(model.userModel.expectations, {
        guid: tr.b.GUID.allocateSimple(),
        model,
        getSettingsKey() {
          return undefined;
        }
      });
    },

    buildSubRows_(slices) {
      if (this.subRows_.length) {
        return this.subRows_;
      }
      this.subRows_.push.apply(this.subRows_,
          tr.ui.tracks.AsyncSliceGroupTrack.prototype.buildSubRows_.call(
          {}, slices, true));
      return this.subRows_;
    },

    addSubTrack_(slices) {
      const track = new tr.ui.tracks.SliceTrack(this.viewport);
      track.slices = slices;
      Polymer.dom(this).appendChild(track);
      return track;
    }
  };

  return {
    InteractionTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ColorScheme = tr.b.ColorScheme;
  const LetterDotTrack = tr.ui.tracks.LetterDotTrack;

  /**
   * A track that displays global memory events.
   *
   * @constructor
   * @extends {tr.ui.tracks.LetterDotTrack}
   */
  const MemoryTrack = tr.ui.b.define('memory-track', LetterDotTrack);

  MemoryTrack.prototype = {
    __proto__: LetterDotTrack.prototype,

    decorate(viewport) {
      LetterDotTrack.prototype.decorate.call(this, viewport);
      this.classList.add('memory-track');
      this.heading = 'Memory Events';
      this.lowMemoryEvents_ = undefined;
    },

    initialize(model) {
      if (model !== undefined) {
        this.lowMemoryEvents_ = model.device.lowMemoryEvents;
      } else {
        this.lowMemoryEvents_ = undefined;
      }

      if (this.hasVisibleContent) {
        this.items = this.buildMemoryLetterDots_(this.lowMemoryEvents_);
      }
    },

    get hasVisibleContent() {
      return !!this.lowMemoryEvents_ && this.lowMemoryEvents_.length !== 0;
    },

    buildMemoryLetterDots_(memoryEvents) {
      return memoryEvents.map(
          memoryEvent => new tr.ui.tracks.LetterDot(
            memoryEvent,
            'K',
            ColorScheme.getColorIdForReservedName('background_memory_dump'),
            memoryEvent.start
          )
      );
    },
  };

  return {
    MemoryTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ALLOCATED_MEMORY_TRACK_HEIGHT = 50;

  /**
   * A track that displays an array of ProcessMemoryDump objects.
   * @constructor
   * @extends {ContainerTrack}
   */
  const ProcessMemoryDumpTrack = tr.ui.b.define(
      'process-memory-dump-track', tr.ui.tracks.ContainerTrack);

  ProcessMemoryDumpTrack.prototype = {
    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      this.memoryDumps_ = undefined;
    },

    get memoryDumps() {
      return this.memoryDumps_;
    },

    set memoryDumps(memoryDumps) {
      this.memoryDumps_ = memoryDumps;
      this.updateContents_();
    },

    updateContents_() {
      this.clearTracks_();

      // Show no tracks if there are no dumps.
      if (!this.memoryDumps_ || !this.memoryDumps_.length) return;

      this.appendAllocatedMemoryTrack_();
    },

    appendAllocatedMemoryTrack_() {
      const series = tr.ui.tracks.buildProcessAllocatedMemoryChartSeries(
          this.memoryDumps_);
      if (!series) return;

      const track = new tr.ui.tracks.ChartTrack(this.viewport);
      track.heading = 'Memory per component';
      track.height = ALLOCATED_MEMORY_TRACK_HEIGHT + 'px';
      track.series = series;
      track.autoSetAllAxes({expandMax: true});
      Polymer.dom(this).appendChild(track);
    }
  };

  return {
    ProcessMemoryDumpTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const ProcessTrackBase = tr.ui.tracks.ProcessTrackBase;

  /**
   * @constructor
   */
  const ProcessTrack = tr.ui.b.define('process-track', ProcessTrackBase);

  ProcessTrack.prototype = {
    __proto__: ProcessTrackBase.prototype,

    decorate(viewport) {
      tr.ui.tracks.ProcessTrackBase.prototype.decorate.call(this, viewport);
    },

    drawTrack(type) {
      switch (type) {
        case tr.ui.tracks.DrawType.INSTANT_EVENT: {
          if (!this.processBase.instantEvents ||
              this.processBase.instantEvents.length === 0) {
            break;
          }

          const ctx = this.context();

          const pixelRatio = window.devicePixelRatio || 1;
          const bounds = this.getBoundingClientRect();
          const canvasBounds = ctx.canvas.getBoundingClientRect();

          ctx.save();
          ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

          const dt = this.viewport.currentDisplayTransform;
          const viewLWorld = dt.xViewToWorld(0);
          const viewRWorld = dt.xViewToWorld(canvasBounds.width * pixelRatio);

          tr.ui.b.drawInstantSlicesAsLines(
              ctx,
              this.viewport.currentDisplayTransform,
              viewLWorld,
              viewRWorld,
              bounds.height,
              this.processBase.instantEvents,
              2);

          ctx.restore();

          break;
        }

        case tr.ui.tracks.DrawType.BACKGROUND:
          this.drawBackground_();
          // Don't bother recursing further, Process is the only level that
          // draws backgrounds.
          return;
      }

      tr.ui.tracks.ContainerTrack.prototype.drawTrack.call(this, type);
    },

    drawBackground_() {
      const ctx = this.context();
      const canvasBounds = ctx.canvas.getBoundingClientRect();
      const pixelRatio = window.devicePixelRatio || 1;

      let draw = false;
      ctx.fillStyle = '#eee';
      for (let i = 0; i < this.children.length; ++i) {
        if (!(this.children[i] instanceof tr.ui.tracks.Track) ||
            (this.children[i] instanceof tr.ui.tracks.SpacingTrack)) {
          continue;
        }

        draw = !draw;
        if (!draw) continue;

        const bounds = this.children[i].getBoundingClientRect();
        ctx.fillRect(0, pixelRatio * (bounds.top - canvasBounds.top),
            ctx.canvas.width, pixelRatio * bounds.height);
      }
    },

    // Process maps to processBase because we derive from ProcessTrackBase.
    set process(process) {
      this.processBase = process;
    },

    get process() {
      return this.processBase;
    },

    get eventContainer() {
      return this.process;
    },

    addContainersToTrackMap(containerToTrackMap) {
      tr.ui.tracks.ProcessTrackBase.prototype.addContainersToTrackMap.apply(
          this, arguments);
      containerToTrackMap.addContainer(this.process, this);
    },

    appendMemoryDumpTrack_() {
      const processMemoryDumps = this.process.memoryDumps;
      if (processMemoryDumps.length) {
        const pmdt = new tr.ui.tracks.ProcessMemoryDumpTrack(this.viewport_);
        pmdt.memoryDumps = processMemoryDumps;
        Polymer.dom(this).appendChild(pmdt);
      }
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onPickHit(instantEvent) {
        selection.push(instantEvent);
      }
      const instantEventWidth = 2 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.processBase.instantEvents,
          function(x) { return x.start; },
          function(x) { return x.duration + instantEventWidth; },
          loWX, hiWX,
          onPickHit.bind(this));

      tr.ui.tracks.ContainerTrack.prototype.
          addIntersectingEventsInRangeToSelectionInWorldSpace.
          apply(this, arguments);
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      this.addClosestInstantEventToSelection(this.processBase.instantEvents,
          worldX, worldMaxDist, selection);
      tr.ui.tracks.ContainerTrack.prototype.addClosestEventToSelection.
          apply(this, arguments);
    }
  };

  return {
    ProcessTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  const SelectionState = tr.model.SelectionState;
  const ColorScheme = tr.b.ColorScheme;
  const EventPresenter = tr.ui.b.EventPresenter;

  /**
   * Visualizes a Model by building ProcessTracks and CpuTracks.
   * @constructor
   */
  const ModelTrack = tr.ui.b.define('model-track', tr.ui.tracks.ContainerTrack);

  ModelTrack.VSYNC_HIGHLIGHT_ALPHA = 0.1;
  ModelTrack.VSYNC_DENSITY_TRANSPARENT = 0.20;
  ModelTrack.VSYNC_DENSITY_OPAQUE = 0.10;
  ModelTrack.VSYNC_DENSITY_RANGE =
      ModelTrack.VSYNC_DENSITY_TRANSPARENT - ModelTrack.VSYNC_DENSITY_OPAQUE;

  /**
   * Generate a zebra striping from a list of times.
   *
   * @param {!Array.<number>} times A sorted array of timestamps.
   * @param {number} minTime the lower bound of time to start striping at.
   * @param {number} maxTime the upper bound of time to stop striping at.
   *     of |times|.
   *
   * @returns {!Array.<tr.b.math.Range>} An array of ranges where each element
   *     represents the time range that a stripe covers. Each range is a subset
   *     of the interval [minTime, maxTime].
   */
  ModelTrack.generateStripes_ = function(times, minTime, maxTime) {
    if (times.length === 0) return [];

    // Find the lowest and highest index within the viewport.
    const lowIndex = tr.b.findLowIndexInSortedArray(
        times, (x => x), minTime);
    let highIndex = lowIndex - 1;
    while (times[highIndex + 1] <= maxTime) {
      highIndex++;
    }

    const stripes = [];
    // Must start at an even index and end at an odd index.
    for (let i = lowIndex - (lowIndex % 2); i <= highIndex; i += 2) {
      const left = i < lowIndex ? minTime : times[i];
      const right = i + 1 > highIndex ? maxTime : times[i + 1];
      stripes.push(tr.b.math.Range.fromExplicitRange(left, right));
    }

    return stripes;
  };


  ModelTrack.prototype = {

    __proto__: tr.ui.tracks.ContainerTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.ContainerTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('model-track');

      this.upperMode_ = false;
      this.annotationViews_ = [];
      this.vSyncTimes_ = [];
    },

    // upperMode is true if the track is being used on the ruler.
    get upperMode() {
      return this.upperMode_;
    },

    set upperMode(upperMode) {
      this.upperMode_ = upperMode;
      this.updateContents_();
    },

    detach() {
      tr.ui.tracks.ContainerTrack.prototype.detach.call(this);
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateContents_();

      this.model_.addEventListener('annotationChange',
          this.updateAnnotations_.bind(this));
    },

    get hasVisibleContent() {
      return this.children.length > 0;
    },

    updateContents_() {
      Polymer.dom(this).textContent = '';
      if (!this.model_) return;

      if (this.upperMode_) {
        this.updateContentsForUpperMode_();
      } else {
        this.updateContentsForLowerMode_();
      }
    },

    updateContentsForUpperMode_() {
    },

    updateContentsForLowerMode_() {
      if (this.model_.userModel.expectations.length > 1) {
        const mrt = new tr.ui.tracks.InteractionTrack(this.viewport_);
        mrt.model = this.model_;
        Polymer.dom(this).appendChild(mrt);
      }

      if (this.model_.alerts.length) {
        const at = new tr.ui.tracks.AlertTrack(this.viewport_);
        at.alerts = this.model_.alerts;
        Polymer.dom(this).appendChild(at);
      }

      if (this.model_.globalMemoryDumps.length) {
        const gmdt = new tr.ui.tracks.GlobalMemoryDumpTrack(this.viewport_);
        gmdt.memoryDumps = this.model_.globalMemoryDumps;
        Polymer.dom(this).appendChild(gmdt);
      }

      this.appendDeviceTrack_();
      this.appendCpuUsageTrack_();
      this.appendMemoryTrack_();
      this.appendKernelTrack_();

      // Get a sorted list of processes.
      const processes = this.model_.getAllProcesses();
      processes.sort(tr.model.Process.compare);

      for (let i = 0; i < processes.length; ++i) {
        const process = processes[i];

        const track = new tr.ui.tracks.ProcessTrack(this.viewport);
        track.process = process;
        if (!track.hasVisibleContent) continue;

        Polymer.dom(this).appendChild(track);
      }
      this.viewport_.rebuildEventToTrackMap();
      this.viewport_.rebuildContainerToTrackMap();
      this.vSyncTimes_ = this.model_.device.vSyncTimestamps;

      this.updateAnnotations_();
    },

    getContentBounds() { return this.model.bounds; },

    addAnnotation(annotation) {
      this.model.addAnnotation(annotation);
    },

    removeAnnotation(annotation) {
      this.model.removeAnnotation(annotation);
    },

    updateAnnotations_() {
      this.annotationViews_ = [];
      const annotations = this.model_.getAllAnnotations();
      for (let i = 0; i < annotations.length; i++) {
        this.annotationViews_.push(
            annotations[i].getOrCreateView(this.viewport_));
      }
      this.invalidateDrawingContainer();
    },

    addEventsToTrackMap(eventToTrackMap) {
      if (!this.model_) return;

      const tracks = this.children;
      for (let i = 0; i < tracks.length; ++i) {
        tracks[i].addEventsToTrackMap(eventToTrackMap);
      }

      if (this.instantEvents === undefined) return;

      const vp = this.viewport_;
      this.instantEvents.forEach(function(ev) {
        eventToTrackMap.addEvent(ev, this);
      }.bind(this));
    },

    appendDeviceTrack_() {
      const device = this.model.device;
      const track = new tr.ui.tracks.DeviceTrack(this.viewport);
      track.device = this.model.device;
      if (!track.hasVisibleContent) return;
      Polymer.dom(this).appendChild(track);
    },

    appendKernelTrack_() {
      const kernel = this.model.kernel;
      const track = new tr.ui.tracks.KernelTrack(this.viewport);
      track.kernel = this.model.kernel;
      if (!track.hasVisibleContent) return;
      Polymer.dom(this).appendChild(track);
    },

    appendCpuUsageTrack_() {
      const track = new tr.ui.tracks.CpuUsageTrack(this.viewport);
      track.initialize(this.model);
      if (!track.hasVisibleContent) return;

      this.appendChild(track);
    },

    appendMemoryTrack_() {
      const track = new tr.ui.tracks.MemoryTrack(this.viewport);
      track.initialize(this.model);
      if (!track.hasVisibleContent) return;

      Polymer.dom(this).appendChild(track);
    },

    drawTrack(type) {
      const ctx = this.context();
      if (!this.model_) return;

      const pixelRatio = window.devicePixelRatio || 1;
      const bounds = this.getBoundingClientRect();
      const canvasBounds = ctx.canvas.getBoundingClientRect();

      ctx.save();
      ctx.translate(0, pixelRatio * (bounds.top - canvasBounds.top));

      const dt = this.viewport.currentDisplayTransform;
      const viewLWorld = dt.xViewToWorld(0);
      const viewRWorld = dt.xViewToWorld(canvasBounds.width * pixelRatio);

      switch (type) {
        case tr.ui.tracks.DrawType.GRID:
          this.viewport.drawMajorMarkLines(ctx);
          // The model is the only thing that draws grid lines.
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.FLOW_ARROWS:
          if (this.model_.flowIntervalTree.size === 0) {
            ctx.restore();
            return;
          }

          this.drawFlowArrows_(viewLWorld, viewRWorld);
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.INSTANT_EVENT:
          if (!this.model_.instantEvents ||
              this.model_.instantEvents.length === 0) {
            break;
          }

          tr.ui.b.drawInstantSlicesAsLines(
              ctx,
              this.viewport.currentDisplayTransform,
              viewLWorld,
              viewRWorld,
              bounds.height,
              this.model_.instantEvents,
              4);

          break;

        case tr.ui.tracks.DrawType.MARKERS:
          if (!this.viewport.interestRange.isEmpty) {
            this.viewport.interestRange.draw(ctx, viewLWorld, viewRWorld);
            this.viewport.interestRange.drawIndicators(
                ctx, viewLWorld, viewRWorld);
          }
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.HIGHLIGHTS:
          this.drawVSyncHighlight(
              ctx, dt, viewLWorld, viewRWorld, bounds.height);
          ctx.restore();
          return;

        case tr.ui.tracks.DrawType.ANNOTATIONS:
          for (let i = 0; i < this.annotationViews_.length; i++) {
            this.annotationViews_[i].draw(ctx);
          }
          ctx.restore();
          return;
      }
      ctx.restore();

      tr.ui.tracks.ContainerTrack.prototype.drawTrack.call(this, type);
    },

    drawFlowArrows_(viewLWorld, viewRWorld) {
      const ctx = this.context();

      ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.lineWidth = 1;

      const events =
          this.model_.flowIntervalTree.findIntersection(viewLWorld, viewRWorld);

      // When not showing flow events, show only highlighted/selected ones.
      const onlyHighlighted = !this.viewport.showFlowEvents;
      const canvasBounds = ctx.canvas.getBoundingClientRect();
      for (let i = 0; i < events.length; ++i) {
        if (onlyHighlighted &&
            events[i].selectionState !== SelectionState.SELECTED &&
            events[i].selectionState !== SelectionState.HIGHLIGHTED) {
          continue;
        }
        this.drawFlowArrow_(ctx, events[i], canvasBounds);
      }
    },

    drawFlowArrow_(ctx, flowEvent, canvasBounds) {
      const dt = this.viewport.currentDisplayTransform;
      const pixelRatio = window.devicePixelRatio || 1;

      const startTrack = this.viewport.trackForEvent(flowEvent.startSlice);
      const endTrack = this.viewport.trackForEvent(flowEvent.endSlice);

      // TODO(nduca): Figure out how to draw flow arrows even when
      // processes are collapsed, bug #931.
      if (startTrack === undefined || endTrack === undefined) return;

      const startBounds = startTrack.getBoundingClientRect();
      const endBounds = endTrack.getBoundingClientRect();

      if (flowEvent.selectionState === SelectionState.SELECTED) {
        ctx.shadowBlur = 1;
        ctx.shadowColor = 'red';
        ctx.shadowOffsety = 2;
        ctx.strokeStyle = tr.b.ColorScheme.colorsAsStrings[
          tr.b.ColorScheme.getVariantColorId(
              flowEvent.colorId,
              tr.b.ColorScheme.properties.brightenedOffsets[0])];
      } else if (flowEvent.selectionState === SelectionState.HIGHLIGHTED) {
        ctx.shadowBlur = 1;
        ctx.shadowColor = 'red';
        ctx.shadowOffsety = 2;
        ctx.strokeStyle = tr.b.ColorScheme.colorsAsStrings[
          tr.b.ColorScheme.getVariantColorId(
              flowEvent.colorId,
              tr.b.ColorScheme.properties.brightenedOffsets[0])];
      } else if (flowEvent.selectionState === SelectionState.DIMMED) {
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.strokeStyle = tr.b.ColorScheme.colorsAsStrings[flowEvent.colorId];
      } else {
        let hasBoost = false;
        const startSlice = flowEvent.startSlice;
        hasBoost |= startSlice.selectionState === SelectionState.SELECTED;
        hasBoost |= startSlice.selectionState === SelectionState.HIGHLIGHTED;
        const endSlice = flowEvent.endSlice;
        hasBoost |= endSlice.selectionState === SelectionState.SELECTED;
        hasBoost |= endSlice.selectionState === SelectionState.HIGHLIGHTED;
        if (hasBoost) {
          ctx.shadowBlur = 1;
          ctx.shadowColor = 'rgba(255, 0, 0, 0.4)';
          ctx.shadowOffsety = 2;
          ctx.strokeStyle = tr.b.ColorScheme.colorsAsStrings[
            tr.b.ColorScheme.getVariantColorId(
                flowEvent.colorId,
                tr.b.ColorScheme.properties.brightenedOffsets[0])];
        } else {
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.strokeStyle = tr.b.ColorScheme.colorsAsStrings[flowEvent.colorId];
        }
      }

      const startSize = startBounds.left + startBounds.top +
          startBounds.bottom + startBounds.right;
      const endSize = endBounds.left + endBounds.top +
          endBounds.bottom + endBounds.right;
      // Nothing to do if both ends of the track are collapsed.
      if (startSize === 0 && endSize === 0) return;

      const startY = this.calculateTrackY_(startTrack, canvasBounds);
      const endY = this.calculateTrackY_(endTrack, canvasBounds);

      const pixelStartY = pixelRatio * startY;
      const pixelEndY = pixelRatio * endY;

      const startXView = dt.xWorldToView(flowEvent.start);
      const endXView = dt.xWorldToView(flowEvent.end);
      const midXView = (startXView + endXView) / 2;

      ctx.beginPath();
      ctx.moveTo(startXView, pixelStartY);
      ctx.bezierCurveTo(
          midXView, pixelStartY,
          midXView, pixelEndY,
          endXView, pixelEndY);
      ctx.stroke();

      const arrowWidth = 5 * pixelRatio;
      const distance = endXView - startXView;
      if (distance <= (2 * arrowWidth)) return;

      const tipX = endXView;
      const tipY = pixelEndY;
      const arrowHeight = (endBounds.height / 4) * pixelRatio;
      tr.ui.b.drawTriangle(ctx,
          tipX, tipY,
          tipX - arrowWidth, tipY - arrowHeight,
          tipX - arrowWidth, tipY + arrowHeight);
      ctx.fill();
    },

    /**
     * Highlights VSync events on the model track (using "zebra" striping).
     */
    drawVSyncHighlight(ctx, dt, viewLWorld, viewRWorld, viewHeight) {
      if (!this.viewport_.highlightVSync) {
        return;
      }

      const stripes = ModelTrack.generateStripes_(
          this.vSyncTimes_, viewLWorld, viewRWorld);
      if (stripes.length === 0) {
        return;
      }

      const vSyncHighlightColor =
          new tr.b.Color(ColorScheme.getColorForReservedNameAsString(
              'vsync_highlight_color'));

      const stripeRange = stripes[stripes.length - 1].max - stripes[0].min;
      const stripeDensity =
        stripeRange ? stripes.length / (dt.scaleX * stripeRange) : 0;
      const clampedStripeDensity =
          tr.b.math.clamp(stripeDensity, ModelTrack.VSYNC_DENSITY_OPAQUE,
              ModelTrack.VSYNC_DENSITY_TRANSPARENT);
      const opacity =
          (ModelTrack.VSYNC_DENSITY_TRANSPARENT - clampedStripeDensity) /
          ModelTrack.VSYNC_DENSITY_RANGE;
      if (opacity === 0) {
        return;
      }

      const pixelRatio = window.devicePixelRatio || 1;
      const height = viewHeight * pixelRatio;

      ctx.fillStyle = vSyncHighlightColor.toStringWithAlphaOverride(
          ModelTrack.VSYNC_HIGHLIGHT_ALPHA * opacity);

      for (let i = 0; i < stripes.length; i++) {
        const xLeftView = dt.xWorldToView(stripes[i].min);
        const xRightView = dt.xWorldToView(stripes[i].max);
        ctx.fillRect(xLeftView, 0, xRightView - xLeftView, height);
      }
    },

    calculateTrackY_(track, canvasBounds) {
      const bounds = track.getBoundingClientRect();
      const size = bounds.left + bounds.top + bounds.bottom + bounds.right;
      if (size === 0) {
        return this.calculateTrackY_(
            Polymer.dom(track).parentNode, canvasBounds);
      }

      return bounds.top - canvasBounds.top + (bounds.height / 2);
    },

    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onPickHit(instantEvent) {
        selection.push(instantEvent);
      }
      const instantEventWidth = 3 * viewPixWidthWorld;
      tr.b.iterateOverIntersectingIntervals(this.model_.instantEvents,
          function(x) { return x.start; },
          function(x) { return x.duration + instantEventWidth; },
          loWX, hiWX,
          onPickHit.bind(this));

      tr.ui.tracks.ContainerTrack.prototype.
          addIntersectingEventsInRangeToSelectionInWorldSpace.
          apply(this, arguments);
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      this.addClosestInstantEventToSelection(this.model_.instantEvents,
          worldX, worldMaxDist, selection);
      tr.ui.tracks.ContainerTrack.prototype.addClosestEventToSelection.
          apply(this, arguments);
    }
  };

  return {
    ModelTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays the x-axis.
   * @constructor
   * @extends {Track}
   */
  const XAxisTrack = tr.ui.b.define('x-axis-track', tr.ui.tracks.Track);

  XAxisTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('x-axis-track');
      this.strings_secs_ = [];
      this.strings_msecs_ = [];
      this.strings_usecs_ = [];
      this.strings_nsecs_ = [];

      this.viewportChange_ = this.viewportChange_.bind(this);
      viewport.addEventListener('change', this.viewportChange_);

      const heading = document.createElement('tr-ui-b-heading');
      heading.arrowVisible = false;
      Polymer.dom(this).appendChild(heading);
    },

    detach() {
      tr.ui.tracks.Track.prototype.detach.call(this);
      this.viewport.removeEventListener('change',
          this.viewportChange_);
    },

    viewportChange_() {
      if (this.viewport.interestRange.isEmpty) {
        Polymer.dom(this).classList.remove('tall-mode');
      } else {
        Polymer.dom(this).classList.add('tall-mode');
      }
    },

    draw(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GRID:
          this.drawGrid_(viewLWorld, viewRWorld);
          break;
        case tr.ui.tracks.DrawType.MARKERS:
          if (!this.viewport.interestRange.isEmpty) {
            this.viewport.interestRange.draw(this.context(),
                viewLWorld, viewRWorld);
          }
          break;
      }
    },

    drawGrid_(viewLWorld, viewRWorld) {
      const ctx = this.context();
      const pixelRatio = window.devicePixelRatio || 1;

      const canvasBounds = ctx.canvas.getBoundingClientRect();
      const trackBounds = this.getBoundingClientRect();
      const width = canvasBounds.width * pixelRatio;
      const height = trackBounds.height * pixelRatio;

      const hasInterestRange = !this.viewport.interestRange.isEmpty;

      const xAxisHeightPx = hasInterestRange ? (height * 2) / 5 : height;

      const vp = this.viewport;
      const dt = vp.currentDisplayTransform;

      vp.updateMajorMarkData(viewLWorld, viewRWorld);
      const majorMarkDistanceWorld = vp.majorMarkWorldPositions.length > 1 ?
          vp.majorMarkWorldPositions[1] - vp.majorMarkWorldPositions[0] : 0;

      const numTicksPerMajor = 5;
      const minorMarkDistanceWorld = majorMarkDistanceWorld / numTicksPerMajor;
      const minorMarkDistancePx = dt.xWorldVectorToView(minorMarkDistanceWorld);

      const minorTickHeight = Math.floor(xAxisHeightPx * 0.25);

      ctx.save();

      ctx.lineWidth = Math.round(pixelRatio);

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      const crispLineCorrection = (ctx.lineWidth % 2) / 2;
      ctx.translate(crispLineCorrection, -crispLineCorrection);

      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      ctx.font = (9 * pixelRatio) + 'px sans-serif';

      const tickLabels = [];
      ctx.beginPath();
      for (let i = 0; i < vp.majorMarkWorldPositions.length; i++) {
        const curXWorld = vp.majorMarkWorldPositions[i];
        const curXView = dt.xWorldToView(curXWorld);
        const displayText = vp.majorMarkUnit.format(
            curXWorld, {deltaValue: majorMarkDistanceWorld});
        ctx.fillText(displayText, curXView + (2 * pixelRatio), 0);

        // Draw major mark.
        tr.ui.b.drawLine(ctx, curXView, 0, curXView, xAxisHeightPx);

        // Draw minor marks.
        if (minorMarkDistancePx) {
          for (let j = 1; j < numTicksPerMajor; ++j) {
            const xView = Math.floor(curXView + minorMarkDistancePx * j);
            tr.ui.b.drawLine(ctx,
                xView, xAxisHeightPx - minorTickHeight,
                xView, xAxisHeightPx);
          }
        }
      }

      // Draw bottom bar.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      tr.ui.b.drawLine(ctx, 0, height, width, height);
      ctx.stroke();

      // Give distance between directly adjacent markers.
      if (!hasInterestRange) return;

      // Draw middle bar.
      tr.ui.b.drawLine(ctx, 0, xAxisHeightPx, width, xAxisHeightPx);
      ctx.stroke();

      // Distance Variables.
      let displayDistance;
      const displayTextColor = 'rgb(0,0,0)';

      // Arrow Variables.
      const arrowSpacing = 10 * pixelRatio;
      const arrowColor = 'rgb(128,121,121)';
      const arrowPosY = xAxisHeightPx * 1.75;
      const arrowWidthView = 3 * pixelRatio;
      const arrowLengthView = 10 * pixelRatio;
      const spaceForArrowsView = 2 * (arrowWidthView + arrowSpacing);

      ctx.textBaseline = 'middle';
      ctx.font = (14 * pixelRatio) + 'px sans-serif';
      const textPosY = arrowPosY;

      const interestRange = vp.interestRange;

      // If the range is zero, draw it's min timestamp next to the line.
      if (interestRange.range === 0) {
        const markerWorld = interestRange.min;
        const markerView = dt.xWorldToView(markerWorld);

        const textToDraw = vp.majorMarkUnit.format(markerWorld);
        let textLeftView = markerView + 4 * pixelRatio;
        const textWidthView = ctx.measureText(textToDraw).width;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width) {
          textLeftView = markerView - 4 * pixelRatio - textWidthView;
        }

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);
        return;
      }

      const leftMarker = interestRange.min;
      const rightMarker = interestRange.max;

      const leftMarkerView = dt.xWorldToView(leftMarker);
      const rightMarkerView = dt.xWorldToView(rightMarker);

      const distanceBetweenMarkers = interestRange.range;
      const distanceBetweenMarkersView =
          dt.xWorldVectorToView(distanceBetweenMarkers);
      const positionInMiddleOfMarkersView =
          leftMarkerView + (distanceBetweenMarkersView / 2);

      const textToDraw = vp.majorMarkUnit.format(distanceBetweenMarkers);
      const textWidthView = ctx.measureText(textToDraw).width;
      const spaceForArrowsAndTextView =
          textWidthView + spaceForArrowsView + arrowSpacing;

      // Set text positions.
      let textLeftView = positionInMiddleOfMarkersView - textWidthView / 2;
      const textRightView = textLeftView + textWidthView;

      if (spaceForArrowsAndTextView > distanceBetweenMarkersView) {
        // Print the display distance text right of the 2 markers.
        textLeftView = rightMarkerView + 2 * arrowSpacing;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width) {
          textLeftView = leftMarkerView - 2 * arrowSpacing - textWidthView;
        }

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);

        // Draw the arrows pointing from outside in and a line in between.
        ctx.strokeStyle = arrowColor;
        ctx.beginPath();
        tr.ui.b.drawLine(ctx, leftMarkerView, arrowPosY, rightMarkerView,
            arrowPosY);
        ctx.stroke();

        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftMarkerView - 1.5 * arrowSpacing, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightMarkerView + 1.5 * arrowSpacing, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
      } else if (spaceForArrowsView <= distanceBetweenMarkersView) {
        let leftArrowStart;
        let rightArrowStart;
        if (spaceForArrowsAndTextView <= distanceBetweenMarkersView) {
          // Print the display distance text.
          ctx.fillStyle = displayTextColor;
          ctx.fillText(textToDraw, textLeftView, textPosY);

          leftArrowStart = textLeftView - arrowSpacing;
          rightArrowStart = textRightView + arrowSpacing;
        } else {
          leftArrowStart = positionInMiddleOfMarkersView;
          rightArrowStart = positionInMiddleOfMarkersView;
        }

        // Draw the arrows pointing inside out.
        ctx.strokeStyle = arrowColor;
        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftArrowStart, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightArrowStart, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
      }

      ctx.restore();
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add results.
     */
    addIntersectingEventsInRangeToSelection(
        loVX, hiVX, loY, hiY, selection) {
      // Does nothing. There's nothing interesting to pick on the xAxis
      // track.
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
    }
  };

  return {
    XAxisTrack,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-timeline-track-view',

  ready() {
    this.displayTransform_ = new tr.ui.TimelineDisplayTransform();
    this.model_ = undefined;

    this.timelineView_ = undefined;
    this.pollIfViewportAttachedInterval_ = undefined;

    this.viewport_ = new tr.ui.TimelineViewport(this);
    this.viewportDisplayTransformAtMouseDown_ = undefined;
    this.brushingStateController_ = undefined;

    this.rulerTrackContainer_ =
        new tr.ui.tracks.DrawingContainer(this.viewport_);
    Polymer.dom(this).appendChild(this.rulerTrackContainer_);
    this.rulerTrackContainer_.invalidate();
    this.rulerTrackContainer_.style.overflowY = 'hidden';
    this.rulerTrackContainer_.style.flexShrink = '0';

    this.rulerTrack_ = new tr.ui.tracks.XAxisTrack(this.viewport_);
    Polymer.dom(this.rulerTrackContainer_).appendChild(this.rulerTrack_);

    this.upperModelTrack_ = new tr.ui.tracks.ModelTrack(this.viewport_);
    this.upperModelTrack_.upperMode = true;
    Polymer.dom(this.rulerTrackContainer_).appendChild(this.upperModelTrack_);

    this.modelTrackContainer_ =
        new tr.ui.tracks.DrawingContainer(this.viewport_);
    Polymer.dom(this).appendChild(this.modelTrackContainer_);
    this.modelTrackContainer_.style.display = 'block';
    this.modelTrackContainer_.style.flexGrow = '1';
    this.modelTrackContainer_.invalidate();

    this.viewport_.modelTrackContainer = this.modelTrackContainer_;

    this.modelTrack_ = new tr.ui.tracks.ModelTrack(this.viewport_);
    Polymer.dom(this.modelTrackContainer_).appendChild(this.modelTrack_);

    this.timingTool_ = new tr.ui.b.TimingTool(this.viewport_, this);

    this.initMouseModeSelector();

    this.hideDragBox_();

    this.initHintText_();

    this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);

    this.onDblClick_ = this.onDblClick_.bind(this);
    this.addEventListener('dblclick', this.onDblClick_);

    this.onMouseWheel_ = this.onMouseWheel_.bind(this);
    this.addEventListener('mousewheel', this.onMouseWheel_);

    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.addEventListener('mousedown', this.onMouseDown_);

    this.onMouseMove_ = this.onMouseMove_.bind(this);
    this.addEventListener('mousemove', this.onMouseMove_);

    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.addEventListener('touchstart', this.onTouchStart_);

    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.addEventListener('touchmove', this.onTouchMove_);

    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.addEventListener('touchend', this.onTouchEnd_);


    this.addHotKeys_();

    this.mouseViewPosAtMouseDown_ = {x: 0, y: 0};
    this.lastMouseViewPos_ = {x: 0, y: 0};

    this.lastTouchViewPositions_ = [];

    this.alert_ = undefined;

    this.isPanningAndScanning_ = false;
    this.isZooming_ = false;
  },

  initMouseModeSelector() {
    this.mouseModeSelector_ = document.createElement(
        'tr-ui-b-mouse-mode-selector');
    this.mouseModeSelector_.targetElement = this;
    Polymer.dom(this).appendChild(this.mouseModeSelector_);

    this.mouseModeSelector_.addEventListener('beginpan',
        this.onBeginPanScan_.bind(this));
    this.mouseModeSelector_.addEventListener('updatepan',
        this.onUpdatePanScan_.bind(this));
    this.mouseModeSelector_.addEventListener('endpan',
        this.onEndPanScan_.bind(this));

    this.mouseModeSelector_.addEventListener('beginselection',
        this.onBeginSelection_.bind(this));
    this.mouseModeSelector_.addEventListener('updateselection',
        this.onUpdateSelection_.bind(this));
    this.mouseModeSelector_.addEventListener('endselection',
        this.onEndSelection_.bind(this));

    this.mouseModeSelector_.addEventListener('beginzoom',
        this.onBeginZoom_.bind(this));
    this.mouseModeSelector_.addEventListener('updatezoom',
        this.onUpdateZoom_.bind(this));
    this.mouseModeSelector_.addEventListener('endzoom',
        this.onEndZoom_.bind(this));

    this.mouseModeSelector_.addEventListener('entertiming',
        this.timingTool_.onEnterTiming.bind(this.timingTool_));
    this.mouseModeSelector_.addEventListener('begintiming',
        this.timingTool_.onBeginTiming.bind(this.timingTool_));
    this.mouseModeSelector_.addEventListener('updatetiming',
        this.timingTool_.onUpdateTiming.bind(this.timingTool_));
    this.mouseModeSelector_.addEventListener('endtiming',
        this.timingTool_.onEndTiming.bind(this.timingTool_));
    this.mouseModeSelector_.addEventListener('exittiming',
        this.timingTool_.onExitTiming.bind(this.timingTool_));

    const m = tr.ui.b.MOUSE_SELECTOR_MODE;
    this.mouseModeSelector_.supportedModeMask =
        m.SELECTION | m.PANSCAN | m.ZOOM | m.TIMING;
    this.mouseModeSelector_.settingsKey =
        'timelineTrackView.mouseModeSelector';
    this.mouseModeSelector_.setKeyCodeForMode(m.PANSCAN, '2'.charCodeAt(0));
    this.mouseModeSelector_.setKeyCodeForMode(m.SELECTION, '1'.charCodeAt(0));
    this.mouseModeSelector_.setKeyCodeForMode(m.ZOOM, '3'.charCodeAt(0));
    this.mouseModeSelector_.setKeyCodeForMode(m.TIMING, '4'.charCodeAt(0));

    this.mouseModeSelector_.setModifierForAlternateMode(
        m.SELECTION, tr.ui.b.MODIFIER.SHIFT);
    this.mouseModeSelector_.setModifierForAlternateMode(
        m.PANSCAN, tr.ui.b.MODIFIER.SPACE);
  },

  get brushingStateController() {
    return this.brushingStateController_;
  },

  set brushingStateController(brushingStateController) {
    if (this.brushingStateController_) {
      this.brushingStateController_.removeEventListener('change',
          this.onSelectionChanged_);
    }
    this.brushingStateController_ = brushingStateController;
    if (this.brushingStateController_) {
      this.brushingStateController_.addEventListener('change',
          this.onSelectionChanged_);
    }
  },

  set timelineView(view) {
    this.timelineView_ = view;
  },

  onSelectionChanged_() {
    this.showHintText_('Press \'m\' to mark current selection');
    this.viewport_.dispatchChangeEvent();
  },

  set selection(selection) {
    throw new Error('DO NOT CALL THIS');
  },

  set highlight(highlight) {
    throw new Error('DO NOT CALL THIS');
  },

  detach() {
    this.modelTrack_.detach();
    this.upperModelTrack_.detach();

    if (this.pollIfViewportAttachedInterval_) {
      window.clearInterval(this.pollIfViewportAttachedInterval_);
      this.pollIfViewportAttachedInterval_ = undefined;
    }
    this.viewport_.detach();
  },

  get viewport() {
    return this.viewport_;
  },

  get model() {
    return this.model_;
  },

  set model(model) {
    if (!model) {
      throw new Error('Model cannot be undefined');
    }

    const modelInstanceChanged = this.model_ !== model;
    this.model_ = model;
    this.modelTrack_.model = model;
    this.upperModelTrack_.model = model;

    // Set up a reasonable viewport.
    if (modelInstanceChanged) {
      // The following code uses an interval to detect when the parent element
      // is attached to the document. That is a trigger to run the setup
      // function and install a resize listener.
      this.pollIfViewportAttachedInterval_ = window.setInterval(
          this.pollIfViewportAttached_.bind(this), 250);
    }
  },

  get hasVisibleContent() {
    return this.modelTrack_.hasVisibleContent ||
        this.upperModelTrack_.hasVisibleContent;
  },

  /**
   * Checks whether the parentNode is attached to the document.
   * When it is, the method installs the iframe-based resize detection hook
   * and then runs setInitialViewport_, if present.
   */
  pollIfViewportAttached_() {
    if (!this.viewport_.isAttachedToDocumentOrInTestMode ||
        this.viewport_.clientWidth === 0) {
      return;
    }
    window.addEventListener(
        'resize', this.viewport_.dispatchChangeEvent);
    window.clearInterval(this.pollIfViewportAttachedInterval_);
    this.pollIfViewportAttachedInterval_ = undefined;

    this.setInitialViewport_();
  },

  setInitialViewport_() {
    // We need the canvas size to be up-to-date at this point. We maybe in
    // here before the raf fires, so the size may have not been updated since
    // the canvas was resized.
    this.modelTrackContainer_.updateCanvasSizeIfNeeded_();
    const w = this.modelTrackContainer_.canvas.width;

    let min;
    let range;

    if (this.model_.bounds.isEmpty) {
      min = 0;
      range = 1000;
    } else if (this.model_.bounds.range === 0) {
      min = this.model_.bounds.min;
      range = 1000;
    } else {
      min = this.model_.bounds.min;
      range = this.model_.bounds.range;
    }

    const boost = range * 0.15;
    this.displayTransform_.set(this.viewport_.currentDisplayTransform);
    this.displayTransform_.xSetWorldBounds(
        min - boost, min + range + boost, w);
    this.viewport_.setDisplayTransformImmediately(this.displayTransform_);
  },

  /**
   * @param {Filter} filter The filter to use for finding matches.
   * @param {Selection} selection The selection to add matches to.
   * @return {Task} which performs the filtering.
   */
  addAllEventsMatchingFilterToSelectionAsTask(filter, selection) {
    const modelTrack = this.modelTrack_;
    const firstT = modelTrack.addAllEventsMatchingFilterToSelectionAsTask(
        filter, selection);
    const lastT = firstT.after(function() {
      this.upperModelTrack_.addAllEventsMatchingFilterToSelection(
          filter, selection);
    }, this);
    return firstT;
  },

  onMouseMove_(e) {
    // Zooming requires the delta since the last mousemove so we need to avoid
    // tracking it when the zoom interaction is active.
    if (this.isZooming_) return;

    this.storeLastMousePos_(e);
  },

  onTouchStart_(e) {
    this.storeLastTouchPositions_(e);
    this.focusElements_();
  },

  onTouchMove_(e) {
    e.preventDefault();
    this.onUpdateTransformForTouch_(e);
  },

  onTouchEnd_(e) {
    this.storeLastTouchPositions_(e);
    this.focusElements_();
  },

  addHotKeys_() {
    this.addKeyDownHotKeys_();
    this.addKeyPressHotKeys_();
  },

  addKeyPressHotKey(dict) {
    dict.eventType = 'keypress';
    dict.useCapture = false;
    dict.thisArg = this;
    const binding = new tr.ui.b.HotKey(dict);
    this.$.hotkey_controller.addHotKey(binding);
  },

  addKeyPressHotKeys_() {
    this.addKeyPressHotKey({
      keyCodes: ['w'.charCodeAt(0), ','.charCodeAt(0)],
      callback(e) {
        this.zoomBy_(1.5, true);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCodes: ['s'.charCodeAt(0), 'o'.charCodeAt(0)],
      callback(e) {
        this.zoomBy_(1 / 1.5, true);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'g'.charCodeAt(0),
      callback(e) {
        this.onGridToggle_(true);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'G'.charCodeAt(0),
      callback(e) {
        this.onGridToggle_(false);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCodes: ['W'.charCodeAt(0), '<'.charCodeAt(0)],
      callback(e) {
        this.zoomBy_(10, true);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCodes: ['S'.charCodeAt(0), 'O'.charCodeAt(0)],
      callback(e) {
        this.zoomBy_(1 / 10, true);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'a'.charCodeAt(0),
      callback(e) {
        this.queueSmoothPan_(this.viewWidth_ * 0.3, 0);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCodes: ['d'.charCodeAt(0), 'e'.charCodeAt(0)],
      callback(e) {
        this.queueSmoothPan_(this.viewWidth_ * -0.3, 0);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'A'.charCodeAt(0),
      callback(e) {
        this.queueSmoothPan_(viewWidth * 0.5, 0);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'D'.charCodeAt(0),
      callback(e) {
        this.queueSmoothPan_(viewWidth * -0.5, 0);
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: '0'.charCodeAt(0),
      callback(e) {
        this.setInitialViewport_();
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'f'.charCodeAt(0),
      callback(e) {
        this.zoomToSelection();
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'm'.charCodeAt(0),
      callback(e) {
        this.setCurrentSelectionAsInterestRange_();
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'p'.charCodeAt(0),
      callback(e) {
        this.selectPowerSamplesInCurrentTimeRange_();
        e.stopPropagation();
      }
    });

    this.addKeyPressHotKey({
      keyCode: 'h'.charCodeAt(0),
      callback(e) {
        this.toggleHighDetails_();
        e.stopPropagation();
      }
    });
  },

  get viewWidth_() {
    return this.modelTrackContainer_.canvas.clientWidth;
  },

  addKeyDownHotKeys_() {
    const addBinding = function(dict) {
      dict.eventType = 'keydown';
      dict.useCapture = false;
      dict.thisArg = this;
      const binding = new tr.ui.b.HotKey(dict);
      this.$.hotkey_controller.addHotKey(binding);
    }.bind(this);

    addBinding({
      keyCode: 37, // Left arrow.
      callback(e) {
        const curSel = this.brushingStateController_.selection;
        const sel = this.viewport.getShiftedSelection(curSel, -1);

        if (sel) {
          this.brushingStateController.changeSelectionFromTimeline(sel);
          this.panToSelection();
        } else {
          this.queueSmoothPan_(this.viewWidth_ * 0.3, 0);
        }
        e.preventDefault();
        e.stopPropagation();
      }
    });

    addBinding({
      keyCode: 39, // Right arrow.
      callback(e) {
        const curSel = this.brushingStateController_.selection;
        const sel = this.viewport.getShiftedSelection(curSel, 1);
        if (sel) {
          this.brushingStateController.changeSelectionFromTimeline(sel);
          this.panToSelection();
        } else {
          this.queueSmoothPan_(-this.viewWidth_ * 0.3, 0);
        }
        e.preventDefault();
        e.stopPropagation();
      }
    });
  },

  onDblClick_(e) {
    if (this.mouseModeSelector_.mode !==
        tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION) {
      return;
    }

    const curSelection = this.brushingStateController_.selection;
    if (!curSelection.length || !tr.b.getOnlyElement(curSelection).title) {
      return;
    }

    const selection = new tr.model.EventSet();
    const filter = new tr.c.ExactTitleFilter(
        tr.b.getOnlyElement(curSelection).title);
    this.modelTrack_.addAllEventsMatchingFilterToSelection(filter,
        selection);

    this.brushingStateController.changeSelectionFromTimeline(selection);
  },

  onMouseWheel_(e) {
    if (!e.altKey) return;

    const delta = e.wheelDelta / 120;
    const zoomScale = Math.pow(1.5, delta);
    this.zoomBy_(zoomScale);
    e.preventDefault();
  },

  onMouseDown_(e) {
    if (this.mouseModeSelector_.mode !==
        tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION) {
      return;
    }

    // Mouse down must start on ruler track for crosshair guide lines to draw.
    if (e.target !== this.rulerTrack_) return;

    // Make sure we don't start a selection drag event here.
    this.dragBeginEvent_ = undefined;

    // Remove nav string marker if it exists, since we're clearing the
    // find control box.
    if (this.xNavStringMarker_) {
      this.model.removeAnnotation(this.xNavStringMarker_);
      this.xNavStringMarker_ = undefined;
    }

    const dt = this.viewport_.currentDisplayTransform;
    tr.ui.b.trackMouseMovesUntilMouseUp(function(e) { // Mouse move handler.
      // If mouse event is on ruler, don't do anything.
      if (e.target === this.rulerTrack_) return;

      const relativePosition = this.extractRelativeMousePosition_(e);
      const loc = tr.model.Location.fromViewCoordinates(
          this.viewport_, relativePosition.x, relativePosition.y);
      // Not all points on the timeline represents a valid location.
      // ex. process header tracks, letter dot tracks.
      if (!loc) return;

      if (this.guideLineAnnotation_ === undefined) {
        this.guideLineAnnotation_ =
            new tr.model.XMarkerAnnotation(loc.xWorld);
        this.model.addAnnotation(this.guideLineAnnotation_);
      } else {
        this.guideLineAnnotation_.timestamp = loc.xWorld;
        this.modelTrackContainer_.invalidate();
      }

      // Set the findcontrol's text to nav string of current state.
      const state = new tr.ui.b.UIState(loc,
          this.viewport_.currentDisplayTransform.scaleX);
      this.timelineView_.setFindCtlText(
          state.toUserFriendlyString(this.viewport_));
    }.bind(this),
        undefined, // Mouse up handler.
        function onKeyUpDuringDrag() {
          if (this.dragBeginEvent_) {
            this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
                this.dragBoxXEnd_, this.dragBoxYEnd_);
          }
        }.bind(this));
  },

  queueSmoothPan_(viewDeltaX, deltaY) {
    const deltaX = this.viewport_.currentDisplayTransform.xViewVectorToWorld(
        viewDeltaX);
    const animation = new tr.ui.TimelineDisplayTransformPanAnimation(
        deltaX, deltaY);
    this.viewport_.queueDisplayTransformAnimation(animation);
  },

  /**
   * Zoom in or out on the timeline by the given scale factor.
   * @param {Number} scale The scale factor to apply.  If <1, zooms out.
   * @param {boolean} Whether to change the zoom level smoothly.
   */
  zoomBy_(scale, smooth) {
    if (scale <= 0) {
      return;
    }

    smooth = !!smooth;
    const vp = this.viewport_;
    const pixelRatio = window.devicePixelRatio || 1;

    const goalFocalPointXView = this.lastMouseViewPos_.x * pixelRatio;
    const goalFocalPointXWorld = vp.currentDisplayTransform.xViewToWorld(
        goalFocalPointXView);
    if (smooth) {
      const animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
          goalFocalPointXWorld, goalFocalPointXView,
          vp.currentDisplayTransform.panY,
          scale);
      vp.queueDisplayTransformAnimation(animation);
    } else {
      this.displayTransform_.set(vp.currentDisplayTransform);
      this.displayTransform_.scaleX *= scale;
      this.displayTransform_.xPanWorldPosToViewPos(
          goalFocalPointXWorld, goalFocalPointXView, this.viewWidth_);
      vp.setDisplayTransformImmediately(this.displayTransform_);
    }
  },

  /**
   * Zoom into the current selection.
   */
  zoomToSelection() {
    if (!this.brushingStateController.selectionOfInterest.length) return;

    const bounds = this.brushingStateController.selectionOfInterest.bounds;
    if (!bounds.range) return;

    const worldCenter = bounds.center;
    const viewCenter = this.modelTrackContainer_.canvas.width / 2;
    const adjustedWorldRange = bounds.range * 1.25;
    const newScale = this.modelTrackContainer_.canvas.width /
        adjustedWorldRange;
    const zoomInRatio = newScale /
        this.viewport_.currentDisplayTransform.scaleX;

    const animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
        worldCenter, viewCenter,
        this.viewport_.currentDisplayTransform.panY,
        zoomInRatio);
    this.viewport_.queueDisplayTransformAnimation(animation);
  },

  /**
   * Pan the view so the current selection becomes visible.
   */
  panToSelection() {
    if (!this.brushingStateController.selectionOfInterest.length) return;

    const bounds = this.brushingStateController.selectionOfInterest.bounds;
    const worldCenter = bounds.center;
    const viewWidth = this.viewWidth_;

    const dt = this.viewport_.currentDisplayTransform;
    if (false && !bounds.range) {
      if (dt.xWorldToView(bounds.center) < 0 ||
          dt.xWorldToView(bounds.center) > viewWidth) {
        this.displayTransform_.set(dt);
        this.displayTransform_.xPanWorldPosToViewPos(
            worldCenter, 'center', viewWidth);
        const deltaX = this.displayTransform_.panX - dt.panX;
        const animation = new tr.ui.TimelineDisplayTransformPanAnimation(
            deltaX, 0);
        this.viewport_.queueDisplayTransformAnimation(animation);
      }
      return;
    }

    this.displayTransform_.set(dt);
    this.displayTransform_.xPanWorldBoundsIntoView(
        bounds.min,
        bounds.max,
        viewWidth);
    const deltaX = this.displayTransform_.panX - dt.panX;
    const animation = new tr.ui.TimelineDisplayTransformPanAnimation(
        deltaX, 0);
    this.viewport_.queueDisplayTransformAnimation(animation);
  },

  navToPosition(uiState, showNavLine) {
    const location = uiState.location;
    const scaleX = uiState.scaleX;
    const track = location.getContainingTrack(this.viewport_);

    const worldCenter = location.xWorld;
    const viewCenter = this.modelTrackContainer_.canvas.width / 5;
    const zoomInRatio = scaleX /
        this.viewport_.currentDisplayTransform.scaleX;

    // Vertically scroll so track is in view.
    track.scrollIntoViewIfNeeded();

    // Perform zoom and panX animation.
    const animation = new tr.ui.TimelineDisplayTransformZoomToAnimation(
        worldCenter, viewCenter,
        this.viewport_.currentDisplayTransform.panY,
        zoomInRatio);
    this.viewport_.queueDisplayTransformAnimation(animation);

    if (!showNavLine) return;
    // Add an X Marker Annotation at the specified timestamp.
    if (this.xNavStringMarker_) {
      this.model.removeAnnotation(this.xNavStringMarker_);
    }
    this.xNavStringMarker_ =
        new tr.model.XMarkerAnnotation(worldCenter);
    this.model.addAnnotation(this.xNavStringMarker_);
  },

  selectPowerSamplesInCurrentTimeRange_() {
    const selectionBounds = this.brushingStateController_.selection.bounds;
    if (this.model.device.powerSeries && !selectionBounds.empty) {
      const events = this.model.device.powerSeries.getSamplesWithinRange(
          selectionBounds.min, selectionBounds.max);
      const selection = new tr.model.EventSet(events);
      this.brushingStateController_.changeSelectionFromTimeline(selection);
    }
  },

  setCurrentSelectionAsInterestRange_() {
    const selectionBounds = this.brushingStateController_.selection.bounds;
    if (selectionBounds.empty) {
      this.viewport_.interestRange.reset();
      return;
    }

    if (this.viewport_.interestRange.min === selectionBounds.min &&
        this.viewport_.interestRange.max === selectionBounds.max) {
      this.viewport_.interestRange.reset();
    } else {
      this.viewport_.interestRange.set(selectionBounds);
    }
  },

  toggleHighDetails_() {
    this.viewport_.highDetails = !this.viewport_.highDetails;
  },

  hideDragBox_() {
    this.$.drag_box.style.left = '-1000px';
    this.$.drag_box.style.top = '-1000px';
    this.$.drag_box.style.width = 0;
    this.$.drag_box.style.height = 0;
  },

  setDragBoxPosition_(xStart, yStart, xEnd, yEnd) {
    const loY = Math.min(yStart, yEnd);
    const hiY = Math.max(yStart, yEnd);
    const loX = Math.min(xStart, xEnd);
    const hiX = Math.max(xStart, xEnd);
    const modelTrackRect = this.modelTrack_.getBoundingClientRect();
    const dragRect = {left: loX, top: loY, width: hiX - loX, height: hiY - loY};

    dragRect.right = dragRect.left + dragRect.width;
    dragRect.bottom = dragRect.top + dragRect.height;

    const modelTrackContainerRect =
        this.modelTrackContainer_.getBoundingClientRect();
    const clipRect = {
      left: modelTrackContainerRect.left,
      top: modelTrackContainerRect.top,
      right: modelTrackContainerRect.right,
      bottom: modelTrackContainerRect.bottom
    };

    const headingWidth = window.getComputedStyle(
        Polymer.dom(this).querySelector('tr-ui-b-heading')).width;
    const trackTitleWidth = parseInt(headingWidth);
    clipRect.left = clipRect.left + trackTitleWidth;

    const intersectRect_ = function(r1, r2) {
      if (r2.left > r1.right || r2.right < r1.left ||
          r2.top > r1.bottom || r2.bottom < r1.top) {
        return false;
      }

      const results = {};
      results.left = Math.max(r1.left, r2.left);
      results.top = Math.max(r1.top, r2.top);
      results.right = Math.min(r1.right, r2.right);
      results.bottom = Math.min(r1.bottom, r2.bottom);
      results.width = results.right - results.left;
      results.height = results.bottom - results.top;
      return results;
    };

    // TODO(dsinclair): intersectRect_ can return false (which should actually
    // be undefined) but we use finalDragBox without checking the return value
    // which could potentially blowup. Fix this .....
    const finalDragBox = intersectRect_(clipRect, dragRect);

    this.$.drag_box.style.left = finalDragBox.left + 'px';
    this.$.drag_box.style.width = finalDragBox.width + 'px';
    this.$.drag_box.style.top = finalDragBox.top + 'px';
    this.$.drag_box.style.height = finalDragBox.height + 'px';
    this.$.drag_box.style.whiteSpace = 'nowrap';

    const pixelRatio = window.devicePixelRatio || 1;
    const canv = this.modelTrackContainer_.canvas;
    const dt = this.viewport_.currentDisplayTransform;
    const loWX = dt.xViewToWorld(
        (loX - canv.offsetLeft) * pixelRatio);
    const hiWX = dt.xViewToWorld(
        (hiX - canv.offsetLeft) * pixelRatio);

    Polymer.dom(this.$.drag_box).textContent =
        tr.b.Unit.byName.timeDurationInMs.format(hiWX - loWX);

    const e = new tr.b.Event('selectionChanging');
    e.loWX = loWX;
    e.hiWX = hiWX;
    this.dispatchEvent(e);
  },

  onGridToggle_(left) {
    const selection = this.brushingStateController_.selection;
    const tb = left ? selection.bounds.min : selection.bounds.max;

    // Toggle the grid off if the grid is on, the marker position is the same
    // and the same element is selected (same timebase).
    if (this.viewport_.gridEnabled &&
        this.viewport_.gridSide === left &&
        this.viewport_.gridInitialTimebase === tb) {
      this.viewport_.gridside = undefined;
      this.viewport_.gridEnabled = false;
      this.viewport_.gridInitialTimebase = undefined;
      return;
    }

    // Shift the timebase left until its just left of model_.bounds.min.
    const numIntervalsSinceStart = Math.ceil((tb - this.model_.bounds.min) /
        this.viewport_.gridStep_);

    this.viewport_.gridEnabled = true;
    this.viewport_.gridSide = left;
    this.viewport_.gridInitialTimebase = tb;
    this.viewport_.gridTimebase = tb -
        (numIntervalsSinceStart + 1) * this.viewport_.gridStep_;
  },

  storeLastMousePos_(e) {
    this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);
  },

  storeLastTouchPositions_(e) {
    this.lastTouchViewPositions_ = this.extractRelativeTouchPositions_(e);
  },

  extractRelativeMousePosition_(e) {
    const canv = this.modelTrackContainer_.canvas;
    return {
      x: e.clientX - canv.offsetLeft,
      y: e.clientY - canv.offsetTop
    };
  },

  extractRelativeTouchPositions_(e) {
    const canv = this.modelTrackContainer_.canvas;

    const touches = [];
    for (let i = 0; i < e.touches.length; ++i) {
      touches.push({
        x: e.touches[i].clientX - canv.offsetLeft,
        y: e.touches[i].clientY - canv.offsetTop
      });
    }
    return touches;
  },

  storeInitialMouseDownPos_(e) {
    const position = this.extractRelativeMousePosition_(e);

    this.mouseViewPosAtMouseDown_.x = position.x;
    this.mouseViewPosAtMouseDown_.y = position.y;
  },

  focusElements_() {
    this.$.hotkey_controller.childRequestsGeneralFocus(this);
  },

  storeInitialInteractionPositionsAndFocus_(e) {
    this.storeInitialMouseDownPos_(e);
    this.storeLastMousePos_(e);

    this.focusElements_();
  },

  onBeginPanScan_(e) {
    const vp = this.viewport_;
    this.viewportDisplayTransformAtMouseDown_ =
        vp.currentDisplayTransform.clone();
    this.isPanningAndScanning_ = true;

    this.storeInitialInteractionPositionsAndFocus_(e);
    e.preventDefault();
  },

  onUpdatePanScan_(e) {
    if (!this.isPanningAndScanning_) return;

    const viewWidth = this.viewWidth_;

    const pixelRatio = window.devicePixelRatio || 1;
    const xDeltaView = pixelRatio * (this.lastMouseViewPos_.x -
        this.mouseViewPosAtMouseDown_.x);

    const yDelta = this.lastMouseViewPos_.y -
        this.mouseViewPosAtMouseDown_.y;

    this.displayTransform_.set(this.viewportDisplayTransformAtMouseDown_);
    this.displayTransform_.incrementPanXInViewUnits(xDeltaView);
    this.displayTransform_.panY -= yDelta;
    this.viewport_.setDisplayTransformImmediately(this.displayTransform_);

    e.preventDefault();
    e.stopPropagation();

    this.storeLastMousePos_(e);
  },

  onEndPanScan_(e) {
    this.isPanningAndScanning_ = false;

    this.storeLastMousePos_(e);

    if (!e.isClick) {
      e.preventDefault();
    }
  },

  onBeginSelection_(e) {
    const canv = this.modelTrackContainer_.canvas;
    const rect = this.modelTrack_.getBoundingClientRect();
    const canvRect = canv.getBoundingClientRect();

    const inside = rect &&
        e.clientX >= rect.left &&
        e.clientX < rect.right &&
        e.clientY >= rect.top &&
        e.clientY < rect.bottom &&
        e.clientX >= canvRect.left &&
        e.clientX < canvRect.right;

    if (!inside) return;

    this.dragBeginEvent_ = e;

    this.storeInitialInteractionPositionsAndFocus_(e);
    e.preventDefault();
  },

  onUpdateSelection_(e) {
    if (!this.dragBeginEvent_) return;

    // Update the drag box
    this.dragBoxXStart_ = this.dragBeginEvent_.clientX;
    this.dragBoxXEnd_ = e.clientX;
    this.dragBoxYStart_ = this.dragBeginEvent_.clientY;
    this.dragBoxYEnd_ = e.clientY;
    this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
        this.dragBoxXEnd_, this.dragBoxYEnd_);
  },

  onEndSelection_(e) {
    e.preventDefault();

    if (!this.dragBeginEvent_) return;

    // Stop the dragging.
    this.hideDragBox_();
    const eDown = this.dragBeginEvent_;
    this.dragBeginEvent_ = undefined;

    // Figure out extents of the drag.
    const loY = Math.min(eDown.clientY, e.clientY);
    const hiY = Math.max(eDown.clientY, e.clientY);
    const loX = Math.min(eDown.clientX, e.clientX);
    const hiX = Math.max(eDown.clientX, e.clientX);

    // Convert to worldspace.
    const canv = this.modelTrackContainer_.canvas;
    const worldOffset = canv.getBoundingClientRect().left;
    const loVX = loX - worldOffset;
    const hiVX = hiX - worldOffset;

    // Figure out what has been selected.
    const selection = new tr.model.EventSet();
    if (eDown.appendSelection) {
      const previousSelection = this.brushingStateController_.selection;
      if (previousSelection !== undefined) {
        selection.addEventSet(previousSelection);
      }
    }
    this.modelTrack_.addIntersectingEventsInRangeToSelection(
        loVX, hiVX, loY, hiY, selection);

    // Activate the new selection.
    this.brushingStateController_.changeSelectionFromTimeline(selection);
  },

  onBeginZoom_(e) {
    this.isZooming_ = true;

    this.storeInitialInteractionPositionsAndFocus_(e);
    e.preventDefault();
  },

  onUpdateZoom_(e) {
    if (!this.isZooming_) return;

    const newPosition = this.extractRelativeMousePosition_(e);

    const zoomScaleValue = 1 + (this.lastMouseViewPos_.y -
        newPosition.y) * 0.01;

    this.zoomBy_(zoomScaleValue, false);
    this.storeLastMousePos_(e);
  },

  onEndZoom_(e) {
    this.isZooming_ = false;

    if (!e.isClick) {
      e.preventDefault();
    }
  },

  computeTouchCenter_(positions) {
    let xSum = 0;
    let ySum = 0;
    for (let i = 0; i < positions.length; ++i) {
      xSum += positions[i].x;
      ySum += positions[i].y;
    }
    return {
      x: xSum / positions.length,
      y: ySum / positions.length
    };
  },

  computeTouchSpan_(positions) {
    let xMin = Number.MAX_VALUE;
    let yMin = Number.MAX_VALUE;
    let xMax = Number.MIN_VALUE;
    let yMax = Number.MIN_VALUE;
    for (let i = 0; i < positions.length; ++i) {
      xMin = Math.min(xMin, positions[i].x);
      yMin = Math.min(yMin, positions[i].y);
      xMax = Math.max(xMax, positions[i].x);
      yMax = Math.max(yMax, positions[i].y);
    }
    return Math.sqrt((xMin - xMax) * (xMin - xMax) +
        (yMin - yMax) * (yMin - yMax));
  },

  onUpdateTransformForTouch_(e) {
    const newPositions = this.extractRelativeTouchPositions_(e);
    const currentPositions = this.lastTouchViewPositions_;

    const newCenter = this.computeTouchCenter_(newPositions);
    const currentCenter = this.computeTouchCenter_(currentPositions);

    const newSpan = this.computeTouchSpan_(newPositions);
    const currentSpan = this.computeTouchSpan_(currentPositions);

    const vp = this.viewport_;
    const viewWidth = this.viewWidth_;
    const pixelRatio = window.devicePixelRatio || 1;

    const xDelta = pixelRatio * (newCenter.x - currentCenter.x);
    const yDelta = newCenter.y - currentCenter.y;
    const zoomScaleValue = currentSpan > 10 ? newSpan / currentSpan : 1;

    const viewFocus = pixelRatio * newCenter.x;
    const worldFocus = vp.currentDisplayTransform.xViewToWorld(viewFocus);

    this.displayTransform_.set(vp.currentDisplayTransform);
    this.displayTransform_.scaleX *= zoomScaleValue;
    this.displayTransform_.xPanWorldPosToViewPos(
        worldFocus, viewFocus, viewWidth);
    this.displayTransform_.incrementPanXInViewUnits(xDelta);
    this.displayTransform_.panY -= yDelta;
    vp.setDisplayTransformImmediately(this.displayTransform_);
    this.storeLastTouchPositions_(e);
  },

  initHintText_() {
    this.$.hint_text.style.display = 'none';

    this.pendingHintTextClearTimeout_ = undefined;
  },

  showHintText_(text) {
    if (this.pendingHintTextClearTimeout_) {
      window.clearTimeout(this.pendingHintTextClearTimeout_);
      this.pendingHintTextClearTimeout_ = undefined;
    }
    this.pendingHintTextClearTimeout_ = setTimeout(
        this.hideHintText_.bind(this), 1000);
    Polymer.dom(this.$.hint_text).textContent = text;
    this.$.hint_text.style.display = '';
  },

  hideHintText_() {
    this.pendingHintTextClearTimeout_ = undefined;
    this.$.hint_text.style.display = 'none';
  }
});


'use strict';

Polymer({
  is: 'tr-ui-find-control',

  filterKeyDown(e) {
    if (e.keyCode === 27) {
      const hkc = tr.b.getHotkeyControllerForElement(this);
      if (hkc) {
        hkc.childRequestsBlur(this);
      } else {
        this.blur();
      }
      e.preventDefault();
      e.stopPropagation();
      return;
    } else if (e.keyCode === 13) {
      if (e.shiftKey) {
        this.findPrevious();
      } else {
        this.findNext();
      }
    }
  },

  filterBlur(e) {
    this.updateHitCountEl();
  },

  filterFocus(e) {
    this.$.filter.select();
  },

  // Prevent that the input text is deselected after focusing the find
  // control with the mouse.
  filterMouseUp(e) {
    e.preventDefault();
  },

  get controller() {
    return this.controller_;
  },

  set controller(c) {
    this.controller_ = c;
    this.updateHitCountEl();
  },

  focus() {
    this.$.filter.focus();
  },

  get hasFocus() {
    return this === document.activeElement;
  },

  filterTextChanged() {
    Polymer.dom(this.$.hitCount).textContent = '';
    this.$.spinner.style.visibility = 'visible';
    this.$.spinner.style.animation = 'spin 1s linear infinite';
    this.controller.startFiltering(this.$.filter.value).then(function() {
      this.$.spinner.style.visibility = 'hidden';
      this.$.spinner.style.animation = '';
      this.updateHitCountEl();
    }.bind(this));
  },

  findNext() {
    if (this.controller) {
      this.controller.findNext();
    }
    this.updateHitCountEl();
  },

  findPrevious() {
    if (this.controller) {
      this.controller.findPrevious();
    }
    this.updateHitCountEl();
  },

  updateHitCountEl() {
    if (!this.controller || this.$.filter.value.length === 0) {
      Polymer.dom(this.$.hitCount).textContent = '';
      return;
    }

    const n = this.controller.filterHits.length;
    const i = n === 0 ? -1 : this.controller.currentHitIndex;
    Polymer.dom(this.$.hitCount).textContent = (i + 1) + ' of ' + n;
  },

  setText(string) {
    this.$.filter.value = string;
  }
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function Context() {
    this.event = undefined;
    this.ancestors = [];
  }

  Context.prototype = {
    push(event) {
      const ctx = new Context();
      ctx.ancestors = this.ancestors.slice();
      ctx.ancestors.push(event);
      return ctx;
    },

    pop(event) {
      const ctx = new Context();
      ctx.event = this.ancestors[this.ancestors.length - 1];
      ctx.ancestors = this.ancestors.slice(0, this.ancestors.length - 1);
      return ctx;
    }
  };

  return {
    Context,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function Filter() {
    tr.c.ScriptingObject.call(this);
  }

  Filter.normalizeFilterExpression = function(filterExpression) {
    // Shortcut: naked strings and regexps can be used to match against slice
    // titles.
    if (filterExpression instanceof String ||
        typeof(filterExpression) === 'string' ||
        filterExpression instanceof RegExp) {
      const filter = new tr.e.tquery.FilterHasTitle(filterExpression);
      return filter;
    }
    return filterExpression;
  };

  Filter.prototype = {
    __proto__: tr.c.ScriptingObject.prototype,

    evaluate(context) {
      throw new Error('Not implemented');
    },

    matchValue_(value, expected) {
      if (expected instanceof RegExp) {
        return expected.test(value);
      } else if (expected instanceof Function) {
        return expected(value);
      }
      return value === expected;
    }
  };

  return {
    Filter,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterAllOf(opt_subExpressions) {
    tr.e.tquery.Filter.call(this);
    this.subExpressions = opt_subExpressions || [];
  }

  FilterAllOf.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpressions(exprs) {
      this.subExpressions_ = [];
      for (let i = 0; i < exprs.length; i++) {
        this.subExpressions_.push(
            tr.e.tquery.Filter.normalizeFilterExpression(exprs[i]));
      }
    },

    get subExpressions() {
      return this.subExpressions_;
    },

    evaluate(context) {
      if (!this.subExpressions.length) return true;
      for (let i = 0; i < this.subExpressions.length; i++) {
        if (!this.subExpressions[i].evaluate(context)) {
          return false;
        }
      }
      return true;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function() {
        const exprs = [];
        for (let i = 0; i < arguments.length; i++) {
          exprs.push(arguments[i]);
        }
        return new FilterAllOf(exprs);
      },
      {
        name: 'allOf'
      }
  );
  return {
    FilterAllOf,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterNot(subExpression) {
    tr.e.tquery.Filter.call(this);
    this.subExpression = subExpression;
  }

  FilterNot.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpression(expr) {
      this.subExpression_ = tr.e.tquery.Filter.normalizeFilterExpression(expr);
    },

    get subExpression() {
      return this.subExpression_;
    },

    evaluate(context) {
      return !this.subExpression.evaluate(context);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function() {
        const exprs = Array.prototype.slice.call(arguments);
        if (exprs.length !== 1) {
          throw new Error('not() must have exactly one subexpression');
        }
        return new FilterNot(exprs[0]);
      },
      {
        name: 'not'
      }
  );
  return {
    FilterNot,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterAnyOf(opt_subExpressions) {
    tr.e.tquery.Filter.call(this);
    this.subExpressions = opt_subExpressions || [];
  }

  FilterAnyOf.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpressions(exprs) {
      this.subExpressions_ = [];
      for (let i = 0; i < exprs.length; i++) {
        this.subExpressions_.push(
            tr.e.tquery.Filter.normalizeFilterExpression(exprs[i]));
      }
    },

    get subExpressions() {
      return this.subExpressions_;
    },

    evaluate(context) {
      if (!this.subExpressions.length) return true;
      for (let i = 0; i < this.subExpressions.length; i++) {
        if (this.subExpressions[i].evaluate(context)) return true;
      }
      return false;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function() {
        const exprs = Array.prototype.slice.call(arguments);
        return new FilterAnyOf(exprs);
      },
      {
        name: 'anyOf'
      }
  );
  tr.c.ScriptingObjectRegistry.register(
      function() {
        const exprs = Array.prototype.slice.call(arguments);
        return new tr.e.tquery.FilterNot(new FilterAnyOf(exprs));
      },
      {
        name: 'noneOf'
      }
  );
  return {
    FilterAnyOf,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasAncestor(opt_subExpression) {
    this.subExpression = opt_subExpression;
  }

  FilterHasAncestor.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpression(expr) {
      this.subExpression_ = tr.e.tquery.Filter.normalizeFilterExpression(expr);
    },

    get subExpression() {
      return this.subExpression_;
    },

    evaluate(context) {
      if (!this.subExpression) {
        return context.ancestors.length > 0;
      }
      while (context.ancestors.length) {
        context = context.pop();
        if (this.subExpression.evaluate(context)) return true;
      }
      return false;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(subExpression) {
        return new FilterHasAncestor(subExpression);
      },
      {
        name: 'hasAncestor'
      }
  );
  return {
    FilterHasAncestor,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasDuration(minValueOrExpected, opt_maxValue) {
    if (minValueOrExpected !== undefined && opt_maxValue !== undefined) {
      this.minValue = minValueOrExpected;
      this.maxValue = opt_maxValue;
    } else {
      this.expected = minValueOrExpected;
    }
  }

  FilterHasDuration.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    evaluate(context) {
      if (context.event.duration === undefined) return false;
      if (this.minValue !== undefined && this.maxValue !== undefined) {
        return context.event.duration >= this.minValue &&
               context.event.duration <= this.maxValue;
      }
      return this.matchValue_(context.event.duration, this.expected);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(minValueOrExpected, opt_maxValue) {
        return new FilterHasDuration(minValueOrExpected, opt_maxValue);
      },
      {
        name: 'hasDuration'
      }
  );
  return {
    FilterHasDuration,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterHasTitle(expected) {
    tr.e.tquery.Filter.call(this);
    this.expected = expected;
  }

  FilterHasTitle.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    evaluate(context) {
      return this.matchValue_(context.event.title, this.expected);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(expected) {
        const filter = new tr.e.tquery.FilterHasTitle(expected);
        return filter;
      },
      {
        name: 'hasTitle'
      }
  );

  return {
    FilterHasTitle,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function FilterIsTopLevel(opt_subExpression) {
    this.subExpression = opt_subExpression;
  }

  FilterIsTopLevel.prototype = {
    __proto__: tr.e.tquery.Filter.prototype,

    set subExpression(expr) {
      this.subExpression_ = tr.e.tquery.Filter.normalizeFilterExpression(expr);
    },

    get subExpression() {
      return this.subExpression_;
    },

    evaluate(context) {
      if (context.ancestors.length > 0) return false;
      if (!this.subExpression) return true;
      return this.subExpression.evaluate(context);
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      function(subExpression) {
        return new FilterIsTopLevel(subExpression);
      },
      {
        name: 'isTopLevel'
      }
  );
  return {
    FilterIsTopLevel,
  };
});


'use strict';

tr.exportTo('tr.e.tquery', function() {
  function addEventTreeToSelection(selection, event) {
    selection.push(event);
    if (!event.subSlices) return;
    event.subSlices.forEach(
        addEventTreeToSelection.bind(undefined, selection));
  }

  function TQuery(model) {
    tr.c.ScriptingObject.call(this);

    this.model_ = model;
    this.parent_ = undefined;
    this.filterExpression_ = undefined;
    // Memoized filtering result.
    this.selection_ = undefined;
  }

  TQuery.prototype = {
    __proto__: tr.c.ScriptingObject.prototype,

    onModelChanged(model) {
      this.model_ = model;
      this.selection_ = undefined;
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    // Append a new filter expression to this query and return a query node
    // that represents the result.
    filter(filterExpression) {
      const result = new TQuery(this.model_);
      result.parent_ = this;
      result.filterExpression_ =
          tr.e.tquery.Filter.normalizeFilterExpression(filterExpression);
      return result;
    },

    // Creates a graph of {Task} objects which will compute the selections for
    // this filter object and all of its parents. The return value is an object
    // with the following fields:
    //  - rootTask: {Task} which should be executed to kick off processing for
    //              the entire task graph.
    //  - lastTask: The final {Task} of the graph. Can be used by the caller to
    //              enqueue additional processing at the end.
    //  - lastNode: The last filter object in the task. It's selection property
    //              will contain the filtering result once |finalTask|
    //              completes.
    createFilterTaskGraph_() {
      // List of nodes in order from the current one to the root.
      const nodes = [this];
      while (nodes[nodes.length - 1].parent_) {
        nodes.push(nodes[nodes.length - 1].parent_);
      }

      const rootTask = new tr.b.Task();
      let lastTask = rootTask;
      let node;
      for (let i = nodes.length - 1; i >= 0; i--) {
        node = nodes[i];
        // Reuse any memoized result.
        if (node.selection_ !== undefined) continue;
        node.selection_ = new tr.model.EventSet();
        if (node.parent_ === undefined) {
          // If this is the root, start by collecting all objects from the
          // model.
          lastTask = lastTask.after(
              this.selectEverythingAsTask_(node.selection_));
        } else {
          // Otherwise execute the filter expression for this node and fill
          // in its selection.
          const prevNode = nodes[i + 1];
          lastTask = this.createFilterTaskForNode_(lastTask, node, prevNode);
        }
      }
      return {rootTask, lastTask, lastNode: node};
    },

    createFilterTaskForNode_(lastTask, node, prevNode) {
      return lastTask.after(function() {
        // TODO(skyostil): Break into subtasks.
        node.evaluateFilterExpression_(
            prevNode.selection_, node.selection_);
      }, this);
    },

    // Applies the result of a filter expression for a given event and all
    // of its subslices and adds the matching events to an output selection.
    evaluateFilterExpression_(inputSelection, outputSelection) {
      const seenEvents = {};
      inputSelection.forEach(function(event) {
        const context = new tr.e.tquery.Context();
        context.event = event;
        this.evaluateFilterExpressionForEvent_(
            context, inputSelection, outputSelection, seenEvents);
      }.bind(this));
    },

    evaluateFilterExpressionForEvent_(
        context, inputSelection, outputSelection, seenEvents) {
      const event = context.event;
      if (inputSelection.contains(event) && !seenEvents[event.guid]) {
        seenEvents[event.guid] = true;
        if (!this.filterExpression_ ||
            this.filterExpression_.evaluate(context)) {
          outputSelection.push(event);
        }
      }
      if (!event.subSlices) return;
      context = context.push(event);
      for (let i = 0; i < event.subSlices.length; i++) {
        context.event = event.subSlices[i];
        this.evaluateFilterExpressionForEvent_(
            context, inputSelection, outputSelection, seenEvents);
      }
    },

    // Returns a task that fills the given selection with everything in the
    // model.
    selectEverythingAsTask_(selection) {
      const filterTask = new tr.b.Task();
      for (const container of this.model_.getDescendantEventContainers()) {
        filterTask.subTask(() => {
          for (const event of container.childEvents()) {
            addEventTreeToSelection(selection, event);
          }
        }, this);
      }
      return filterTask;
    },

    // Returns a promise which will resolve into a {EventSet} representing the
    // result of this query.
    ready() {
      return new Promise(function(resolve, reject) {
        const graph = this.createFilterTaskGraph_();
        graph.lastTask = graph.lastTask.after(function() {
          resolve(this.selection_);
        }, this);
        tr.b.Task.RunWhenIdle(graph.rootTask);
      }.bind(this));
    },

    get selection() {
      if (this.selection_ === undefined) {
        const graph = this.createFilterTaskGraph_();
        tr.b.Task.RunSynchronously(graph.rootTask);
      }
      return this.selection_;
    }
  };
  tr.c.ScriptingObjectRegistry.register(
      new TQuery(),
      {
        name: '$t'
      }
  );

  return {
    TQuery,
  };
});


'use strict';

Polymer({
  is: 'tr-ui-scripting-control',

  isEnterKey_(event) {
    // Check if in IME.
    // Remove keyIdentifier after reference build rolls past M51 when
    // KeyboardEvent.key was added.
    return event.keyCode !== 229 &&
      (event.key === 'Enter' || event.keyIdentifier === 'Enter');
  },

  setFocus_(focused) {
    const promptEl = this.$.prompt;
    if (focused) {
      promptEl.focus();
      Polymer.dom(this.$.root).classList.add('focused');
      // Move cursor to the end of any existing text.
      if (promptEl.value.length > 0) {
        const sel = window.getSelection();
        sel.collapse(
            Polymer.dom(promptEl).firstChild, promptEl.value.length);
      }
    } else {
      promptEl.blur();
      Polymer.dom(this.$.root).classList.remove('focused');
      // Workaround for crbug.com/89026 to ensure the prompt doesn't retain
      // keyboard focus.
      const parent = promptEl.parentElement;
      const nextEl = Polymer.dom(promptEl).nextSibling;
      promptEl.remove();
      Polymer.dom(parent).insertBefore(promptEl, nextEl);
    }
  },

  onConsoleFocus(e) {
    e.stopPropagation();
    this.setFocus_(true);
  },

  onConsoleBlur(e) {
    e.stopPropagation();
    this.setFocus_(false);
  },

  promptKeyDown(e) {
    e.stopPropagation();
    if (!this.isEnterKey_(e)) return;

    e.preventDefault();
    const promptEl = this.$.prompt;
    const command = promptEl.value;
    if (command.length === 0) return;

    promptEl.value = '';
    this.addLine_(String.fromCharCode(187) + ' ' + command);

    let result;
    try {
      result = this.controller_.executeCommand(command);
    } catch (e) {
      result = e.stack || e.stackTrace;
    }

    if (result instanceof tr.e.tquery.TQuery) {
      // TODO(skyostil): Show a cool spinner.
      result.ready().then(function(selection) {
        this.addLine_(selection.length + ' matches');
        this.controller_.brushingStateController.
            showScriptControlSelection(selection);
      }.bind(this));
    } else {
      this.addLine_(result);
    }
    promptEl.scrollIntoView();
  },

  addLine_(line) {
    const historyEl = this.$.history;
    if (historyEl.innerText.length !== 0) {
      historyEl.innerText += '\n';
    }
    historyEl.innerText += line;
  },

  promptKeyPress(e) {
    e.stopPropagation();
  },

  toggleVisibility() {
    const root = this.$.root;
    if (!this.visible) {
      Polymer.dom(root).classList.remove('hidden');
      this.setFocus_(true);
    } else {
      Polymer.dom(root).classList.add('hidden');
      this.setFocus_(false);
    }
  },

  get hasFocus() {
    return this === document.activeElement;
  },

  get visible() {
    const root = this.$.root;
    return !Polymer.dom(root).classList.contains('hidden');
  },

  get controller() {
    return this.controller_;
  },

  set controller(c) {
    this.controller_ = c;
  }
});


'use strict';

tr.exportTo('tr.ui.behaviors', function() {
  const SidePanel = {

    get rangeOfInterest() {
      throw new Error('Not implemented');
    },

    set rangeOfInterest(rangeOfInterest) {
      throw new Error('Not implemented');
    },

    get selection() {
      throw new Error('Not implemented');
    },

    set selection(selection) {
      throw new Error('Not implemented');
    },

    get model() {
      throw new Error('Not implemented');
    },

    set model(model) {
      throw new Error('Not implemented');
    },

    supportsModel(m) {
      throw new Error('Not implemented');
    }
  };

  return {
    SidePanel,
  };
});


'use strict';

// TODO(charliea): This can probably be cleaned up so that we don't have to
// manually wrap the Polymer element names with a function and
// `document.createElement` at each of the registration sites by creating a
// new "Polymer" registration mode.
tr.exportTo('tr.ui.side_panel', function() {
  /**
   * SidePanelRegistry is an entity for side panel Polymer elements to register
   * on so that they'll render a side panel if the model has the correct data.
   *
   * Example usage:
   *
   *   SidePanelRegistry.register(function() {
   *     return document.createElement('my-side-panel');
   *   });
   *
   * @constructor
   */
  function SidePanelRegistry() {}

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(SidePanelRegistry, options);

  return {
    SidePanelRegistry,
  };
});


'use strict';
Polymer({
  is: 'tr-ui-side-panel-container',

  ready() {
    this.activePanelContainer_ = this.$.active_panel_container;
    this.tabStrip_ = this.$.tab_strip;

    this.dragHandle_ = this.$.side_panel_drag_handle;
    this.dragHandle_.horizontal = false;
    this.dragHandle_.target = this.activePanelContainer_;
    this.rangeOfInterest_ = new tr.b.math.Range();
    this.brushingStateController_ = undefined;
    this.onSelectionChanged_ = this.onSelectionChanged_.bind(this);
    this.onModelChanged_ = this.onModelChanged_.bind(this);
  },

  get brushingStateController() {
    return this.brushingStateController_;
  },

  set brushingStateController(brushingStateController) {
    if (this.brushingStateController) {
      this.brushingStateController_.removeEventListener(
          'change', this.onSelectionChanged_);
      this.brushingStateController_.removeEventListener(
          'model-changed', this.onModelChanged_);
    }
    this.brushingStateController_ = brushingStateController;
    if (this.brushingStateController) {
      this.brushingStateController_.addEventListener(
          'change', this.onSelectionChanged_);
      this.brushingStateController_.addEventListener(
          'model-changed', this.onModelChanged_);
      if (this.model) {
        this.onModelChanged_();
      }
    }
  },

  onSelectionChanged_() {
    if (this.activePanel) {
      this.activePanel.selection = this.selection;
    }
  },

  get model() {
    return this.brushingStateController_.model;
  },

  onModelChanged_() {
    this.activePanelType_ = undefined;
    this.updateContents_();
  },

  get expanded() {
    this.hasAttribute('expanded');
  },

  get activePanel() {
    return this.activePanelContainer_.children[0];
  },

  get activePanelType() {
    return this.activePanelType_;
  },

  set activePanelType(panelType) {
    if (this.model === undefined) {
      throw new Error('Cannot activate panel without a model');
    }

    let panel = undefined;
    if (panelType) {
      panel = document.createElement(panelType);
    }

    if (panel !== undefined && !panel.supportsModel(this.model)) {
      throw new Error('Cannot activate panel: does not support this model');
    }

    if (this.activePanelType) {
      Polymer.dom(this.getLabelElementForPanelType_(
          this.activePanelType)).removeAttribute('selected');
    }

    if (this.activePanelType) {
      this.getLabelElementForPanelType_(
          this.activePanelType).removeAttribute('selected');
    }

    if (this.activePanel) {
      this.activePanelContainer_.removeChild(this.activePanel);
    }

    if (panelType === undefined) {
      Polymer.dom(this).removeAttribute('expanded');
      this.activePanelType_ = undefined;
      return;
    }

    Polymer.dom(this.getLabelElementForPanelType_(panelType)).
        setAttribute('selected', true);
    Polymer.dom(this).setAttribute('expanded', true);

    Polymer.dom(this.activePanelContainer_).appendChild(panel);
    panel.rangeOfInterest = this.rangeOfInterest_;
    panel.selection = this.selection_;
    panel.model = this.model;

    this.activePanelType_ = panelType;
  },

  getPanelTypeForConstructor_(constructor) {
    for (let i = 0; i < this.tabStrip_.children.length; i++) {
      if (this.tabStrip_.children[i].panelType.constructor === constructor) {
        return this.tabStrip_.children[i].panelType;
      }
    }
  },

  getLabelElementForPanelType_(panelType) {
    for (let i = 0; i < this.tabStrip_.children.length; i++) {
      if (this.tabStrip_.children[i].panelType === panelType) {
        return this.tabStrip_.children[i];
      }
    }
    return undefined;
  },

  updateContents_() {
    const previouslyActivePanelType = this.activePanelType;

    Polymer.dom(this.tabStrip_).textContent = '';
    const supportedPanelTypes = [];
    const panelTypeInfos =
      tr.ui.side_panel.SidePanelRegistry.getAllRegisteredTypeInfos();
    const unsupportedLabelEls = [];

    for (const panelTypeInfo of panelTypeInfos) {
      const labelEl = document.createElement('tab-strip-label');
      const panel = panelTypeInfo.constructor();
      const panelType = panel.tagName;

      Polymer.dom(labelEl).textContent = panel.textLabel;
      labelEl.panelType = panelType;

      const supported = panel.supportsModel(this.model);
      if (this.model && supported.supported) {
        supportedPanelTypes.push(panelType);
        Polymer.dom(labelEl).setAttribute('enabled', true);
        labelEl.addEventListener('click', function(panelType) {
          this.activePanelType =
              this.activePanelType === panelType ? undefined : panelType;
        }.bind(this, panelType));
        Polymer.dom(this.tabStrip_).appendChild(labelEl);
      } else {
        if (this.activePanel) {
          this.activePanelContainer_.removeChild(this.activePanel);
        }
        this.removeAttribute('expanded');
        unsupportedLabelEls.push(labelEl);
      }
    }

    // Labels do not shrink, so when the user drags the analysis-view up, the
    // bottom labels are obscured first.
    // Append all unsupported panel labels after all supported panel labels so
    // that unsupported panel labels are obscured first.
    for (const labelEl of unsupportedLabelEls) {
      Polymer.dom(this.tabStrip_).appendChild(labelEl);
    }

    // Restore the active panel, or collapse
    if (previouslyActivePanelType &&
        supportedPanelTypes.includes(previouslyActivePanelType)) {
      this.activePanelType = previouslyActivePanelType;
      Polymer.dom(this).setAttribute('expanded', true);
    } else {
      if (this.activePanel) {
        Polymer.dom(this.activePanelContainer_).removeChild(this.activePanel);
      }
      Polymer.dom(this).removeAttribute('expanded');
    }
  },

  get rangeOfInterest() {
    return this.rangeOfInterest_;
  },

  set rangeOfInterest(range) {
    if (range === undefined) {
      throw new Error('Must not be undefined');
    }
    this.rangeOfInterest_ = range;
    if (this.activePanel) {
      this.activePanel.rangeOfInterest = range;
    }
  }
});


'use strict';

Polymer({
  is: 'tr-ui-timeline-view-help-overlay',

  ready() {
    const mod = tr.isMac ? 'cmd ' : 'ctrl';
    const spans = Polymer.dom(this.root).querySelectorAll(
        'span.mod');
    for (let i = 0; i < spans.length; i++) {
      Polymer.dom(spans[i]).textContent = mod;
    }
  }
});


'use strict';

Polymer({
  is: 'tr-ui-timeline-view-metadata-overlay',

  created() {
    this.metadata_ = undefined;
  },

  ready() {
    this.$.table.tableColumns = [
      {
        title: 'name',
        value: d => d.name,
      },
      {
        title: 'value',
        value: d => {
          const gov = document.createElement('tr-ui-a-generic-object-view');
          gov.object = d.value;
          return gov;
        },
      }
    ];
  },

  get metadata() {
    return this.metadata_;
  },

  set metadata(metadata) {
    this.metadata_ = metadata;
    this.$.table.tableRows = this.metadata_;
    this.$.table.rebuild();
  }
});


  'use strict';
  Polymer({
    is: 'tr-v-ui-preferred-display-unit',

    ready() {
      this.preferredTimeDisplayMode_ = undefined;
    },

    attached() {
      tr.b.Unit.didPreferredTimeDisplayUnitChange();
    },

    detached() {
      tr.b.Unit.didPreferredTimeDisplayUnitChange();
    },

    // null means no-preference
    get preferredTimeDisplayMode() {
      return this.preferredTimeDisplayMode_;
    },

    set preferredTimeDisplayMode(v) {
      if (this.preferredTimeDisplayMode_ === v) return;
      this.preferredTimeDisplayMode_ = v;
      tr.b.Unit.didPreferredTimeDisplayUnitChange();
    }

  });


'use strict';

Polymer({
  is: 'tr-ui-timeline-view',

  created() {
    this.trackViewContainer_ = undefined;

    this.queuedModel_ = undefined;

    this.builtPromise_ = undefined;
    this.doneBuilding_ = undefined;
  },

  attached() {
    this.async(function() {
      this.trackViewContainer_ = Polymer.dom(this).querySelector(
          '#track_view_container');
      if (!this.trackViewContainer_) {
        throw new Error('missing trackviewContainer');
      }

      if (this.queuedModel_) this.updateContents_();
    });
  },

  ready() {
    this.tabIndex = 0; // Let the timeline able to receive key events.

    this.titleEl_ = this.$.title;
    this.leftControlsEl_ = this.$.left_controls;
    this.rightControlsEl_ = this.$.right_controls;
    this.collapsingControlsEl_ = this.$.collapsing_controls;
    this.sidePanelContainer_ = this.$.side_panel_container;

    this.brushingStateController_ = new tr.c.BrushingStateController(this);

    this.findCtl_ = this.$.view_find_control;
    this.findCtl_.controller = new tr.ui.FindController(
        this.brushingStateController_);

    this.scriptingCtl_ = document.createElement('tr-ui-scripting-control');
    this.scriptingCtl_.controller = new tr.c.ScriptingController(
        this.brushingStateController_);

    this.sidePanelContainer_.brushingStateController =
        this.brushingStateController_;

    if (window.tr.metrics && window.tr.metrics.sh &&
        window.tr.metrics.sh.SystemHealthMetric) {
      this.railScoreSpan_ = document.createElement(
          'tr-metrics-ui-sh-system-health-span');
      Polymer.dom(this.rightControls).appendChild(this.railScoreSpan_);
    } else {
      this.railScoreSpan_ = undefined;
    }

    this.optionsDropdown_ = this.$.view_options_dropdown;
    Polymer.dom(this.optionsDropdown_.iconElement).textContent = 'View Options';

    this.showFlowEvents_ = false;
    Polymer.dom(this.optionsDropdown_).appendChild(tr.ui.b.createCheckBox(
        this, 'showFlowEvents',
        'tr.ui.TimelineView.showFlowEvents', false,
        'Flow events'));
    this.highlightVSync_ = false;
    this.highlightVSyncCheckbox_ = tr.ui.b.createCheckBox(
        this, 'highlightVSync',
        'tr.ui.TimelineView.highlightVSync', false,
        'Highlight VSync');
    Polymer.dom(this.optionsDropdown_).appendChild(
        this.highlightVSyncCheckbox_);

    this.initMetadataButton_();
    this.initConsoleButton_();
    this.initHelpButton_();

    Polymer.dom(this.collapsingControls).appendChild(this.scriptingCtl_);

    this.dragEl_ = this.$.drag_handle;

    this.analysisEl_ = this.$.analysis;
    this.analysisEl_.brushingStateController = this.brushingStateController_;

    this.addEventListener(
        'requestSelectionChange',
        function(e) {
          const sc = this.brushingStateController_;
          sc.changeSelectionFromRequestSelectionChangeEvent(e.selection);
        }.bind(this));

    // Bookkeeping.
    this.onViewportChanged_ = this.onViewportChanged_.bind(this);
    this.bindKeyListeners_();

    this.dragEl_.target = this.analysisEl_;
  },

  get globalMode() {
    return this.hotkeyController.globalMode;
  },

  set globalMode(globalMode) {
    globalMode = !!globalMode;
    this.brushingStateController_.historyEnabled = globalMode;
    this.hotkeyController.globalMode = globalMode;
  },

  get hotkeyController() {
    return this.$.hkc;
  },

  updateDocumentFavicon() {
    let hue;
    if (!this.model) {
      hue = 'blue';
    } else {
      hue = this.model.faviconHue;
    }

    let faviconData = tr.ui.b.FaviconsByHue[hue];
    if (faviconData === undefined) {
      faviconData = tr.ui.b.FaviconsByHue.blue;
    }

    // Find link if its there
    let link = Polymer.dom(document.head).querySelector(
        'link[rel="shortcut icon"]');
    if (!link) {
      link = document.createElement('link');
      link.rel = 'shortcut icon';
      Polymer.dom(document.head).appendChild(link);
    }
    link.href = faviconData;
  },

  get showFlowEvents() {
    return this.showFlowEvents_;
  },

  set showFlowEvents(showFlowEvents) {
    this.showFlowEvents_ = showFlowEvents;
    if (!this.trackView_) return;

    this.trackView_.viewport.showFlowEvents = showFlowEvents;
  },

  get highlightVSync() {
    return this.highlightVSync_;
  },

  set highlightVSync(highlightVSync) {
    this.highlightVSync_ = highlightVSync;
    if (!this.trackView_) return;

    this.trackView_.viewport.highlightVSync = highlightVSync;
  },

  initHelpButton_() {
    const helpButtonEl = this.$.view_help_button;

    const dlg = new tr.ui.b.Overlay();
    dlg.title = 'Chrome Tracing Help';
    dlg.visible = false;
    dlg.appendChild(
        document.createElement('tr-ui-timeline-view-help-overlay'));

    function onClick(e) {
      dlg.visible = !dlg.visible;
      // Stop event so it doesn't trigger new click listener on document.
      e.stopPropagation();
    }

    helpButtonEl.addEventListener('click', onClick.bind(this));
  },

  initConsoleButton_() {
    const toggleEl = this.$.view_console_button;

    function onClick(e) {
      this.scriptingCtl_.toggleVisibility();
      e.stopPropagation();
      return false;
    }
    toggleEl.addEventListener('click', onClick.bind(this));
  },

  initMetadataButton_() {
    const showEl = this.$.view_metadata_button;

    function onClick(e) {
      const dlg = new tr.ui.b.Overlay();
      dlg.title = 'Metadata for trace';

      const metadataOverlay = document.createElement(
          'tr-ui-timeline-view-metadata-overlay');
      metadataOverlay.metadata = this.model.metadata;

      Polymer.dom(dlg).appendChild(metadataOverlay);
      dlg.visible = true;

      e.stopPropagation();
      return false;
    }
    showEl.addEventListener('click', onClick.bind(this));

    this.updateMetadataButtonVisibility_();
  },

  updateMetadataButtonVisibility_() {
    const showEl = this.$.view_metadata_button;
    showEl.style.display =
        (this.model && this.model.metadata.length) ? '' : 'none';
  },

  get leftControls() {
    return this.leftControlsEl_;
  },

  get rightControls() {
    return this.rightControlsEl_;
  },

  get collapsingControls() {
    return this.collapsingControlsEl_;
  },

  get viewTitle() {
    return Polymer.dom(this.titleEl_).textContent.substring(
        Polymer.dom(this.titleEl_).textContent.length - 2);
  },

  set viewTitle(text) {
    if (text === undefined) {
      Polymer.dom(this.titleEl_).textContent = '';
      this.titleEl_.hidden = true;
      return;
    }
    this.titleEl_.hidden = false;
    Polymer.dom(this.titleEl_).textContent = text;
  },

  get model() {
    if (this.trackView_) {
      return this.trackView_.model;
    }
    return undefined;
  },

  set model(model) {
    this.build(model);
  },

  async build(model) {
    this.queuedModel_ = model;
    this.builtPromise_ = new Promise((resolve, reject) => {
      this.doneBuilding_ = resolve;
    });
    if (this.trackViewContainer_) await this.updateContents_();
  },

  get builtPromise() {
    return this.builtPromise_;
  },

  async updateContents_() {
    if (this.trackViewContainer_ === undefined) {
      throw new Error(
          'timeline-view.updateContents_ requires trackViewContainer_');
    }

    const model = this.queuedModel_;
    this.queuedModel_ = undefined;

    const modelInstanceChanged = model !== this.model;
    const modelValid = model && !model.bounds.isEmpty;

    const importWarningsEl = Polymer.dom(this.root).querySelector(
        '#import-warnings');
    Polymer.dom(importWarningsEl).textContent = '';

    // Remove old trackView if the model has completely changed.
    if (modelInstanceChanged) {
      if (this.railScoreSpan_) {
        this.railScoreSpan_.model = undefined;
      }
      Polymer.dom(this.trackViewContainer_).textContent = '';
      if (this.trackView_) {
        this.trackView_.viewport.removeEventListener(
            'change', this.onViewportChanged_);
        this.trackView_.brushingStateController = undefined;
        this.trackView_.detach();
        this.trackView_ = undefined;
      }
      this.brushingStateController_.modelWillChange();
    }

    // Create new trackView if needed.
    if (modelValid && !this.trackView_) {
      this.trackView_ = document.createElement('tr-ui-timeline-track-view');
      this.trackView_.timelineView = this;

      this.trackView.brushingStateController = this.brushingStateController_;

      Polymer.dom(this.trackViewContainer_).appendChild(this.trackView_);
      this.trackView_.viewport.addEventListener(
          'change', this.onViewportChanged_);
    }

    // Set the model.
    if (modelValid) {
      this.trackView_.model = model;
      this.trackView_.viewport.showFlowEvents = this.showFlowEvents;
      this.trackView_.viewport.highlightVSync = this.highlightVSync;
      if (this.railScoreSpan_) {
        this.railScoreSpan_.model = model;
      }

      this.$.display_unit.preferredTimeDisplayMode = model.intrinsicTimeUnit;
    }

    if (model) {
      for (const warning of model.importWarningsThatShouldBeShownToUser) {
        importWarningsEl.addMessage(
            `Import Warning: ${warning.type}: ${warning.message}`, [{
              buttonText: 'Dismiss',
              onClick(event, infobar) {
                infobar.visible = false;
              }
            }]);
      }
    }

    // Do things that are selection specific
    if (modelInstanceChanged) {
      this.updateMetadataButtonVisibility_();
      this.brushingStateController_.modelDidChange();
      this.onViewportChanged_();
    }

    this.doneBuilding_();
  },

  get brushingStateController() {
    return this.brushingStateController_;
  },

  get trackView() {
    return this.trackView_;
  },

  get settings() {
    if (!this.settings_) {
      this.settings_ = new tr.b.Settings();
    }
    return this.settings_;
  },

  /**
   * Deprecated. Kept around because third_party code occasionally calls
   * this to set up embedding.
   */
  set focusElement(value) {
    throw new Error('This is deprecated. Please set globalMode to true.');
  },

  bindKeyListeners_() {
    const hkc = this.hotkeyController;

    // Shortcuts that *can* steal focus from the console and the filter text
    // box.
    hkc.addHotKey(new tr.ui.b.HotKey({
      eventType: 'keypress',
      keyCode: '`'.charCodeAt(0),
      useCapture: true,
      thisArg: this,
      callback(e) {
        this.scriptingCtl_.toggleVisibility();
        if (!this.scriptingCtl_.hasFocus) {
          this.focus();
        }
        e.stopPropagation();
      }
    }));

    // Shortcuts that *can* steal focus from the filter text box.
    hkc.addHotKey(new tr.ui.b.HotKey({
      eventType: 'keypress',
      keyCode: '/'.charCodeAt(0),
      useCapture: true,
      thisArg: this,
      callback(e) {
        if (this.scriptingCtl_.hasFocus) return;

        if (this.findCtl_.hasFocus) {
          this.focus();
        } else {
          this.findCtl_.focus();
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }));

    // Shortcuts that *can't* steal focus.
    hkc.addHotKey(new tr.ui.b.HotKey({
      eventType: 'keypress',
      keyCode: '?'.charCodeAt(0),
      useCapture: false,
      thisArg: this,
      callback(e) {
        this.$.view_help_button.click();
        e.stopPropagation();
      }
    }));

    hkc.addHotKey(new tr.ui.b.HotKey({
      eventType: 'keypress',
      keyCode: 'v'.charCodeAt(0),
      useCapture: false,
      thisArg: this,
      callback(e) {
        this.toggleHighlightVSync_();
        e.stopPropagation();
      }
    }));
  },

  onViewportChanged_(e) {
    const spc = this.sidePanelContainer_;
    if (!this.trackView_) {
      spc.rangeOfInterest.reset();
      return;
    }

    const vr = this.trackView_.viewport.interestRange.asRangeObject();
    if (!spc.rangeOfInterest.equals(vr)) {
      spc.rangeOfInterest = vr;
    }

    if (this.railScoreSpan_ && this.model) {
      this.railScoreSpan_.model = this.model;
    }
  },

  toggleHighlightVSync_() {
    this.highlightVSyncCheckbox_.checked =
        !this.highlightVSyncCheckbox_.checked;
  },

  setFindCtlText(string) {
    this.findCtl_.setText(string);
  }
});


'use strict';

let g_timelineViewEl;

(function() {
  const styleEl = document.createElement('style');
  const lines = [
    'html, body {',
    '  box-sizing: border-box;',
    '  overflow: hidden;',
    '  margin: 0px;',
    '  padding: 0;',
    '  width: 100%;',
    '  height: 100%;',
    '}',
    'tr-ui-timeline-view {',
    '  width: 100%;',
    '  height: 100%;',
    '}',
    'tr-ui-timeline-view:focus {',
    '  outline: none;',
    '}'
  ];
  Polymer.dom(styleEl).textContent = lines.join('\n');
  Polymer.dom(document.head).appendChild(styleEl);
})();

document.addEventListener('DOMContentLoaded', function() {
  const container = document.createElement('track-view-container');
  container.id = 'track_view_container';

  g_timelineViewEl = document.createElement('tr-ui-timeline-view');
  Polymer.dom(g_timelineViewEl).appendChild(container);

  Polymer.dom(document.body).appendChild(g_timelineViewEl);

  const traces = [];
  const viewerDataScripts = Polymer.dom(document).querySelectorAll(
      '#viewer-data');
  for (let i = 0; i < viewerDataScripts.length; i++) {
    let text = Polymer.dom(viewerDataScripts[i]).textContent;
    // Trim leading newlines off the text. They happen during writing.
    while (text[0] === '\n') {
      text = text.substring(1);
    }
    traces.push(tr.b.Base64.atob(text));
  }

  const m = new tr.Model();
  const i = new tr.importer.Import(m);
  const p = i.importTracesWithProgressDialog(traces);
  p.then(
      function() {
        g_timelineViewEl.model = m;
        g_timelineViewEl.updateDocumentFavicon();
        g_timelineViewEl.globalMode = true;
        g_timelineViewEl.viewTitle = document.title;
      },
      function(err) {
        const overlay = new tr.ui.b.Overlay();
        Polymer.dom(overlay).textContent = tr.b.normalizeException(err).message;
        overlay.title = 'Import error';
        overlay.visible = true;
      });
});


'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
tr.exportTo('tr.importer', function() {
  function Importer() { }

  Importer.prototype = {
    __proto__: Object.prototype,

    get importerName() {
      return 'Importer';
    },

    /**
     * Called by the Model to check whether the importer type stores the actual
     * trace data or just holds it as container for further extraction.
     */
    isTraceDataContainer() {
      return false;
    },

    /**
     * Called by the Model to extract one or more subtraces from the event data.
     */
    extractSubtraces() {
      return [];
    },

    /**
     * Called to import clock sync markers into the Model.
     */
    importClockSyncMarkers() {
    },

    /**
     * Called to import events into the Model.
     */
    importEvents() {
    },

    /**
     * Called to import sample data into the Model.
     */
    importSampleData() {
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport() {
    }
  };


  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Importer;
  tr.b.decorateExtensionRegistry(Importer, options);

  Importer.findImporterFor = function(eventData) {
    const typeInfo = Importer.findTypeInfoMatching(function(ti) {
      return ti.constructor.canImport(eventData);
    });
    if (typeInfo) {
      return typeInfo.constructor;
    }
    return undefined;
  };

  return {
    Importer,
  };
});



'use strict';

/**
 * @fileoverview GcloudTraceImporter imports JSON data from Google Cloud Trace.
 */
tr.exportTo('tr.e.importer.gcloud_trace', function() {
  function GcloudTraceImporter(model, eventData) {
    this.importPriority = 2;
    this.eventData_ = eventData;
  }

  /**
   * @return {boolean} Whether obj looks like the JSON output from Cloud Trace.
   */
  GcloudTraceImporter.canImport = function(eventData) {
    if (typeof(eventData) !== 'string' && !(eventData instanceof String)) {
      return false;
    }

    // Slice the data so we don't potentially do a replace on a gigantic string.
    const normalizedEventData = eventData.slice(0, 20).replace(/\s/g, '');
    if (normalizedEventData.length < 14) return false;

    return normalizedEventData.slice(0, 14) === '{"projectId":"';
  };

  GcloudTraceImporter.prototype = {

    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'GcloudTraceImporter';
    },

    /**
     * Called by the Model to extract subtraces from the event data. The
     * subtraces are passed on to other importers that can recognize them.
     */
    extractSubtraces() {
      const traceEvents = this.createEventsForTrace();
      return traceEvents ? [traceEvents] : [];
    },

    createEventsForTrace() {
      const events = [];
      const trace = JSON.parse(this.eventData_);
      const spanLength = trace.spans.length;
      for (let i = 0; i < spanLength; i++) {
        events.push(this.createEventForSpan(trace.traceId, trace.spans[i]));
      }
      return {
        'traceEvents': events
      };
    },

    createEventForSpan(traceId, span) {
      let newArgs = {};
      if (span.labels) {
        newArgs = JSON.parse(JSON.stringify(span.labels));
      }
      newArgs['Span ID'] = span.spanId;
      newArgs['Start Time'] = span.startTime;
      newArgs['End Time'] = span.endTime;
      if (span.parentSpanId) {
        newArgs['Parent Span ID'] = span.parentSpanId;
      }
      // The timestamps are ISO-standard strings, which are parsed to millis,
      // then converted to the micros that the trace viewer expects.
      return {
        name: span.name,
        args: newArgs,
        pid: traceId,
        ts: Date.parse(span.startTime) * 1000,
        dur: (Date.parse(span.endTime) - Date.parse(span.startTime)) * 1000,
        cat: 'tracespan',
        tid: traceId,
        ph: 'X'
      };
    }
  };

  tr.importer.Importer.register(GcloudTraceImporter);

  return {
    GcloudTraceImporter,
  };
});


'use strict';

/**
 * @fileoverview Class for managing android-specific model meta data,
 * such as rendering apps, and frames rendered.
 */
tr.exportTo('tr.model.helpers', function() {
  const Frame = tr.model.Frame;
  const Statistics = tr.b.math.Statistics;

  const UI_DRAW_TYPE = {
    NONE: 'none',
    LEGACY: 'legacy',
    MARSHMALLOW: 'marshmallow'
  };

  const UI_THREAD_DRAW_NAMES = {
    'performTraversals': UI_DRAW_TYPE.LEGACY,
    'Choreographer#doFrame': UI_DRAW_TYPE.MARSHMALLOW
  };

  const RENDER_THREAD_DRAW_NAME = 'DrawFrame';
  const RENDER_THREAD_INDEP_DRAW_NAME = 'doFrame';
  const RENDER_THREAD_QUEUE_NAME = 'queueBuffer';
  const RENDER_THREAD_SWAP_NAME = 'eglSwapBuffers';
  const THREAD_SYNC_NAME = 'syncFrameState';

  function getSlicesForThreadTimeRanges(threadTimeRanges) {
    const ret = [];
    threadTimeRanges.forEach(function(threadTimeRange) {
      const slices = [];

      threadTimeRange.thread.sliceGroup.iterSlicesInTimeRange(
          function(slice) { slices.push(slice); },
          threadTimeRange.start, threadTimeRange.end);
      ret.push.apply(ret, slices);
    });
    return ret;
  }

  function makeFrame(threadTimeRanges, surfaceFlinger) {
    const args = {};
    if (surfaceFlinger && surfaceFlinger.hasVsyncs) {
      const start = Statistics.min(threadTimeRanges,
          function(threadTimeRanges) { return threadTimeRanges.start; });
      args.deadline = surfaceFlinger.getFrameDeadline(start);
      args.frameKickoff = surfaceFlinger.getFrameKickoff(start);
    }
    const events = getSlicesForThreadTimeRanges(threadTimeRanges);
    return new Frame(events, threadTimeRanges, args);
  }

  function findOverlappingDrawFrame(renderThread, uiDrawSlice) {
    if (!renderThread) return undefined;

    // of all top level renderthread slices, find the one that has a 'sync'
    // within the uiDrawSlice
    let overlappingDrawFrame;
    const slices = tr.b.iterateOverIntersectingIntervals(
        renderThread.sliceGroup.slices,
        function(range) { return range.start; },
        function(range) { return range.end; },
        uiDrawSlice.start,
        uiDrawSlice.end,
        function(rtDrawSlice) {
          if (rtDrawSlice.title === RENDER_THREAD_DRAW_NAME) {
            const rtSyncSlice = rtDrawSlice.findDescendentSlice(
                THREAD_SYNC_NAME);
            if (rtSyncSlice &&
                rtSyncSlice.start >= uiDrawSlice.start &&
                rtSyncSlice.end <= uiDrawSlice.end) {
              // sync observed which overlaps ui draw. This means the RT draw
              // corresponds to the UI draw
              overlappingDrawFrame = rtDrawSlice;
            }
          }
        });
    return overlappingDrawFrame;
  }

  /**
   * Builds an array of {start, end} ranges grouping common work of a frame
   * that occurs just before performTraversals().
   *
   * Only necessary before Choreographer#doFrame tracing existed.
   */
  function getPreTraversalWorkRanges(uiThread) {
    if (!uiThread) return [];

    // gather all frame work that occurs outside of performTraversals
    const preFrameEvents = [];
    uiThread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title === 'obtainView' ||
          slice.title === 'setupListItem' ||
          slice.title === 'deliverInputEvent' ||
          slice.title === 'RV Scroll') {
        preFrameEvents.push(slice);
      }
    });
    uiThread.asyncSliceGroup.slices.forEach(function(slice) {
      if (slice.title === 'deliverInputEvent') {
        preFrameEvents.push(slice);
      }
    });

    return tr.b.math.mergeRanges(
        tr.b.math.convertEventsToRanges(preFrameEvents),
        3,
        function(events) {
          return {
            start: events[0].min,
            end: events[events.length - 1].max
          };
        });
  }

  function getFrameStartTime(traversalStart, preTraversalWorkRanges) {
    const preTraversalWorkRange =
      tr.b.findClosestIntervalInSortedIntervals(
          preTraversalWorkRanges,
          function(range) { return range.start; },
          function(range) { return range.end; },
          traversalStart,
          3);

    if (preTraversalWorkRange) {
      return preTraversalWorkRange.start;
    }
    return traversalStart;
  }

  function getRtFrameEndTime(rtDrawSlice) {
    // First try and get time that frame is queued:
    const rtQueueSlice = rtDrawSlice.findDescendentSlice(
        RENDER_THREAD_QUEUE_NAME);
    if (rtQueueSlice) {
      return rtQueueSlice.end;
    }
    // failing that, end of swapbuffers:
    const rtSwapSlice = rtDrawSlice.findDescendentSlice(
        RENDER_THREAD_SWAP_NAME);
    if (rtSwapSlice) {
      return rtSwapSlice.end;
    }
    // failing that, end of renderthread frame trace
    return rtDrawSlice.end;
  }

  function getUiThreadDrivenFrames(app) {
    if (!app.uiThread) return [];

    let preTraversalWorkRanges = [];
    if (app.uiDrawType === UI_DRAW_TYPE.LEGACY) {
      preTraversalWorkRanges = getPreTraversalWorkRanges(app.uiThread);
    }

    const frames = [];
    app.uiThread.sliceGroup.slices.forEach(function(slice) {
      if (!(slice.title in UI_THREAD_DRAW_NAMES)) {
        return;
      }

      const threadTimeRanges = [];
      const uiThreadTimeRange = {
        thread: app.uiThread,
        start: getFrameStartTime(slice.start, preTraversalWorkRanges),
        end: slice.end
      };
      threadTimeRanges.push(uiThreadTimeRange);

      // on SDK 21+ devices with RenderThread,
      // account for time taken on RenderThread
      const rtDrawSlice = findOverlappingDrawFrame(
          app.renderThread, slice);
      if (rtDrawSlice) {
        const rtSyncSlice = rtDrawSlice.findDescendentSlice(THREAD_SYNC_NAME);
        if (rtSyncSlice) {
          // Generally, the UI thread is only on the critical path
          // until the start of sync.
          uiThreadTimeRange.end = Math.min(uiThreadTimeRange.end,
              rtSyncSlice.start);
        }

        threadTimeRanges.push({
          thread: app.renderThread,
          start: rtDrawSlice.start,
          end: getRtFrameEndTime(rtDrawSlice)
        });
      }
      frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
    });
    return frames;
  }

  function getRenderThreadDrivenFrames(app) {
    if (!app.renderThread) return [];

    const frames = [];
    app.renderThread.sliceGroup.getSlicesOfName(RENDER_THREAD_INDEP_DRAW_NAME)
        .forEach(function(slice) {
          const threadTimeRanges = [{
            thread: app.renderThread,
            start: slice.start,
            end: slice.end
          }];
          frames.push(makeFrame(threadTimeRanges, app.surfaceFlinger));
        });
    return frames;
  }

  function getUiDrawType(uiThread) {
    if (!uiThread) {
      return UI_DRAW_TYPE.NONE;
    }

    const slices = uiThread.sliceGroup.slices;
    for (let i = 0; i < slices.length; i++) {
      if (slices[i].title in UI_THREAD_DRAW_NAMES) {
        return UI_THREAD_DRAW_NAMES[slices[i].title];
      }
    }
    return UI_DRAW_TYPE.NONE;
  }

  function getInputSamples(process) {
    let samples = undefined;
    for (const counterName in process.counters) {
      if (/^android\.aq\:pending/.test(counterName) &&
        process.counters[counterName].numSeries === 1) {
        samples = process.counters[counterName].series[0].samples;
        break;
      }
    }

    if (!samples) return [];

    // output rising edges only, since those are user inputs
    const inputSamples = [];
    let lastValue = 0;
    samples.forEach(function(sample) {
      if (sample.value > lastValue) {
        inputSamples.push(sample);
      }
      lastValue = sample.value;
    });
    return inputSamples;
  }

  function getAnimationAsyncSlices(uiThread) {
    if (!uiThread) return [];

    const slices = [];
    for (const slice of uiThread.asyncSliceGroup.getDescendantEvents()) {
      if (/^animator\:/.test(slice.title)) {
        slices.push(slice);
      }
    }
    return slices;
  }

  /**
   * Model for Android App specific data.
   * @constructor
   */
  function AndroidApp(process, uiThread, renderThread, surfaceFlinger,
      uiDrawType) {
    this.process = process;
    this.uiThread = uiThread;
    this.renderThread = renderThread;
    this.surfaceFlinger = surfaceFlinger;
    this.uiDrawType = uiDrawType;

    this.frames_ = undefined;
    this.inputs_ = undefined;
  }

  AndroidApp.createForProcessIfPossible = function(process, surfaceFlinger) {
    let uiThread = process.getThread(process.pid);
    const uiDrawType = getUiDrawType(uiThread);
    if (uiDrawType === UI_DRAW_TYPE.NONE) {
      uiThread = undefined;
    }
    const renderThreads = process.findAllThreadsNamed('RenderThread');
    const renderThread = (renderThreads.length === 1 ?
        renderThreads[0] : undefined);

    if (uiThread || renderThread) {
      return new AndroidApp(process, uiThread, renderThread, surfaceFlinger,
        uiDrawType);
    }
  };

  AndroidApp.prototype = {
  /**
   * Returns a list of all frames in the trace for the app,
   * constructed on first query.
   */
    getFrames() {
      if (!this.frames_) {
        const uiFrames = getUiThreadDrivenFrames(this);
        const rtFrames = getRenderThreadDrivenFrames(this);
        this.frames_ = uiFrames.concat(rtFrames);

        // merge frames by sorting by end timestamp
        this.frames_.sort(function(a, b) { a.end - b.end; });
      }
      return this.frames_;
    },

    /**
     * Returns list of CounterSamples for each input event enqueued to the app.
     */
    getInputSamples() {
      if (!this.inputs_) {
        this.inputs_ = getInputSamples(this.process);
      }
      return this.inputs_;
    },

    getAnimationAsyncSlices() {
      if (!this.animations_) {
        this.animations_ = getAnimationAsyncSlices(this.uiThread);
      }
      return this.animations_;
    }
  };

  return {
    AndroidApp,
  };
});


'use strict';

/**
 * @fileoverview Class for representing SurfaceFlinger process and its Vsyncs.
 */
tr.exportTo('tr.model.helpers', function() {
  const findLowIndexInSortedArray = tr.b.findLowIndexInSortedArray;

  const VSYNC_SF_NAME = 'android.VSYNC-sf';
  const VSYNC_APP_NAME = 'android.VSYNC-app';
  const VSYNC_FALLBACK_NAME = 'android.VSYNC';

  // when sampling vsync, push samples back by this much to ensure
  // frame start samples *between* vsyncs
  const TIMESTAMP_FUDGE_MS = 0.01;

  function getVsyncTimestamps(process, counterName) {
    let vsync = process.counters[counterName];
    if (!vsync) {
      vsync = process.counters[VSYNC_FALLBACK_NAME];
    }

    if (vsync && vsync.numSeries === 1 && vsync.numSamples > 1) {
      return vsync.series[0].timestamps;
    }
    return undefined;
  }

  /**
   * Model for SurfaceFlinger specific data.
   * @constructor
   */
  function AndroidSurfaceFlinger(process, thread) {
    this.process = process;
    this.thread = thread;

    this.appVsync_ = undefined;
    this.sfVsync_ = undefined;

    this.appVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_APP_NAME);
    this.sfVsyncTimestamps_ = getVsyncTimestamps(process, VSYNC_SF_NAME);

    // separation of vsync of app vs sf - assume app has at least window of 5ms
    this.deadlineDelayMs_ =
        this.appVsyncTimestamps_ !== this.sfVsyncTimestamps_ ?
        5 : TIMESTAMP_FUDGE_MS;
  }

  AndroidSurfaceFlinger.createForProcessIfPossible = function(process) {
    const mainThread = process.getThread(process.pid);

    // newer versions - main thread, lowercase name, preceeding forward slash
    if (mainThread && mainThread.name &&
        /surfaceflinger/.test(mainThread.name)) {
      return new AndroidSurfaceFlinger(process, mainThread);
    }

    // older versions - another thread is named SurfaceFlinger
    const primaryThreads = process.findAllThreadsNamed('SurfaceFlinger');
    if (primaryThreads.length === 1) {
      return new AndroidSurfaceFlinger(process, primaryThreads[0]);
    }
    return undefined;
  };

  AndroidSurfaceFlinger.prototype = {
    get hasVsyncs() {
      return !!this.appVsyncTimestamps_ && !!this.sfVsyncTimestamps_;
    },

    getFrameKickoff(timestamp) {
      if (!this.hasVsyncs) {
        throw new Error('cannot query vsync info without vsyncs');
      }

      const firstGreaterIndex =
          findLowIndexInSortedArray(this.appVsyncTimestamps_,
              function(x) { return x; },
              timestamp + TIMESTAMP_FUDGE_MS);

      if (firstGreaterIndex < 1) return undefined;
      return this.appVsyncTimestamps_[firstGreaterIndex - 1];
    },

    getFrameDeadline(timestamp) {
      if (!this.hasVsyncs) {
        throw new Error('cannot query vsync info without vsyncs');
      }

      const firstGreaterIndex =
          findLowIndexInSortedArray(this.sfVsyncTimestamps_,
              function(x) { return x; },
              timestamp + this.deadlineDelayMs_);
      if (firstGreaterIndex >= this.sfVsyncTimestamps_.length) {
        return undefined;
      }
      return this.sfVsyncTimestamps_[firstGreaterIndex];
    }
  };

  return {
    AndroidSurfaceFlinger,
  };
});


'use strict';

/**
 * @fileoverview Class for managing android-specific model meta data,
 * such as rendering apps, frames rendered, and SurfaceFlinger.
 */
tr.exportTo('tr.model.helpers', function() {
  const AndroidApp = tr.model.helpers.AndroidApp;
  const AndroidSurfaceFlinger = tr.model.helpers.AndroidSurfaceFlinger;

  const IMPORTANT_SURFACE_FLINGER_SLICES = {
    'doComposition': true,
    'updateTexImage': true,
    'postFramebuffer': true
  };
  const IMPORTANT_UI_THREAD_SLICES = {
    'Choreographer#doFrame': true,
    'performTraversals': true,
    'deliverInputEvent': true
  };
  const IMPORTANT_RENDER_THREAD_SLICES = {
    'doFrame': true
  };

  function iterateImportantThreadSlices(thread, important, callback) {
    if (!thread) return;

    thread.sliceGroup.slices.forEach(function(slice) {
      if (slice.title in important) {
        callback(slice);
      }
    });
  }

  /**
   * Model for Android-specific data.
   * @constructor
   */
  function AndroidModelHelper(model) {
    this.model = model;
    this.apps = [];
    this.surfaceFlinger = undefined;

    const processes = model.getAllProcesses();
    for (let i = 0; i < processes.length && !this.surfaceFlinger; i++) {
      this.surfaceFlinger =
          AndroidSurfaceFlinger.createForProcessIfPossible(processes[i]);
    }

    model.getAllProcesses().forEach(function(process) {
      const app = AndroidApp.createForProcessIfPossible(
          process, this.surfaceFlinger);
      if (app) {
        this.apps.push(app);
      }
    }, this);
  }

  AndroidModelHelper.guid = tr.b.GUID.allocateSimple();

  AndroidModelHelper.supportsModel = function(model) {
    return true;
  };

  AndroidModelHelper.prototype = {
    iterateImportantSlices(callback) {
      if (this.surfaceFlinger) {
        iterateImportantThreadSlices(
            this.surfaceFlinger.thread,
            IMPORTANT_SURFACE_FLINGER_SLICES,
            callback);
      }

      this.apps.forEach(function(app) {
        iterateImportantThreadSlices(
            app.uiThread,
            IMPORTANT_UI_THREAD_SLICES,
            callback);
        iterateImportantThreadSlices(
            app.renderThread,
            IMPORTANT_RENDER_THREAD_SLICES,
            callback);
      });
    }
  };

  return {
    AndroidModelHelper,
  };
});


'use strict';

/**
 * @fileoverview Class for Android-specific Auditing.
 */
tr.exportTo('tr.e.audits', function() {
  const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
  const Auditor = tr.c.Auditor;
  const AndroidModelHelper = tr.model.helpers.AndroidModelHelper;
  const ColorScheme = tr.b.ColorScheme;
  const Statistics = tr.b.math.Statistics;
  const FRAME_PERF_CLASS = tr.model.FRAME_PERF_CLASS;
  const Alert = tr.model.Alert;
  const EventInfo = tr.model.EventInfo;
  const Scalar = tr.b.Scalar;
  const timeDurationInMs = tr.b.Unit.byName.timeDurationInMs;

  // TODO: extract from VSYNC, since not all devices have vsync near 60fps
  const EXPECTED_FRAME_TIME_MS = 16.67;

  function getStart(e) { return e.start; }
  function getDuration(e) { return e.duration; }
  // used for general UI thread responsiveness alerts, falls back to duration
  function getCpuDuration(e) {
    return (e.cpuDuration !== undefined) ? e.cpuDuration : e.duration;
  }

  function frameIsActivityStart(frame) {
    return frame.associatedEvents.any(x => x.title === 'activityStart');
  }

  function frameMissedDeadline(frame) {
    return frame.args.deadline && frame.args.deadline < frame.end;
  }

  /** Builder object for EventInfo docLink structures */
  function DocLinkBuilder() {
    this.docLinks = [];
  }
  DocLinkBuilder.prototype = {
    addAppVideo(name, videoId) {
      this.docLinks.push({
        label: 'Video Link',
        textContent: ('Android Performance Patterns: ' + name),
        href: 'https://www.youtube.com/watch?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&v=' + videoId // @suppress longLineCheck
      });
      return this;
    },
    addDacRef(name, link) {
      this.docLinks.push({
        label: 'Doc Link',
        textContent: (name + ' documentation'),
        href: 'https://developer.android.com/reference/' + link
      });
      return this;
    },
    build() {
      return this.docLinks;
    }
  };

  /**
   * Auditor for Android-specific traces.
   * @constructor
   */
  function AndroidAuditor(model) {
    Auditor.call(this, model);

    const helper = model.getOrCreateHelper(AndroidModelHelper);
    if (helper.apps.length || helper.surfaceFlinger) {
      this.helper = helper;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // Rendering / RenderThread alerts - only available on SDK 22+
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.viewAlphaAlertInfo_ = new EventInfo(
      'Inefficient View alpha usage',
      'Setting an alpha between 0 and 1 has significant performance costs, if one of the fast alpha paths is not used.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk')
          .addDacRef('View#setAlpha()', 'android/view/View.html#setAlpha(float)') // @suppress longLineCheck
          .build());
  AndroidAuditor.saveLayerAlertInfo_ = new EventInfo(
      'Expensive rendering with Canvas#saveLayer()',
      'Canvas#saveLayer() incurs extremely high rendering cost. They disrupt the rendering pipeline when drawn, forcing a flush of drawing content. Instead use View hardware layers, or static Bitmaps. This enables the offscreen buffers to be reused in between frames, and avoids the disruptive render target switch.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Hidden Cost of Transparency', 'wIy8g8yNhNk')
          .addDacRef('Canvas#saveLayerAlpha()', 'android/graphics/Canvas.html#saveLayerAlpha(android.graphics.RectF, int, int)') // @suppress longLineCheck
          .build());
  AndroidAuditor.getSaveLayerAlerts_ = function(frame) {
    const badAlphaRegEx =
        /^(.+) alpha caused (unclipped )?saveLayer (\d+)x(\d+)$/;
    const saveLayerRegEx = /^(unclipped )?saveLayer (\d+)x(\d+)$/;

    const ret = [];
    const events = [];

    frame.associatedEvents.forEach(function(slice) {
      const match = badAlphaRegEx.exec(slice.title);
      if (match) {
        // due to bug in tracing code on SDK 22, ignore
        // presence of 'unclipped' string in View alpha slices
        const args = { 'view name': match[1],
          'width': parseInt(match[3]),
          'height': parseInt(match[4]) };
        ret.push(new Alert(AndroidAuditor.viewAlphaAlertInfo_,
                           slice.start, [slice], args));
      } else if (saveLayerRegEx.test(slice.title)) {
        events.push(slice);
      }
    }, this);

    if (events.length > ret.length) {
      // more saveLayers than bad alpha can account for - add another alert

      const unclippedSeen = Statistics.sum(events, function(slice) {
        return saveLayerRegEx.exec(slice.title)[1] ? 1 : 0;
      });
      const clippedSeen = events.length - unclippedSeen;
      const earliestStart = Statistics.min(events, function(slice) {
        return slice.start;
      });

      const args = {
        'Unclipped saveLayer count (especially bad!)': unclippedSeen,
        'Clipped saveLayer count': clippedSeen
      };

      events.push(frame);
      ret.push(new Alert(AndroidAuditor.saveLayerAlertInfo_,
                         earliestStart, events, args));
    }

    return ret;
  };


  AndroidAuditor.pathAlertInfo_ = new EventInfo(
      'Path texture churn',
      'Paths are drawn with a mask texture, so when a path is modified / newly drawn, that texture must be generated and uploaded to the GPU. Ensure that you cache paths between frames and do not unnecessarily call Path#reset(). You can cut down on this cost by sharing Path object instances between drawables/views.'); // @suppress longLineCheck
  AndroidAuditor.getPathAlert_ = function(frame) {
    const uploadRegEx = /^Generate Path Texture$/;

    const events = frame.associatedEvents.filter(function(event) {
      return event.title === 'Generate Path Texture';
    });
    const start = Statistics.min(events, getStart);
    const duration = Statistics.sum(events, getDuration);

    if (duration < 3) return undefined;

    events.push(frame);
    return new Alert(AndroidAuditor.pathAlertInfo_, start, events,
        { 'Time spent': new Scalar(timeDurationInMs, duration) });
  };


  AndroidAuditor.uploadAlertInfo_ = new EventInfo(
      'Expensive Bitmap uploads',
      'Bitmaps that have been modified / newly drawn must be uploaded to the GPU. Since this is expensive if the total number of pixels uploaded is large, reduce the amount of Bitmap churn in this animation/context, per frame.'); // @suppress longLineCheck
  AndroidAuditor.getUploadAlert_ = function(frame) {
    const uploadRegEx = /^Upload (\d+)x(\d+) Texture$/;

    const events = [];
    let start = Number.POSITIVE_INFINITY;
    let duration = 0;
    let pixelsUploaded = 0;
    frame.associatedEvents.forEach(function(event) {
      const match = uploadRegEx.exec(event.title);
      if (match) {
        events.push(event);
        start = Math.min(start, event.start);
        duration += event.duration;
        pixelsUploaded += parseInt(match[1]) * parseInt(match[2]);
      }
    });
    if (events.length === 0 || duration < 3) return undefined;

    const mPixels = (pixelsUploaded / 1000000).toFixed(2) + ' million';
    const args = { 'Pixels uploaded': mPixels,
      'Time spent': new Scalar(timeDurationInMs, duration) };
    events.push(frame);
    return new Alert(AndroidAuditor.uploadAlertInfo_, start, events, args);
  };

  //////////////////////////////////////////////////////////////////////////////
  // UI responsiveness alerts
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.ListViewInflateAlertInfo_ = new EventInfo(
      'Inflation during ListView recycling',
      'ListView item recycling involved inflating views. Ensure your Adapter#getView() recycles the incoming View, instead of constructing a new one.'); // @suppress longLineCheck
  AndroidAuditor.ListViewBindAlertInfo_ = new EventInfo(
      'Inefficient ListView recycling/rebinding',
      'ListView recycling taking too much time per frame. Ensure your Adapter#getView() binds data efficiently.'); // @suppress longLineCheck
  AndroidAuditor.getListViewAlert_ = function(frame) {
    const events = frame.associatedEvents.filter(function(event) {
      return event.title === 'obtainView' || event.title === 'setupListItem';
    });
    const duration = Statistics.sum(events, getCpuDuration);

    if (events.length === 0 || duration < 3) return undefined;

    // simplifying assumption - check for *any* inflation.
    // TODO(ccraik): make 'inflate' slices associated events.
    let hasInflation = false;
    for (const event of events) {
      if (event.findDescendentSlice('inflate')) {
        hasInflation = true;
      }
    }

    const start = Statistics.min(events, getStart);
    const args = { 'Time spent': new Scalar(timeDurationInMs, duration) };
    args['ListView items ' + (hasInflation ? 'inflated' : 'rebound')] =
        events.length / 2;
    const eventInfo = hasInflation ? AndroidAuditor.ListViewInflateAlertInfo_ :
        AndroidAuditor.ListViewBindAlertInfo_;
    events.push(frame);
    return new Alert(eventInfo, start, events, args);
  };


  AndroidAuditor.measureLayoutAlertInfo_ = new EventInfo(
      'Expensive measure/layout pass',
      'Measure/Layout took a significant time, contributing to jank. Avoid triggering layout during animations.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E')
          .build());
  AndroidAuditor.getMeasureLayoutAlert_ = function(frame) {
    const events = frame.associatedEvents.filter(function(event) {
      return event.title === 'measure' || event.title === 'layout';
    });
    const duration = Statistics.sum(events, getCpuDuration);

    if (events.length === 0 || duration < 3) return undefined;

    const start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.measureLayoutAlertInfo_, start, events,
        { 'Time spent': new Scalar(timeDurationInMs, duration) });
  };


  AndroidAuditor.viewDrawAlertInfo_ = new EventInfo(
      'Long View#draw()',
      'Recording the drawing commands of invalidated Views took a long time. Avoid significant work in View or Drawable custom drawing, especially allocations or drawing to Bitmaps.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Invalidations, Layouts, and Performance', 'we6poP0kw6E')
          .addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E')
          .build());
  AndroidAuditor.getViewDrawAlert_ = function(frame) {
    let slice = undefined;
    for (const event of frame.associatedEvents) {
      if (event.title === 'getDisplayList' ||
          event.title === 'Record View#draw()') {
        slice = event;
        break;
      }
    }

    if (!slice || getCpuDuration(slice) < 3) return undefined;
    return new Alert(AndroidAuditor.viewDrawAlertInfo_, slice.start,
        [slice, frame],
        { 'Time spent': new Scalar(
            timeDurationInMs, getCpuDuration(slice)) });
  };


  //////////////////////////////////////////////////////////////////////////////
  // Runtime alerts
  //////////////////////////////////////////////////////////////////////////////

  AndroidAuditor.blockingGcAlertInfo_ = new EventInfo(
      'Blocking Garbage Collection',
      'Blocking GCs are caused by object churn, and made worse by having large numbers of objects in the heap. Avoid allocating objects during animations/scrolling, and recycle Bitmaps to avoid triggering garbage collection.', // @suppress longLineCheck
      new DocLinkBuilder()
          .addAppVideo('Garbage Collection in Android', 'pzfzz50W5Uo')
          .addAppVideo('Avoiding Allocations in onDraw()', 'HAK5acHQ53E')
          .build());
  AndroidAuditor.getBlockingGcAlert_ = function(frame) {
    const events = frame.associatedEvents.filter(function(event) {
      return event.title === 'DVM Suspend' ||
          event.title === 'GC: Wait For Concurrent';
    });
    const blockedDuration = Statistics.sum(events, getDuration);
    if (blockedDuration < 3) return undefined;

    const start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.blockingGcAlertInfo_, start, events,
        { 'Blocked duration': new Scalar(
            timeDurationInMs, blockedDuration) });
  };


  AndroidAuditor.lockContentionAlertInfo_ = new EventInfo(
      'Lock contention',
      'UI thread lock contention is caused when another thread holds a lock that the UI thread is trying to use. UI thread progress is blocked until the lock is released. Inspect locking done within the UI thread, and ensure critical sections are short.'); // @suppress longLineCheck
  AndroidAuditor.getLockContentionAlert_ = function(frame) {
    const events = frame.associatedEvents.filter(function(event) {
      return /^Lock Contention on /.test(event.title);
    });

    const blockedDuration = Statistics.sum(events, getDuration);
    if (blockedDuration < 1) return undefined;

    const start = Statistics.min(events, getStart);
    events.push(frame);
    return new Alert(AndroidAuditor.lockContentionAlertInfo_, start, events,
        { 'Blocked duration': new Scalar(
            timeDurationInMs, blockedDuration) });
  };

  AndroidAuditor.schedulingAlertInfo_ = new EventInfo(
      'Scheduling delay',
      'Work to produce this frame was descheduled for several milliseconds, contributing to jank. Ensure that code on the UI thread doesn\'t block on work being done on other threads, and that background threads (doing e.g. network or bitmap loading) are running at android.os.Process#THREAD_PRIORITY_BACKGROUND or lower so they are less likely to interrupt the UI thread. These background threads should show up with a priority number of 130 or higher in the scheduling section under the Kernel process.'); // @suppress longLineCheck
  AndroidAuditor.getSchedulingAlert_ = function(frame) {
    let totalDuration = 0;
    const totalStats = {};
    for (const ttr of frame.threadTimeRanges) {
      const stats = ttr.thread.getSchedulingStatsForRange(ttr.start, ttr.end);
      for (const [key, value] of Object.entries(stats)) {
        if (!(key in totalStats)) {
          totalStats[key] = 0;
        }
        totalStats[key] += value;
        totalDuration += value;
      }
    }

    // only alert if frame not running for > 3ms. Note that we expect a frame
    // to never describe intentionally idle time.
    if (!(SCHEDULING_STATE.RUNNING in totalStats) ||
        totalDuration === 0 ||
        totalDuration - totalStats[SCHEDULING_STATE.RUNNING] < 3) {
      return;
    }

    const args = {};
    for (const [key, value] of Object.entries(totalStats)) {
      let newKey = key;
      if (key === SCHEDULING_STATE.RUNNABLE) {
        newKey = 'Not scheduled, but runnable';
      } else if (key === SCHEDULING_STATE.UNINTR_SLEEP) {
        newKey = 'Blocking I/O delay';
      }
      args[newKey] = new Scalar(timeDurationInMs, value);
    }

    return new Alert(AndroidAuditor.schedulingAlertInfo_, frame.start, [frame],
                     args);
  };

  AndroidAuditor.prototype = {
    __proto__: Auditor.prototype,

    renameAndSort_() {
      this.model.kernel.important = false;// auto collapse
      // SurfaceFlinger first, other processes sorted by slice count
      this.model.getAllProcesses().forEach(function(process) {
        if (this.helper.surfaceFlinger &&
            process === this.helper.surfaceFlinger.process) {
          if (!process.name) {
            process.name = 'SurfaceFlinger';
          }
          process.sortIndex = Number.NEGATIVE_INFINITY;
          process.important = false; // auto collapse
          return;
        }

        const uiThread = process.getThread(process.pid);
        if (!process.name && uiThread && uiThread.name) {
          if (/^ndroid\./.test(uiThread.name)) {
            uiThread.name = 'a' + uiThread.name;
          }
          process.name = uiThread.name;

          uiThread.name = 'UI Thread';
        }

        process.sortIndex = 0;
        for (const tid in process.threads) {
          process.sortIndex -= process.threads[tid].sliceGroup.slices.length;
        }
      }, this);

      // ensure sequential, relative order for UI/Render/Worker threads
      this.model.getAllThreads().forEach(function(thread) {
        if (thread.tid === thread.parent.pid) {
          thread.sortIndex = -3;
        }
        if (thread.name === 'RenderThread') {
          thread.sortIndex = -2;
        }
        if (/^hwuiTask/.test(thread.name)) {
          thread.sortIndex = -1;
        }
      });
    },

    pushFramesAndJudgeJank_() {
      let badFramesObserved = 0;
      let framesObserved = 0;
      const surfaceFlinger = this.helper.surfaceFlinger;

      this.helper.apps.forEach(function(app) {
        // override frame list
        app.process.frames = app.getFrames();

        app.process.frames.forEach(function(frame) {
          if (frame.totalDuration > EXPECTED_FRAME_TIME_MS * 2) {
            badFramesObserved += 2;
            frame.perfClass = FRAME_PERF_CLASS.TERRIBLE;
          } else if (frame.totalDuration > EXPECTED_FRAME_TIME_MS ||
              frameMissedDeadline(frame)) {
            badFramesObserved++;
            frame.perfClass = FRAME_PERF_CLASS.BAD;
          } else {
            frame.perfClass = FRAME_PERF_CLASS.GOOD;
          }
        });
        framesObserved += app.process.frames.length;
      });

      if (framesObserved) {
        const portionBad = badFramesObserved / framesObserved;
        if (portionBad > 0.3) {
          this.model.faviconHue = 'red';
        } else if (portionBad > 0.05) {
          this.model.faviconHue = 'yellow';
        } else {
          this.model.faviconHue = 'green';
        }
      }
    },

    pushEventInfo_() {
      const appAnnotator = new AppAnnotator();
      this.helper.apps.forEach(function(app) {
        if (app.uiThread) {
          appAnnotator.applyEventInfos(app.uiThread.sliceGroup);
        }
        if (app.renderThread) {
          appAnnotator.applyEventInfos(app.renderThread.sliceGroup);
        }
      });
    },

    runAnnotate() {
      if (!this.helper) return;

      this.renameAndSort_();
      this.pushFramesAndJudgeJank_();
      this.pushEventInfo_();

      this.helper.iterateImportantSlices(function(slice) {
        slice.important = true;
      });
    },

    runAudit() {
      if (!this.helper) return;

      const alerts = this.model.alerts;
      this.helper.apps.forEach(function(app) {
        app.getFrames().forEach(function(frame) {
          alerts.push.apply(alerts, AndroidAuditor.getSaveLayerAlerts_(frame));

          // skip most alerts for neutral or good frames
          if (frame.perfClass === FRAME_PERF_CLASS.NEUTRAL ||
              frame.perfClass === FRAME_PERF_CLASS.GOOD) {
            return;
          }

          let alert = AndroidAuditor.getPathAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getUploadAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getListViewAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getMeasureLayoutAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getViewDrawAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getBlockingGcAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getLockContentionAlert_(frame);
          if (alert) alerts.push(alert);

          alert = AndroidAuditor.getSchedulingAlert_(frame);
          if (alert) alerts.push(alert);
        });
      }, this);

      this.addRenderingInteractionRecords();
      this.addInputInteractionRecords();
    },

    addRenderingInteractionRecords() {
      const events = [];
      this.helper.apps.forEach(function(app) {
        events.push.apply(events, app.getAnimationAsyncSlices());
        events.push.apply(events, app.getFrames());
      });

      const mergerFunction = function(events) {
        const ir = new tr.model.um.ResponseExpectation(
            this.model, 'Rendering',
            events[0].min,
            events[events.length - 1].max - events[0].min);
        this.model.userModel.expectations.push(ir);
      }.bind(this);
      tr.b.math.mergeRanges(
          tr.b.math.convertEventsToRanges(events), 30, mergerFunction);
    },

    addInputInteractionRecords() {
      const inputSamples = [];
      this.helper.apps.forEach(function(app) {
        inputSamples.push.apply(inputSamples, app.getInputSamples());
      });

      const mergerFunction = function(events) {
        const ir = new tr.model.um.ResponseExpectation(
            this.model, 'Input',
            events[0].min,
            events[events.length - 1].max - events[0].min);
        this.model.userModel.expectations.push(ir);
      }.bind(this);
      const inputRanges = inputSamples.map(function(sample) {
        return tr.b.math.Range.fromExplicitRange(
            sample.timestamp, sample.timestamp);
      });
      tr.b.math.mergeRanges(inputRanges, 30, mergerFunction);
    }
  };

  Auditor.register(AndroidAuditor);

  function AppAnnotator() {
    this.titleInfoLookup = new Map();
    this.titleParentLookup = new Map();
    this.build_();
  }

  AppAnnotator.prototype = {
    build_() {
      const registerEventInfo = function(dict) {
        this.titleInfoLookup.set(dict.title, new EventInfo(
            dict.title, dict.description, dict.docLinks));
        if (dict.parents) {
          this.titleParentLookup.set(dict.title, dict.parents);
        }
      }.bind(this);

      registerEventInfo({
        title: 'inflate',
        description: 'Constructing a View hierarchy from pre-processed XML via LayoutInflater#layout. This includes constructing all of the View objects in the hierarchy, and applying styled attributes.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Adapter view
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
        title: 'obtainView',
        description: 'Adapter#getView() called to bind content to a recycled View that is being presented.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'setupListItem',
        description: 'Attached a newly-bound, recycled View to its parent ListView.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'setupGridItem',
        description: 'Attached a newly-bound, recycled View to its parent GridView.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Choreographer (tracing enabled on M+)
      //////////////////////////////////////////////////////////////////////////
      const choreographerLinks = new DocLinkBuilder()
          .addDacRef('Choreographer', 'android/view/Choreographer.html') // @suppress longLineCheck
          .build();
      registerEventInfo({
        title: 'Choreographer#doFrame',
        docLinks: choreographerLinks,
        description: 'Choreographer executes frame callbacks for inputs, animations, and rendering traversals. When this work is done, a frame will be presented to the user.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'input',
        parents: ['Choreographer#doFrame'],
        docLinks: choreographerLinks,
        description: 'Input callbacks are processed. This generally encompasses dispatching input to Views, as well as any work the Views do to process this input/gesture.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'animation',
        parents: ['Choreographer#doFrame'],
        docLinks: choreographerLinks,
        description: 'Animation callbacks are processed. This is generally minimal work, as animations determine progress for the frame, and push new state to animated objects (such as setting View properties).'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'traversals',
        parents: ['Choreographer#doFrame'],
        docLinks: choreographerLinks,
        description: 'Primary draw traversals. This is the primary traversal of the View hierarchy, including layout and draw passes.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // performTraversals + sub methods
      //////////////////////////////////////////////////////////////////////////
      const traversalParents = ['Choreographer#doFrame', 'performTraversals'];
      const layoutLinks = new DocLinkBuilder()
          .addDacRef('View#Layout', 'android/view/View.html#Layout')
          .build();
      registerEventInfo({
        title: 'performTraversals',
        description: 'A drawing traversal of the View hierarchy, comprised of all layout and drawing needed to produce the frame.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'measure',
        parents: traversalParents,
        docLinks: layoutLinks,
        description: 'First of two phases in view hierarchy layout. Views are asked to size themselves according to constraints supplied by their parent. Some ViewGroups may measure a child more than once to help satisfy their own constraints. Nesting ViewGroups that measure children more than once can lead to excessive and repeated work.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'layout',
        parents: traversalParents,
        docLinks: layoutLinks,
        description: 'Second of two phases in view hierarchy layout, repositioning content and child Views into their new locations.'}); // @suppress longLineCheck
      const drawString = 'Draw pass over the View hierarchy. Every invalidated View will have its drawing commands recorded. On Android versions prior to Lollipop, this would also include the issuing of draw commands to the GPU. Starting with Lollipop, it only includes the recording of commands, and syncing that information to the RenderThread.'; // @suppress longLineCheck
      registerEventInfo({
        title: 'draw',
        parents: traversalParents,
        description: drawString});

      const recordString = 'Every invalidated View\'s drawing commands are recorded. Each will have View#draw() called, and is passed a Canvas that will record and store its drawing commands until it is next invalidated/rerecorded.'; // @suppress longLineCheck
      registerEventInfo({
        title: 'getDisplayList', // Legacy name for compatibility.
        parents: ['draw'],
        description: recordString});
      registerEventInfo({
        title: 'Record View#draw()',
        parents: ['draw'],
        description: recordString});

      registerEventInfo({
        title: 'drawDisplayList',
        parents: ['draw'],
        description: 'Execution of recorded draw commands to generate a frame. This represents the actual formation and issuing of drawing commands to the GPU. On Android L and higher devices, this work is done on a dedicated RenderThread, instead of on the UI Thread.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // RenderThread
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
        title: 'DrawFrame',
        description: 'RenderThread portion of the standard UI/RenderThread split frame. This represents the actual formation and issuing of drawing commands to the GPU.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'doFrame',
        description: 'RenderThread animation frame. Represents drawing work done by the RenderThread on a frame where the UI thread did not produce new drawing content.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'syncFrameState',
        description: 'Sync stage between the UI thread and the RenderThread, where the UI thread hands off a frame (including information about modified Views). Time in this method primarily consists of uploading modified Bitmaps to the GPU. After this sync is completed, the UI thread is unblocked, and the RenderThread starts to render the frame.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'flush drawing commands',
        description: 'Issuing the now complete drawing commands to the GPU.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'eglSwapBuffers',
        description: 'Complete GPU rendering of the frame.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // RecyclerView
      //////////////////////////////////////////////////////////////////////////
      registerEventInfo({
        title: 'RV Scroll',
        description: 'RecyclerView is calculating a scroll. If there are too many of these in Systrace, some Views inside RecyclerView might be causing it. Try to avoid using EditText, focusable views or handle them with care.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'RV OnLayout',
        description: 'OnLayout has been called by the View system. If this shows up too many times in Systrace, make sure the children of RecyclerView do not update themselves directly. This will cause a full re-layout but when it happens via the Adapter notifyItemChanged, RecyclerView can avoid full layout calculation.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'RV FullInvalidate',
        description: 'NotifyDataSetChanged or equal has been called. If this is taking a long time, try sending granular notify adapter changes instead of just calling notifyDataSetChanged or setAdapter / swapAdapter. Adding stable ids to your adapter might help.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'RV PartialInvalidate',
        description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'RV OnBindView',
        description: 'RecyclerView is rebinding a View. If this is taking a lot of time, consider optimizing your layout or make sure you are not doing extra operations in onBindViewHolder call.'}); // @suppress longLineCheck
      registerEventInfo({
        title: 'RV CreateView',
        description: 'RecyclerView is creating a new View. If too many of these are present: 1) There might be a problem in Recycling (e.g. custom Animations that set transient state and prevent recycling or ItemAnimator not implementing the contract properly. See Adapter#onFailedToRecycleView(ViewHolder). 2) There may be too many item view types. Try merging them. 3) There might be too many itemChange animations and not enough space in RecyclerPool. Try increasing your pool size and item cache size.'}); // @suppress longLineCheck

      //////////////////////////////////////////////////////////////////////////
      // Graphics + Composition
      //////////////////////////////////////////////////////////////////////////
      // TODO(ccraik): SurfaceFlinger work
      registerEventInfo({
        title: 'eglSwapBuffers',
        description: 'The CPU has finished producing drawing commands, and is flushing drawing work to the GPU, and posting that buffer to the consumer (which is often SurfaceFlinger window composition). Once this is completed, the GPU can produce the frame content without any involvement from the CPU.'}); // @suppress longLineCheck
    },

    applyEventInfosRecursive_(parentNames, slice) {
      const checkExpectedParentNames = function(expectedParentNames) {
        if (!expectedParentNames) return true;
        return expectedParentNames.some(function(name) {
          return parentNames.has(name);
        });
      };

      // Set EventInfo on the slice if it matches title, and parent.
      if (this.titleInfoLookup.has(slice.title)) {
        if (checkExpectedParentNames(this.titleParentLookup.get(slice.title))) {
          slice.info = this.titleInfoLookup.get(slice.title);
        }
      }

      // Push slice into parentNames, and recurse over subSlices.
      if (slice.subSlices.length > 0) {
        // Increment title in parentName dict.
        if (!parentNames.has(slice.title)) {
          parentNames.set(slice.title, 0);
        }
        parentNames.set(slice.title, parentNames.get(slice.title) + 1);

        // Recurse over subSlices.
        slice.subSlices.forEach(function(subSlice) {
          this.applyEventInfosRecursive_(parentNames, subSlice);
        }, this);

        // Decrement title in parentName dict.
        parentNames.set(slice.title, parentNames.get(slice.title) - 1);
        if (parentNames.get(slice.title) === 0) {
          delete parentNames[slice.title];
        }
      }
    },

    applyEventInfos(sliceGroup) {
      sliceGroup.topLevelSlices.forEach(function(slice) {
        this.applyEventInfosRecursive_(new Map(), slice);
      }, this);
    }
  };

  return {
    AndroidAuditor,
  };
});


'use strict';

/**
 * @fileoverview BlameContext is the Trace Viewer side correspondence of
 * Chrome's class base::trace_event::BlameContext. More specifically,
 *
 * BlameContextSnapshot, which inherits from ObjectSnapshot, is the base class
 * of all snapshots of blame contexts traced in Chrome.
 *
 * BlameContextInstance, which inherits from ObjectInstance, gathers snapshots
 * of the same blame context traced in Chrome.
 *
 * BlameContextSnapshot and BlameContextInstance should never be instantiated
 * directly. Subclasses corresponding to different BlameContexts in Chrome
 * should define their own BlameContextSnapshot and BlameContextInstance
 * specializations for instantiation.
 *
 */
tr.exportTo('tr.e.chrome', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;
  const ObjectInstance = tr.model.ObjectInstance;

  function BlameContextSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  BlameContextSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    /**
     * Returns the parent in the context tree.
     */
    get parentContext() {
      if (this.args.parent instanceof BlameContextSnapshot) {
        return this.args.parent;
      }
      return undefined;
    },

    get userFriendlyName() {
      return 'BlameContext';
    }
  };

  function BlameContextInstance() {
    ObjectInstance.apply(this, arguments);
  }

  BlameContextInstance.prototype = {
    __proto__: ObjectInstance.prototype,

    /**
     * Returns the type of the blame context, to be overriden by subclasses.
     */
    get blameContextType() {
      throw new Error('Not implemented');
    }
  };

  return {
    BlameContextSnapshot,
    BlameContextInstance,
  };
});


'use strict';

/**
 * @fileoverview Trace Viewer side's correspondence of Chrome's
 * content::FrameTreeNode class.
 *
 */
tr.exportTo('tr.e.chrome', function() {
  const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
  const BlameContextInstance = tr.e.chrome.BlameContextInstance;

  function FrameTreeNodeSnapshot() {
    BlameContextSnapshot.apply(this, arguments);
  }

  FrameTreeNodeSnapshot.prototype = {
    __proto__: BlameContextSnapshot.prototype,

    get renderFrame() {
      if (this.args.renderFrame instanceof tr.e.chrome.RenderFrameSnapshot) {
        return this.args.renderFrame;
      }
      return undefined;
    },

    get url() {
      return this.args.url;
    },

    get userFriendlyName() {
      return 'FrameTreeNode';
    }
  };

  tr.model.ObjectSnapshot.subTypes.register(
      FrameTreeNodeSnapshot,
      {typeName: 'FrameTreeNode'});

  function FrameTreeNodeInstance() {
    BlameContextInstance.apply(this, arguments);
  }

  FrameTreeNodeInstance.prototype = {
    __proto__: BlameContextInstance.prototype,

    get blameContextType() {
      return 'Frame';
    }
  };

  tr.model.ObjectInstance.subTypes.register(
      FrameTreeNodeInstance,
      {typeName: 'FrameTreeNode'});

  return {
    FrameTreeNodeSnapshot,
    FrameTreeNodeInstance,
  };
});


'use strict';

/**
 * @fileoverview Trace Viewer side's correspondence of Chrome's
 * content::FrameBlameContext class.
 *
 */
tr.exportTo('tr.e.chrome', function() {
  const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
  const BlameContextInstance = tr.e.chrome.BlameContextInstance;

  function RenderFrameSnapshot() {
    BlameContextSnapshot.apply(this, arguments);
  }

  RenderFrameSnapshot.prototype = {
    __proto__: BlameContextSnapshot.prototype,

    referencedAt(item, object, field) {
      if (item instanceof tr.e.chrome.FrameTreeNodeSnapshot &&
          object === item.args &&
          field === 'renderFrame') {
        this.args.frameTreeNode = item;
      }
    },

    get frameTreeNode() {
      if (this.args.frameTreeNode instanceof
          tr.e.chrome.FrameTreeNodeSnapshot) {
        return this.args.frameTreeNode;
      }
      return undefined;
    },

    get url() {
      if (this.frameTreeNode) {
        return this.frameTreeNode.url;
      }
      return undefined;
    },

    get userFriendlyName() {
      return 'RenderFrame';
    }
  };

  tr.model.ObjectSnapshot.subTypes.register(
      RenderFrameSnapshot,
      {typeName: 'RenderFrame'});

  function RenderFrameInstance() {
    BlameContextInstance.apply(this, arguments);
  }

  RenderFrameInstance.prototype = {
    __proto__: BlameContextInstance.prototype,

    get blameContextType() {
      return 'Frame';
    }
  };

  tr.model.ObjectInstance.subTypes.register(
      RenderFrameInstance,
      {typeName: 'RenderFrame'});

  return {
    RenderFrameSnapshot,
    RenderFrameInstance,
  };
});


'use strict';

/**
 * @fileoverview Trace Viewer side's correspondence of Chrome's
 * content::TopLevelBlameContext class.
 *
 */
tr.exportTo('tr.e.chrome', function() {
  const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
  const BlameContextInstance = tr.e.chrome.BlameContextInstance;

  function TopLevelSnapshot() {
    BlameContextSnapshot.apply(this, arguments);
  }

  TopLevelSnapshot.prototype = {
    __proto__: BlameContextSnapshot.prototype,

    get userFriendlyName() {
      return 'TopLevel';
    }
  };

  tr.model.ObjectSnapshot.subTypes.register(
      TopLevelSnapshot,
      {typeName: 'TopLevel'});

  function TopLevelInstance() {
    BlameContextInstance.apply(this, arguments);
  }

  TopLevelInstance.prototype = {
    __proto__: BlameContextInstance.prototype,

    get blameContextType() {
      return 'TopLevel';
    }
  };

  tr.model.ObjectInstance.subTypes.register(
      TopLevelInstance,
      {typeName: 'TopLevel'});

  return {
    TopLevelSnapshot,
    TopLevelInstance,
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tr.exportTo('tr.e.audits', function() {
  const Auditor = tr.c.Auditor;

  /**
   * Auditor for Chrome-specific traces.
   * @constructor
   */
  function ChromeAuditor(model) {
    Auditor.call(this, model);

    const modelHelper = this.model.getOrCreateHelper(
        tr.model.helpers.ChromeModelHelper);
    if (modelHelper && modelHelper.browserHelper) {
      // Must be a browserHelper in order to do audits.
      this.modelHelper = modelHelper;
    } else {
      this.modelHelper = undefined;
    }
  }

  ChromeAuditor.prototype = {
    __proto__: Auditor.prototype,

    runAnnotate() {
      if (!this.modelHelper) return;

      for (const pid in this.modelHelper.rendererHelpers) {
        const rendererHelper = this.modelHelper.rendererHelpers[pid];

        if (rendererHelper.isChromeTracingUI) {
          rendererHelper.process.important = false;
        }
      }
    },

    /**
     * Called by import to install userFriendlyCategoryDriver.
     */
    installUserFriendlyCategoryDriverIfNeeded() {
      this.model.addUserFriendlyCategoryDriver(
          tr.e.chrome.ChromeUserFriendlyCategoryDriver);
    },

    runAudit() {
      if (!this.modelHelper) return;

      this.model.replacePIDRefsInPatchups(
          tr.model.BROWSER_PROCESS_PID_REF,
          this.modelHelper.browserProcess.pid);
      this.model.applyObjectRefPatchups();
    }
  };

  Auditor.register(ChromeAuditor);

  return {
    ChromeAuditor,
  };
});


'use strict';

tr.exportTo('tr.e.chrome', function() {
  const KNOWN_PROPERTIES = {
    absX: 1,
    absY: 1,
    address: 1,
    anonymous: 1,
    childNeeds: 1,
    children: 1,
    classNames: 1,
    col: 1,
    colSpan: 1,
    float: 1,
    height: 1,
    htmlId: 1,
    name: 1,
    posChildNeeds: 1,
    positioned: 1,
    positionedMovement: 1,
    relX: 1,
    relY: 1,
    relativePositioned: 1,
    row: 1,
    rowSpan: 1,
    selfNeeds: 1,
    stickyPositioned: 1,
    tag: 1,
    width: 1
  };

  function LayoutObject(snapshot, args) {
    this.snapshot_ = snapshot;
    this.id_ = args.address;
    this.name_ = args.name;
    this.childLayoutObjects_ = [];
    this.otherProperties_ = {};
    this.tag_ = args.tag;
    this.relativeRect_ = tr.b.math.Rect.fromXYWH(
        args.relX, args.relY, args.width, args.height);
    this.absoluteRect_ = tr.b.math.Rect.fromXYWH(
        args.absX, args.absY, args.width, args.height);
    this.isFloat_ = args.float;
    this.isStickyPositioned_ = args.stickyPositioned;
    this.isPositioned_ = args.positioned;
    this.isRelativePositioned_ = args.relativePositioned;
    this.isAnonymous_ = args.anonymous;
    this.htmlId_ = args.htmlId;
    this.classNames_ = args.classNames;
    this.needsLayoutReasons_ = [];
    if (args.selfNeeds) {
      this.needsLayoutReasons_.push('self');
    }
    if (args.childNeeds) {
      this.needsLayoutReasons_.push('child');
    }
    if (args.posChildNeeds) {
      this.needsLayoutReasons_.push('positionedChild');
    }
    if (args.positionedMovement) {
      this.needsLayoutReasons_.push('positionedMovement');
    }
    this.tableRow_ = args.row;
    this.tableCol_ = args.col;
    this.tableRowSpan_ = args.rowSpan;
    this.tableColSpan_ = args.colSpan;

    if (args.children) {
      args.children.forEach(function(child) {
        this.childLayoutObjects_.push(new LayoutObject(snapshot, child));
      }.bind(this));
    }

    for (const property in args) {
      if (!KNOWN_PROPERTIES[property]) {
        this.otherProperties_[property] = args[property];
      }
    }
  }

  LayoutObject.prototype = {
    get snapshot() {
      return this.snapshot_;
    },

    get id() {
      return this.id_;
    },

    get name() {
      return this.name_;
    },

    get tag() {
      return this.tag_;
    },

    get relativeRect() {
      return this.relativeRect_;
    },

    get absoluteRect() {
      return this.absoluteRect_;
    },

    get isPositioned() {
      return this.isPositioned_;
    },

    get isFloat() {
      return this.isFloat_;
    },

    get isStickyPositioned() {
      return this.isStickyPositioned_;
    },

    get isRelativePositioned() {
      return this.isRelativePositioned_;
    },

    get isAnonymous() {
      return this.isAnonymous_;
    },

    get tableRow() {
      return this.tableRow_;
    },

    get tableCol() {
      return this.tableCol_;
    },

    get tableRowSpan() {
      return this.tableRowSpan_;
    },

    get tableColSpan() {
      return this.tableColSpan_;
    },

    get htmlId() {
      return this.htmlId_;
    },

    get classNames() {
      return this.classNames_;
    },

    get needsLayoutReasons() {
      return this.needsLayoutReasons_;
    },

    get hasChildLayoutObjects() {
      return this.childLayoutObjects_.length > 0;
    },

    get childLayoutObjects() {
      return this.childLayoutObjects_;
    },

    traverseTree(cb, opt_this) {
      cb.call(opt_this, this);
      if (!this.hasChildLayoutObjects) return;
      this.childLayoutObjects.forEach(function(child) {
        child.traverseTree(cb, opt_this);
      });
    },

    get otherPropertyNames() {
      const names = [];
      for (const name in this.otherProperties_) {
        names.push(name);
      }
      return names;
    },

    getProperty(name) {
      return this.otherProperties_[name];
    },

    get previousSnapshotLayoutObject() {
      if (!this.snapshot.previousSnapshot) return undefined;
      return this.snapshot.previousSnapshot.getLayoutObjectById(this.id);
    },

    get nextSnapshotLayoutObject() {
      if (!this.snapshot.nextSnapshot) return undefined;
      return this.snapshot.nextSnapshot.getLayoutObjectById(this.id);
    }
  };

  return {
    LayoutObject,
  };
});


'use strict';

tr.exportTo('tr.e.chrome', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;
  const ObjectInstance = tr.model.ObjectInstance;

  function LayoutTreeInstance() {
    ObjectInstance.apply(this, arguments);
  }

  LayoutTreeInstance.prototype = {
    __proto__: ObjectInstance.prototype,
  };

  ObjectInstance.subTypes.register(
      LayoutTreeInstance, {typeName: 'LayoutTree'});

  function LayoutTreeSnapshot() {
    ObjectSnapshot.apply(this, arguments);
    this.rootLayoutObject = new tr.e.chrome.LayoutObject(this, this.args);
  }

  LayoutTreeSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,
  };

  ObjectSnapshot.subTypes.register(
      LayoutTreeSnapshot, {typeName: 'LayoutTree'});

  return {
    LayoutTreeInstance,
    LayoutTreeSnapshot,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const Event = tr.model.Event;
  const EventRegistry = tr.model.EventRegistry;

  /**
   * A sample containing data about what fraction of a resource
   * (CPU or GPU) is being used at a given point in time.
   */
  class ResourceUsageSample extends Event {

    /**
     * @param {ResourceUsageSeries } series The ResourceUsageSeries that this
     * sample will be a part of.
     * @param {float} start Time of the sample.
     * @param {float} usage Fraction of the resource (CPU or GPU) in use at the
     * time of the sample.
     */
    constructor(series, start, usage) {
      super();

      this.series_ = series;
      this.start_ = start;
      this.usage_ = usage;
    }

    get series() {
      return this.series_;
    }

    get start() {
      return this.start_;
    }

    set start(value) {
      this.start_ = value;
    }

    get usage() {
      return this.usage_;
    }

    set usage(value) {
      this.usage_ = value;
    }

    addBoundsToRange(range) {
      range.addValue(this.start);
    }
  }

  EventRegistry.register(
      ResourceUsageSample,
      {
        name: 'resourceUsageSample',
        pluralName: 'resourceUsageSamples'
      });

  return {
    ResourceUsageSample,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  const ResourceUsageSample = tr.model.ResourceUsageSample;

  /**
   * A container holding a time series of samples giving the
   * fraction of usage of a resource (e.g. CPU or GPU) at each
   * sample time.
   */

  class ResourceUsageSeries extends tr.model.EventContainer {
    constructor(device) {
      super();

      this.device_ = device;
      this.samples_ = [];
    }

    get device() {
      return this.device_;
    }

    get samples() {
      return this.samples_;
    }

    get stableId() {
      return this.device_.stableId + '.ResourceUsageSeries';
    }

    /**
     * Adds a usage sample to the series and returns it.
     *
     * Note: Samples must be added in chronological order.
     */
    addUsageSample(ts, val) {
      const sample = new ResourceUsageSample(this, ts, val);
      this.samples_.push(sample);
      return sample;
    }

    /**
     * Returns the total time consumed by a resource (e.g. CPU or GPU) between
     * the specified start and end timestamps (in milliseconds).
     */
    computeResourceTimeConsumedInMs(start, end) {
      const measurementRange = tr.b.math.Range.fromExplicitRange(start, end);

      let resourceTimeInMs = 0;
      let startIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, start) - 1;
      const endIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, end);

      if (startIndex < 0) startIndex = 0;

      for (let i = startIndex; i < endIndex; i++) {
        const sample = this.samples[i];
        const nextSample = this.samples[i + 1];

        const sampleRange = new tr.b.math.Range();
        sampleRange.addValue(sample.start);
        sampleRange.addValue(nextSample ? nextSample.start : sample.start);

        const intersectionRangeInMs = measurementRange.findIntersection(
            sampleRange);

        resourceTimeInMs += intersectionRangeInMs.duration * sample.usage;
      }

      return resourceTimeInMs;
    }

    getSamplesWithinRange(start, end) {
      const startIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, start);
      const endIndex = tr.b.findLowIndexInSortedArray(
          this.samples, x => x.start, end);
      return this.samples.slice(startIndex, endIndex);
    }

    shiftTimestampsForward(amount) {
      for (let i = 0; i < this.samples_.length; ++i) {
        this.samples_[i].start += amount;
      }
    }

    updateBounds() {
      this.bounds.reset();

      if (this.samples_.length === 0) return;

      this.bounds.addValue(this.samples_[0].start);
      this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
    }

    * childEvents() {
      yield* this.samples_;
    }
  }

  return {
    ResourceUsageSeries,
  };
});


'use strict';

tr.exportTo('tr.e.audits', function() {
  /**
   * Auditor that analyzes the model and, if possible, adds data to it
   * showing CPU usage.
   */
  class CpuUsageAuditor extends tr.c.Auditor {

    constructor(model) {
      super();
      this.model_ = model;
    }

    runAnnotate() {
      this.model_.device.cpuUsageSeries = this.computeCpuUsageSeries_(
          this.model_.bounds.min, this.model_.bounds.max,
          this.computeCpuUsage_());
    }

    /**
     * Compute the bin size given the start and end times of the trace.
     */
    computeBinSize_(start, end) {
      const MIN_BIN_SIZE_MS = 1.0;
      const MAX_NUM_BINS = 100000;
      const interval = end - start;
      let binSize = MIN_BIN_SIZE_MS;
      while (binSize * MAX_NUM_BINS < interval) binSize *= 2;
      return binSize;
    }

    /**
     * Returns a CPU usage series from a given set of CPU usage slices.
     * Slices are in the format created by getCpuUsage below.
     */
    computeCpuUsageSeries_(start, end, usageRecords) {
      const series = new tr.model.ResourceUsageSeries();
      if (start === undefined || usageRecords.length === 0) return series;
      const binSize = this.computeBinSize_(start, end);
      const numBins = Math.ceil((end - start) / binSize);
      const arr = new Array(numBins).fill(0);
      for (const record of usageRecords) {
        const firstIndex = Math.ceil((record.start - start) / binSize);
        const lastIndex = Math.floor((record.end - start) / binSize);
        for (let i = firstIndex; i <= lastIndex; i++) arr[i] += record.usage;
      }
      for (let i = 0; i < numBins; i++) {
        series.addUsageSample(start + (i * binSize), arr[i]);
      }
      return series;
    }

    /**
     * Returns a list of CPU usage slices based on tracing data. Thus, this
     * effectively counts only processes that are traced (will not count
     * e.g. background processes)
     */
    computeCpuUsage_() {
      const model = this.model_;
      const result = [];
      for (const pid in model.processes) {
        for (const e of model.processes[pid].getDescendantEvents()) {
          if (!(e instanceof tr.model.ThreadSlice) || e.duration === 0 ||
              e.cpuDuration === undefined) {
            continue;
          }

          // This slice contains the most fine-grained CPU usage information
          // for the area of the trace that it covers but that is not covered
          // by its subslices.
          // The math goes this way:
          //   s.selfTime    : duration of slice s not spent in its subslices.
          //   s.cpuSelfTime : cpuDuration over slice s but not its subslices.
          //
          // We're looking for
          //   s.cpuSelfTimeRatio: average CPU usage over the area covered by
          //                       s but not any of its subslices.
          //                       = s.cpuSelfTime / s.selfTime
          if (e.selfTime === 0 || e.selfTime === undefined ||
              e.cpuSelfTime === undefined) {
            continue;
          }
          const usage = tr.b.math.clamp(e.cpuSelfTime / e.selfTime, 0, 1);

          // Go through the area covered by this slice but not its subslices
          // and add the cpuSelfTimeRatio contribution over this area.
          let lastTime = e.start;
          for (const subslice of e.subSlices) {
            result.push({usage, start: lastTime, end: subslice.start});
            lastTime = subslice.end;
          }
          result.push({usage, start: lastTime, end: e.end});
        }
      }
      return result;
    }
  }

  tr.c.Auditor.register(CpuUsageAuditor);

  return {
    CpuUsageAuditor
  };
});


'use strict';

/**
 * @fileoverview Base class for Windows ETW event parsers.
 *
 * The ETW trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. Thread and Process implements
 * decoding of scheduling events.  Parser subclasses must
 * call Parser.register to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tr.e.importer.etw.Parser;
 *
 * function ThreadParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler(guid, kThreadStartOpcode,
 *       ThreadParser.prototype.decodeStart.bind(this));
 *   importer.registerEventHandler(guid, kThreadEndOpcode,
 *       ThreadParser.prototype.decodeEnd.bind(this));
 * }
 *
 * Parser.register(ThreadParser);
 *
 * When a registered event is found, the associated event handler is invoked:
 *
 *   decodeStart: function(header, decoder) {
 *     [...]
 *     return true;
 *   },
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.model.importWarning.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 */
tr.exportTo('tr.e.importer.etw', function() {
  /**
   * Parses Windows ETW events.
   * @constructor
   */
  function Parser(importer) {
    this.importer = importer;
    this.model = importer.model;
  }

  Parser.prototype = {
    __proto__: Object.prototype
  };

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.mandatoryBaseClass = Parser;
  tr.b.decorateExtensionRegistry(Parser, options);


  return {
    Parser,
  };
});


'use strict';

/**
 * @fileoverview Parses EventTrace events in the Windows event trace format.
 */

tr.exportTo('tr.e.importer.etw', function() {
  const Parser = tr.e.importer.etw.Parser;

  // Constants for EventTrace events.
  const guid = '68FDD900-4A3E-11D1-84F4-0000F80464E3';
  const kEventTraceHeaderOpcode = 0;

  /**
   * Parses Windows EventTrace trace events.
   * @constructor
   */
  function EventTraceParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kEventTraceHeaderOpcode,
        EventTraceParser.prototype.decodeHeader.bind(this));
  }

  EventTraceParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields(header, decoder) {
      if (header.version !== 2) {
        throw new Error('Incompatible EventTrace event version.');
      }

      const bufferSize = decoder.decodeUInt32();
      const version = decoder.decodeUInt32();
      const providerVersion = decoder.decodeUInt32();
      const numberOfProcessors = decoder.decodeUInt32();
      const endTime = decoder.decodeUInt64ToString();
      const timerResolution = decoder.decodeUInt32();
      const maxFileSize = decoder.decodeUInt32();
      const logFileMode = decoder.decodeUInt32();
      const buffersWritten = decoder.decodeUInt32();
      const startBuffers = decoder.decodeUInt32();
      const pointerSize = decoder.decodeUInt32();
      const eventsLost = decoder.decodeUInt32();
      const cpuSpeed = decoder.decodeUInt32();
      const loggerName = decoder.decodeUInteger(header.is64);
      const logFileName = decoder.decodeUInteger(header.is64);
      const timeZoneInformation = decoder.decodeTimeZoneInformation();
      const padding = decoder.decodeUInt32();
      const bootTime = decoder.decodeUInt64ToString();
      const perfFreq = decoder.decodeUInt64ToString();
      const startTime = decoder.decodeUInt64ToString();
      const reservedFlags = decoder.decodeUInt32();
      const buffersLost = decoder.decodeUInt32();
      const sessionNameString = decoder.decodeW16String();
      const logFileNameString = decoder.decodeW16String();

      return {
        bufferSize,
        version,
        providerVersion,
        numberOfProcessors,
        endTime,
        timerResolution,
        maxFileSize,
        logFileMode,
        buffersWritten,
        startBuffers,
        pointerSize,
        eventsLost,
        cpuSpeed,
        loggerName,
        logFileName,
        timeZoneInformation,
        bootTime,
        perfFreq,
        startTime,
        reservedFlags,
        buffersLost,
        sessionNameString,
        logFileNameString
      };
    },

    decodeHeader(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      // TODO(etienneb): Update the Model with |fields|.
      return true;
    }

  };

  Parser.register(EventTraceParser);

  return {
    EventTraceParser,
  };
});


'use strict';

/**
 * @fileoverview Parses processes events in the Windows event trace format.
 *
 * The Windows process events are:
 *
 * - DCStart: Describes a process that was already running when the trace
 *    started. ETW automatically generates these events for all running
 *    processes at the beginning of the trace.
 * - Start: Describes a process launched during the tracing session.
 * - End: Describes a process that ended during the tracing session.
 * - DCEnd: Describes a process that was still running when the trace ended.
 *
 * See http://msdn.microsoft.com/library/windows/desktop/aa364092.aspx
 */
tr.exportTo('tr.e.importer.etw', function() {
  const Parser = tr.e.importer.etw.Parser;

  // Constants for Process events.
  const guid = '3D6FA8D0-FE05-11D0-9DDA-00C04FD7BA7C';
  const kProcessStartOpcode = 1;
  const kProcessEndOpcode = 2;
  const kProcessDCStartOpcode = 3;
  const kProcessDCEndOpcode = 4;
  const kProcessDefunctOpcode = 39;

  /**
   * Parses Windows process trace events.
   * @constructor
   */
  function ProcessParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kProcessStartOpcode,
        ProcessParser.prototype.decodeStart.bind(this));
    importer.registerEventHandler(guid, kProcessEndOpcode,
        ProcessParser.prototype.decodeEnd.bind(this));
    importer.registerEventHandler(guid, kProcessDCStartOpcode,
        ProcessParser.prototype.decodeDCStart.bind(this));
    importer.registerEventHandler(guid, kProcessDCEndOpcode,
        ProcessParser.prototype.decodeDCEnd.bind(this));
    importer.registerEventHandler(guid, kProcessDefunctOpcode,
        ProcessParser.prototype.decodeDefunct.bind(this));
  }

  ProcessParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields(header, decoder) {
      if (header.version > 5) {
        throw new Error('Incompatible Process event version.');
      }

      let pageDirectoryBase;
      if (header.version === 1) {
        pageDirectoryBase = decoder.decodeUInteger(header.is64);
      }

      let uniqueProcessKey;
      if (header.version >= 2) {
        uniqueProcessKey = decoder.decodeUInteger(header.is64);
      }

      const processId = decoder.decodeUInt32();
      const parentId = decoder.decodeUInt32();

      let sessionId;
      let exitStatus;
      if (header.version >= 1) {
        sessionId = decoder.decodeUInt32();
        exitStatus = decoder.decodeInt32();
      }

      let directoryTableBase;
      if (header.version >= 3) {
        directoryTableBase = decoder.decodeUInteger(header.is64);
      }

      let flags;
      if (header.version >= 4) {
        flags = decoder.decodeUInt32();
      }

      const userSID = decoder.decodeSID(header.is64);

      let imageFileName;
      if (header.version >= 1) {
        imageFileName = decoder.decodeString();
      }

      let commandLine;
      if (header.version >= 2) {
        commandLine = decoder.decodeW16String();
      }

      let packageFullName;
      let applicationId;
      if (header.version >= 4) {
        packageFullName = decoder.decodeW16String();
        applicationId = decoder.decodeW16String();
      }

      let exitTime;
      if (header.version === 5 && header.opcode === kProcessDefunctOpcode) {
        exitTime = decoder.decodeUInt64ToString();
      }

      return {
        pageDirectoryBase,
        uniqueProcessKey,
        processId,
        parentId,
        sessionId,
        exitStatus,
        directoryTableBase,
        flags,
        userSID,
        imageFileName,
        commandLine,
        packageFullName,
        applicationId,
        exitTime
      };
    },

    decodeStart(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      const process = this.model.getOrCreateProcess(fields.processId);
      if (process.hasOwnProperty('has_ended')) {
        // On Windows, a process ID used by a process could be reused as soon as
        // the process ends (there is no pid cycling like on Linux). However, in
        // a short trace, this is unlikely to happen.
        throw new Error('Process clash detected.');
      }
      process.name = fields.imageFileName;
      return true;
    },

    decodeEnd(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      const process = this.model.getOrCreateProcess(fields.processId);
      process.has_ended = true;
      return true;
    },

    decodeDCStart(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      const process = this.model.getOrCreateProcess(fields.processId);
      if (process.hasOwnProperty('has_ended')) {
        throw new Error('Process clash detected.');
      }
      process.name = fields.imageFileName;
      return true;
    },

    decodeDCEnd(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      const process = this.model.getOrCreateProcess(fields.processId);
      process.has_ended = true;
      return true;
    },

    decodeDefunct(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      // TODO(etienneb): Update the Model with |fields|.
      return true;
    }

  };

  Parser.register(ProcessParser);

  return {
    ProcessParser,
  };
});


'use strict';

/**
 * @fileoverview Parses threads events in the Windows event trace format.
 *
 * The Windows thread events are:
 *
 * - DCStart: Describes a thread that was already running when the trace
 *    started. ETW automatically generates these events for all running
 *    threads at the beginning of the trace.
 * - Start: Describes a thread that started during the tracing session.
 * - End: Describes a thread that ended during the tracing session.
 * - DCEnd: Describes a thread that was still alive when the trace ended.
 *
 * See http://msdn.microsoft.com/library/windows/desktop/aa364132.aspx
 */
tr.exportTo('tr.e.importer.etw', function() {
  const Parser = tr.e.importer.etw.Parser;

  // Constants for Thread events.
  const guid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
  const kThreadStartOpcode = 1;
  const kThreadEndOpcode = 2;
  const kThreadDCStartOpcode = 3;
  const kThreadDCEndOpcode = 4;
  const kThreadCSwitchOpcode = 36;

  /**
   * Parses Windows threads trace events.
   * @constructor
   */
  function ThreadParser(importer) {
    Parser.call(this, importer);

    // Register handlers.
    importer.registerEventHandler(guid, kThreadStartOpcode,
        ThreadParser.prototype.decodeStart.bind(this));
    importer.registerEventHandler(guid, kThreadEndOpcode,
        ThreadParser.prototype.decodeEnd.bind(this));
    importer.registerEventHandler(guid, kThreadDCStartOpcode,
        ThreadParser.prototype.decodeDCStart.bind(this));
    importer.registerEventHandler(guid, kThreadDCEndOpcode,
        ThreadParser.prototype.decodeDCEnd.bind(this));
    importer.registerEventHandler(guid, kThreadCSwitchOpcode,
        ThreadParser.prototype.decodeCSwitch.bind(this));
  }

  ThreadParser.prototype = {
    __proto__: Parser.prototype,

    decodeFields(header, decoder) {
      if (header.version > 3) {
        throw new Error('Incompatible Thread event version.');
      }

      // Common fields to all Thread events.
      const processId = decoder.decodeUInt32();
      const threadId = decoder.decodeUInt32();

      // Extended fields.
      let stackBase;
      let stackLimit;
      let userStackBase;
      let userStackLimit;
      let affinity;
      let startAddr;
      let win32StartAddr;
      let tebBase;
      let subProcessTag;
      let basePriority;
      let pagePriority;
      let ioPriority;
      let threadFlags;
      let waitMode;

      if (header.version === 1) {
        // On version 1, only start events have extended information.
        if (header.opcode === kThreadStartOpcode ||
            header.opcode === kThreadDCStartOpcode) {
          stackBase = decoder.decodeUInteger(header.is64);
          stackLimit = decoder.decodeUInteger(header.is64);
          userStackBase = decoder.decodeUInteger(header.is64);
          userStackLimit = decoder.decodeUInteger(header.is64);
          startAddr = decoder.decodeUInteger(header.is64);
          win32StartAddr = decoder.decodeUInteger(header.is64);
          waitMode = decoder.decodeInt8();
          decoder.skip(3);
        }
      } else {
        stackBase = decoder.decodeUInteger(header.is64);
        stackLimit = decoder.decodeUInteger(header.is64);
        userStackBase = decoder.decodeUInteger(header.is64);
        userStackLimit = decoder.decodeUInteger(header.is64);

        // Version 2 produces a field named 'startAddr'.
        if (header.version === 2) {
          startAddr = decoder.decodeUInteger(header.is64);
        } else {
          affinity = decoder.decodeUInteger(header.is64);
        }

        win32StartAddr = decoder.decodeUInteger(header.is64);
        tebBase = decoder.decodeUInteger(header.is64);
        subProcessTag = decoder.decodeUInt32();

        if (header.version === 3) {
          basePriority = decoder.decodeUInt8();
          pagePriority = decoder.decodeUInt8();
          ioPriority = decoder.decodeUInt8();
          threadFlags = decoder.decodeUInt8();
        }
      }

      return {
        processId,
        threadId,
        stackBase,
        stackLimit,
        userStackBase,
        userStackLimit,
        affinity,
        startAddr,
        win32StartAddr,
        tebBase,
        subProcessTag,
        waitMode,
        basePriority,
        pagePriority,
        ioPriority,
        threadFlags
      };
    },

    decodeCSwitchFields(header, decoder) {
      if (header.version !== 2) {
        throw new Error('Incompatible Thread event version.');
      }

      // Decode CSwitch payload.
      const newThreadId = decoder.decodeUInt32();
      const oldThreadId = decoder.decodeUInt32();
      const newThreadPriority = decoder.decodeInt8();
      const oldThreadPriority = decoder.decodeInt8();
      const previousCState = decoder.decodeUInt8();
      const spareByte = decoder.decodeInt8();
      const oldThreadWaitReason = decoder.decodeInt8();
      const oldThreadWaitMode = decoder.decodeInt8();
      const oldThreadState = decoder.decodeInt8();
      const oldThreadWaitIdealProcessor = decoder.decodeInt8();
      const newThreadWaitTime = decoder.decodeUInt32();
      const reserved = decoder.decodeUInt32();

      return {
        newThreadId,
        oldThreadId,
        newThreadPriority,
        oldThreadPriority,
        previousCState,
        spareByte,
        oldThreadWaitReason,
        oldThreadWaitMode,
        oldThreadState,
        oldThreadWaitIdealProcessor,
        newThreadWaitTime,
        reserved
      };
    },

    decodeStart(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
      return true;
    },

    decodeEnd(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      this.importer.removeThreadIfPresent(fields.threadId);
      return true;
    },

    decodeDCStart(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      this.importer.createThreadIfNeeded(fields.processId, fields.threadId);
      return true;
    },

    decodeDCEnd(header, decoder) {
      const fields = this.decodeFields(header, decoder);
      this.importer.removeThreadIfPresent(fields.threadId);
      return true;
    },

    decodeCSwitch(header, decoder) {
      const fields = this.decodeCSwitchFields(header, decoder);
      const cpu = this.importer.getOrCreateCpu(header.cpu);
      const newThread =
          this.importer.getThreadFromWindowsTid(fields.newThreadId);

      // Generate the new thread name. If some events were lost, it's possible
      // that information about the new thread or process is not available.
      let newThreadName;
      if (newThread && newThread.userFriendlyName) {
        newThreadName = newThread.userFriendlyName;
      } else {
        const newProcessId = this.importer.getPidFromWindowsTid(
            fields.newThreadId);
        const newProcess = this.model.getProcess(newProcessId);
        let newProcessName;
        if (newProcess) {
          newProcessName = newProcess.name;
        } else {
          newProcessName = 'Unknown process';
        }

        newThreadName =
            newProcessName + ' (tid ' + fields.newThreadId + ')';
      }

      cpu.switchActiveThread(
          header.timestamp,
          {},
          fields.newThreadId,
          newThreadName,
          fields);
      return true;
    }

  };

  Parser.register(ThreadParser);

  return {
    ThreadParser,
  };
});


/**
 * @fileoverview Imports JSON file with the raw payloads from a Windows event
 * trace into the Model. This format is outputted by Chrome running
 * on a Windows system.
 *
 * This importer assumes the events arrived as a JSON file and the payloads are
 * undecoded sequence of bytes in hex format string. The unit tests provide
 * examples of the trace format.
 *
 * The format of the system trace is
 *     {
 *       name: 'ETW',
 *       content: [ <events> ]
 *     }
  *
 * where the <events> are dictionary values with fields.
 *
 *     {
 *       guid: "1234-...",    // The unique GUID for the event.
 *       op: 12,              // The opcode of the event.
 *       ver: 1,              // The encoding version of the event.
 *       cpu: 0,              // The cpu id on which the event was captured.
 *       ts: 1092,            // The thread id on which the event was captured.
 *       payload: "aaaa"      // A base64 encoded string of the raw payload.
 *     }
 *
 * The payload is an undecoded version of the raw event sent by ETW.
 * This importer uses specific parsers to decode recognized events.
 * A parser need to register the recognized event by calling
 * registerEventHandler(guid, opcode, handler). The parser is responsible to
 * decode the payload and update the Model.
 *
 * The payload formats are described there:
 *   http://msdn.microsoft.com/en-us/library/windows/desktop/aa364085(v=vs.85).aspx
 *
 */
'use strict';

tr.exportTo('tr.e.importer.etw', function() {
  // GUID and opcode of a Thread DCStart event, as defined at the link above.
  const kThreadGuid = '3D6FA8D1-FE05-11D0-9DDA-00C04FD7BA7C';
  const kThreadDCStartOpcode = 3;

  /**
   * Represents the raw bytes payload decoder.
   * @constructor
   */
  function Decoder() {
    this.payload_ = new DataView(new ArrayBuffer(256));
  }

  Decoder.prototype = {
    __proto__: Object.prototype,

    reset(base64Payload) {
      const decodedSize = tr.b.Base64.getDecodedBufferLength(base64Payload);
      if (decodedSize > this.payload_.byteLength) {
        this.payload_ = new DataView(new ArrayBuffer(decodedSize));
      }

      tr.b.Base64.DecodeToTypedArray(base64Payload, this.payload_);
      this.position_ = 0;
    },

    skip(length) {
      this.position_ += length;
    },

    decodeUInt8() {
      const result = this.payload_.getUint8(this.position_, true);
      this.position_ += 1;
      return result;
    },

    decodeUInt16() {
      const result = this.payload_.getUint16(this.position_, true);
      this.position_ += 2;
      return result;
    },

    decodeUInt32() {
      const result = this.payload_.getUint32(this.position_, true);
      this.position_ += 4;
      return result;
    },

    decodeUInt64ToString() {
      // Javascript isn't able to manage 64-bit numeric values.
      const low = this.decodeUInt32();
      const high = this.decodeUInt32();
      const lowStr = ('0000000' + low.toString(16)).substr(-8);
      const highStr = ('0000000' + high.toString(16)).substr(-8);
      const result = highStr + lowStr;
      return result;
    },

    decodeInt8() {
      const result = this.payload_.getInt8(this.position_, true);
      this.position_ += 1;
      return result;
    },

    decodeInt16() {
      const result = this.payload_.getInt16(this.position_, true);
      this.position_ += 2;
      return result;
    },

    decodeInt32() {
      const result = this.payload_.getInt32(this.position_, true);
      this.position_ += 4;
      return result;
    },

    decodeInt64ToString() {
      // Javascript isn't able to manage 64-bit numeric values.
      // Fallback to unsigned 64-bit hexa value.
      return this.decodeUInt64ToString();
    },

    decodeUInteger(is64) {
      if (is64) {
        return this.decodeUInt64ToString();
      }
      return this.decodeUInt32();
    },

    decodeString() {
      let str = '';
      while (true) {
        const c = this.decodeUInt8();
        if (!c) return str;
        str = str + String.fromCharCode(c);
      }
    },

    decodeW16String() {
      let str = '';
      while (true) {
        const c = this.decodeUInt16();
        if (!c) return str;
        str = str + String.fromCharCode(c);
      }
    },

    decodeFixedW16String(length) {
      const oldPosition = this.position_;
      let str = '';
      for (let i = 0; i < length; i++) {
        const c = this.decodeUInt16();
        if (!c) break;
        str = str + String.fromCharCode(c);
      }

      // Move the position after the fixed buffer (i.e. wchar[length]).
      this.position_ = oldPosition + 2 * length;
      return str;
    },

    decodeBytes(length) {
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        const c = this.decodeUInt8();
        bytes.push(c);
      }
      return bytes;
    },

    decodeSID(is64) {
      // Decode the TOKEN_USER structure.
      const pSid = this.decodeUInteger(is64);
      const attributes = this.decodeUInt32();

      // Skip padding.
      if (is64) {
        this.decodeUInt32();
      }

      // Decode the SID structure.
      const revision = this.decodeUInt8();
      const subAuthorityCount = this.decodeUInt8();
      this.decodeUInt16();
      this.decodeUInt32();

      if (revision !== 1) {
        throw new Error(
            'Invalid SID revision: could not decode the SID structure.');
      }

      const sid = this.decodeBytes(4 * subAuthorityCount);

      return {
        pSid,
        attributes,
        sid
      };
    },

    decodeSystemTime() {
      // Decode the SystemTime structure.
      const wYear = this.decodeInt16();
      const wMonth = this.decodeInt16();
      const wDayOfWeek = this.decodeInt16();
      const wDay = this.decodeInt16();
      const wHour = this.decodeInt16();
      const wMinute = this.decodeInt16();
      const wSecond = this.decodeInt16();
      const wMilliseconds = this.decodeInt16();
      return {
        wYear,
        wMonth,
        wDayOfWeek,
        wDay,
        wHour,
        wMinute,
        wSecond,
        wMilliseconds
      };
    },

    decodeTimeZoneInformation() {
      // Decode the TimeZoneInformation structure.
      const bias = this.decodeUInt32();
      const standardName = this.decodeFixedW16String(32);
      const standardDate = this.decodeSystemTime();
      const standardBias = this.decodeUInt32();
      const daylightName = this.decodeFixedW16String(32);
      const daylightDate = this.decodeSystemTime();
      const daylightBias = this.decodeUInt32();
      return {
        bias,
        standardName,
        standardDate,
        standardBias,
        daylightName,
        daylightDate,
        daylightBias
      };
    }

  };

  /**
   * Imports Windows ETW kernel events into a specified model.
   * @constructor
   */
  function EtwImporter(model, events) {
    this.importPriority = 3;
    this.model_ = model;
    this.events_ = events;
    this.handlers_ = {};
    this.decoder_ = new Decoder();
    this.walltime_ = undefined;
    this.ticks_ = undefined;
    this.is64bit_ = undefined;

    // A map of tids to their process pid. On Windows, the tid is global to
    // the system and doesn't need to belong to a process. As many events
    // only provide tid, this map allows to retrieve the parent process.
    this.tidsToPid_ = {};

    // Instantiate the parsers; this will register handlers for known events.
    const allTypeInfos = tr.e.importer.etw.Parser.getAllRegisteredTypeInfos();
    this.parsers_ = allTypeInfos.map(
        function(typeInfo) {
          return new typeInfo.constructor(this);
        }, this);
  }

  /**
   * Guesses whether the provided events is from a Windows ETW trace.
   * The object must has a property named 'name' with the value 'ETW' and
   * a property 'content' with all the undecoded events.
   *
   * @return {boolean} True when events is a Windows ETW array.
   */
  EtwImporter.canImport = function(events) {
    if (!events.hasOwnProperty('name') ||
        !events.hasOwnProperty('content') ||
        events.name !== 'ETW') {
      return false;
    }

    return true;
  };

  EtwImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'EtwImporter';
    },

    get model() {
      return this.model_;
    },

    createThreadIfNeeded(pid, tid) {
      this.tidsToPid_[tid] = pid;
    },

    removeThreadIfPresent(tid) {
      this.tidsToPid_[tid] = undefined;
    },

    getPidFromWindowsTid(tid) {
      if (tid === 0) return 0;
      const pid = this.tidsToPid_[tid];
      if (pid === undefined) {
        // Kernel threads are not defined.
        return 0;
      }
      return pid;
    },

    getThreadFromWindowsTid(tid) {
      const pid = this.getPidFromWindowsTid(tid);
      const process = this.model_.getProcess(pid);
      if (!process) return undefined;
      return process.getThread(tid);
    },

    /*
     * Retrieve the Cpu for a given cpuNumber.
     * @return {Cpu} A Cpu corresponding to the given cpuNumber.
     */
    getOrCreateCpu(cpuNumber) {
      const cpu = this.model_.kernel.getOrCreateCpu(cpuNumber);
      return cpu;
    },

    /**
     * Imports the data in this.events_ into this.model_.
     */
    importEvents() {
      this.events_.content.forEach(this.parseInfo.bind(this));

      if (this.walltime_ === undefined || this.ticks_ === undefined) {
        throw Error('Cannot find clock sync information in the system trace.');
      }

      if (this.is64bit_ === undefined) {
        throw Error('Cannot determine pointer size of the system trace.');
      }

      this.events_.content.forEach(this.parseEvent.bind(this));
    },

    importTimestamp(timestamp) {
      const ts = parseInt(timestamp, 16);
      return (ts - this.walltime_ + this.ticks_) / 1000.;
    },

    parseInfo(event) {
      // Retrieve clock sync information.
      if (event.hasOwnProperty('guid') &&
          event.hasOwnProperty('walltime') &&
          event.hasOwnProperty('tick') &&
          event.guid === 'ClockSync') {
        this.walltime_ = parseInt(event.walltime, 16);
        this.ticks_ = parseInt(event.tick, 16);
      }

      // Retrieve pointer size information from a Thread.DCStart event.
      if (this.is64bit_ === undefined &&
          event.hasOwnProperty('guid') &&
          event.hasOwnProperty('op') &&
          event.hasOwnProperty('ver') &&
          event.hasOwnProperty('payload') &&
          event.guid === kThreadGuid &&
          event.op === kThreadDCStartOpcode) {
        const decodedSize = tr.b.Base64.getDecodedBufferLength(event.payload);

        if (event.ver === 1) {
          if (decodedSize >= 52) {
            this.is64bit_ = true;
          } else {
            this.is64bit_ = false;
          }
        } else if (event.ver === 2) {
          if (decodedSize >= 64) {
            this.is64bit_ = true;
          } else {
            this.is64bit_ = false;
          }
        } else if (event.ver === 3) {
          if (decodedSize >= 60) {
            this.is64bit_ = true;
          } else {
            this.is64bit_ = false;
          }
        }
      }

      return true;
    },

    parseEvent(event) {
      if (!event.hasOwnProperty('guid') ||
          !event.hasOwnProperty('op') ||
          !event.hasOwnProperty('ver') ||
          !event.hasOwnProperty('cpu') ||
          !event.hasOwnProperty('ts') ||
          !event.hasOwnProperty('payload')) {
        return false;
      }

      const timestamp = this.importTimestamp(event.ts);

      // Create the event header.
      const header = {
        guid: event.guid,
        opcode: event.op,
        version: event.ver,
        cpu: event.cpu,
        timestamp,
        is64: this.is64bit_
      };

      // Set the payload to decode.
      const decoder = this.decoder_;
      decoder.reset(event.payload);

      // Retrieve the handler to decode the payload.
      const handler = this.getEventHandler(header.guid, header.opcode);
      if (!handler) return false;

      if (!handler(header, decoder)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Malformed ' + header.guid + ' event (' + event.payload + ')'
        });
        return false;
      }

      return true;
    },

    /**
     * Registers a windows ETW event handler used by parseEvent().
     */
    registerEventHandler(guid, opcode, handler) {
      if (this.handlers_[guid] === undefined) {
        this.handlers_[guid] = [];
      }
      this.handlers_[guid][opcode] = handler;
    },

    /**
     * Retrieves a registered event handler.
     */
    getEventHandler(guid, opcode) {
      if (this.handlers_[guid] === undefined) {
        return undefined;
      }
      return this.handlers_[guid][opcode];
    }

  };

  // Register the EtwImporter to the Importer.
  tr.importer.Importer.register(EtwImporter);

  return {
    EtwImporter,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  /**
   * A TraceStream is a data structure holding trace data that supports
   * sequentially reading data, efficiently. It also supports rewinding to the
   * beginning of the trace data and building a sub-stream; but, the latter two
   * operations do not have to be very efficient. For example, it is OK that an
   * implementation sends a new XHR to get the trace data again when rewinding
   * or creating a sub-stream from a large stream that does not fit in memory.
   */
  class TraceStream {
    static get HEADER_SIZE() {
      return Math.pow(2, 10);
    }

    static get CHUNK_SIZE() {
      return Math.pow(2, 20);
    }

    get isBinary() {
      throw new Error('Not implemented');
    }

    /**
     * @returns {boolean} true if there is data remaining in the stream to read,
     * without rewinding.
     */
    get hasData() {
      throw new Error('Not implemented');
    }

    /**
     * @returns {string} The first chunk of the stream. The header size is
     * either given in the constructor or the default 1KB is used.
     */
    get header() {
      throw new Error('Not implemented');
    }

    /**
     * Reads until a given character, including the given character.
     *
     * @param {!string} delim A string of size exactly one.
     *
     * @returns {!string} The data until the delimiter as a string. If the
     * delimiter is not found, all of the remaining data is returned.
     */
    readUntilDelimiter(delim) {
      throw new Error('Not implemented');
    }

    /**
     * Reads a specific number of bytes from the stream.
     *
     * @param {number=} opt_size The maximum number of bytes to be read from the
     * stream. If unspecified, at most 1MB will be read.
     *
     * @returns {!string} A string of size opt_size, unless there is not enough
     * data in the stream in which the string will be smaller.
     */
    readNumBytes(opt_size) {
      throw new Error('Not implemented');
    }

    rewind() {
      throw new Error('Not implemented');
    }

    /**
     * Returns a new stream, created from a subset of this stream. This is
     * needed to support importing subtraces. For example, when the importer
     * encounters a trace event stream that has a BattOr subtrace in it, it will
     * create a new stream for the BattOr subtrace and use the proper importer.
     *
     * @param {!number} startOffset The start offset of the new stream.
     * @param {number=} opt_endOffset The end offset of the new stream
     * (exclusive). If unspecified, the end offset of the current stream is
     * used.
     * @param {number=} opt_headerSize The header size of the new stream. If
     * unspecified, the header size is assumed to be 1KB.
     *
     * @returns {!TraceStream} The new stream. The cursor of the new stream will
     * be at the beginning.
     */
    substream(offset, opt_length, opt_headerSize) {
      throw new Error('Not implemented');
    }
  }

  return {
    TraceStream,
  };
});


'use strict';

tr.exportTo('tr.e.importer.fuchsia', function() {
  const IMPORT_PRIORITY = 0;
  const IDLE_THREAD_THRESHOLD = 6444000000;

  class FuchsiaImporter extends tr.importer.Importer {
    constructor(model, eventData) {
      super(model, eventData);
      this.importPriority = IMPORT_PRIORITY;
      this.model_ = model;
      this.events_ = eventData.events;
      this.parsers_ = [];
      this.threadInfo_ = new Map();
      this.processNames_ = new Map();
    }

    static canImport(eventData) {
      if (eventData instanceof tr.b.TraceStream) {
        if (eventData.isBinary) return false;
        eventData = eventData.header;
      }

      if (eventData instanceof Object && eventData.type === 'fuchsia') {
        return true;
      }

      return false;
    }

    get importerName() {
      return 'FuchsiaImporter';
    }

    get model() {
      return this.model_;
    }

    importClockSyncMarkers() {
    }

    finalizeImport() {
    }

    processContextSwitchEvent_(event) {
      let tid = event.in.tid;
      let threadName = tid.toString();
      let procName = '';

      if (this.threadInfo_.has(tid)) {
        const threadInfo = this.threadInfo_.get(tid);
        threadName = threadInfo.name;
        const pid = threadInfo.pid;
        if (this.processNames_.has(pid)) {
          procName = this.processNames_.get(pid) + ':';
        }
      }

      const name = procName + threadName;

      // There's not a good way to detect the kernel's idle threads right now
      // so we're stuck with assuming that large numbered threads are idle ones.
      if (tid > IDLE_THREAD_THRESHOLD) {
        tid = undefined; // Fake kernel idle task
      }

      const cpu = this.model_.kernel.getOrCreateCpu(event.cpu);
      cpu.switchActiveThread(tr.b.Unit.timestampFromUs(event.ts),
                             {}, tid, name, tid);
    }

    processProcessInfoEvent_(event) {
      const process = this.model_.getOrCreateProcess(event.pid);
      process.name = event.name;
      this.processNames_.set(event.pid, event.name);

      if ('sort_index' in event) {
        process.sortIndex = event.sort_index;
      }
    }

    processThreadInfoEvent_(event) {
      const thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      thread.name = event.name;
      this.threadInfo_.set(event.tid, {'name': event.name, 'pid': event.pid});

      if ('sort_index' in event) {
        const thread = this.model_.getOrCreateProcess(event.pid).
            getOrCreateThread(event.tid);
        thread.sortIndex = event.sort_index;
      }
    }

    processEvent_(event) {
      switch (event.ph) {
        case 'k':
          this.processContextSwitchEvent_(event);
          break;
        case 'p':
          this.processProcessInfoEvent_(event);
          break;
        case 't':
          this.processThreadInfoEvent_(event);
          break;
      }
    }

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents() {
      for (const event of this.events_) {
        this.processEvent_(event);
      }
    }
  }

  tr.importer.Importer.register(FuchsiaImporter);

  return {
    FuchsiaImporter,
    IMPORT_PRIORITY,
  };
});


'use strict';

tr.exportTo('tr.b', function() {
  const MAX_FUNCTION_ARGS_COUNT = Math.pow(2, 15) - 1;

  class InMemoryTraceStream extends tr.b.TraceStream {
    constructor(buffer, isBinary, opt_headerSize) {
      super();
      if (!buffer instanceof Uint8Array) {
        throw new Error('buffer should be a Uint8Array');
      }
      const headerSize = opt_headerSize || tr.b.TraceStream.HEADER_SIZE;

      this.data_ = buffer;
      this.isBinary_ = isBinary;
      this.header_ = InMemoryTraceStream.uint8ArrayToString_(
          this.data_.subarray(0, headerSize));
      this.cursor_ = 0;
    }

    get isBinary() {
      return this.isBinary_;
    }

    get hasData() {
      return this.cursor_ < this.data_.length;
    }

    get header() {
      return this.header_;
    }

    get data() {
      return this.data_;
    }

    toString() {
      this.rewind();
      return this.readNumBytes(Number.MAX_VALUE);
    }

    readUntilDelimiter(delim) {
      if (delim.length !== 1) {
        throw new Error('delim must be exactly one character');
      }
      const offset = this.data_.indexOf(delim.charCodeAt(0), this.cursor_) + 1;
      return this.readToOffset_(
          offset > 0 ? Math.min(offset, this.data_.length) : this.data_.length);
    }

    readNumBytes(opt_size) {
      if (opt_size !== undefined && opt_size <= 0) {
        throw new Error(
            `readNumBytes expects a positive size (${opt_size} given)`);
      }

      const size = opt_size || tr.b.TraceStream.CHUNK_SIZE;
      const offset = Math.min(this.cursor_ + size, this.data_.length);
      return this.readToOffset_(offset);
    }

    rewind() {
      this.cursor_ = 0;
    }

    // The underlying buffer is not copied.
    substream(startOffset, opt_endOffset, opt_headerSize) {
      return new InMemoryTraceStream(
          this.data_.subarray(startOffset, opt_endOffset), this.isBinary_,
          opt_headerSize);
    }

    /**
     * @returns {string} The contents of the stream between the current cursor
     * location (inclusive) and |offset| (exclusive). The cursor location is
     * moved forward to |offset|.
     */
    readToOffset_(offset) {
      const out = InMemoryTraceStream.uint8ArrayToString_(
          this.data_.subarray(this.cursor_, offset));
      this.cursor_ = offset;
      return out;
    }

    static uint8ArrayToString_(arr) {
      if (typeof TextDecoder !== 'undefined') {
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(arr);
      }
      const c = [];
      for (let i = 0; i < arr.length; i += MAX_FUNCTION_ARGS_COUNT) {
        c.push(String.fromCharCode(...arr.subarray(
            i, i + MAX_FUNCTION_ARGS_COUNT)));
      }
      return c.join('');
    }
  }

  return {
    InMemoryTraceStream,
  };
});


'use strict';
// Vinn workaround for JSzip requiring window.
if (tr.isVinn) {
  /**
   * Hack.
   */
  global.window = {};
}

/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;"undefined"!=typeof window?b=window:"undefined"!=typeof global?b=global:"undefined"!=typeof self&&(b=self),b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};b[g][0].call(j.exports,function(a){var c=b[g][1][a];return e(c?c:a)},j,j.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,f,g,h,i,j="",k=0;k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),e=a.charCodeAt(k++),f=b>>2,g=(3&b)<<4|c>>4,h=(15&c)<<2|e>>6,i=63&e,isNaN(c)?h=i=64:isNaN(e)&&(i=64),j=j+d.charAt(f)+d.charAt(g)+d.charAt(h)+d.charAt(i);return j},c.decode=function(a){var b,c,e,f,g,h,i,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)f=d.indexOf(a.charAt(k++)),g=d.indexOf(a.charAt(k++)),h=d.indexOf(a.charAt(k++)),i=d.indexOf(a.charAt(k++)),b=f<<2|g>>4,c=(15&g)<<4|h>>2,e=(3&h)<<6|i,j+=String.fromCharCode(b),64!=h&&(j+=String.fromCharCode(c)),64!=i&&(j+=String.fromCharCode(e));return j}},{}],2:[function(a,b){"use strict";function c(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}c.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=c},{}],3:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":8}],4:[function(a,b){"use strict";var c=a("./utils"),d=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var e="string"!==c.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=e?a[i]:a.charCodeAt(i),g=255&(b^h),f=d[g],b=b>>>8^f;return-1^b}},{"./utils":21}],5:[function(a,b){"use strict";function c(){this.data=null,this.length=0,this.index=0}var d=a("./utils");c.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return d.transformTo("string",this.readData(a))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=c},{"./utils":21}],6:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.comment=null},{}],7:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":21}],8:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a){return e.deflateRaw(a)},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:24}],9:[function(a,b){"use strict";function c(a,b){return this instanceof c?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new c;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new c(a,b)}var d=a("./base64");c.prototype=a("./object"),c.prototype.load=a("./load"),c.support=a("./support"),c.defaults=a("./defaults"),c.utils=a("./deprecatedPublicUtils"),c.base64={encode:function(a){return d.encode(a)},decode:function(a){return d.decode(a)}},c.compressions=a("./compressions"),b.exports=c},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(a,b){"use strict";var c=a("./base64"),d=a("./zipEntries");b.exports=function(a,b){var e,f,g,h;for(b=b||{},b.base64&&(a=c.decode(a)),f=new d(a,b),e=f.files,g=0;g<e.length;g++)h=e[g],this.file(h.fileName,h.decompressed,{binary:!0,optimizedBinaryString:!0,date:h.date,dir:h.dir,comment:h.fileComment.length?h.fileComment:null,createFolders:b.createFolders});return f.zipComment.length&&(this.comment=f.zipComment),this}},{"./base64":1,"./zipEntries":22}],11:[function(a,b){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],12:[function(a,b){"use strict";function c(a){this.data=a,this.length=this.data.length,this.index=0}var d=a("./uint8ArrayReader");c.prototype=new d,c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./uint8ArrayReader":18}],13:[function(a,b){"use strict";var c=a("./support"),d=a("./utils"),e=a("./crc32"),f=a("./signature"),g=a("./defaults"),h=a("./base64"),i=a("./compressions"),j=a("./compressedObject"),k=a("./nodeBuffer"),l=a("./utf8"),m=a("./stringWriter"),n=a("./uint8ArrayWriter"),o=function(a){if(a._data instanceof j&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===d.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},p=function(a){var b=o(a),e=d.getTypeOf(b);return"string"===e?!a.options.binary&&c.nodebuffer?k(b,"utf-8"):a.asBinary():b},q=function(a){var b=o(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=h.decode(b)),b=a&&this.options.binary?A.utf8decode(b):d.transformTo("string",b),a||this.options.binary||(b=d.transformTo("string",A.utf8encode(b))),b)},r=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};r.prototype={asText:function(){return q.call(this,!0)},asBinary:function(){return q.call(this,!1)},asNodeBuffer:function(){var a=p(this);return d.transformTo("nodebuffer",a)},asUint8Array:function(){var a=p(this);return d.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var s=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},t=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=t(a,g),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var e,f=d.getTypeOf(b);if(c=u(c),c.createFolders&&(e=w(a))&&x.call(this,e,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=d.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof j))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=d.transformTo("uint8array",b))}var g=new r(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a,b){return"/"!=a.slice(-1)&&(a+="/"),b="undefined"!=typeof b?b:!1,this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},y=function(a,b){var c,f=new j;return a._data instanceof j?(f.uncompressedSize=a._data.uncompressedSize,f.crc32=a._data.crc32,0===f.uncompressedSize||a.dir?(b=i.STORE,f.compressedContent="",f.crc32=0):a._data.compressionMethod===b.magic?f.compressedContent=a._data.getCompressedContent():(c=a._data.getContent(),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c)))):(c=p(a),(!c||0===c.length||a.dir)&&(b=i.STORE,c=""),f.uncompressedSize=c.length,f.crc32=e(c),f.compressedContent=b.compress(d.transformTo(b.compressInputType,c))),f.compressedSize=f.compressedContent.length,f.compressionMethod=b.magic,f},z=function(a,b,c,g){var h,i,j,k,m=(c.compressedContent,d.transformTo("string",l.utf8encode(b.name))),n=b.comment||"",o=d.transformTo("string",l.utf8encode(n)),p=m.length!==b.name.length,q=o.length!==n.length,r=b.options,t="",u="",v="";j=b._initialMetadata.dir!==b.dir?b.dir:r.dir,k=b._initialMetadata.date!==b.date?b.date:r.date,h=k.getHours(),h<<=6,h|=k.getMinutes(),h<<=5,h|=k.getSeconds()/2,i=k.getFullYear()-1980,i<<=4,i|=k.getMonth()+1,i<<=5,i|=k.getDate(),p&&(u=s(1,1)+s(e(m),4)+m,t+="up"+s(u.length,2)+u),q&&(v=s(1,1)+s(this.crc32(o),4)+o,t+="uc"+s(v.length,2)+v);var w="";w+="\n\x00",w+=p||q?"\x00\b":"\x00\x00",w+=c.compressionMethod,w+=s(h,2),w+=s(i,2),w+=s(c.crc32,4),w+=s(c.compressedSize,4),w+=s(c.uncompressedSize,4),w+=s(m.length,2),w+=s(t.length,2);var x=f.LOCAL_FILE_HEADER+w+m+t,y=f.CENTRAL_FILE_HEADER+"\x00"+w+s(o.length,2)+"\x00\x00\x00\x00"+(j===!0?"\x00\x00\x00":"\x00\x00\x00\x00")+s(g,4)+m+t+o;return{fileRecord:x,dirRecord:y,compressedObject:c}},A={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,e,f=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],e=new r(d.name,d._data,t(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,e)&&f.push(e));return f},file:function(a,b,c){if(1===arguments.length){if(d.isRegExp(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=x.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=t(a||{},{base64:!0,compression:"STORE",type:"base64",comment:null}),d.checkSupport(a.type);var b,c,e=[],g=0,j=0,k=d.transformTo("string",this.utf8encode(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var o=this.files[l],p=o.options.compression||a.compression.toUpperCase(),q=i[p];if(!q)throw new Error(p+" is not a valid compression method !");var r=y.call(this,o,q),u=z.call(this,l,o,r,g);g+=u.fileRecord.length+r.compressedSize,j+=u.dirRecord.length,e.push(u)}var v="";v=f.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+s(e.length,2)+s(e.length,2)+s(j,4)+s(g,4)+s(k.length,2)+k;var w=a.type.toLowerCase();for(b="uint8array"===w||"arraybuffer"===w||"blob"===w||"nodebuffer"===w?new n(g+j+v.length):new m(g+j+v.length),c=0;c<e.length;c++)b.append(e[c].fileRecord),b.append(e[c].compressedObject.compressedContent);for(c=0;c<e.length;c++)b.append(e[c].dirRecord);b.append(v);var x=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return d.transformTo(a.type.toLowerCase(),x);case"blob":return d.arrayBuffer2Blob(d.transformTo("arraybuffer",x));case"base64":return a.base64?h.encode(x):x;default:return x}},crc32:function(a,b){return e(a,b)},utf8encode:function(a){return d.transformTo("string",l.utf8encode(a))},utf8decode:function(a){return l.utf8decode(a)}};b.exports=A},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],15:[function(a,b){"use strict";function c(a,b){this.data=a,b||(this.data=e.string2binary(this.data)),this.length=this.data.length,this.index=0}var d=a("./dataReader"),e=a("./utils");c.prototype=new d,c.prototype.byteAt=function(a){return this.data.charCodeAt(a)},c.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)},c.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5,"./utils":21}],16:[function(a,b){"use strict";var c=a("./utils"),d=function(){this.data=[]};d.prototype={append:function(a){a=c.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=d},{"./utils":21}],17:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],18:[function(a,b){"use strict";function c(a){a&&(this.data=a,this.length=this.data.length,this.index=0)}var d=a("./dataReader");c.prototype=new d,c.prototype.byteAt=function(a){return this.data[a]},c.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f;return-1},c.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.index,this.index+a);return this.index+=a,b},b.exports=c},{"./dataReader":5}],19:[function(a,b){"use strict";var c=a("./utils"),d=function(a){this.data=new Uint8Array(a),this.index=0};d.prototype={append:function(a){0!==a.length&&(a=c.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=d},{"./utils":21}],20:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;h>b;)if(e=a[b++],128>e)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&h>b;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:65536>e?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;f>c;){var h=j(a,Math.min(c+g,f));b.push(e.uint8array?k(a.subarray(c,h)):k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{d.push("array"===f||"nodebuffer"===f?String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e))):String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a){c.checkSupport("blob");try{return new Blob([a],{type:"application/zip"})}catch(b){try{var d=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,e=new d;return e.append(a),e.getBlob("application/zip")}catch(b){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(a,b){"use strict";function c(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var d=a("./stringReader"),e=a("./nodeBufferReader"),f=a("./uint8ArrayReader"),g=a("./utils"),h=a("./signature"),i=a("./zipEntry"),j=a("./support"),k=a("./object");c.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+g.pretty(b)+", expected "+g.pretty(a)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength),this.zipComment=k.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(h.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===h.CENTRAL_FILE_HEADER;)a=new i({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(h.CENTRAL_DIRECTORY_END);if(-1===a)throw new Error("Corrupted zip : can't find end of central directory");if(this.reader.setIndex(a),this.checkSignature(h.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===g.MAX_VALUE_16BITS||this.diskWithCentralDirStart===g.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===g.MAX_VALUE_16BITS||this.centralDirRecords===g.MAX_VALUE_16BITS||this.centralDirSize===g.MAX_VALUE_32BITS||this.centralDirOffset===g.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),-1===a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(a),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(h.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(a){var b=g.getTypeOf(a);this.reader="string"!==b||j.uint8array?"nodebuffer"===b?new e(a):new f(g.transformTo("uint8array",a)):new d(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=c},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(a,b){"use strict";function c(a,b){this.options=a,this.loadOptions=b}var d=a("./stringReader"),e=a("./utils"),f=a("./compressedObject"),g=a("./object");c.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,f){return function(){var a=e.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==f)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readString(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=e.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+e.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new f,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=e.transformTo("string",this.decompressed.getContent()),g.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readString(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readString(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readString(this.fileCommentLength),this.dir=16&this.externalFileAttributes?!0:!1},parseZIP64ExtraField:function(){if(this.extraFields[1]){var a=new d(this.extraFields[1].value);this.uncompressedSize===e.MAX_VALUE_32BITS&&(this.uncompressedSize=a.readInt(8)),this.compressedSize===e.MAX_VALUE_32BITS&&(this.compressedSize=a.readInt(8)),this.localHeaderOffset===e.MAX_VALUE_32BITS&&(this.localHeaderOffset=a.readInt(8)),this.diskNumberStart===e.MAX_VALUE_32BITS&&(this.diskNumberStart=a.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){if(this.useUTF8())this.fileName=g.utf8decode(this.fileName),this.fileComment=g.utf8decode(this.fileComment);else{var a=this.findExtraFieldUnicodePath();null!==a&&(this.fileName=a);var b=this.findExtraFieldUnicodeComment();null!==b&&(this.fileComment=b)}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileName)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new d(a.value);return 1!==b.readInt(1)?null:g.crc32(this.fileComment)!==b.readInt(4)?null:g.utf8decode(b.readString(a.length-5))}return null}},b.exports=c},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(a,b){"use strict";var c=a("./lib/utils/common").assign,d=a("./lib/deflate"),e=a("./lib/inflate"),f=a("./lib/zlib/constants"),g={};c(g,d,e,f),b.exports=g},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(a,b,c){"use strict";function d(a,b){var c=new s(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}function f(a,b){return b=b||{},b.gzip=!0,d(a,b)}var g=a("./zlib/deflate.js"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=0,m=4,n=0,o=1,p=-1,q=0,r=8,s=function(a){this.options=h.assign({level:p,method:r,chunkSize:16384,windowBits:15,memLevel:8,strategy:q,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=g.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==n)throw new Error(j[c]);b.header&&g.deflateSetHeader(this.strm,b.header)
};s.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?m:l,e.input="string"==typeof a?i.string2buf(a):a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new h.Buf8(f),e.next_out=0,e.avail_out=f),c=g.deflate(e,d),c!==o&&c!==n)return this.onEnd(c),this.ended=!0,!1;(0===e.avail_out||0===e.avail_in&&d===m)&&this.onData("string"===this.options.to?i.buf2binstring(h.shrinkBuf(e.output,e.next_out)):h.shrinkBuf(e.output,e.next_out))}while((e.avail_in>0||0===e.avail_out)&&c!==o);return d===m?(c=g.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===n):!0},s.prototype.onData=function(a){this.chunks.push(a)},s.prototype.onEnd=function(a){a===n&&(this.result="string"===this.options.to?this.chunks.join(""):h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=s,c.deflate=d,c.deflateRaw=e,c.gzip=f},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(a,b,c){"use strict";function d(a,b){var c=new m(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function e(a,b){return b=b||{},b.raw=!0,d(a,b)}var f=a("./zlib/inflate.js"),g=a("./utils/common"),h=a("./utils/strings"),i=a("./zlib/constants"),j=a("./zlib/messages"),k=a("./zlib/zstream"),l=a("./zlib/gzheader"),m=function(a){this.options=g.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new k,this.strm.avail_out=0;var c=f.inflateInit2(this.strm,b.windowBits);if(c!==i.Z_OK)throw new Error(j[c]);this.header=new l,f.inflateGetHeader(this.strm,this.header)};m.prototype.push=function(a,b){var c,d,e,j,k,l=this.strm,m=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?i.Z_FINISH:i.Z_NO_FLUSH,l.input="string"==typeof a?h.binstring2buf(a):a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new g.Buf8(m),l.next_out=0,l.avail_out=m),c=f.inflate(l,i.Z_NO_FLUSH),c!==i.Z_STREAM_END&&c!==i.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0===l.avail_out||c===i.Z_STREAM_END||0===l.avail_in&&d===i.Z_FINISH)&&("string"===this.options.to?(e=h.utf8border(l.output,l.next_out),j=l.next_out-e,k=h.buf2string(l.output,e),l.next_out=j,l.avail_out=m-j,j&&g.arraySet(l.output,l.output,e,j,0),this.onData(k)):this.onData(g.shrinkBuf(l.output,l.next_out)))}while(l.avail_in>0&&c!==i.Z_STREAM_END);return c===i.Z_STREAM_END&&(d=i.Z_FINISH),d===i.Z_FINISH?(c=f.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===i.Z_OK):!0},m.prototype.onData=function(a){this.chunks.push(a)},m.prototype.onEnd=function(a){a===i.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):g.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=m,c.inflate=d,c.inflateRaw=e,c.ungzip=d},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],28:[function(a,b,c){"use strict";function d(a,b){if(65537>b&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;b>d;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;256>j;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new e.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;d>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;h>c;)if(f=a[c++],128>f)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&h>c;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:65536>f?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":27}],29:[function(a,b){"use strict";function c(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=c},{}],30:[function(a,b){b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(a,b){"use strict";function c(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function d(a,b,c,d){var f=e,g=d+c;a=-1^a;for(var h=d;g>h;h++)a=a>>>8^f[255&(a^b[h])];return-1^a}var e=c();b.exports=d},{}],32:[function(a,b,c){"use strict";function d(a,b){return a.msg=G[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(C.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){D._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,C.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=E(a.adler,b,e,c):2===a.state.wrap&&(a.adler=F(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-jb?a.strstart-(a.w_size-jb):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ib,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ib-(m-f),f=m-ib,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-jb)){C.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=hb)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+hb-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<hb)););}while(a.lookahead<jb&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===H)return sb;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return sb;if(a.strstart-a.block_start>=a.w_size-jb&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?sb:sb}function o(a,b){for(var c,d;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c)),a.match_length>=hb)if(d=D._tr_tally(a,a.strstart-a.match_start,a.match_length-hb),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=hb){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function p(a,b){for(var c,d,e;;){if(a.lookahead<jb){if(m(a),a.lookahead<jb&&b===H)return sb;if(0===a.lookahead)break}if(c=0,a.lookahead>=hb&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=hb-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-jb&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===S||a.match_length===hb&&a.strstart-a.match_start>4096)&&(a.match_length=hb-1)),a.prev_length>=hb&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-hb,d=D._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-hb),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+hb-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=hb-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return sb}else if(a.match_available){if(d=D._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return sb}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=D._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<hb-1?a.strstart:hb-1,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ib){if(m(a),a.lookahead<=ib&&b===H)return sb;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=hb&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ib;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ib-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=hb?(c=D._tr_tally(a,1,a.match_length-hb),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===H)return sb;break}if(a.match_length=0,c=D._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return sb}return a.insert=0,b===K?(h(a,!0),0===a.strm.avail_out?ub:vb):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?sb:tb}function s(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=B[a.level].max_lazy,a.good_match=B[a.level].good_length,a.nice_match=B[a.level].nice_length,a.max_chain_length=B[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=hb-1,a.match_available=0,a.ins_h=0}function t(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Y,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new C.Buf16(2*fb),this.dyn_dtree=new C.Buf16(2*(2*db+1)),this.bl_tree=new C.Buf16(2*(2*eb+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new C.Buf16(gb+1),this.heap=new C.Buf16(2*cb+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new C.Buf16(2*cb+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function u(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=X,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?lb:qb,a.adler=2===b.wrap?0:1,b.last_flush=H,D._tr_init(b),M):d(a,O)}function v(a){var b=u(a);return b===M&&s(a.state),b}function w(a,b){return a&&a.state?2!==a.state.wrap?O:(a.state.gzhead=b,M):O}function x(a,b,c,e,f,g){if(!a)return O;var h=1;if(b===R&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>Z||c!==Y||8>e||e>15||0>b||b>9||0>g||g>V)return d(a,O);8===e&&(e=9);var i=new t;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+hb-1)/hb),i.window=new C.Buf8(2*i.w_size),i.head=new C.Buf16(i.hash_size),i.prev=new C.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new C.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,v(a)}function y(a,b){return x(a,b,Y,$,_,W)}function z(a,b){var c,h,k,l;if(!a||!a.state||b>L||0>b)return a?d(a,O):O;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===rb&&b!==K)return d(a,0===a.avail_out?Q:O);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===lb)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=F(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=mb):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=T||h.level<2?4:0),i(h,wb),h.status=qb);else{var m=Y+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=T||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=kb),m+=31-m%31,h.status=qb,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===mb)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=nb)}else h.status=nb;if(h.status===nb)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=ob)}else h.status=ob;if(h.status===ob)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=F(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=pb)}else h.status=pb;if(h.status===pb&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=qb)):h.status=qb),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,M}else if(0===a.avail_in&&e(b)<=e(c)&&b!==K)return d(a,Q);if(h.status===rb&&0!==a.avail_in)return d(a,Q);if(0!==a.avail_in||0!==h.lookahead||b!==H&&h.status!==rb){var o=h.strategy===T?r(h,b):h.strategy===U?q(h,b):B[h.level].func(h,b);if((o===ub||o===vb)&&(h.status=rb),o===sb||o===ub)return 0===a.avail_out&&(h.last_flush=-1),M;if(o===tb&&(b===I?D._tr_align(h):b!==L&&(D._tr_stored_block(h,0,0,!1),b===J&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,M}return b!==K?M:h.wrap<=0?N:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?M:N)}function A(a){var b;return a&&a.state?(b=a.state.status,b!==lb&&b!==mb&&b!==nb&&b!==ob&&b!==pb&&b!==qb&&b!==rb?d(a,O):(a.state=null,b===qb?d(a,P):M)):O}var B,C=a("../utils/common"),D=a("./trees"),E=a("./adler32"),F=a("./crc32"),G=a("./messages"),H=0,I=1,J=3,K=4,L=5,M=0,N=1,O=-2,P=-3,Q=-5,R=-1,S=1,T=2,U=3,V=4,W=0,X=2,Y=8,Z=9,$=15,_=8,ab=29,bb=256,cb=bb+1+ab,db=30,eb=19,fb=2*cb+1,gb=15,hb=3,ib=258,jb=ib+hb+1,kb=32,lb=42,mb=69,nb=73,ob=91,pb=103,qb=113,rb=666,sb=1,tb=2,ub=3,vb=4,wb=3,xb=function(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e};B=[new xb(0,0,0,0,n),new xb(4,4,8,4,o),new xb(4,5,16,8,o),new xb(4,6,32,32,o),new xb(4,4,16,16,p),new xb(8,16,32,32,p),new xb(8,16,128,128,p),new xb(8,32,128,256,p),new xb(32,128,258,1024,p),new xb(32,258,258,4096,p)],c.deflateInit=y,c.deflateInit2=x,c.deflateReset=v,c.deflateResetKeep=u,c.deflateSetHeader=w,c.deflate=z,c.deflateEnd=A,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(a,b){"use strict";function c(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=c},{}],34:[function(a,b){"use strict";var c=30,d=12;b.exports=function(a,b){var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;e=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=e.dmax,l=e.wsize,m=e.whave,n=e.wnext,o=e.window,p=e.hold,q=e.bits,r=e.lencode,s=e.distcode,t=(1<<e.lenbits)-1,u=(1<<e.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){e.mode=d;break a}a.msg="invalid literal/length code",e.mode=c;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",e.mode=c;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",e.mode=c;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&e.sane){a.msg="invalid distance too far back",e.mode=c;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),e.hold=p,e.bits=q}},{}],35:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(ob),b.distcode=b.distdyn=new r.Buf32(pb),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,rb)}function k(a){if(sb){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sb=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,ob,pb,qb,rb,sb,tb,ub,vb,wb,xb,yb,zb,Ab=0,Bb=new r.Buf8(4),Cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xb=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=lb;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=lb;break}if(m>>>=4,n-=4,wb=(15&m)+8,0===c.wbits)c.wbits=wb;else if(wb>c.wbits){a.msg="invalid window size",c.mode=lb;break}c.dmax=1<<wb,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=lb;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=lb;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,Bb[2]=m>>>16&255,Bb[3]=m>>>24&255,c.check=t(c.check,Bb,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Bb[0]=255&m,Bb[1]=m>>>8&255,c.check=t(c.check,Bb,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wb=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wb)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.name+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wb=e[g+q++],c.head&&wb&&c.length<65536&&(c.head.comment+=String.fromCharCode(wb));while(wb&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wb)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=lb;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ib;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=bb,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=lb}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=lb;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=lb;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Cb[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Cb[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,yb={bits:c.lenbits},xb=v(w,c.lens,0,19,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid code lengths set",c.mode=lb;break}c.have=0,c.mode=ab;case ab:for(;c.have<c.nlen+c.ndist;){for(;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sb)m>>>=qb,n-=qb,c.lens[c.have++]=sb;else{if(16===sb){for(zb=qb+2;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qb,n-=qb,0===c.have){a.msg="invalid bit length repeat",c.mode=lb;break}wb=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sb){for(zb=qb+3;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=3+(7&m),m>>>=3,n-=3}else{for(zb=qb+7;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qb,n-=qb,wb=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=lb;break}for(;q--;)c.lens[c.have++]=wb}}if(c.mode===lb)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=lb;break}if(c.lenbits=9,yb={bits:c.lenbits},xb=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,yb),c.lenbits=yb.bits,xb){a.msg="invalid literal/lengths set",c.mode=lb;break}if(c.distbits=6,c.distcode=c.distdyn,yb={bits:c.distbits},xb=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,yb),c.distbits=yb.bits,xb){a.msg="invalid distances set",c.mode=lb;break}if(c.mode=bb,b===B)break a;case bb:c.mode=cb;case cb:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);break}for(c.back=0;Ab=c.lencode[m&(1<<c.lenbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(rb&&0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.lencode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,c.length=sb,0===rb){c.mode=hb;break}if(32&rb){c.back=-1,c.mode=V;break}if(64&rb){a.msg="invalid literal/length code",c.mode=lb;break}c.extra=15&rb,c.mode=db;case db:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=eb;case eb:for(;Ab=c.distcode[m&(1<<c.distbits)-1],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&rb)){for(tb=qb,ub=rb,vb=sb;Ab=c.distcode[vb+((m&(1<<tb+ub)-1)>>tb)],qb=Ab>>>24,rb=Ab>>>16&255,sb=65535&Ab,!(n>=tb+qb);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=tb,n-=tb,c.back+=tb}if(m>>>=qb,n-=qb,c.back+=qb,64&rb){a.msg="invalid distance code",c.mode=lb;break}c.offset=sb,c.extra=15&rb,c.mode=fb;case fb:if(c.extra){for(zb=c.extra;zb>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=lb;break}c.mode=gb;case gb:if(0===j)break a;
if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=lb;break}q>c.wnext?(q-=c.wnext,ob=c.wsize-q):ob=c.wnext-q,q>c.length&&(q=c.length),pb=c.window}else pb=f,ob=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pb[ob++];while(--q);0===c.length&&(c.mode=cb);break;case hb:if(0===j)break a;f[h++]=c.length,j--,c.mode=cb;break;case ib:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=lb;break}m=0,n=0}c.mode=jb;case jb:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=lb;break}m=0,n=0}c.mode=kb;case kb:xb=D;break a;case lb:xb=G;break a;case mb:return H;case nb:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<lb&&(c.mode<ib||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=mb,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===bb||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xb===C&&(xb=I),xb)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,ab=19,bb=20,cb=21,db=22,eb=23,fb=24,gb=25,hb=26,ib=27,jb=28,kb=29,lb=30,mb=31,nb=32,ob=852,pb=592,qb=15,rb=qb,sb=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(a,b){"use strict";var c=a("../utils/common"),d=15,e=852,f=592,g=0,h=1,i=2,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],k=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],l=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],m=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,n,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new c.Buf16(d+1),Q=new c.Buf16(d+1),R=null,S=0;for(D=0;d>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[n+E]]++;for(H=C,G=d;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;d>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===g||1!==G))return-1;for(Q[1]=0,D=1;d>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[n+E]&&(r[Q[b[n+E]]++]=E);if(a===g?(N=R=r,y=19):a===h?(N=j,O-=257,R=k,S-=257,y=256):(N=l,R=m,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===h&&L>e||a===i&&L>f)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[n+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===h&&L>e||a===i&&L>f)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":27}],37:[function(a,b){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a){return 256>a?gb[a]:gb[256+(a>>>7)]}function f(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function g(a,b,c){a.bi_valid>V-c?(a.bi_buf|=b<<a.bi_valid&65535,f(a,a.bi_buf),a.bi_buf=b>>V-a.bi_valid,a.bi_valid+=c-V):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function h(a,b,c){g(a,c[2*b],c[2*b+1])}function i(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function j(a){16===a.bi_valid?(f(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function k(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;U>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;T>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function l(a,b,c){var d,e,f=new Array(U+1),g=0;for(d=1;U>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=i(f[h]++,h))}}function m(){var a,b,c,d,e,f=new Array(U+1);for(c=0,d=0;O-1>d;d++)for(ib[d]=c,a=0;a<1<<_[d];a++)hb[c++]=d;for(hb[c-1]=d,e=0,d=0;16>d;d++)for(jb[d]=e,a=0;a<1<<ab[d];a++)gb[e++]=d;for(e>>=7;R>d;d++)for(jb[d]=e<<7,a=0;a<1<<ab[d]-7;a++)gb[256+e++]=d;for(b=0;U>=b;b++)f[b]=0;for(a=0;143>=a;)eb[2*a+1]=8,a++,f[8]++;for(;255>=a;)eb[2*a+1]=9,a++,f[9]++;for(;279>=a;)eb[2*a+1]=7,a++,f[7]++;for(;287>=a;)eb[2*a+1]=8,a++,f[8]++;for(l(eb,Q+1,f),a=0;R>a;a++)fb[2*a+1]=5,fb[2*a]=i(a,5);kb=new nb(eb,_,P+1,Q,U),lb=new nb(fb,ab,0,R,U),mb=new nb(new Array(0),bb,0,S,W)}function n(a){var b;for(b=0;Q>b;b++)a.dyn_ltree[2*b]=0;for(b=0;R>b;b++)a.dyn_dtree[2*b]=0;for(b=0;S>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*X]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function o(a){a.bi_valid>8?f(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function p(a,b,c,d){o(a),d&&(f(a,c),f(a,~c)),E.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function q(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function r(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&q(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!q(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function s(a,b,c){var d,f,i,j,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],f=a.pending_buf[a.l_buf+k],k++,0===d?h(a,f,b):(i=hb[f],h(a,i+P+1,b),j=_[i],0!==j&&(f-=ib[i],g(a,f,j)),d--,i=e(d),h(a,i,c),j=ab[i],0!==j&&(d-=jb[i],g(a,d,j)));while(k<a.last_lit);h(a,X,b)}function t(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=T,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)r(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],r(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,r(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],k(a,b),l(f,j,a.bl_count)}function u(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*Y]++):10>=h?a.bl_tree[2*Z]++:a.bl_tree[2*$]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function v(a,b,c){var d,e,f=-1,i=b[1],j=0,k=7,l=4;for(0===i&&(k=138,l=3),d=0;c>=d;d++)if(e=i,i=b[2*(d+1)+1],!(++j<k&&e===i)){if(l>j){do h(a,e,a.bl_tree);while(0!==--j)}else 0!==e?(e!==f&&(h(a,e,a.bl_tree),j--),h(a,Y,a.bl_tree),g(a,j-3,2)):10>=j?(h(a,Z,a.bl_tree),g(a,j-3,3)):(h(a,$,a.bl_tree),g(a,j-11,7));j=0,f=e,0===i?(k=138,l=3):e===i?(k=6,l=3):(k=7,l=4)}}function w(a){var b;for(u(a,a.dyn_ltree,a.l_desc.max_code),u(a,a.dyn_dtree,a.d_desc.max_code),t(a,a.bl_desc),b=S-1;b>=3&&0===a.bl_tree[2*cb[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function x(a,b,c,d){var e;for(g(a,b-257,5),g(a,c-1,5),g(a,d-4,4),e=0;d>e;e++)g(a,a.bl_tree[2*cb[e]+1],3);v(a,a.dyn_ltree,b-1),v(a,a.dyn_dtree,c-1)}function y(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return G;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return H;for(b=32;P>b;b++)if(0!==a.dyn_ltree[2*b])return H;return G}function z(a){pb||(m(),pb=!0),a.l_desc=new ob(a.dyn_ltree,kb),a.d_desc=new ob(a.dyn_dtree,lb),a.bl_desc=new ob(a.bl_tree,mb),a.bi_buf=0,a.bi_valid=0,n(a)}function A(a,b,c,d){g(a,(J<<1)+(d?1:0),3),p(a,b,c,!0)}function B(a){g(a,K<<1,3),h(a,X,eb),j(a)}function C(a,b,c,d){var e,f,h=0;a.level>0?(a.strm.data_type===I&&(a.strm.data_type=y(a)),t(a,a.l_desc),t(a,a.d_desc),h=w(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?A(a,b,c,d):a.strategy===F||f===e?(g(a,(K<<1)+(d?1:0),3),s(a,eb,fb)):(g(a,(L<<1)+(d?1:0),3),x(a,a.l_desc.max_code+1,a.d_desc.max_code+1,h+1),s(a,a.dyn_ltree,a.dyn_dtree)),n(a),d&&o(a)}function D(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(hb[c]+P+1)]++,a.dyn_dtree[2*e(b)]++),a.last_lit===a.lit_bufsize-1}var E=a("../utils/common"),F=4,G=0,H=1,I=2,J=0,K=1,L=2,M=3,N=258,O=29,P=256,Q=P+1+O,R=30,S=19,T=2*Q+1,U=15,V=16,W=7,X=256,Y=16,Z=17,$=18,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ab=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],bb=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],cb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],db=512,eb=new Array(2*(Q+2));d(eb);var fb=new Array(2*R);d(fb);var gb=new Array(db);d(gb);var hb=new Array(N-M+1);d(hb);var ib=new Array(O);d(ib);var jb=new Array(R);d(jb);var kb,lb,mb,nb=function(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length},ob=function(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b},pb=!1;c._tr_init=z,c._tr_stored_block=A,c._tr_flush_block=C,c._tr_tally=D,c._tr_align=B},{"../utils/common":27}],39:[function(a,b){"use strict";function c(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=c},{}]},{},[9])(9)});

'use strict';
// Vinn workaround for JSzip requiring window.
if (tr.isVinn) {
  /**
   * Hack.
   */
  global.JSZip = global.window.JSZip;
  global.window = undefined;
} else if (tr.isNode) {
  const jsZipAbsPath = HTMLImportsLoader.hrefToAbsolutePath(
      '/jszip.min.js');
  const jsZipModule = require(jsZipAbsPath);
  global.JSZip = jsZipModule;
}


'use strict';

/**
 * @fileoverview GzipImporter inflates gzip compressed data and passes it along
 * to an actual importer.
 */
tr.exportTo('tr.e.importer', function() {
  const GZIP_MEMBER_HEADER_ID_SIZE = 3;

  const GZIP_HEADER_ID1 = 0x1f;
  const GZIP_HEADER_ID2 = 0x8b;
  const GZIP_DEFLATE_COMPRESSION = 8;

  function GzipImporter(model, eventData) {
    // Normalize the data into an Uint8Array.
    this.inflateAsTraceStream = false;
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = JSZip.utils.transformTo('uint8array', eventData);
    } else if (eventData instanceof ArrayBuffer) {
      eventData = new Uint8Array(eventData);
    } else if (eventData instanceof tr.b.InMemoryTraceStream) {
      // This importer does not support processing general TraceStreams, only
      // InMemoryTraceStreams for now.
      eventData = eventData.data;
      this.inflateAsTraceStream_ = true;
    } else {
      throw new Error('Unknown gzip data format');
    }
    this.model_ = model;
    this.gzipData_ = eventData;
  }

  /**
   * @param {eventData} Possibly gzip compressed data as a string or an
   *                    ArrayBuffer.
   * @return {boolean} Whether obj looks like gzip compressed data.
   */
  GzipImporter.canImport = function(eventData) {
    // This importer does not support processing general TraceStreams, only
    // InMemoryTraceStreams for now.
    if (eventData instanceof tr.b.InMemoryTraceStream) {
      eventData = eventData.header;
    }

    let header;
    if (eventData instanceof ArrayBuffer) {
      header = new Uint8Array(eventData.slice(0, GZIP_MEMBER_HEADER_ID_SIZE));
    } else if (typeof(eventData) === 'string' || eventData instanceof String) {
      header = eventData.substring(0, GZIP_MEMBER_HEADER_ID_SIZE);
      // Convert the string to a byteArray for correct value comparison.
      header = JSZip.utils.transformTo('uint8array', header);
    } else {
      return false;
    }
    return header[0] === GZIP_HEADER_ID1 &&
        header[1] === GZIP_HEADER_ID2 &&
        header[2] === GZIP_DEFLATE_COMPRESSION;
  };

  /**
   * Inflates (decompresses) the data stored in the given gzip bitstream.
   * @return {string} Inflated data.
   */
  GzipImporter.inflateGzipData_ = function(data) {
    let position = 0;

    function getByte() {
      if (position >= data.length) {
        throw new Error('Unexpected end of gzip data');
      }
      return data[position++];
    }

    function getWord() {
      const low = getByte();
      const high = getByte();
      return (high << 8) + low;
    }

    function skipBytes(amount) {
      position += amount;
    }

    function skipZeroTerminatedString() {
      while (getByte() !== 0) {}
    }

    const id1 = getByte();
    const id2 = getByte();
    if (id1 !== GZIP_HEADER_ID1 || id2 !== GZIP_HEADER_ID2) {
      throw new Error('Not gzip data');
    }
    const compressionMethod = getByte();
    if (compressionMethod !== GZIP_DEFLATE_COMPRESSION) {
      throw new Error('Unsupported compression method: ' + compressionMethod);
    }
    const flags = getByte();
    const haveHeaderCrc = flags & (1 << 1);
    const haveExtraFields = flags & (1 << 2);
    const haveFileName = flags & (1 << 3);
    const haveComment = flags & (1 << 4);

    // Skip modification time, extra flags and OS.
    skipBytes(4 + 1 + 1);

    // Skip remaining fields before compressed data.
    if (haveExtraFields) {
      const bytesToSkip = getWord();
      skipBytes(bytesToSkip);
    }
    if (haveFileName) skipZeroTerminatedString();
    if (haveComment) skipZeroTerminatedString();
    if (haveHeaderCrc) getWord();

    // Inflate the data using jszip.
    const inflatedData =
        JSZip.compressions.DEFLATE.uncompress(data.subarray(position));

    if (this.inflateAsTraceStream_) {
      return GzipImporter.transformToStream(inflatedData);
    }

    let string;
    try {
      string = GzipImporter.transformToString(inflatedData);
    } catch (err) {
      // It may be the case that inflated data does not fit into a V8 string. In
      // that case, try to transform to a trace stream.
      return GzipImporter.transformToStream(inflatedData);
    }

    if (inflatedData.length > 0 && string.length === 0) {
      // Try transforming to a trace stream.
      return GzipImporter.transformToStream(inflatedData);
    }

    return string;
  };

  GzipImporter.transformToStream = function(data) {
    const type = JSZip.utils.getTypeOf(data);
    if (type === 'uint8array') return new tr.b.InMemoryTraceStream(data, false);
    throw new Error(`Cannot transform ${type} to TraceStream.`);
  };

  /**
   * Transforms an array-like object to a string.
   *
   * Note that the following two expressions yield identical results:
   *
   *   GzipImporter.transformToString_(data)
   *   JSZip.utils.transformTo('string', data)
   *
   * We use a custom static method because it is faster and, more importantly,
   * avoids OOMing on large traces. See
   * https://github.com/catapult-project/catapult/issues/2051.
   */
  GzipImporter.transformToString = function(data) {
    if (typeof TextDecoder === 'undefined') {
      // Fall back to jszip if TextDecoder is not available.
      return JSZip.utils.transformTo('string', data);
    }

    const type = JSZip.utils.getTypeOf(data);
    if (type === 'string') return data;  // We already have a string.

    if (type === 'array') {
      // TextDecoder requires an ArrayBuffer or an ArrayBufferView.
      data = new Uint8Array(data);
    }

    const decoder = new TextDecoder('utf-8');
    return decoder.decode(data);
  };

  GzipImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'GzipImporter';
    },

    /**
     * Called by the Model to check whether the importer just encapsulates
     * the actual trace data which needs to be imported by another importer.
     */
    isTraceDataContainer() {
      return true;
    },

    /**
     * Called by the Model to extract subtraces from the event data. The
     * subtraces are passed on to other importers that can recognize them.
     */
    extractSubtraces() {
      const eventData = GzipImporter.inflateGzipData_(this.gzipData_);
      return eventData ? [eventData] : [];
    }
  };

  tr.importer.Importer.register(GzipImporter);

  return {
    GzipImporter,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  class SimpleLineReader {
    constructor(text) {
      this.data_ = text instanceof tr.b.TraceStream ? text : text.split('\n');
      this.curLine_ = 0;
      this.readLastLine_ = false;
      this.savedLines_ = undefined;
    }

    * [Symbol.iterator]() {
      let lastLine = undefined;
      while (this.hasData_) {
        if (this.readLastLine_) {
          this.curLine_++;
          this.readLastLine_ = false;
        } else if (this.data_ instanceof tr.b.TraceStream) {
          this.curLine_++;
          const line = this.data_.readUntilDelimiter('\n');
          lastLine = line.endsWith('\n') ? line.slice(0, -1) : line;
        } else {
          this.curLine_++;
          lastLine = this.data_[this.curLine_ - 1];
        }
        yield lastLine;
      }
    }

    get curLineNumber() {
      return this.curLine_;
    }

    get hasData_() {
      if (this.data_ instanceof tr.b.TraceStream) return this.data_.hasData;
      return this.curLine_ < this.data_.length;
    }

    advanceToLineMatching(regex) {
      for (const line of this) {
        if (this.savedLines_ !== undefined) this.savedLines_.push(line);
        if (regex.test(line)) {
          this.goBack_();
          return true;
        }
      }
      return false;
    }

    goBack_() {
      if (this.readLastLine_) {
        throw new Error('There should be at least one nextLine call between ' +
                        'any two goBack calls.');
      }
      if (this.curLine_ === 0) {
        throw new Error('There should be at least one nextLine call before ' +
                        'the first goBack call.');
      }
      this.readLastLine_ = true;
      this.curLine_--;
    }

    beginSavingLines() {
      this.savedLines_ = [];
    }

    endSavingLinesAndGetResult() {
      const tmp = this.savedLines_;
      this.savedLines_ = undefined;
      return tmp;
    }
  }

  return {
    SimpleLineReader,
  };
});


'use strict';

tr.exportTo('tr.e.importer', function() {
  function Trace2HTMLImporter(model, events) {
    this.importPriority = 0;
  }

  Trace2HTMLImporter.subtraces_ = [];

  function _extractEventsFromHTML(text) {
    // Clear the array before pushing data to it.
    Trace2HTMLImporter.subtraces_ = [];

    const r = new tr.importer.SimpleLineReader(text);

    // Try to find viewer-data...
    while (true) {
      if (!r.advanceToLineMatching(
          new RegExp('^<\s*script id="viewer-data" ' +
                     'type="(application\/json|text\/plain)">$'))) {
        break;
      }

      r.beginSavingLines();
      if (!r.advanceToLineMatching(/^<\/\s*script>$/)) return;

      let rawEvents = r.endSavingLinesAndGetResult();

      // Drop off first and last event as it contains the end script tag.
      rawEvents = rawEvents.slice(1, rawEvents.length - 1);
      const data64 = rawEvents.join('\n');
      const buffer = new ArrayBuffer(
          tr.b.Base64.getDecodedBufferLength(data64));
      const len = tr.b.Base64.DecodeToTypedArray(data64, new DataView(buffer));
      Trace2HTMLImporter.subtraces_.push(buffer.slice(0, len));
    }
  }

  function _canImportFromHTML(text) {
    if (!/^<!DOCTYPE html>/.test(text)) return false;

    // Try to find viewer-data...
    _extractEventsFromHTML(text);
    if (Trace2HTMLImporter.subtraces_.length === 0) return false;
    return true;
  }

  Trace2HTMLImporter.canImport = function(events) {
    if (events instanceof tr.b.TraceStream) return false;
    return _canImportFromHTML(events);
  };

  Trace2HTMLImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'Trace2HTMLImporter';
    },

    isTraceDataContainer() {
      return true;
    },

    extractSubtraces() {
      return Trace2HTMLImporter.subtraces_;
    },

    importEvents() {
    }
  };


  tr.importer.Importer.register(Trace2HTMLImporter);


  return {
    Trace2HTMLImporter,
  };
});


'use strict';

/**
 * @fileoverview Splay tree used by CodeMap.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Constructs a Splay tree.  A splay tree is a self-balancing binary
   * search tree with the additional property that recently accessed
   * elements are quick to access again. It performs basic operations
   * such as insertion, look-up and removal in O(log(n)) amortized time.
   *
   * @constructor
   */
  function SplayTree() { }

  /**
   * Pointer to the root node of the tree.
   *
   * @type {SplayTree.Node}
   * @private
   */
  SplayTree.prototype.root_ = null;

  /**
   * @return {boolean} Whether the tree is empty.
   */
  SplayTree.prototype.isEmpty = function() {
    return !this.root_;
  };

  /**
   * Inserts a node into the tree with the specified key and value if
   * the tree does not already contain a node with the specified key. If
   * the value is inserted, it becomes the root of the tree.
   *
   * @param {number} key Key to insert into the tree.
   * @param {*} value Value to insert into the tree.
   */
  SplayTree.prototype.insert = function(key, value) {
    if (this.isEmpty()) {
      this.root_ = new SplayTree.Node(key, value);
      return;
    }
    // Splay on the key to move the last node on the search path for
    // the key to the root of the tree.
    this.splay_(key);
    if (this.root_.key === key) {
      return;
    }
    const node = new SplayTree.Node(key, value);
    if (key > this.root_.key) {
      node.left = this.root_;
      node.right = this.root_.right;
      this.root_.right = null;
    } else {
      node.right = this.root_;
      node.left = this.root_.left;
      this.root_.left = null;
    }
    this.root_ = node;
  };


  /**
   * Removes a node with the specified key from the tree if the tree
   * contains a node with this key. The removed node is returned. If the
   * key is not found, an exception is thrown.
   *
   * @param {number} key Key to find and remove from the tree.
   * @return {SplayTree.Node} The removed node.
   */
  SplayTree.prototype.remove = function(key) {
    if (this.isEmpty()) {
      throw Error('Key not found: ' + key);
    }
    this.splay_(key);
    if (this.root_.key !== key) {
      throw Error('Key not found: ' + key);
    }
    const removed = this.root_;
    if (!this.root_.left) {
      this.root_ = this.root_.right;
    } else {
      const right = this.root_.right;
      this.root_ = this.root_.left;
      // Splay to make sure that the new root has an empty right child.
      this.splay_(key);
      // Insert the original right child as the right child of the new
      // root.
      this.root_.right = right;
    }
    return removed;
  };


  /**
   * Returns the node having the specified key or null if the tree doesn't
   * contain a node with the specified key.
   *
   *
   * @param {number} key Key to find in the tree.
   * @return {SplayTree.Node} Node having the specified key.
   */
  SplayTree.prototype.find = function(key) {
    if (this.isEmpty()) return null;
    this.splay_(key);
    return this.root_.key === key ? this.root_ : null;
  };

  /**
   * @return {SplayTree.Node} Node having the minimum key value.
   */
  SplayTree.prototype.findMin = function() {
    if (this.isEmpty()) return null;
    let current = this.root_;
    while (current.left) {
      current = current.left;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value.
   */
  SplayTree.prototype.findMax = function(opt_startNode) {
    if (this.isEmpty()) return null;
    let current = opt_startNode || this.root_;
    while (current.right) {
      current = current.right;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value that
   *     is less or equal to the specified key value.
   */
  SplayTree.prototype.findGreatestLessThan = function(key) {
    if (this.isEmpty()) return null;
    // Splay on the key to move the node with the given key or the last
    // node on the search path to the top of the tree.
    this.splay_(key);
    // Now the result is either the root node or the greatest node in
    // the left subtree.
    if (this.root_.key <= key) {
      return this.root_;
    }
    if (this.root_.left) {
      return this.findMax(this.root_.left);
    }
    return null;
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes
   * paired with keys.
   *
   */
  SplayTree.prototype.exportKeysAndValues = function() {
    const result = [];
    this.traverse_(function(node) { result.push([node.key, node.value]); });
    return result;
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes.
   */
  SplayTree.prototype.exportValues = function() {
    const result = [];
    this.traverse_(function(node) { result.push(node.value); });
    return result;
  };

  /**
   * Perform the splay operation for the given key. Moves the node with
   * the given key to the top of the tree.  If no node has the given
   * key, the last node on the search path is moved to the top of the
   * tree. This is the simplified top-down splaying algorithm from:
   * "Self-adjusting Binary Search Trees" by Sleator and Tarjan
   *
   * @param {number} key Key to splay the tree on.
   * @private
   */
  SplayTree.prototype.splay_ = function(key) {
    if (this.isEmpty()) return;
    // Create a dummy node.  The use of the dummy node is a bit
    // counter-intuitive: The right child of the dummy node will hold
    // the L tree of the algorithm.  The left child of the dummy node
    // will hold the R tree of the algorithm.  Using a dummy node, left
    // and right will always be nodes and we avoid special cases.
    const dummy = new SplayTree.Node(null, null);
    let left = dummy;
    let right = dummy;
    let current = this.root_;
    while (true) {
      if (key < current.key) {
        if (!current.left) {
          break;
        }
        if (key < current.left.key) {
          // Rotate right.
          const tmp = current.left;
          current.left = tmp.right;
          tmp.right = current;
          current = tmp;
          if (!current.left) {
            break;
          }
        }
        // Link right.
        right.left = current;
        right = current;
        current = current.left;
      } else if (key > current.key) {
        if (!current.right) {
          break;
        }
        if (key > current.right.key) {
          // Rotate left.
          const tmp = current.right;
          current.right = tmp.left;
          tmp.left = current;
          current = tmp;
          if (!current.right) {
            break;
          }
        }
        // Link left.
        left.right = current;
        left = current;
        current = current.right;
      } else {
        break;
      }
    }
    // Assemble.
    left.right = current.left;
    right.left = current.right;
    current.left = dummy.right;
    current.right = dummy.left;
    this.root_ = current;
  };

  /**
   * Performs a preorder traversal of the tree.
   *
   * @param {function(SplayTree.Node)} f Visitor function.
   * @private
   */
  SplayTree.prototype.traverse_ = function(f) {
    const nodesToVisit = [this.root_];
    while (nodesToVisit.length > 0) {
      const node = nodesToVisit.shift();
      if (node === null) continue;
      f(node);
      nodesToVisit.push(node.left);
      nodesToVisit.push(node.right);
    }
  };

  /**
   * Constructs a Splay tree node.
   *
   * @param {number} key Key.
   * @param {*} value Value.
   */
  SplayTree.Node = function(key, value) {
    this.key = key;
    this.value = value;
  };

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.left = null;

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.right = null;

  return {
    SplayTree,
  };
});


'use strict';

/**
 * @fileoverview Map addresses to dynamically created functions.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Constructs a mapper that maps addresses into code entries.
   *
   * @constructor
   */
  function CodeMap() {
    /**
     * Dynamic code entries. Used for JIT compiled code.
     */
    this.dynamics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Name generator for entries having duplicate names.
     */
    this.dynamicsNameGen_ = new tr.e.importer.v8.CodeMap.NameGenerator();

    /**
     * Static code entries. Used for statically compiled code.
     */
    this.statics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Libraries entries. Used for the whole static code libraries.
     */
    this.libraries_ = new tr.e.importer.v8.SplayTree();

    /**
     * Map of memory pages occupied with static code.
     */
    this.pages_ = [];
  }

  /**
   * The number of alignment bits in a page address.
   */
  CodeMap.PAGE_ALIGNMENT = 12;

  /**
   * Page size in bytes.
   */
  CodeMap.PAGE_SIZE = 1 << CodeMap.PAGE_ALIGNMENT;

  /**
   * Adds a dynamic (i.e. moveable and discardable) code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addCode = function(start, codeEntry) {
    this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
    this.dynamics_.insert(start, codeEntry);
  };

  /**
   * Moves a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} from The starting address of the entry being moved.
   * @param {number} to The destination address.
   */
  CodeMap.prototype.moveCode = function(from, to) {
    const removedNode = this.dynamics_.remove(from);
    this.deleteAllCoveredNodes_(this.dynamics_, to,
        to + removedNode.value.size);
    this.dynamics_.insert(to, removedNode.value);
  };

  /**
   * Discards a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} start The starting address of the entry being deleted.
   */
  CodeMap.prototype.deleteCode = function(start) {
    const removedNode = this.dynamics_.remove(start);
  };

  /**
   * Adds a library entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addLibrary = function(
      start, codeEntry) {
    this.markPages_(start, start + codeEntry.size);
    this.libraries_.insert(start, codeEntry);
  };

  /**
   * Adds a static code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addStaticCode = function(
      start, codeEntry) {
    this.statics_.insert(start, codeEntry);
  };

  /**
   * @private
   */
  CodeMap.prototype.markPages_ = function(start, end) {
    for (let addr = start; addr <= end;
         addr += CodeMap.PAGE_SIZE) {
      this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
    }
  };

  /**
   * @private
   */
  CodeMap.prototype.deleteAllCoveredNodes_ = function(tree, start, end) {
    const toDelete = [];
    let addr = end - 1;
    while (addr >= start) {
      const node = tree.findGreatestLessThan(addr);
      if (!node) break;
      const start2 = node.key;
      const end2 = start2 + node.value.size;
      if (start2 < end && start < end2) toDelete.push(start2);
      addr = start2 - 1;
    }
    for (let i = 0, l = toDelete.length; i < l; ++i) tree.remove(toDelete[i]);
  };

  /**
   * @private
   */
  CodeMap.prototype.isAddressBelongsTo_ = function(addr, node) {
    return addr >= node.key && addr < (node.key + node.value.size);
  };

  /**
   * @private
   */
  CodeMap.prototype.findInTree_ = function(tree, addr) {
    const node = tree.findGreatestLessThan(addr);
    return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
  };

  /**
   * Finds a code entry that contains the specified address in static libraries.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntryInLibraries = function(addr) {
    const pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) {
      return this.findInTree_(this.libraries_, addr);
    }
    return undefined;
  };

  /**
   * Finds a code entry that contains the specified address. Both static and
   * dynamic code entries are considered.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntry = function(addr) {
    const pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) {
      // Static code entries can contain "holes" of unnamed code.
      // In this case, the whole library is assigned to this address.
      return this.findInTree_(this.statics_, addr) ||
          this.findInTree_(this.libraries_, addr);
    }
    const min = this.dynamics_.findMin();
    const max = this.dynamics_.findMax();
    if (max !== null && addr < (max.key + max.value.size) && addr >= min.key) {
      const dynaEntry = this.findInTree_(this.dynamics_, addr);
      if (dynaEntry === null) return null;
      // Dedupe entry name.
      if (!dynaEntry.nameUpdated_) {
        dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
        dynaEntry.nameUpdated_ = true;
      }
      return dynaEntry;
    }
    return null;
  };

  /**
   * Returns a dynamic code entry using its starting address.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findDynamicEntryByStartAddress =
      function(addr) {
        const node = this.dynamics_.find(addr);
        return node ? node.value : null;
      };

  /**
   * Returns an array of all dynamic code entries.
   */
  CodeMap.prototype.getAllDynamicEntries = function() {
    return this.dynamics_.exportValues();
  };

  /**
   * Returns an array of pairs of all dynamic code entries and their addresses.
   */
  CodeMap.prototype.getAllDynamicEntriesWithAddresses = function() {
    return this.dynamics_.exportKeysAndValues();
  };

  /**
   * Returns an array of all static code entries.
   */
  CodeMap.prototype.getAllStaticEntries = function() {
    return this.statics_.exportValues();
  };

  /**
   * Returns an array of all libraries entries.
   */
  CodeMap.prototype.getAllLibrariesEntries = function() {
    return this.libraries_.exportValues();
  };

  /**
   * Enum for code state regarding its dynamic optimization.
   *
   * @enum {number}
   */
  CodeMap.CodeState = {
    COMPILED: 0,
    OPTIMIZABLE: 1,
    OPTIMIZED: 2
  };

  /**
   * Creates a code entry object.
   *
   * @param {number} size Code entry size in bytes.
   * @param {string=} opt_name Code entry name.
   * @constructor
   */
  CodeMap.CodeEntry = function(size, opt_name, opt_type) {
    this.id = tr.b.GUID.allocateSimple();
    this.size = size;
    this.name_ = opt_name || '';
    this.type = opt_type || '';
    this.nameUpdated_ = false;
  };

  CodeMap.CodeEntry.prototype = {
    __proto__: Object.prototype,

    get name() {
      return this.name_;
    },

    set name(value) {
      this.name_ = value;
    },

    toString() {
      this.name_ + ': ' + this.size.toString(16);
    }
  };

  CodeMap.CodeEntry.TYPE = {
    SHARED_LIB: 'SHARED_LIB',
    CPP: 'CPP'
  };

  /**
   * Creates a dynamic code entry.
   *
   * @param {number} size Code size.
   * @param {string} type Code type.
   * @param {CodeMap.FunctionEntry} func Shared function entry.
   * @param {CodeMap.CodeState} state Code optimization state.
   * @constructor
   */
  CodeMap.DynamicFuncCodeEntry = function(size, type, func, state) {
    CodeMap.CodeEntry.call(this, size, '', type);
    this.func = func;
    this.state = state;
  };

  CodeMap.DynamicFuncCodeEntry.STATE_PREFIX = ['', '~', '*'];

  CodeMap.DynamicFuncCodeEntry.prototype = {
    __proto__: CodeMap.CodeEntry.prototype,

    /**
     * Returns node name.
     */
    get name() {
      return CodeMap.DynamicFuncCodeEntry.STATE_PREFIX[this.state] +
        this.func.name;
    },

    set name(value) {
      this.name_ = value;
    },

    /**
     * Returns raw node name (without type decoration).
     */
    getRawName() {
      return this.func.getName();
    },

    isJSFunction() {
      return true;
    },

    toString() {
      return this.type + ': ' + this.name + ': ' + this.size.toString(16);
    }
  };

  /**
   * Creates a shared function object entry.
   *
   * @param {string} name Function name.
   * @constructor
   */
  CodeMap.FunctionEntry = function(name) {
    CodeMap.CodeEntry.call(this, 0, name);
  };

  CodeMap.FunctionEntry.prototype = {
    __proto__: CodeMap.CodeEntry.prototype,

    /**
     * Returns node name.
     */
    get name() {
      let name = this.name_;
      if (name.length === 0) {
        name = '<anonymous>';
      } else if (name.charAt(0) === ' ') {
        // An anonymous function with location: " aaa.js:10".
        name = '<anonymous>' + name;
      }
      return name;
    },

    set name(value) {
      this.name_ = value;
    }
  };

  CodeMap.NameGenerator = function() {
    this.knownNames_ = {};
  };

  CodeMap.NameGenerator.prototype.getName = function(name) {
    if (!(name in this.knownNames_)) {
      this.knownNames_[name] = 0;
      return name;
    }
    const count = ++this.knownNames_[name];
    return name + ' {' + count + '}';
  };
  return {
    CodeMap,
  };
});


'use strict';

/**
 * @fileoverview Log Reader is used to process log file produced by V8.
 */
tr.exportTo('tr.e.importer.v8', function() {
  /**
   * Creates a CSV lines parser.
   */
  function CsvParser() { }

  /**
   * A regex for matching a CSV field.
   * @private
   */
  CsvParser.CSV_FIELD_RE_ = /^"((?:[^"]|"")*)"|([^,]*)/;

  /**
   * A regex for matching a double quote.
   * @private
   */
  CsvParser.DOUBLE_QUOTE_RE_ = /""/g;

  /**
   * Parses a line of CSV-encoded values. Returns an array of fields.
   *
   * @param {string} line Input line.
   */
  CsvParser.prototype.parseLine = function(line) {
    const fieldRe = CsvParser.CSV_FIELD_RE_;
    const doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;
    let pos = 0;
    const endPos = line.length;
    const fields = [];
    if (endPos > 0) {
      do {
        const fieldMatch = fieldRe.exec(line.substr(pos));
        if (typeof fieldMatch[1] === 'string') {
          const field = fieldMatch[1];
          pos += field.length + 3;  // Skip comma and quotes.
          fields.push(field.replace(doubleQuoteRe, '"'));
        } else {
          // The second field pattern will match anything, thus
          // in the worst case the match will be an empty string.
          const field = fieldMatch[2];
          pos += field.length + 1;  // Skip comma.
          fields.push(field);
        }
      } while (pos <= endPos);
    }
    return fields;
  };

  /**
   * Base class for processing log files.
   *
   * @param {Array.<Object>} dispatchTable A table used for parsing and
   * processing log records.
   *
   * @constructor
   */
  function LogReader(dispatchTable) {
    /**
     * @type {Array.<Object>}
     */
    this.dispatchTable_ = dispatchTable;

    /**
     * Current line.
     * @type {number}
     */
    this.lineNum_ = 0;

    /**
     * CSV lines parser.
     * @type {CsvParser}
     */
    this.csvParser_ = new CsvParser();
  }

  /**
   * Used for printing error messages.
   *
   * @param {string} str Error message.
   */
  LogReader.prototype.printError = function(str) {
    // Do nothing.
  };

  /**
   * Processes a portion of V8 profiler event log.
   *
   * @param {string} chunk A portion of log.
   */
  LogReader.prototype.processLogChunk = function(chunk) {
    this.processLog_(chunk.split('\n'));
  };

  /**
   * Processes a line of V8 profiler event log.
   *
   * @param {string} line A line of log.
   */
  LogReader.prototype.processLogLine = function(line) {
    this.processLog_([line]);
  };

  /**
   * Processes stack record.
   *
   * @param {number} pc Program counter.
   * @param {number} func JS Function.
   * @param {Array.<string>} stack String representation of a stack.
   * @return {Array.<number>} Processed stack.
   */
  LogReader.prototype.processStack = function(pc, func, stack) {
    const fullStack = func ? [pc, func] : [pc];
    let prevFrame = pc;
    for (let i = 0, n = stack.length; i < n; ++i) {
      const frame = stack[i];
      const firstChar = frame.charAt(0);
      if (firstChar === '+' || firstChar === '-') {
        // An offset from the previous frame.
        prevFrame += parseInt(frame, 16);
        fullStack.push(prevFrame);
      // Filter out possible 'overflow' string.
      } else if (firstChar !== 'o') {
        fullStack.push(parseInt(frame, 16));
      }
    }
    return fullStack;
  };

  /**
   * Returns whether a particular dispatch must be skipped.
   *
   * @param {!Object} dispatch Dispatch record.
   * @return {boolean} True if dispatch must be skipped.
   */
  LogReader.prototype.skipDispatch = function(dispatch) {
    return false;
  };

  /**
   * Does a dispatch of a log record.
   *
   * @param {Array.<string>} fields Log record.
   * @private
   */
  LogReader.prototype.dispatchLogRow_ = function(fields) {
    // Obtain the dispatch.
    const command = fields[0];
    if (!(command in this.dispatchTable_)) return;

    const dispatch = this.dispatchTable_[command];

    if (dispatch === null || this.skipDispatch(dispatch)) {
      return;
    }

    // Parse fields.
    const parsedFields = [];
    for (let i = 0; i < dispatch.parsers.length; ++i) {
      const parser = dispatch.parsers[i];
      if (parser === null) {
        parsedFields.push(fields[1 + i]);
      } else if (typeof parser === 'function') {
        parsedFields.push(parser(fields[1 + i]));
      } else {
        // var-args
        parsedFields.push(fields.slice(1 + i));
        break;
      }
    }

    // Run the processor.
    dispatch.processor.apply(this, parsedFields);
  };

  /**
   * Processes log lines.
   *
   * @param {Array.<string>} lines Log lines.
   * @private
   */
  LogReader.prototype.processLog_ = function(lines) {
    for (let i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {
      const line = lines[i];
      if (!line) {
        continue;
      }
      try {
        const fields = this.csvParser_.parseLine(line);
        this.dispatchLogRow_(fields);
      } catch (e) {
        this.printError('line ' + (this.lineNum_ + 1) + ': ' +
                        (e.message || e));
      }
    }
  };
  return {
    LogReader,
  };
});


'use strict';

/**
 * @fileoverview Provides the ProfileNode class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A ProfileNode represents a node in the profile tree,
   * it is essentially a frame in the stack when the sample gets recorded.
   */
  // TODO(lpy) Move V8 specific part out of ProfileNode.
  function ProfileNode(id, title, parentNode) {
    this.id_ = id;
    this.title_ = title;
    this.parentNode_ = parentNode;
    this.colorId_ = -1;
    // Cache the constructed call stack starting from this node to root.
    this.userFriendlyStack_ = [];
  }

  ProfileNode.prototype = {
    __proto__: Object.prototype,

    get title() {
      return this.title_;
    },

    get parentNode() {
      return this.parentNode_;
    },

    set parentNode(value) {
      this.parentNode_ = value;
    },

    get id() {
      return this.id_;
    },

    get colorId() {
      return this.colorId_;
    },

    set colorId(value) {
      this.colorId_ = value;
    },

    get userFriendlyName() {
      return this.title_;
    },

    get userFriendlyStack() {
      if (this.userFriendlyStack_.length === 0) {
        this.userFriendlyStack_ = [this.userFriendlyName];
        if (this.parentNode_ !== undefined) {
          this.userFriendlyStack_ =
            this.userFriendlyStack_.concat(this.parentNode_.userFriendlyStack);
        }
      }
      return this.userFriendlyStack_;
    },

    get sampleTitle() {
      throw new Error('Not implemented.');
    }
  };

  tr.model.EventRegistry.register(
      ProfileNode,
      {
        name: 'Node',
        pluralName: 'Nodes'
      }
  );

  return {
    ProfileNode,
  };
});


'use strict';

/**
 * @fileoverview Provides the V8CpuProfileNode class.
 */
tr.exportTo('tr.e.v8', function() {
  const ProfileNode = tr.model.ProfileNode;
  /**
   * A V8CpuProfileNode represents a node in the v8 cpu profile tree,
   * it is essentially a frame in the stack when the sample gets recorded.
   */
  function V8CpuProfileNode(id, callFrame, parentNode) {
    ProfileNode.call(this, id, callFrame.functionName, parentNode);
    this.callFrame_ = tr.b.deepCopy(callFrame);
    this.deoptReason_ = '';
    this.colorId_ = tr.b.ColorScheme.getColorIdForGeneralPurposeString(
        callFrame.functionName);
  }

  V8CpuProfileNode.prototype = {
    __proto__: ProfileNode.prototype,

    get functionName() {
      return this.callFrame_.functionName;
    },

    get scriptId() {
      return this.callFrame_.scriptId;
    },

    get url() {
      if (!this.callFrame_.url) {
        return 'unknown';
      }
      let url = this.callFrame_.url;
      if (this.callFrame_.lineNumber === undefined) {
        return url;
      }
      url = url + ':' + this.callFrame_.lineNumber;
      if (this.callFrame_.columnNumber === undefined) {
        return url;
      }
      url = url + ':' + this.callFrame_.columnNumber;
      return url;
    },

    get deoptReason() {
      return this.deoptReason_;
    },

    set deoptReason(value) {
      this.deoptReason_ = value;
    },

    get userFriendlyName() {
      const name = this.functionName + ' url: ' + this.url;
      return !this.deoptReason_ ?
        name : name + ' Deoptimized reason: ' + this.deoptReason_;
    },

    get sampleTitle() {
      return 'V8 Sample';
    }
  };

  V8CpuProfileNode.constructFromObject = function(profileTree, node) {
    const nodeId = node.id;
    if (nodeId === 1) {
      // Ignore fake root.
      // The node with id 1 is a fake root for the profile tree,
      // since we are using map, we don't really need it.
      return undefined;
    }
    const parentNode = profileTree.getNode(node.parent);
    const profileNode = new V8CpuProfileNode(nodeId, node.callFrame,
                                           parentNode);
    if (node.deoptReason !== undefined) {
      profileNode.deoptReason = node.deoptReason;
    }
    return profileNode;
  };

  ProfileNode.subTypes.register(
      V8CpuProfileNode,
      {
        typeName: 'cpuProfile',
        name: 'v8 cpu profile node',
        pluralName: 'v8 cpu profile nodes'
      }
  );

  ProfileNode.subTypes.register(
      V8CpuProfileNode,
      {
        typeName: 'legacySample',
        name: 'v8 cpu profile node',
        pluralName: 'v8 cpu profile nodes'
      }
  );

  return {
    ProfileNode,
  };
});


'use strict';

/**
 * @fileoverview Provides the Sample class.
 */
tr.exportTo('tr.model', function() {
  /**
   * A ProfileTree represents all call stack we collect in sampling
   * in the form of a tree.
   * By traversing from root to a leaf we get a call stack
   * that belongs to some samples we collect.
   */
  function ProfileTree() {
    this.startTime_ = undefined;
    this.endTime_ = undefined;
    this.tree_ = new Map();
    this.pid_ = -1;
    this.tid_ = -1;
  }

  ProfileTree.prototype = {
    __proto__: Object.prototype,

    get pid() {
      return this.pid_;
    },

    set pid(value) {
      this.pid_ = value;
    },

    get tid() {
      return this.tid_;
    },

    set tid(value) {
      this.tid_ = value;
    },

    get tree() {
      return this.tree_;
    },

    get startTime() {
      return this.startTime_;
    },

    set startTime(value) {
      this.startTime_ = value;
      this.endTime_ = value;
    },

    get endTime() {
      return this.endTime_;
    },

    set endTime(value) {
      this.endTime_ = value;
    },

    add(node) {
      if (this.tree_.has(node.id)) {
        throw new Error('Conflict id in the profile tree.');
      }
      this.tree_.set(node.id, node);
      return node;
    },

    getNode(nodeId) {
      return this.tree_.get(nodeId);
    }
  };

  return {
    ProfileTree,
  };
});



'use strict';

/**
 * @fileoverview V8LogImporter imports v8.log files into the provided model.
 */
tr.exportTo('tr.e.importer.v8', function() {
  const CodeEntry = tr.e.importer.v8.CodeMap.CodeEntry;
  const CodeMap = tr.e.importer.v8.CodeMap;
  const ColorScheme = tr.b.ColorScheme;
  const DynamicFuncCodeEntry = tr.e.importer.v8.CodeMap.DynamicFuncCodeEntry;
  const FunctionEntry = tr.e.importer.v8.CodeMap.FunctionEntry;
  const ProfileNodeType = tr.model.ProfileNode.subTypes.getConstructor(
      undefined, 'legacySample');

  function V8LogImporter(model, eventData) {
    this.importPriority = 3;
    this.model_ = model;

    this.logData_ = eventData;

    this.code_map_ = new CodeMap();
    this.v8_timer_thread_ = undefined;
    this.v8_thread_ = undefined;

    this.profileTree_ = new tr.model.ProfileTree();
    // We predefine a unknown Profile Node so that when a stack address
    // can't be symbolized, we make it attach to the unknown Profile Node.
    this.profileTree_.add(new ProfileNodeType(
        -1, {
          url: '',
          functionName: 'unknown'
        }
    ));

    // We reconstruct the stack timeline from ticks.
    this.v8_stack_timeline_ = [];
  }

  const kV8BinarySuffixes = ['/d8', '/libv8.so'];


  const TimerEventDefaultArgs = {
    'V8.Execute': { pause: false, no_execution: false},
    'V8.External': { pause: false, no_execution: true},
    'V8.CompileFullCode': { pause: true, no_execution: true},
    'V8.RecompileSynchronous': { pause: true, no_execution: true},
    'V8.RecompileParallel': { pause: false, no_execution: false},
    'V8.CompileEval': { pause: true, no_execution: true},
    'V8.Parse': { pause: true, no_execution: true},
    'V8.PreParse': { pause: true, no_execution: true},
    'V8.ParseLazy': { pause: true, no_execution: true},
    'V8.GCScavenger': { pause: true, no_execution: true},
    'V8.GCCompactor': { pause: true, no_execution: true},
    'V8.GCContext': { pause: true, no_execution: true}
  };

  /**
   * @return {boolean} Whether obj is a V8 log string.
   */
  V8LogImporter.canImport = function(eventData) {
    if (typeof(eventData) !== 'string' && !(eventData instanceof String)) {
      return false;
    }

    return eventData.substring(0, 11) === 'v8-version,' ||
           eventData.substring(0, 12) === 'timer-event,' ||
           eventData.substring(0, 5) === 'tick,' ||
           eventData.substring(0, 15) === 'shared-library,' ||
           eventData.substring(0, 9) === 'profiler,' ||
           eventData.substring(0, 14) === 'code-creation,';
  };

  V8LogImporter.prototype = {

    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'V8LogImporter';
    },

    processTimerEvent_(name, startInUs, lengthInUs) {
      const args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      const startInMs = tr.b.convertUnit(startInUs,
          tr.b.UnitPrefixScale.METRIC.MICRO,
          tr.b.UnitPrefixScale.METRIC.MILLI);
      const lengthInMs = tr.b.convertUnit(lengthInUs,
          tr.b.UnitPrefixScale.METRIC.MICRO,
          tr.b.UnitPrefixScale.METRIC.MILLI);
      const colorId = ColorScheme.getColorIdForGeneralPurposeString(name);
      const slice = new tr.model.ThreadSlice('v8', name, colorId, startInMs,
          args, lengthInMs);
      this.v8_timer_thread_.sliceGroup.pushSlice(slice);
    },

    processTimerEventStart_(name, startInUs) {
      const args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      const startInMs = tr.b.convertUnit(startInUs,
          tr.b.UnitPrefixScale.METRIC.MICRO,
          tr.b.UnitPrefixScale.METRIC.MILLI);
      this.v8_timer_thread_.sliceGroup.beginSlice('v8', name, startInMs, args);
    },

    processTimerEventEnd_(name, endInUs) {
      const endInMs = tr.b.convertUnit(endInUs,
          tr.b.UnitPrefixScale.METRIC.MICRO,
          tr.b.UnitPrefixScale.METRIC.MILLI);
      this.v8_timer_thread_.sliceGroup.endSlice(endInMs);
    },

    processCodeCreateEvent_(type, kind, address, size, name,
        maybeFunc) {
      function parseState(s) {
        switch (s) {
          case '': return CodeMap.CodeState.COMPILED;
          case '~': return CodeMap.CodeState.OPTIMIZABLE;
          case '*': return CodeMap.CodeState.OPTIMIZED;
        }
        throw new Error('unknown code state: ' + s);
      }

      if (maybeFunc.length) {
        const funcAddr = parseInt(maybeFunc[0]);
        const state = parseState(maybeFunc[1]);
        let func = this.code_map_.findDynamicEntryByStartAddress(funcAddr);
        if (!func) {
          func = new FunctionEntry(name);
          func.kind = kind;
          this.code_map_.addCode(funcAddr, func);
        } else if (func.name !== name) {
          // Function object has been overwritten with a new one.
          func.name = name;
        }
        let entry = this.code_map_.findDynamicEntryByStartAddress(address);
        if (entry) {
          if (entry.size === size && entry.func === func) {
            // Entry state has changed.
            entry.state = state;
          }
        } else {
          entry = new DynamicFuncCodeEntry(size, type, func, state);
          entry.kind = kind;
          this.code_map_.addCode(address, entry);
        }
      } else {
        const codeEntry = new CodeEntry(size, name);
        codeEntry.kind = kind;
        this.code_map_.addCode(address, codeEntry);
      }
    },

    processCodeMoveEvent_(from, to) {
      this.code_map_.moveCode(from, to);
    },

    processCodeDeleteEvent_(address) {
      this.code_map_.deleteCode(address);
    },

    processSharedLibrary_(name, start, end) {
      const codeEntry = new CodeEntry(end - start, name,
                                     CodeEntry.TYPE.SHARED_LIB);
      codeEntry.kind = -3;  // External code kind.
      for (let i = 0; i < kV8BinarySuffixes.length; i++) {
        const suffix = kV8BinarySuffixes[i];
        if (name.indexOf(suffix, name.length - suffix.length) >= 0) {
          codeEntry.kind = -1;  // V8 runtime code kind.
          break;
        }
      }
      this.code_map_.addLibrary(start, codeEntry);
    },

    processCppSymbol_(address, size, name) {
      const codeEntry = new CodeEntry(size, name, CodeEntry.TYPE.CPP);
      codeEntry.kind = -1;
      this.code_map_.addStaticCode(address, codeEntry);
    },

    processTickEvent_(pc, startInUs, isExternalCallback,
        tosOrExternalCallback, vmstate, stack) {
      const startInMs = tr.b.convertUnit(startInUs,
          tr.b.UnitPrefixScale.METRIC.MICRO,
          tr.b.UnitPrefixScale.METRIC.MILLI);

      function findChildWithEntryID(stackFrame, entryID) {
        for (let i = 0; i < stackFrame.children.length; i++) {
          if (stackFrame.children[i].entryID === entryID) {
            return stackFrame.children[i];
          }
        }
        return undefined;
      }

      function processStack(pc, func, stack) {
        const fullStack = func ? [pc, func] : [pc];
        let prevFrame = pc;
        for (let i = 0, n = stack.length; i < n; ++i) {
          const frame = stack[i];
          const firstChar = frame.charAt(0);
          if (firstChar === '+' || firstChar === '-') {
            // An offset from the previous frame.
            prevFrame += parseInt(frame, 16);
            fullStack.push(prevFrame);
            // Filter out possible 'overflow' string.
          } else if (firstChar !== 'o') {
            fullStack.push(parseInt(frame, 16));
          }
          // Otherwise, they will be skipped.
        }
        return fullStack;
      }

      if (isExternalCallback) {
        // Don't use PC when in external callback code, as it can point
        // inside callback's code, and we will erroneously report
        // that a callback calls itself. Instead use tosOrExternalCallback,
        // as simply resetting PC will produce unaccounted ticks.
        pc = tosOrExternalCallback;
        tosOrExternalCallback = 0;
      } else if (tosOrExternalCallback) {
        // Find out, if top of stack was pointing inside a JS function
        // meaning that we have encountered a frameless invocation.
        const funcEntry = this.code_map_.findEntry(tosOrExternalCallback);
        if (!funcEntry ||
            !funcEntry.isJSFunction ||
            !funcEntry.isJSFunction()) {
          tosOrExternalCallback = 0;
        }
      }

      let processedStack = processStack(pc, tosOrExternalCallback, stack);
      let node = undefined;
      let lastNode = undefined;
      // v8 log stacks are inverted, leaf first and the root at the end.
      processedStack = processedStack.reverse();
      for (let i = 0, n = processedStack.length; i < n; i++) {
        const frame = processedStack[i];
        if (!frame) break;
        const entry = this.code_map_.findEntry(frame);

        if (!entry && i !== 0) {
          continue;
        }

        let sourceInfo = undefined;
        if (entry && entry.type === CodeEntry.TYPE.CPP) {
          const libEntry = this.code_map_.findEntryInLibraries(frame);
          if (libEntry) {
            sourceInfo = {
              file: libEntry.name
            };
          }
        }
        const entryId = entry ? entry.id : -1;
        node = this.profileTree_.getNode(entryId);
        if (node === undefined) {
          node = this.profileTree_.add(new ProfileNodeType(
            entryId, {
              functionName: entry.name,
              url: sourceInfo ? sourceInfo.file : '',
              lineNumber: sourceInfo ? sourceInfo.line : undefined,
              columnNumber: sourceInfo ? sourceInfo.column : undefined,
              scriptId: sourceInfo ? sourceInfo.scriptId : undefined
            }, lastNode));
        }
        lastNode = node;
      }
      this.model_.samples.push(new tr.model.Sample(
          startInMs, 'V8 PC', node, this.v8_thread_, undefined, 1));
    },

    processDistortion_(distortionInPicoseconds) {
      // Do nothing.
    },

    processPlotRange_(start, end) {
      // Do nothing.
    },

    processV8Version_(major, minor, build, patch, candidate) {
      // Do nothing.
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents() {
      const logreader = new tr.e.importer.v8.LogReader(
          { 'timer-event': {
            parsers: [null, parseInt, parseInt],
            processor: this.processTimerEvent_.bind(this)
          },
            'shared-library': {
              parsers: [null, parseInt, parseInt],
              processor: this.processSharedLibrary_.bind(this)
            },
            'timer-event-start': {
              parsers: [null, parseInt],
              processor: this.processTimerEventStart_.bind(this)
            },
            'timer-event-end': {
              parsers: [null, parseInt],
              processor: this.processTimerEventEnd_.bind(this)
            },
            'code-creation': {
              parsers: [null, parseInt, parseInt, parseInt, null, 'var-args'],
              processor: this.processCodeCreateEvent_.bind(this)
            },
            'code-move': {
              parsers: [parseInt, parseInt],
              processor: this.processCodeMoveEvent_.bind(this)
            },
            'code-delete': {
              parsers: [parseInt],
              processor: this.processCodeDeleteEvent_.bind(this)
            },
            'cpp': {
              parsers: [parseInt, parseInt, null],
              processor: this.processCppSymbol_.bind(this)
            },
            'tick': {
              parsers: [parseInt, parseInt, parseInt, parseInt, parseInt,
                'var-args'],
              processor: this.processTickEvent_.bind(this)
            },
            'distortion': {
              parsers: [parseInt],
              processor: this.processDistortion_.bind(this)
            },
            'plot-range': {
              parsers: [parseInt, parseInt],
              processor: this.processPlotRange_.bind(this)
            },
            'v8-version': {
              parsers: [parseInt, parseInt, parseInt, parseInt, parseInt],
              processor: this.processV8Version_.bind(this)
            }
          });

      this.v8_timer_thread_ =
          this.model_.getOrCreateProcess(-32).getOrCreateThread(1);
      this.v8_timer_thread_.name = 'V8 Timers';
      this.v8_thread_ =
          this.model_.getOrCreateProcess(-32).getOrCreateThread(2);
      this.v8_thread_.name = 'V8';

      const lines = this.logData_.split('\n');
      for (let i = 0; i < lines.length; i++) {
        logreader.processLogLine(lines[i]);
      }

      function addSlices(slices, thread) {
        for (let i = 0; i < slices.length; i++) {
          const duration = slices[i].end - slices[i].start;
          const slice = new tr.model.ThreadSlice('v8', slices[i].name,
              ColorScheme.getColorIdForGeneralPurposeString(slices[i].name),
              slices[i].start, {}, duration);
          thread.sliceGroup.pushSlice(slice);
          addSlices(slices[i].children, thread);
        }
      }
      addSlices(this.v8_stack_timeline_, this.v8_thread_);
    }
  };

  tr.importer.Importer.register(V8LogImporter);

  return {
    V8LogImporter,
  };
});


'use strict';

/**
 * @fileoverview ZipImporter inflates zip compressed data and passes it along
 * to an actual importer.
 */
tr.exportTo('tr.e.importer', function() {
  function ZipImporter(model, eventData) {
    if (eventData instanceof ArrayBuffer) {
      eventData = new Uint8Array(eventData);
    }
    this.model_ = model;
    this.eventData_ = eventData;
  }

  /**
   * @param {eventData} string Possibly zip compressed data.
   * @return {boolean} Whether eventData looks like zip compressed data.
   */
  ZipImporter.canImport = function(eventData) {
    let header;
    if (eventData instanceof ArrayBuffer) {
      header = new Uint8Array(eventData.slice(0, 2));
    } else if (typeof(eventData) === 'string' || eventData instanceof String) {
      header = [eventData.charCodeAt(0), eventData.charCodeAt(1)];
    } else {
      return false;
    }
    return header[0] === 'P'.charCodeAt(0) && header[1] === 'K'.charCodeAt(0);
  };

  ZipImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'ZipImporter';
    },

    isTraceDataContainer() {
      return true;
    },

    extractSubtraces() {
      const zip = new JSZip(this.eventData_);
      const subtraces = [];
      for (const idx in zip.files) {
        subtraces.push(zip.files[idx].asBinary());
      }
      return subtraces;
    }
  };

  tr.importer.Importer.register(ZipImporter);

  return {
    ZipImporter,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  /**
   * HeapEntry represents a single value describing the state of the heap of an
   * allocator in a single process.
   *
   * An entry specifies how much space (e.g. 19 MiB) was allocated in a
   * particular context, which consists of a codepath (e.g. drawQuad <- draw <-
   * MessageLoop::RunTask) and an object type (e.g. HTMLImportLoader).
   *
   * If |valuesAreTotals| is true the size and count of this entry are totals
   * for this and all more specific entries, otherwise they are values just for
   * this specific entry.
   *
   * @{constructor}
   */
  function HeapEntry(
      heapDump, leafStackFrame, objectTypeName, size, count, valuesAreTotals) {
    this.heapDump = heapDump;

    // The leaf stack frame of the associated backtrace (e.g. drawQuad for the
    // drawQuad <- draw <- MessageLoop::RunTask backtrace). If undefined, the
    // backtrace is empty.
    this.leafStackFrame = leafStackFrame;

    // The name of the allocated object type (e.g. 'HTMLImportLoader'). If
    // undefined, the entry represents the sum over all object types.
    this.objectTypeName = objectTypeName;

    this.size = size;
    this.count = count;
    this.valuesAreTotals = valuesAreTotals;
  }

  /**
   * HeapDump represents a dump of the heap of an allocator in a single process
   * at a particular timestamp.
   *
   * @{constructor}
   */
  function HeapDump(processMemoryDump, allocatorName, isComplete) {
    this.processMemoryDump = processMemoryDump;
    this.allocatorName = allocatorName;
    this.isComplete = isComplete;
    this.entries = [];
  }

  HeapDump.prototype = {
    addEntry(
        leafStackFrame, objectTypeName, size, count, opt_valuesAreTotals) {
      if (opt_valuesAreTotals === undefined) opt_valuesAreTotals = true;
      const valuesAreTotals = opt_valuesAreTotals;
      const entry = new HeapEntry(
          this, leafStackFrame, objectTypeName, size, count, valuesAreTotals);
      this.entries.push(entry);
      return entry;
    }
  };

  return {
    HeapEntry,
    HeapDump,
  };
});


'use strict';

/**
 * @fileoverview Logic for importing a Heap Dump.
 */
tr.exportTo('tr.e.importer', function() {
  /**
   * @constructor
   */
  function HeapDumpTraceEventImporter(
      heapProfileExpander,
      stackFrames,
      processMemoryDump,
      idPrefix,
      model) {
    this.expander = heapProfileExpander;
    this.stackFrames = stackFrames;
    this.processMemoryDump = processMemoryDump;
    this.idPrefix = idPrefix;
    this.model = model;
  }

  HeapDumpTraceEventImporter.prototype = {

    getLeafStackFrame(stackFrameId) {
      // Root.
      if (stackFrameId === '') return undefined;
      const parentId = this.idPrefix + stackFrameId;
      const id = parentId + ':self';

      // In the new format all values are 'self' values,
      // we distingiush these from the totals in the UI via
      // artificial '<self>' stack frames.
      if (!this.stackFrames[id]) {
        const parentStackFrame = this.stackFrames[parentId];
        const stackFrame = new tr.model.StackFrame(
            parentStackFrame, id, '<self>',
            undefined /* colorId */);
        this.model.addStackFrame(stackFrame);
      }
      return this.stackFrames[id];
    },

    parseEntry(entry, heapDump) {
      const size = entry.size;
      const count = entry.count;
      const leafStackFrame = this.getLeafStackFrame(entry.node.id);
      const objectTypeName = entry.type.name;
      const valuesAreTotals = false;
      if (objectTypeName === undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Missing object type name (ID ' + typeId + ')',
        });
      }
      heapDump.addEntry(
          leafStackFrame, objectTypeName, size, count, valuesAreTotals);
    },

    parse() {
      const heapDumps = {};
      const inflated = this.expander.inflated;
      for (const [allocatorName, entries] of Object.entries(inflated)) {
        const heapDump =
            new tr.model.HeapDump(this.processMemoryDump, allocatorName);
        for (const entry of entries) {
          this.parseEntry(entry, heapDump);
        }
        heapDump.isComplete = true;
        heapDumps[allocatorName] = heapDump;
      }
      return heapDumps;
    },

  };

  return {
    HeapDumpTraceEventImporter,
  };
});


'use strict';

/**
 * @fileoverview Logic for importing a Heap Dump.
 */
tr.exportTo('tr.e.importer', function() {
  /**
   * @constructor
   * @param {!tr.model.Model} model The model we are currently building.
   * @param {!tr.model.ProcessMemoryDump} processMemoryDump
   *     The parent memory dump for this heap dump.
   * @param {!Map|undefined} processObjectTypeNameMap
   *     A map from raw heap dump 'type' ids to human-readable names.
   * @param {!string} idPrefix Process-specific prefix to prepend to a stack
   *     trace id before looking it up in the model.
   * @param {!string} dumpId
   *     Raw heap dump id, used only for nice error messages.
   * @param {!Object} rawHeapDumps
   *     Raw heap dump.
   */
  function LegacyHeapDumpTraceEventImporter(
      model,
      processMemoryDump,
      processObjectTypeNameMap,
      idPrefix,
      dumpId,
      rawHeapDumps) {
    this.model_ = model;
    this.processObjectTypeNameMap_ = processObjectTypeNameMap;
    this.idPrefix_ = idPrefix;
    this.processMemoryDump_ = processMemoryDump;
    this.pid_ = this.processMemoryDump_.process.pid;
    this.dumpId_ = dumpId;
    this.rawHeapDumps_ = rawHeapDumps;
  }

  LegacyHeapDumpTraceEventImporter.prototype = {
    /**
     * Parse rawHeapDump and add entries to heapDump.
     *
     * @param {!{!entries:(!Array<!Object>|undefined)}} rawHeapDump
     *     The data we're going to parse.
     * @param {!string} allocatorName e.g. malloc.
     * @return {!tr.model.HeapDump} on success or undefined on an error.
     */
    parseRawHeapDump(rawHeapDump, allocatorName) {
      const model = this.model_;
      const processMemoryDump = this.processMemoryDump_;
      const heapDump = new tr.model.HeapDump(processMemoryDump, allocatorName);

      const entries = rawHeapDump.entries;
      if (entries === undefined || entries.length === 0) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'No heap entries in a ' + allocatorName +
              ' heap dump for PID=' + this.pid_ +
              ' and dump ID=' + this.dumpId_ + '.'
        });

        return undefined;
      }

      // The old format always starts with a {size: <total>} entry.
      // See https://goo.gl/WYStil
      // TODO(petrcermak): Remove support for the old format once the new
      // format has been around long enough.
      const isOldFormat = entries[0].bt === undefined;
      if (!isOldFormat && this.processObjectTypeNameMap_ === undefined) {
        // Mapping from object type IDs to names must be provided in the new
        // format.
        return undefined;
      }

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        const size = parseInt(entry.size, 16);
        const leafStackFrameIndex = entry.bt;
        let leafStackFrame;

        // There are two possible mappings from leaf stack frame indices
        // (provided in the trace) to the corresponding stack frames
        // depending on the format.
        if (isOldFormat) {
          // Old format:
          //   Undefined index        -> / (root)
          //   Defined index for /A/B -> /A/B/<self>
          if (leafStackFrameIndex === undefined) {
            leafStackFrame = undefined; /* root */
          } else {
            // Get the leaf stack frame corresponding to the provided index.
            let leafStackFrameId = this.idPrefix_ + leafStackFrameIndex;
            if (leafStackFrameIndex === '') {
              leafStackFrame = undefined; /* root */
            } else {
              leafStackFrame = model.stackFrames[leafStackFrameId];
              if (leafStackFrame === undefined) {
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Missing leaf stack frame (ID ' +
                      leafStackFrameId + ') of heap entry ' + i + ' (size ' +
                      size + ') in a ' + allocatorName +
                      ' heap dump for PID=' + this.pid_ + '.'
                });
                continue;
              }
            }

            // Inject an artificial <self> leaf stack frame.
            leafStackFrameId += ':self';
            if (model.stackFrames[leafStackFrameId] !== undefined) {
              // The frame might already exist if there are multiple process
              // memory dumps (for the same process) in the trace.
              leafStackFrame = model.stackFrames[leafStackFrameId];
            } else {
              leafStackFrame = new tr.model.StackFrame(
                  leafStackFrame, leafStackFrameId, '<self>',
                  undefined /* colorId */);
              model.addStackFrame(leafStackFrame);
            }
          }
        } else {
          // New format:
          //   Undefined index        -> (invalid value)
          //   Defined index for /A/B -> /A/B
          if (leafStackFrameIndex === undefined) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Missing stack frame ID of heap entry ' + i +
                  ' (size ' + size + ') in a ' + allocatorName +
                  ' heap dump for PID=' + this.pid_ + '.'
            });
            continue;
          }

          // Get the leaf stack frame corresponding to the provided index.
          const leafStackFrameId = this.idPrefix_ + leafStackFrameIndex;
          if (leafStackFrameIndex === '') {
            leafStackFrame = undefined; /* root */
          } else {
            leafStackFrame = model.stackFrames[leafStackFrameId];
            if (leafStackFrame === undefined) {
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Missing leaf stack frame (ID ' + leafStackFrameId +
                    ') of heap entry ' + i + ' (size ' + size + ') in a ' +
                    allocatorName + ' heap dump for PID=' + this.pid_ + '.'
              });
              continue;
            }
          }
        }

        const objectTypeId = entry.type;
        let objectTypeName;
        if (objectTypeId === undefined) {
          objectTypeName = undefined; /* total over all types */
        } else if (this.processObjectTypeNameMap_ === undefined) {
          // This can only happen when the old format is used.
          continue;
        } else {
          objectTypeName = this.processObjectTypeNameMap_[objectTypeId];
          if (objectTypeName === undefined) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Missing object type name (ID ' + objectTypeId +
                  ') of heap entry ' + i + ' (size ' + size + ') in a ' +
                  allocatorName + ' heap dump for PID=' + this.pid_ + '.'
            });
            continue;
          }
        }

        const count = entry.count === undefined ? undefined :
            parseInt(entry.count, 16);
        heapDump.addEntry(leafStackFrame, objectTypeName, size, count);
      }

      return heapDump;
    },

    parse() {
      const heapDumps = {};
      for (const allocatorName in this.rawHeapDumps_) {
        const rawHeapDump = this.rawHeapDumps_[allocatorName];
        const heapDump = this.parseRawHeapDump(rawHeapDump, allocatorName);

        // Throw away heap dumps with no entries. This can happen if all raw
        // entries in the trace are skipped for some reason (e.g. invalid leaf
        // stack frame ID).
        if (heapDump !== undefined && heapDump.entries.length > 0) {
          heapDumps[allocatorName] = heapDump;
        }
      }
      return heapDumps;
    },

  };

  return {
    LegacyHeapDumpTraceEventImporter,
  };
});


'use strict';
if (tr.isHeadless) {
  // oboe requires window; there is no window object in headless mode.
  // Temporarily make one.
  global.window = {};
}

// This file is the concatenation of many js files.
// See http://github.com/jimhigson/oboe.js for the raw source

// having a local undefined, window, Object etc allows slightly better minification:
(function  (window, Object, Array, Error, JSON, undefined ) {

   // v2.1.3-2-gc85b5c4

/*

Copyright (c) 2013, Jim Higson

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

1.  Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/** 
 * Partially complete a function.
 * 
 *  var add3 = partialComplete( function add(a,b){return a+b}, 3 );
 *  
 *  add3(4) // gives 7
 *  
 *  function wrap(left, right, cen){return left + " " + cen + " " + right;}
 *  
 *  var pirateGreeting = partialComplete( wrap , "I'm", ", a mighty pirate!" );
 *  
 *  pirateGreeting("Guybrush Threepwood"); 
 *  // gives "I'm Guybrush Threepwood, a mighty pirate!"
 */
var partialComplete = varArgs(function( fn, args ) {

      // this isn't the shortest way to write this but it does
      // avoid creating a new array each time to pass to fn.apply,
      // otherwise could just call boundArgs.concat(callArgs)       

      var numBoundArgs = args.length;

      return varArgs(function( callArgs ) {
         
         for (var i = 0; i < callArgs.length; i++) {
            args[numBoundArgs + i] = callArgs[i];
         }
         
         args.length = numBoundArgs + callArgs.length;         
                     
         return fn.apply(this, args);
      }); 
   }),

/**
 * Compose zero or more functions:
 * 
 *    compose(f1, f2, f3)(x) = f1(f2(f3(x))))
 * 
 * The last (inner-most) function may take more than one parameter:
 * 
 *    compose(f1, f2, f3)(x,y) = f1(f2(f3(x,y))))
 */
   compose = varArgs(function(fns) {

      var fnsList = arrayAsList(fns);
   
      function next(params, curFn) {  
         return [apply(params, curFn)];   
      }
            
      return varArgs(function(startParams){
        
         return foldR(next, startParams, fnsList)[0];
      });
   });

/**
 * A more optimised version of compose that takes exactly two functions
 * @param f1
 * @param f2
 */
function compose2(f1, f2){
   return function(){
      return f1.call(this,f2.apply(this,arguments));
   }
}

/**
 * Generic form for a function to get a property from an object
 * 
 *    var o = {
 *       foo:'bar'
 *    }
 *    
 *    var getFoo = attr('foo')
 *    
 *    fetFoo(o) // returns 'bar'
 * 
 * @param {String} key the property name
 */
function attr(key) {
   return function(o) { return o[key]; };
}
        
/**
 * Call a list of functions with the same args until one returns a 
 * truthy result. Similar to the || operator.
 * 
 * So:
 *      lazyUnion([f1,f2,f3 ... fn])( p1, p2 ... pn )
 *      
 * Is equivalent to: 
 *      apply([p1, p2 ... pn], f1) || 
 *      apply([p1, p2 ... pn], f2) || 
 *      apply([p1, p2 ... pn], f3) ... apply(fn, [p1, p2 ... pn])  
 *  
 * @returns the first return value that is given that is truthy.
 */
   var lazyUnion = varArgs(function(fns) {

      return varArgs(function(params){
   
         var maybeValue;
   
         for (var i = 0; i < len(fns); i++) {
   
            maybeValue = apply(params, fns[i]);
   
            if( maybeValue ) {
               return maybeValue;
            }
         }
      });
   });   

/**
 * This file declares various pieces of functional programming.
 * 
 * This isn't a general purpose functional library, to keep things small it
 * has just the parts useful for Oboe.js.
 */


/**
 * Call a single function with the given arguments array.
 * Basically, a functional-style version of the OO-style Function#apply for 
 * when we don't care about the context ('this') of the call.
 * 
 * The order of arguments allows partial completion of the arguments array
 */
function apply(args, fn) {
   return fn.apply(undefined, args);
}

/**
 * Define variable argument functions but cut out all that tedious messing about 
 * with the arguments object. Delivers the variable-length part of the arguments
 * list as an array.
 * 
 * Eg:
 * 
 * var myFunction = varArgs(
 *    function( fixedArgument, otherFixedArgument, variableNumberOfArguments ){
 *       console.log( variableNumberOfArguments );
 *    }
 * )
 * 
 * myFunction('a', 'b', 1, 2, 3); // logs [1,2,3]
 * 
 * var myOtherFunction = varArgs(function( variableNumberOfArguments ){
 *    console.log( variableNumberOfArguments );
 * })
 * 
 * myFunction(1, 2, 3); // logs [1,2,3]
 * 
 */
function varArgs(fn){

   var numberOfFixedArguments = fn.length -1,
       slice = Array.prototype.slice;          
         
                   
   if( numberOfFixedArguments == 0 ) {
      // an optimised case for when there are no fixed args:   
   
      return function(){
         return fn.call(this, slice.call(arguments));
      }
      
   } else if( numberOfFixedArguments == 1 ) {
      // an optimised case for when there are is one fixed args:
   
      return function(){
         return fn.call(this, arguments[0], slice.call(arguments, 1));
      }
   }
   
   // general case   

   // we know how many arguments fn will always take. Create a
   // fixed-size array to hold that many, to be re-used on
   // every call to the returned function
   var argsHolder = Array(fn.length);   
                             
   return function(){
                            
      for (var i = 0; i < numberOfFixedArguments; i++) {
         argsHolder[i] = arguments[i];         
      }

      argsHolder[numberOfFixedArguments] = 
         slice.call(arguments, numberOfFixedArguments);
                                
      return fn.apply( this, argsHolder);      
   }       
}


/**
 * Swap the order of parameters to a binary function
 * 
 * A bit like this flip: http://zvon.org/other/haskell/Outputprelude/flip_f.html
 */
function flip(fn){
   return function(a, b){
      return fn(b,a);
   }
}


/**
 * Create a function which is the intersection of two other functions.
 * 
 * Like the && operator, if the first is truthy, the second is never called,
 * otherwise the return value from the second is returned.
 */
function lazyIntersection(fn1, fn2) {

   return function (param) {
                                                              
      return fn1(param) && fn2(param);
   };   
}

/**
 * A function which does nothing
 */
function noop(){}

/**
 * A function which is always happy
 */
function always(){return true}

/**
 * Create a function which always returns the same
 * value
 * 
 * var return3 = functor(3);
 * 
 * return3() // gives 3
 * return3() // still gives 3
 * return3() // will always give 3
 */
function functor(val){
   return function(){
      return val;
   }
}

/**
 * This file defines some loosely associated syntactic sugar for 
 * Javascript programming 
 */


/**
 * Returns true if the given candidate is of type T
 */
function isOfType(T, maybeSomething){
   return maybeSomething && maybeSomething.constructor === T;
}

var len = attr('length'),    
    isString = partialComplete(isOfType, String);

/** 
 * I don't like saying this:
 * 
 *    foo !=== undefined
 *    
 * because of the double-negative. I find this:
 * 
 *    defined(foo)
 *    
 * easier to read.
 */ 
function defined( value ) {
   return value !== undefined;
}

/**
 * Returns true if object o has a key named like every property in 
 * the properties array. Will give false if any are missing, or if o 
 * is not an object.
 */
function hasAllProperties(fieldList, o) {

   return      (o instanceof Object) 
            &&
               all(function (field) {         
                  return (field in o);         
               }, fieldList);
}
/**
 * Like cons in Lisp
 */
function cons(x, xs) {
   
   /* Internally lists are linked 2-element Javascript arrays.
          
      Ideally the return here would be Object.freeze([x,xs])
      so that bugs related to mutation are found fast.
      However, cons is right on the critical path for
      performance and this slows oboe-mark down by
      ~25%. Under theoretical future JS engines that freeze more
      efficiently (possibly even use immutability to
      run faster) this should be considered for
      restoration.
   */
   
   return [x,xs];
}

/**
 * The empty list
 */
var emptyList = null,

/**
 * Get the head of a list.
 * 
 * Ie, head(cons(a,b)) = a
 */
    head = attr(0),

/**
 * Get the tail of a list.
 * 
 * Ie, tail(cons(a,b)) = b
 */
    tail = attr(1);


/** 
 * Converts an array to a list 
 * 
 *    asList([a,b,c])
 * 
 * is equivalent to:
 *    
 *    cons(a, cons(b, cons(c, emptyList))) 
 **/
function arrayAsList(inputArray){

   return reverseList( 
      inputArray.reduce(
         flip(cons),
         emptyList 
      )
   );
}

/**
 * A varargs version of arrayAsList. Works a bit like list
 * in LISP.
 * 
 *    list(a,b,c) 
 *    
 * is equivalent to:
 * 
 *    cons(a, cons(b, cons(c, emptyList)))
 */
var list = varArgs(arrayAsList);

/**
 * Convert a list back to a js native array
 */
function listAsArray(list){

   return foldR( function(arraySoFar, listItem){
      
      arraySoFar.unshift(listItem);
      return arraySoFar;
           
   }, [], list );
   
}

/**
 * Map a function over a list 
 */
function map(fn, list) {

   return list
            ? cons(fn(head(list)), map(fn,tail(list)))
            : emptyList
            ;
}

/**
 * foldR implementation. Reduce a list down to a single value.
 * 
 * @pram {Function} fn     (rightEval, curVal) -> result 
 */
function foldR(fn, startValue, list) {
      
   return list 
            ? fn(foldR(fn, startValue, tail(list)), head(list))
            : startValue
            ;
}

/**
 * foldR implementation. Reduce a list down to a single value.
 * 
 * @pram {Function} fn     (rightEval, curVal) -> result 
 */
function foldR1(fn, list) {
      
   return tail(list) 
            ? fn(foldR1(fn, tail(list)), head(list))
            : head(list)
            ;
}


/**
 * Return a list like the one given but with the first instance equal 
 * to item removed 
 */
function without(list, test, removedFn) {
 
   return withoutInner(list, removedFn || noop);
 
   function withoutInner(subList, removedFn) {
      return subList  
         ?  ( test(head(subList)) 
                  ? (removedFn(head(subList)), tail(subList)) 
                  : cons(head(subList), withoutInner(tail(subList), removedFn))
            )
         : emptyList
         ;
   }               
}

/** 
 * Returns true if the given function holds for every item in 
 * the list, false otherwise 
 */
function all(fn, list) {
   
   return !list || 
          ( fn(head(list)) && all(fn, tail(list)) );
}

/**
 * Call every function in a list of functions with the same arguments
 * 
 * This doesn't make any sense if we're doing pure functional because 
 * it doesn't return anything. Hence, this is only really useful if the
 * functions being called have side-effects. 
 */
function applyEach(fnList, args) {

   if( fnList ) {  
      head(fnList).apply(null, args);
      
      applyEach(tail(fnList), args);
   }
}

/**
 * Reverse the order of a list
 */
function reverseList(list){ 

   // js re-implementation of 3rd solution from:
   //    http://www.haskell.org/haskellwiki/99_questions/Solutions/5
   function reverseInner( list, reversedAlready ) {
      if( !list ) {
         return reversedAlready;
      }
      
      return reverseInner(tail(list), cons(head(list), reversedAlready))
   }

   return reverseInner(list, emptyList);
}

function first(test, list) {
   return   list &&
               (test(head(list)) 
                  ? head(list) 
                  : first(test,tail(list))); 
}

/* 
   This is a slightly hacked-up browser only version of clarinet 
   
      *  some features removed to help keep browser Oboe under 
         the 5k micro-library limit
      *  plug directly into event bus
   
   For the original go here:
      https://github.com/dscape/clarinet

   We receive the events:
      STREAM_DATA
      STREAM_END
      
   We emit the events:
      SAX_KEY
      SAX_VALUE_OPEN
      SAX_VALUE_CLOSE      
      FAIL_EVENT      
 */

function clarinet(eventBus) {
  "use strict";
   
  var 
      // shortcut some events on the bus
      emitSaxKey           = eventBus(SAX_KEY).emit,
      emitValueOpen        = eventBus(SAX_VALUE_OPEN).emit,
      emitValueClose       = eventBus(SAX_VALUE_CLOSE).emit,
      emitFail             = eventBus(FAIL_EVENT).emit,
              
      MAX_BUFFER_LENGTH = 64 * 1024
  ,   stringTokenPattern = /[\\"\n]/g
  ,   _n = 0
  
      // states
  ,   BEGIN                = _n++
  ,   VALUE                = _n++ // general stuff
  ,   OPEN_OBJECT          = _n++ // {
  ,   CLOSE_OBJECT         = _n++ // }
  ,   OPEN_ARRAY           = _n++ // [
  ,   CLOSE_ARRAY          = _n++ // ]
  ,   STRING               = _n++ // ""
  ,   OPEN_KEY             = _n++ // , "a"
  ,   CLOSE_KEY            = _n++ // :
  ,   TRUE                 = _n++ // r
  ,   TRUE2                = _n++ // u
  ,   TRUE3                = _n++ // e
  ,   FALSE                = _n++ // a
  ,   FALSE2               = _n++ // l
  ,   FALSE3               = _n++ // s
  ,   FALSE4               = _n++ // e
  ,   NULL                 = _n++ // u
  ,   NULL2                = _n++ // l
  ,   NULL3                = _n++ // l
  ,   NUMBER_DECIMAL_POINT = _n++ // .
  ,   NUMBER_DIGIT         = _n   // [0-9]

      // setup initial parser values
  ,   bufferCheckPosition  = MAX_BUFFER_LENGTH
  ,   latestError                
  ,   c                    
  ,   p                    
  ,   textNode             = undefined
  ,   numberNode           = ""     
  ,   slashed              = false
  ,   closed               = false
  ,   state                = BEGIN
  ,   stack                = []
  ,   unicodeS             = null
  ,   unicodeI             = 0
  ,   depth                = 0
  ,   position             = 0
  ,   column               = 0  //mostly for error reporting
  ,   line                 = 1
  ;

  function checkBufferLength () {
     
    var maxActual = 0;
     
    if (textNode !== undefined && textNode.length > MAX_BUFFER_LENGTH) {
      emitError("Max buffer length exceeded: textNode");
      maxActual = Math.max(maxActual, textNode.length);
    }
    if (numberNode.length > MAX_BUFFER_LENGTH) {
      emitError("Max buffer length exceeded: numberNode");
      maxActual = Math.max(maxActual, numberNode.length);
    }
     
    bufferCheckPosition = (MAX_BUFFER_LENGTH - maxActual)
                               + position;
  }

  eventBus(STREAM_DATA).on(handleData);

   /* At the end of the http content close the clarinet 
    This will provide an error if the total content provided was not 
    valid json, ie if not all arrays, objects and Strings closed properly */
  eventBus(STREAM_END).on(handleStreamEnd);   

  function emitError (errorString) {
     if (textNode !== undefined) {
        emitValueOpen(textNode);
        emitValueClose();
        textNode = undefined;
     }

     latestError = Error(errorString + "\nLn: "+line+
                                       "\nCol: "+column+
                                       "\nChr: "+c);
     
     emitFail(errorReport(undefined, undefined, latestError));
  }

  function handleStreamEnd() {
    if( state == BEGIN ) {
      // Handle the case where the stream closes without ever receiving
      // any input. This isn't an error - response bodies can be blank,
      // particularly for 204 http responses
      
      // Because of how Oboe is currently implemented, we parse a
      // completely empty stream as containing an empty object.
      // This is because Oboe's done event is only fired when the
      // root object of the JSON stream closes.
      
      // This should be decoupled and attached instead to the input stream
      // from the http (or whatever) resource ending.
      // If this decoupling could happen the SAX parser could simply emit
      // zero events on a completely empty input.
      emitValueOpen({});
      emitValueClose();

      closed = true;
      return;
    }
  
    if (state !== VALUE || depth !== 0)
      emitError("Unexpected end");
 
    if (textNode !== undefined) {
      emitValueOpen(textNode);
      emitValueClose();
      textNode = undefined;
    }
     
    closed = true;
  }

  function whitespace(c){
     return c == '\r' || c == '\n' || c == ' ' || c == '\t';
  }
   
  function handleData (chunk) {
         
    // this used to throw the error but inside Oboe we will have already
    // gotten the error when it was emitted. The important thing is to
    // not continue with the parse.
    if (latestError)
      return;
      
    if (closed) {
       return emitError("Cannot write after close");
    }

    var i = 0;
    c = chunk[0]; 

    while (c) {
      p = c;
      c = chunk[i++];
      if(!c) break;

      position ++;
      if (c == "\n") {
        line ++;
        column = 0;
      } else column ++;
      switch (state) {

        case BEGIN:
          if (c === "{") state = OPEN_OBJECT;
          else if (c === "[") state = OPEN_ARRAY;
          else if (!whitespace(c))
            return emitError("Non-whitespace before {[.");
        continue;

        case OPEN_KEY:
        case OPEN_OBJECT:
          if (whitespace(c)) continue;
          if(state === OPEN_KEY) stack.push(CLOSE_KEY);
          else {
            if(c === '}') {
              emitValueOpen({});
              emitValueClose();
              state = stack.pop() || VALUE;
              continue;
            } else  stack.push(CLOSE_OBJECT);
          }
          if(c === '"')
             state = STRING;
          else
             return emitError("Malformed object key should start with \" ");
        continue;

        case CLOSE_KEY:
        case CLOSE_OBJECT:
          if (whitespace(c)) continue;

          if(c===':') {
            if(state === CLOSE_OBJECT) {
              stack.push(CLOSE_OBJECT);

               if (textNode !== undefined) {
                  // was previously (in upstream Clarinet) one event
                  //  - object open came with the text of the first
                  emitValueOpen({});
                  emitSaxKey(textNode);
                  textNode = undefined;
               }
               depth++;
            } else {
               if (textNode !== undefined) {
                  emitSaxKey(textNode);
                  textNode = undefined;
               }
            }
             state  = VALUE;
          } else if (c==='}') {
             if (textNode !== undefined) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = undefined;
             }
             emitValueClose();
            depth--;
            state = stack.pop() || VALUE;
          } else if(c===',') {
            if(state === CLOSE_OBJECT)
              stack.push(CLOSE_OBJECT);
             if (textNode !== undefined) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = undefined;
             }
             state  = OPEN_KEY;
          } else 
             return emitError('Bad object');
        continue;

        case OPEN_ARRAY: // after an array there always a value
        case VALUE:
          if (whitespace(c)) continue;
          if(state===OPEN_ARRAY) {
            emitValueOpen([]);
            depth++;             
            state = VALUE;
            if(c === ']') {
              emitValueClose();
              depth--;
              state = stack.pop() || VALUE;
              continue;
            } else {
              stack.push(CLOSE_ARRAY);
            }
          }
               if(c === '"') state = STRING;
          else if(c === '{') state = OPEN_OBJECT;
          else if(c === '[') state = OPEN_ARRAY;
          else if(c === 't') state = TRUE;
          else if(c === 'f') state = FALSE;
          else if(c === 'n') state = NULL;
          else if(c === '-') { // keep and continue
            numberNode += c;
          } else if(c==='0') {
            numberNode += c;
            state = NUMBER_DIGIT;
          } else if('123456789'.indexOf(c) !== -1) {
            numberNode += c;
            state = NUMBER_DIGIT;
          } else               
            return emitError("Bad value");
        continue;

        case CLOSE_ARRAY:
          if(c===',') {
            stack.push(CLOSE_ARRAY);
             if (textNode !== undefined) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = undefined;
             }
             state  = VALUE;
          } else if (c===']') {
             if (textNode !== undefined) {
                emitValueOpen(textNode);
                emitValueClose();
                textNode = undefined;
             }
             emitValueClose();
            depth--;
            state = stack.pop() || VALUE;
          } else if (whitespace(c))
              continue;
          else 
             return emitError('Bad array');
        continue;

        case STRING:
          if (textNode === undefined) {
              textNode = "";
          }

          // thanks thejh, this is an about 50% performance improvement.
          var starti              = i-1;
           
          STRING_BIGLOOP: while (true) {

            // zero means "no unicode active". 1-4 mean "parse some more". end after 4.
            while (unicodeI > 0) {
              unicodeS += c;
              c = chunk.charAt(i++);
              if (unicodeI === 4) {
                // TODO this might be slow? well, probably not used too often anyway
                textNode += String.fromCharCode(parseInt(unicodeS, 16));
                unicodeI = 0;
                starti = i-1;
              } else {
                unicodeI++;
              }
              // we can just break here: no stuff we skipped that still has to be sliced out or so
              if (!c) break STRING_BIGLOOP;
            }
            if (c === '"' && !slashed) {
              state = stack.pop() || VALUE;
              textNode += chunk.substring(starti, i-1);
              break;
            }
            if (c === '\\' && !slashed) {
              slashed = true;
              textNode += chunk.substring(starti, i-1);
               c = chunk.charAt(i++);
              if (!c) break;
            }
            if (slashed) {
              slashed = false;
                   if (c === 'n') { textNode += '\n'; }
              else if (c === 'r') { textNode += '\r'; }
              else if (c === 't') { textNode += '\t'; }
              else if (c === 'f') { textNode += '\f'; }
              else if (c === 'b') { textNode += '\b'; }
              else if (c === 'u') {
                // \uxxxx. meh!
                unicodeI = 1;
                unicodeS = '';
              } else {
                textNode += c;
              }
              c = chunk.charAt(i++);
              starti = i-1;
              if (!c) break;
              else continue;
            }

            stringTokenPattern.lastIndex = i;
            var reResult = stringTokenPattern.exec(chunk);
            if (!reResult) {
              i = chunk.length+1;
              textNode += chunk.substring(starti, i-1);
              break;
            }
            i = reResult.index+1;
            c = chunk.charAt(reResult.index);
            if (!c) {
              textNode += chunk.substring(starti, i-1);
              break;
            }
          }
        continue;

        case TRUE:
          if (!c)  continue; // strange buffers
          if (c==='r') state = TRUE2;
          else
             return emitError( 'Invalid true started with t'+ c);
        continue;

        case TRUE2:
          if (!c)  continue;
          if (c==='u') state = TRUE3;
          else
             return emitError('Invalid true started with tr'+ c);
        continue;

        case TRUE3:
          if (!c) continue;
          if(c==='e') {
            emitValueOpen(true);
            emitValueClose();
            state = stack.pop() || VALUE;
          } else
             return emitError('Invalid true started with tru'+ c);
        continue;

        case FALSE:
          if (!c)  continue;
          if (c==='a') state = FALSE2;
          else
             return emitError('Invalid false started with f'+ c);
        continue;

        case FALSE2:
          if (!c)  continue;
          if (c==='l') state = FALSE3;
          else
             return emitError('Invalid false started with fa'+ c);
        continue;

        case FALSE3:
          if (!c)  continue;
          if (c==='s') state = FALSE4;
          else
             return emitError('Invalid false started with fal'+ c);
        continue;

        case FALSE4:
          if (!c)  continue;
          if (c==='e') {
            emitValueOpen(false);
            emitValueClose();
            state = stack.pop() || VALUE;
          } else
             return emitError('Invalid false started with fals'+ c);
        continue;

        case NULL:
          if (!c)  continue;
          if (c==='u') state = NULL2;
          else
             return emitError('Invalid null started with n'+ c);
        continue;

        case NULL2:
          if (!c)  continue;
          if (c==='l') state = NULL3;
          else
             return emitError('Invalid null started with nu'+ c);
        continue;

        case NULL3:
          if (!c) continue;
          if(c==='l') {
            emitValueOpen(null);
            emitValueClose();
            state = stack.pop() || VALUE;
          } else 
             return emitError('Invalid null started with nul'+ c);
        continue;

        case NUMBER_DECIMAL_POINT:
          if(c==='.') {
            numberNode += c;
            state       = NUMBER_DIGIT;
          } else 
             return emitError('Leading zero not followed by .');
        continue;

        case NUMBER_DIGIT:
          if('0123456789'.indexOf(c) !== -1) numberNode += c;
          else if (c==='.') {
            if(numberNode.indexOf('.')!==-1)
               return emitError('Invalid number has two dots');
            numberNode += c;
          } else if (c==='e' || c==='E') {
            if(numberNode.indexOf('e')!==-1 ||
               numberNode.indexOf('E')!==-1 )
               return emitError('Invalid number has two exponential');
            numberNode += c;
          } else if (c==="+" || c==="-") {
            if(!(p==='e' || p==='E'))
               return emitError('Invalid symbol in number');
            numberNode += c;
          } else {
            if (numberNode) {
              emitValueOpen(parseFloat(numberNode));
              emitValueClose();
              numberNode = "";
            }
            i--; // go back one
            state = stack.pop() || VALUE;
          }
        continue;

        default:
          return emitError("Unknown state: " + state);
      }
    }
    if (position >= bufferCheckPosition)
      checkBufferLength();
  }
}


/** 
 * A bridge used to assign stateless functions to listen to clarinet.
 * 
 * As well as the parameter from clarinet, each callback will also be passed
 * the result of the last callback.
 * 
 * This may also be used to clear all listeners by assigning zero handlers:
 * 
 *    ascentManager( clarinet, {} )
 */
function ascentManager(oboeBus, handlers){
   "use strict";
   
   var listenerId = {},
       ascent;

   function stateAfter(handler) {
      return function(param){
         ascent = handler( ascent, param);
      }
   }
   
   for( var eventName in handlers ) {

      oboeBus(eventName).on(stateAfter(handlers[eventName]), listenerId);
   }
   
   oboeBus(NODE_SWAP).on(function(newNode) {
      
      var oldHead = head(ascent),
          key = keyOf(oldHead),
          ancestors = tail(ascent),
          parentNode;

      if( ancestors ) {
         parentNode = nodeOf(head(ancestors));
         parentNode[key] = newNode;
      }
   });

   oboeBus(NODE_DROP).on(function() {

      var oldHead = head(ascent),
          key = keyOf(oldHead),
          ancestors = tail(ascent),
          parentNode;

      if( ancestors ) {
         parentNode = nodeOf(head(ancestors));
 
         delete parentNode[key];
      }
   });

   oboeBus(ABORTING).on(function(){
      
      for( var eventName in handlers ) {
         oboeBus(eventName).un(listenerId);
      }
   });   
}

// based on gist https://gist.github.com/monsur/706839

/**
 * XmlHttpRequest's getAllResponseHeaders() method returns a string of response
 * headers according to the format described here:
 * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method
 * This method parses that string into a user-friendly key/value pair object.
 */
function parseResponseHeaders(headerStr) {
   var headers = {};
   
   headerStr && headerStr.split('\u000d\u000a')
      .forEach(function(headerPair){
   
         // Can't use split() here because it does the wrong thing
         // if the header value has the string ": " in it.
         var index = headerPair.indexOf('\u003a\u0020');
         
         headers[headerPair.substring(0, index)] 
                     = headerPair.substring(index + 2);
      });
   
   return headers;
}

/**
 * Detect if a given URL is cross-origin in the scope of the
 * current page.
 * 
 * Browser only (since cross-origin has no meaning in Node.js)
 *
 * @param {Object} pageLocation - as in window.location
 * @param {Object} ajaxHost - an object like window.location describing the 
 *    origin of the url that we want to ajax in
 */
function isCrossOrigin(pageLocation, ajaxHost) {

   /*
    * NB: defaultPort only knows http and https.
    * Returns undefined otherwise.
    */
   function defaultPort(protocol) {
      return {'http:':80, 'https:':443}[protocol];
   }
   
   function portOf(location) {
      // pageLocation should always have a protocol. ajaxHost if no port or
      // protocol is specified, should use the port of the containing page
      
      return location.port || defaultPort(location.protocol||pageLocation.protocol);
   }

   // if ajaxHost doesn't give a domain, port is the same as pageLocation
   // it can't give a protocol but not a domain
   // it can't give a port but not a domain
   
   return !!(  (ajaxHost.protocol  && (ajaxHost.protocol  != pageLocation.protocol)) ||
               (ajaxHost.host      && (ajaxHost.host      != pageLocation.host))     ||
               (ajaxHost.host      && (portOf(ajaxHost) != portOf(pageLocation)))
          );
}

/* turn any url into an object like window.location */
function parseUrlOrigin(url) {
   // url could be domain-relative
   // url could give a domain

   // cross origin means:
   //    same domain
   //    same port
   //    some protocol
   // so, same everything up to the first (single) slash 
   // if such is given
   //
   // can ignore everything after that   
   
   var URL_HOST_PATTERN = /(\w+:)?(?:\/\/)([\w.-]+)?(?::(\d+))?\/?/,

         // if no match, use an empty array so that
         // subexpressions 1,2,3 are all undefined
         // and will ultimately return all empty
         // strings as the parse result:
       urlHostMatch = URL_HOST_PATTERN.exec(url) || [];
   
   return {
      protocol:   urlHostMatch[1] || '',
      host:       urlHostMatch[2] || '',
      port:       urlHostMatch[3] || ''
   };
}

function httpTransport(){
   return new XMLHttpRequest();
}

/**
 * A wrapper around the browser XmlHttpRequest object that raises an 
 * event whenever a new part of the response is available.
 * 
 * In older browsers progressive reading is impossible so all the 
 * content is given in a single call. For newer ones several events
 * should be raised, allowing progressive interpretation of the response.
 *      
 * @param {Function} oboeBus an event bus local to this Oboe instance
 * @param {XMLHttpRequest} xhr the xhr to use as the transport. Under normal
 *          operation, will have been created using httpTransport() above
 *          but for tests a stub can be provided instead.
 * @param {String} method one of 'GET' 'POST' 'PUT' 'PATCH' 'DELETE'
 * @param {String} url the url to make a request to
 * @param {String|Null} data some content to be sent with the request.
 *                      Only valid if method is POST or PUT.
 * @param {Object} [headers] the http request headers to send
 * @param {boolean} withCredentials the XHR withCredentials property will be
 *    set to this value
 */  
function streamingHttp(oboeBus, xhr, method, url, data, headers, withCredentials) {
           
   "use strict";
   
   var emitStreamData = oboeBus(STREAM_DATA).emit,
       emitFail       = oboeBus(FAIL_EVENT).emit,
       numberOfCharsAlreadyGivenToCallback = 0,
       stillToSendStartEvent = true;

   // When an ABORTING message is put on the event bus abort 
   // the ajax request         
   oboeBus( ABORTING ).on( function(){
  
      // if we keep the onreadystatechange while aborting the XHR gives 
      // a callback like a successful call so first remove this listener
      // by assigning null:
      xhr.onreadystatechange = null;
            
      xhr.abort();
   });

   /** 
    * Handle input from the underlying xhr: either a state change,
    * the progress event or the request being complete.
    */
   function handleProgress() {
                        
      var textSoFar = xhr.responseText,
          newText = textSoFar.substr(numberOfCharsAlreadyGivenToCallback);
      
      
      /* Raise the event for new text.
      
         On older browsers, the new text is the whole response. 
         On newer/better ones, the fragment part that we got since 
         last progress. */
         
      if( newText ) {
         emitStreamData( newText );
      } 

      numberOfCharsAlreadyGivenToCallback = len(textSoFar);
   }
   
   
   if('onprogress' in xhr){  // detect browser support for progressive delivery
      xhr.onprogress = handleProgress;
   }
      
   xhr.onreadystatechange = function() {

      function sendStartIfNotAlready() {
         // Internet Explorer is very unreliable as to when xhr.status etc can
         // be read so has to be protected with try/catch and tried again on 
         // the next readyState if it fails
         try{
            stillToSendStartEvent && oboeBus( HTTP_START ).emit(
               xhr.status,
               parseResponseHeaders(xhr.getAllResponseHeaders()) );
            stillToSendStartEvent = false;
         } catch(e){/* do nothing, will try again on next readyState*/}
      }
      
      switch( xhr.readyState ) {
               
         case 2: // HEADERS_RECEIVED
         case 3: // LOADING
            return sendStartIfNotAlready();
            
         case 4: // DONE
            sendStartIfNotAlready(); // if xhr.status hasn't been available yet, it must be NOW, huh IE?
            
            // is this a 2xx http code?
            var successful = String(xhr.status)[0] == 2;
            
            if( successful ) {
               // In Chrome 29 (not 28) no onprogress is emitted when a response
               // is complete before the onload. We need to always do handleInput
               // in case we get the load but have not had a final progress event.
               // This looks like a bug and may change in future but let's take
               // the safest approach and assume we might not have received a 
               // progress event for each part of the response
               handleProgress();
               
               oboeBus(STREAM_END).emit();
            } else {

               emitFail( errorReport(
                  xhr.status, 
                  xhr.responseText
               ));
            }
      }
   };
   
   try{
   
      xhr.open(method, url, true);
   
      for( var headerName in headers ){
         xhr.setRequestHeader(headerName, headers[headerName]);
      }
      
      if( !isCrossOrigin(window.location, parseUrlOrigin(url)) ) {
         xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      }

      xhr.withCredentials = withCredentials;
      
      xhr.send(data);
      
   } catch( e ) {
      
      // To keep a consistent interface with Node, we can't emit an event here.
      // Node's streaming http adaptor receives the error as an asynchronous
      // event rather than as an exception. If we emitted now, the Oboe user
      // has had no chance to add a .fail listener so there is no way
      // the event could be useful. For both these reasons defer the
      // firing to the next JS frame.  
      window.setTimeout(
         partialComplete(emitFail, errorReport(undefined, undefined, e))
      ,  0
      );
   }            
}

var jsonPathSyntax = (function() {
 
   var
   
   /** 
    * Export a regular expression as a simple function by exposing just 
    * the Regex#exec. This allows regex tests to be used under the same 
    * interface as differently implemented tests, or for a user of the
    * tests to not concern themselves with their implementation as regular
    * expressions.
    * 
    * This could also be expressed point-free as:
    *   Function.prototype.bind.bind(RegExp.prototype.exec),
    *   
    * But that's far too confusing! (and not even smaller once minified 
    * and gzipped)
    */
       regexDescriptor = function regexDescriptor(regex) {
            return regex.exec.bind(regex);
       }
       
   /**
    * Join several regular expressions and express as a function.
    * This allows the token patterns to reuse component regular expressions
    * instead of being expressed in full using huge and confusing regular
    * expressions.
    */       
   ,   jsonPathClause = varArgs(function( componentRegexes ) {

            // The regular expressions all start with ^ because we 
            // only want to find matches at the start of the 
            // JSONPath fragment we are inspecting           
            componentRegexes.unshift(/^/);
            
            return   regexDescriptor(
                        RegExp(
                           componentRegexes.map(attr('source')).join('')
                        )
                     );
       })
       
   ,   possiblyCapturing =           /(\$?)/
   ,   namedNode =                   /([\w-_]+|\*)/
   ,   namePlaceholder =             /()/
   ,   nodeInArrayNotation =         /\["([^"]+)"\]/
   ,   numberedNodeInArrayNotation = /\[(\d+|\*)\]/
   ,   fieldList =                      /{([\w ]*?)}/
   ,   optionalFieldList =           /(?:{([\w ]*?)})?/
    

       //   foo or *                  
   ,   jsonPathNamedNodeInObjectNotation   = jsonPathClause( 
                                                possiblyCapturing, 
                                                namedNode, 
                                                optionalFieldList
                                             )
                                             
       //   ["foo"]   
   ,   jsonPathNamedNodeInArrayNotation    = jsonPathClause( 
                                                possiblyCapturing, 
                                                nodeInArrayNotation, 
                                                optionalFieldList
                                             )  

       //   [2] or [*]       
   ,   jsonPathNumberedNodeInArrayNotation = jsonPathClause( 
                                                possiblyCapturing, 
                                                numberedNodeInArrayNotation, 
                                                optionalFieldList
                                             )

       //   {a b c}      
   ,   jsonPathPureDuckTyping              = jsonPathClause( 
                                                possiblyCapturing, 
                                                namePlaceholder, 
                                                fieldList
                                             )
   
       //   ..
   ,   jsonPathDoubleDot                   = jsonPathClause(/\.\./)                  
   
       //   .
   ,   jsonPathDot                         = jsonPathClause(/\./)                    
   
       //   !
   ,   jsonPathBang                        = jsonPathClause(
                                                possiblyCapturing, 
                                                /!/
                                             )  
   
       //   nada!
   ,   emptyString                         = jsonPathClause(/$/)                     
   
   ;
   
  
   /* We export only a single function. When called, this function injects 
      into another function the descriptors from above.             
    */
   return function (fn){      
      return fn(      
         lazyUnion(
            jsonPathNamedNodeInObjectNotation
         ,  jsonPathNamedNodeInArrayNotation
         ,  jsonPathNumberedNodeInArrayNotation
         ,  jsonPathPureDuckTyping 
         )
      ,  jsonPathDoubleDot
      ,  jsonPathDot
      ,  jsonPathBang
      ,  emptyString 
      );
   }; 

}());
/**
 * Get a new key->node mapping
 * 
 * @param {String|Number} key
 * @param {Object|Array|String|Number|null} node a value found in the json
 */
function namedNode(key, node) {
   return {key:key, node:node};
}

/** get the key of a namedNode */
var keyOf = attr('key');

/** get the node from a namedNode */
var nodeOf = attr('node');
/** 
 * This file provides various listeners which can be used to build up
 * a changing ascent based on the callbacks provided by Clarinet. It listens
 * to the low-level events from Clarinet and emits higher-level ones.
 *  
 * The building up is stateless so to track a JSON file
 * ascentManager.js is required to store the ascent state
 * between calls.
 */



/** 
 * A special value to use in the path list to represent the path 'to' a root 
 * object (which doesn't really have any path). This prevents the need for 
 * special-casing detection of the root object and allows it to be treated 
 * like any other object. We might think of this as being similar to the 
 * 'unnamed root' domain ".", eg if I go to 
 * http://en.wikipedia.org./wiki/En/Main_page the dot after 'org' deliminates 
 * the unnamed root of the DNS.
 * 
 * This is kept as an object to take advantage that in Javascript's OO objects 
 * are guaranteed to be distinct, therefore no other object can possibly clash 
 * with this one. Strings, numbers etc provide no such guarantee. 
 **/
var ROOT_PATH = {};


/**
 * Create a new set of handlers for clarinet's events, bound to the emit 
 * function given.  
 */ 
function incrementalContentBuilder( oboeBus ) {

   var emitNodeOpened = oboeBus(NODE_OPENED).emit,
       emitNodeClosed = oboeBus(NODE_CLOSED).emit,
       emitRootOpened = oboeBus(ROOT_PATH_FOUND).emit,
       emitRootClosed = oboeBus(ROOT_NODE_FOUND).emit;

   function arrayIndicesAreKeys( possiblyInconsistentAscent, newDeepestNode) {
   
      /* for values in arrays we aren't pre-warned of the coming paths 
         (Clarinet gives no call to onkey like it does for values in objects) 
         so if we are in an array we need to create this path ourselves. The 
         key will be len(parentNode) because array keys are always sequential 
         numbers. */

      var parentNode = nodeOf( head( possiblyInconsistentAscent));
      
      return      isOfType( Array, parentNode)
               ?
                  keyFound(  possiblyInconsistentAscent, 
                              len(parentNode), 
                              newDeepestNode
                  )
               :  
                  // nothing needed, return unchanged
                  possiblyInconsistentAscent 
               ;
   }
                 
   function nodeOpened( ascent, newDeepestNode ) {
      
      if( !ascent ) {
         // we discovered the root node,         
         emitRootOpened( newDeepestNode);
                    
         return keyFound( ascent, ROOT_PATH, newDeepestNode);         
      }

      // we discovered a non-root node
                 
      var arrayConsistentAscent  = arrayIndicesAreKeys( ascent, newDeepestNode),      
          ancestorBranches       = tail( arrayConsistentAscent),
          previouslyUnmappedName = keyOf( head( arrayConsistentAscent));
          
      appendBuiltContent( 
         ancestorBranches, 
         previouslyUnmappedName, 
         newDeepestNode 
      );
                                                                                                         
      return cons( 
               namedNode( previouslyUnmappedName, newDeepestNode ), 
               ancestorBranches
      );                                                                          
   }


   /**
    * Add a new value to the object we are building up to represent the
    * parsed JSON
    */
   function appendBuiltContent( ancestorBranches, key, node ){
     
      nodeOf( head( ancestorBranches))[key] = node;
   }

     
   /**
    * For when we find a new key in the json.
    * 
    * @param {String|Number|Object} newDeepestName the key. If we are in an 
    *    array will be a number, otherwise a string. May take the special 
    *    value ROOT_PATH if the root node has just been found
    *    
    * @param {String|Number|Object|Array|Null|undefined} [maybeNewDeepestNode] 
    *    usually this won't be known so can be undefined. Can't use null 
    *    to represent unknown because null is a valid value in JSON
    **/  
   function keyFound(ascent, newDeepestName, maybeNewDeepestNode) {

      if( ascent ) { // if not root
      
         // If we have the key but (unless adding to an array) no known value
         // yet. Put that key in the output but against no defined value:      
         appendBuiltContent( ascent, newDeepestName, maybeNewDeepestNode );
      }
   
      var ascentWithNewPath = cons( 
                                 namedNode( newDeepestName, 
                                            maybeNewDeepestNode), 
                                 ascent
                              );

      emitNodeOpened( ascentWithNewPath);
 
      return ascentWithNewPath;
   }


   /**
    * For when the current node ends.
    */
   function nodeClosed( ascent ) {

      emitNodeClosed( ascent);
       
      return tail( ascent) ||
             // If there are no nodes left in the ascent the root node
             // just closed. Emit a special event for this: 
             emitRootClosed(nodeOf(head(ascent)));
   }      

   var contentBuilderHandlers = {};
   contentBuilderHandlers[SAX_VALUE_OPEN] = nodeOpened;
   contentBuilderHandlers[SAX_VALUE_CLOSE] = nodeClosed;
   contentBuilderHandlers[SAX_KEY] = keyFound;
   return contentBuilderHandlers;
}

/**
 * The jsonPath evaluator compiler used for Oboe.js. 
 * 
 * One function is exposed. This function takes a String JSONPath spec and 
 * returns a function to test candidate ascents for matches.
 * 
 *  String jsonPath -> (List ascent) -> Boolean|Object
 *
 * This file is coded in a pure functional style. That is, no function has 
 * side effects, every function evaluates to the same value for the same 
 * arguments and no variables are reassigned.
 */  
// the call to jsonPathSyntax injects the token syntaxes that are needed 
// inside the compiler
var jsonPathCompiler = jsonPathSyntax(function (pathNodeSyntax, 
                                                doubleDotSyntax, 
                                                dotSyntax,
                                                bangSyntax,
                                                emptySyntax ) {

   var CAPTURING_INDEX = 1;
   var NAME_INDEX = 2;
   var FIELD_LIST_INDEX = 3;

   var headKey  = compose2(keyOf, head),
       headNode = compose2(nodeOf, head);
                   
   /**
    * Create an evaluator function for a named path node, expressed in the
    * JSONPath like:
    *    foo
    *    ["bar"]
    *    [2]   
    */
   function nameClause(previousExpr, detection ) {
     
      var name = detection[NAME_INDEX],
            
          matchesName = ( !name || name == '*' ) 
                           ?  always
                           :  function(ascent){return headKey(ascent) == name};
     

      return lazyIntersection(matchesName, previousExpr);
   }

   /**
    * Create an evaluator function for a a duck-typed node, expressed like:
    * 
    *    {spin, taste, colour}
    *    .particle{spin, taste, colour}
    *    *{spin, taste, colour}
    */
   function duckTypeClause(previousExpr, detection) {

      var fieldListStr = detection[FIELD_LIST_INDEX];

      if (!fieldListStr) 
         return previousExpr; // don't wrap at all, return given expr as-is      

      var hasAllrequiredFields = partialComplete(
                                    hasAllProperties, 
                                    arrayAsList(fieldListStr.split(/\W+/))
                                 ),
                                 
          isMatch =  compose2( 
                        hasAllrequiredFields, 
                        headNode
                     );

      return lazyIntersection(isMatch, previousExpr);
   }

   /**
    * Expression for $, returns the evaluator function
    */
   function capture( previousExpr, detection ) {

      // extract meaning from the detection      
      var capturing = !!detection[CAPTURING_INDEX];

      if (!capturing)          
         return previousExpr; // don't wrap at all, return given expr as-is      
      
      return lazyIntersection(previousExpr, head);
            
   }            
      
   /**
    * Create an evaluator function that moves onto the next item on the 
    * lists. This function is the place where the logic to move up a 
    * level in the ascent exists. 
    * 
    * Eg, for JSONPath ".foo" we need skip1(nameClause(always, [,'foo']))
    */
   function skip1(previousExpr) {
   
   
      if( previousExpr == always ) {
         /* If there is no previous expression this consume command 
            is at the start of the jsonPath.
            Since JSONPath specifies what we'd like to find but not 
            necessarily everything leading down to it, when running
            out of JSONPath to check against we default to true */
         return always;
      }

      /** return true if the ascent we have contains only the JSON root,
       *  false otherwise
       */
      function notAtRoot(ascent){
         return headKey(ascent) != ROOT_PATH;
      }
      
      return lazyIntersection(
               /* If we're already at the root but there are more 
                  expressions to satisfy, can't consume any more. No match.

                  This check is why none of the other exprs have to be able 
                  to handle empty lists; skip1 is the only evaluator that 
                  moves onto the next token and it refuses to do so once it 
                  reaches the last item in the list. */
               notAtRoot,
               
               /* We are not at the root of the ascent yet.
                  Move to the next level of the ascent by handing only 
                  the tail to the previous expression */ 
               compose2(previousExpr, tail) 
      );
                                                                                                               
   }   
   
   /**
    * Create an evaluator function for the .. (double dot) token. Consumes
    * zero or more levels of the ascent, the fewest that are required to find
    * a match when given to previousExpr.
    */   
   function skipMany(previousExpr) {

      if( previousExpr == always ) {
         /* If there is no previous expression this consume command 
            is at the start of the jsonPath.
            Since JSONPath specifies what we'd like to find but not 
            necessarily everything leading down to it, when running
            out of JSONPath to check against we default to true */            
         return always;
      }
          
      var 
          // In JSONPath .. is equivalent to !.. so if .. reaches the root
          // the match has succeeded. Ie, we might write ..foo or !..foo
          // and both should match identically.
          terminalCaseWhenArrivingAtRoot = rootExpr(),
          terminalCaseWhenPreviousExpressionIsSatisfied = previousExpr,
          recursiveCase = skip1(function(ascent) {
             return cases(ascent);
          }),

          cases = lazyUnion(
                     terminalCaseWhenArrivingAtRoot
                  ,  terminalCaseWhenPreviousExpressionIsSatisfied
                  ,  recursiveCase  
                  );
      
      return cases;
   }      
   
   /**
    * Generate an evaluator for ! - matches only the root element of the json
    * and ignores any previous expressions since nothing may precede !. 
    */   
   function rootExpr() {
      
      return function(ascent){
         return headKey(ascent) == ROOT_PATH;
      };
   }   
         
   /**
    * Generate a statement wrapper to sit around the outermost 
    * clause evaluator.
    * 
    * Handles the case where the capturing is implicit because the JSONPath
    * did not contain a '$' by returning the last node.
    */   
   function statementExpr(lastClause) {
      
      return function(ascent) {
   
         // kick off the evaluation by passing through to the last clause
         var exprMatch = lastClause(ascent);
                                                     
         return exprMatch === true ? head(ascent) : exprMatch;
      };
   }      
                          
   /**
    * For when a token has been found in the JSONPath input.
    * Compiles the parser for that token and returns in combination with the
    * parser already generated.
    * 
    * @param {Function} exprs  a list of the clause evaluator generators for
    *                          the token that was found
    * @param {Function} parserGeneratedSoFar the parser already found
    * @param {Array} detection the match given by the regex engine when 
    *                          the feature was found
    */
   function expressionsReader( exprs, parserGeneratedSoFar, detection ) {
                     
      // if exprs is zero-length foldR will pass back the 
      // parserGeneratedSoFar as-is so we don't need to treat 
      // this as a special case
      
      return   foldR( 
                  function( parserGeneratedSoFar, expr ){
         
                     return expr(parserGeneratedSoFar, detection);
                  }, 
                  parserGeneratedSoFar, 
                  exprs
               );                     

   }

   /** 
    *  If jsonPath matches the given detector function, creates a function which
    *  evaluates against every clause in the clauseEvaluatorGenerators. The
    *  created function is propagated to the onSuccess function, along with
    *  the remaining unparsed JSONPath substring.
    *  
    *  The intended use is to create a clauseMatcher by filling in
    *  the first two arguments, thus providing a function that knows
    *  some syntax to match and what kind of generator to create if it
    *  finds it. The parameter list once completed is:
    *  
    *    (jsonPath, parserGeneratedSoFar, onSuccess)
    *  
    *  onSuccess may be compileJsonPathToFunction, to recursively continue 
    *  parsing after finding a match or returnFoundParser to stop here.
    */
   function generateClauseReaderIfTokenFound (
     
                        tokenDetector, clauseEvaluatorGenerators,
                         
                        jsonPath, parserGeneratedSoFar, onSuccess) {
                        
      var detected = tokenDetector(jsonPath);

      if(detected) {
         var compiledParser = expressionsReader(
                                 clauseEvaluatorGenerators, 
                                 parserGeneratedSoFar, 
                                 detected
                              ),
         
             remainingUnparsedJsonPath = jsonPath.substr(len(detected[0]));                
                               
         return onSuccess(remainingUnparsedJsonPath, compiledParser);
      }         
   }
                 
   /**
    * Partially completes generateClauseReaderIfTokenFound above. 
    */
   function clauseMatcher(tokenDetector, exprs) {
        
      return   partialComplete( 
                  generateClauseReaderIfTokenFound, 
                  tokenDetector, 
                  exprs 
               );
   }

   /**
    * clauseForJsonPath is a function which attempts to match against 
    * several clause matchers in order until one matches. If non match the
    * jsonPath expression is invalid and an error is thrown.
    * 
    * The parameter list is the same as a single clauseMatcher:
    * 
    *    (jsonPath, parserGeneratedSoFar, onSuccess)
    */     
   var clauseForJsonPath = lazyUnion(

      clauseMatcher(pathNodeSyntax   , list( capture, 
                                             duckTypeClause, 
                                             nameClause, 
                                             skip1 ))
                                                     
   ,  clauseMatcher(doubleDotSyntax  , list( skipMany))
       
       // dot is a separator only (like whitespace in other languages) but 
       // rather than make it a special case, use an empty list of 
       // expressions when this token is found
   ,  clauseMatcher(dotSyntax        , list() )  
                                                                                      
   ,  clauseMatcher(bangSyntax       , list( capture,
                                             rootExpr))
                                                          
   ,  clauseMatcher(emptySyntax      , list( statementExpr))
   
   ,  function (jsonPath) {
         throw Error('"' + jsonPath + '" could not be tokenised')      
      }
   );


   /**
    * One of two possible values for the onSuccess argument of 
    * generateClauseReaderIfTokenFound.
    * 
    * When this function is used, generateClauseReaderIfTokenFound simply 
    * returns the compiledParser that it made, regardless of if there is 
    * any remaining jsonPath to be compiled.
    */
   function returnFoundParser(_remainingJsonPath, compiledParser){ 
      return compiledParser 
   }     
              
   /**
    * Recursively compile a JSONPath expression.
    * 
    * This function serves as one of two possible values for the onSuccess 
    * argument of generateClauseReaderIfTokenFound, meaning continue to
    * recursively compile. Otherwise, returnFoundParser is given and
    * compilation terminates.
    */
   function compileJsonPathToFunction( uncompiledJsonPath, 
                                       parserGeneratedSoFar ) {

      /**
       * On finding a match, if there is remaining text to be compiled
       * we want to either continue parsing using a recursive call to 
       * compileJsonPathToFunction. Otherwise, we want to stop and return 
       * the parser that we have found so far.
       */
      var onFind =      uncompiledJsonPath
                     ?  compileJsonPathToFunction 
                     :  returnFoundParser;
                   
      return   clauseForJsonPath( 
                  uncompiledJsonPath, 
                  parserGeneratedSoFar, 
                  onFind
               );                              
   }

   /**
    * This is the function that we expose to the rest of the library.
    */
   return function(jsonPath){
        
      try {
         // Kick off the recursive parsing of the jsonPath 
         return compileJsonPathToFunction(jsonPath, always);
         
      } catch( e ) {
         throw Error( 'Could not compile "' + jsonPath + 
                      '" because ' + e.message
         );
      }
   }

});

/**
 * A pub/sub which is responsible for a single event type. A
 * multi-event type event bus is created by pubSub by collecting
 * several of these.
 *
 * @param {String} eventType
 *    the name of the events managed by this singleEventPubSub
 * @param {singleEventPubSub} [newListener]
 *    place to notify of new listeners
 * @param {singleEventPubSub} [removeListener]
 *    place to notify of when listeners are removed
 */
function singleEventPubSub(eventType, newListener, removeListener){

  /** we are optimised for emitting events over firing them.
   *  As well as the tuple list which stores event ids and
   *  listeners there is a list with just the listeners which
   *  can be iterated more quickly when we are emitting
   */
  var listenerTupleList,
      listenerList;

  function hasId(id){
    return function(tuple) {
      return tuple.id == id;
    };
  }

  return {

    /**
     * @param {Function} listener
     * @param {*} listenerId
     *    an id that this listener can later by removed by.
     *    Can be of any type, to be compared to other ids using ==
     */
    on:function( listener, listenerId ) {

      var tuple = {
        listener: listener
        ,  id:       listenerId || listener // when no id is given use the
        // listener function as the id
      };

      if( newListener ) {
        newListener.emit(eventType, listener, tuple.id);
      }

      listenerTupleList = cons( tuple,    listenerTupleList );
      listenerList      = cons( listener, listenerList      );

      return this; // chaining
    },

    emit:function () {
      applyEach( listenerList, arguments );
    },

    un: function( listenerId ) {

      var removed;

      listenerTupleList = without(
        listenerTupleList,
        hasId(listenerId),
        function(tuple){
          removed = tuple;
        }
      );

      if( removed ) {
        listenerList = without( listenerList, function(listener){
          return listener == removed.listener;
        });

        if( removeListener ) {
          removeListener.emit(eventType, removed.listener, removed.id);
        }
      }
    },

    listeners: function(){
      // differs from Node EventEmitter: returns list, not array
      return listenerList;
    },

    hasListener: function(listenerId){
      var test = listenerId? hasId(listenerId) : always;

      return defined(first( test, listenerTupleList));
    }
  };
}

/**
 * pubSub is a curried interface for listening to and emitting
 * events.
 *
 * If we get a bus:
 *
 *    var bus = pubSub();
 *
 * We can listen to event 'foo' like:
 *
 *    bus('foo').on(myCallback)
 *
 * And emit event foo like:
 *
 *    bus('foo').emit()
 *
 * or, with a parameter:
 *
 *    bus('foo').emit('bar')
 *
 * All functions can be cached and don't need to be
 * bound. Ie:
 *
 *    var fooEmitter = bus('foo').emit
 *    fooEmitter('bar');  // emit an event
 *    fooEmitter('baz');  // emit another
 *
 * There's also an uncurried[1] shortcut for .emit and .on:
 *
 *    bus.on('foo', callback)
 *    bus.emit('foo', 'bar')
 *
 * [1]: http://zvon.org/other/haskell/Outputprelude/uncurry_f.html
 */
function pubSub(){

   var singles = {},
       newListener = newSingle('newListener'),
       removeListener = newSingle('removeListener');

   function newSingle(eventName) {
      return singles[eventName] = singleEventPubSub(
         eventName,
         newListener,
         removeListener
      );
   }

   /** pubSub instances are functions */
   function pubSubInstance( eventName ){

      return singles[eventName] || newSingle( eventName );
   }

   // add convenience EventEmitter-style uncurried form of 'emit' and 'on'
   ['emit', 'on', 'un'].forEach(function(methodName){

      pubSubInstance[methodName] = varArgs(function(eventName, parameters){
         apply( parameters, pubSubInstance( eventName )[methodName]);
      });
   });

   return pubSubInstance;
}

/**
 * This file declares some constants to use as names for event types.
 */

var // the events which are never exported are kept as 
    // the smallest possible representation, in numbers:
    _S = 1,

    // fired whenever a new node starts in the JSON stream:
    NODE_OPENED     = _S++,

    // fired whenever a node closes in the JSON stream:
    NODE_CLOSED     = _S++,

    // called if a .node callback returns a value - 
    NODE_SWAP       = _S++,
    NODE_DROP       = _S++,

    FAIL_EVENT      = 'fail',
   
    ROOT_NODE_FOUND = _S++,
    ROOT_PATH_FOUND = _S++,
   
    HTTP_START      = 'start',
    STREAM_DATA     = 'data',
    STREAM_END      = 'end',
    ABORTING        = _S++,

    // SAX events butchered from Clarinet
    SAX_KEY          = _S++,
    SAX_VALUE_OPEN   = _S++,
    SAX_VALUE_CLOSE  = _S++;
    
function errorReport(statusCode, body, error) {
   try{
      var jsonBody = JSON.parse(body);
   }catch(e){}

   return {
      statusCode:statusCode,
      body:body,
      jsonBody:jsonBody,
      thrown:error
   };
}    

/** 
 *  The pattern adaptor listens for newListener and removeListener
 *  events. When patterns are added or removed it compiles the JSONPath
 *  and wires them up.
 *  
 *  When nodes and paths are found it emits the fully-qualified match 
 *  events with parameters ready to ship to the outside world
 */

function patternAdapter(oboeBus, jsonPathCompiler) {

   var predicateEventMap = {
      node:oboeBus(NODE_CLOSED)
   ,  path:oboeBus(NODE_OPENED)
   };
     
   function emitMatchingNode(emitMatch, node, ascent) {
         
      /* 
         We're now calling to the outside world where Lisp-style 
         lists will not be familiar. Convert to standard arrays. 
   
         Also, reverse the order because it is more common to 
         list paths "root to leaf" than "leaf to root"  */
      var descent     = reverseList(ascent);
                
      emitMatch(
         node,
         
         // To make a path, strip off the last item which is the special
         // ROOT_PATH token for the 'path' to the root node          
         listAsArray(tail(map(keyOf,descent))),  // path
         listAsArray(map(nodeOf, descent))       // ancestors    
      );         
   }

   /* 
    * Set up the catching of events such as NODE_CLOSED and NODE_OPENED and, if 
    * matching the specified pattern, propagate to pattern-match events such as 
    * oboeBus('node:!')
    * 
    * 
    * 
    * @param {Function} predicateEvent 
    *          either oboeBus(NODE_CLOSED) or oboeBus(NODE_OPENED).
    * @param {Function} compiledJsonPath          
    */
   function addUnderlyingListener( fullEventName, predicateEvent, compiledJsonPath ){
   
      var emitMatch = oboeBus(fullEventName).emit;
   
      predicateEvent.on( function (ascent) {

         var maybeMatchingMapping = compiledJsonPath(ascent);

         /* Possible values for maybeMatchingMapping are now:

          false: 
          we did not match 

          an object/array/string/number/null: 
          we matched and have the node that matched.
          Because nulls are valid json values this can be null.

          undefined:
          we matched but don't have the matching node yet.
          ie, we know there is an upcoming node that matches but we 
          can't say anything else about it. 
          */
         if (maybeMatchingMapping !== false) {

            emitMatchingNode(
               emitMatch, 
               nodeOf(maybeMatchingMapping), 
               ascent
            );
         }
      }, fullEventName);
     
      oboeBus('removeListener').on( function(removedEventName){

         // if the fully qualified match event listener is later removed, clean up 
         // by removing the underlying listener if it was the last using that pattern:
      
         if( removedEventName == fullEventName ) {
         
            if( !oboeBus(removedEventName).listeners(  )) {
               predicateEvent.un( fullEventName );
            }
         }
      });   
   }

   oboeBus('newListener').on( function(fullEventName){

      var match = /(node|path):(.*)/.exec(fullEventName);
      
      if( match ) {
         var predicateEvent = predicateEventMap[match[1]];
                    
         if( !predicateEvent.hasListener( fullEventName) ) {  
                  
            addUnderlyingListener(
               fullEventName,
               predicateEvent, 
               jsonPathCompiler( match[2] )
            );
         }
      }    
   })

}

/**
 * The instance API is the thing that is returned when oboe() is called.
 * it allows:
 *
 *    - listeners for various events to be added and removed
 *    - the http response header/headers to be read
 */
function instanceApi(oboeBus, contentSource){

  var oboeApi,
      fullyQualifiedNamePattern = /^(node|path):./,
      rootNodeFinishedEvent = oboeBus(ROOT_NODE_FOUND),
      emitNodeDrop = oboeBus(NODE_DROP).emit,
      emitNodeSwap = oboeBus(NODE_SWAP).emit,

      /**
       * Add any kind of listener that the instance api exposes
       */
      addListener = varArgs(function( eventId, parameters ){

        if( oboeApi[eventId] ) {

          // for events added as .on(event, callback), if there is a
          // .event() equivalent with special behaviour , pass through
          // to that:
          apply(parameters, oboeApi[eventId]);
        } else {

          // we have a standard Node.js EventEmitter 2-argument call.
          // The first parameter is the listener.
          var event = oboeBus(eventId),
              listener = parameters[0];

          if( fullyQualifiedNamePattern.test(eventId) ) {

            // allow fully-qualified node/path listeners
            // to be added
            addForgettableCallback(event, listener);
          } else  {

            // the event has no special handling, pass through
            // directly onto the event bus:
            event.on( listener);
          }
        }

        return oboeApi; // chaining
      }),

      /**
       * Remove any kind of listener that the instance api exposes
       */
      removeListener = function( eventId, p2, p3 ){

        if( eventId == 'done' ) {

          rootNodeFinishedEvent.un(p2);

        } else if( eventId == 'node' || eventId == 'path' ) {

          // allow removal of node and path
          oboeBus.un(eventId + ':' + p2, p3);
        } else {

          // we have a standard Node.js EventEmitter 2-argument call.
          // The second parameter is the listener. This may be a call
          // to remove a fully-qualified node/path listener but requires
          // no special handling
          var listener = p2;

          oboeBus(eventId).un(listener);
        }

        return oboeApi; // chaining
      };

  /**
   * Add a callback, wrapped in a try/catch so as to not break the
   * execution of Oboe if an exception is thrown (fail events are
   * fired instead)
   *
   * The callback is used as the listener id so that it can later be
   * removed using .un(callback)
   */
  function addProtectedCallback(eventName, callback) {
    oboeBus(eventName).on(protectedCallback(callback), callback);
    return oboeApi; // chaining
  }

  /**
   * Add a callback where, if .forget() is called during the callback's
   * execution, the callback will be de-registered
   */
  function addForgettableCallback(event, callback, listenerId) {

    // listenerId is optional and if not given, the original
    // callback will be used
    listenerId = listenerId || callback;

    var safeCallback = protectedCallback(callback);

    event.on( function() {

      var discard = false;

      oboeApi.forget = function(){
        discard = true;
      };

      apply( arguments, safeCallback );

      delete oboeApi.forget;

      if( discard ) {
        event.un(listenerId);
      }
    }, listenerId);

    return oboeApi; // chaining
  }

  /**
   *  wrap a callback so that if it throws, Oboe.js doesn't crash but instead
   *  throw the error in another event loop
   */
  function protectedCallback( callback ) {
    return function() {
      try{
        return callback.apply(oboeApi, arguments);
      }catch(e)  {
        setTimeout(function() {
          throw new Error(e.message);
        });
      }
    }
  }

  /**
   * Return the fully qualified event for when a pattern matches
   * either a node or a path
   *
   * @param type {String} either 'node' or 'path'
   */
  function fullyQualifiedPatternMatchEvent(type, pattern) {
    return oboeBus(type + ':' + pattern);
  }

  function wrapCallbackToSwapNodeIfSomethingReturned( callback ) {
    return function() {
      var returnValueFromCallback = callback.apply(this, arguments);

      if( defined(returnValueFromCallback) ) {

        if( returnValueFromCallback == oboe.drop ) {
          emitNodeDrop();
        } else {
          emitNodeSwap(returnValueFromCallback);
        }
      }
    }
  }

  function addSingleNodeOrPathListener(eventId, pattern, callback) {

    var effectiveCallback;

    if( eventId == 'node' ) {
      effectiveCallback = wrapCallbackToSwapNodeIfSomethingReturned(callback);
    } else {
      effectiveCallback = callback;
    }

    addForgettableCallback(
      fullyQualifiedPatternMatchEvent(eventId, pattern),
      effectiveCallback,
      callback
    );
  }

  /**
   * Add several listeners at a time, from a map
   */
  function addMultipleNodeOrPathListeners(eventId, listenerMap) {

    for( var pattern in listenerMap ) {
      addSingleNodeOrPathListener(eventId, pattern, listenerMap[pattern]);
    }
  }

  /**
   * implementation behind .onPath() and .onNode()
   */
  function addNodeOrPathListenerApi( eventId, jsonPathOrListenerMap, callback ){

    if( isString(jsonPathOrListenerMap) ) {
      addSingleNodeOrPathListener(eventId, jsonPathOrListenerMap, callback);

    } else {
      addMultipleNodeOrPathListeners(eventId, jsonPathOrListenerMap);
    }

    return oboeApi; // chaining
  }


  // some interface methods are only filled in after we receive
  // values and are noops before that:
  oboeBus(ROOT_PATH_FOUND).on( function(rootNode) {
    oboeApi.root = functor(rootNode);
  });

  /**
   * When content starts make the headers readable through the
   * instance API
   */
  oboeBus(HTTP_START).on( function(_statusCode, headers) {

    oboeApi.header =  function(name) {
      return name ? headers[name]
        : headers
      ;
    }
  });

  /**
   * Construct and return the public API of the Oboe instance to be
   * returned to the calling application
   */
  return oboeApi = {
    on             : addListener,
    addListener    : addListener,
    removeListener : removeListener,
    emit           : oboeBus.emit,

    node           : partialComplete(addNodeOrPathListenerApi, 'node'),
    path           : partialComplete(addNodeOrPathListenerApi, 'path'),

    done           : partialComplete(addForgettableCallback, rootNodeFinishedEvent),
    start          : partialComplete(addProtectedCallback, HTTP_START ),

    // fail doesn't use protectedCallback because
    // could lead to non-terminating loops
    fail           : oboeBus(FAIL_EVENT).on,

    // public api calling abort fires the ABORTING event
    abort          : oboeBus(ABORTING).emit,

    // for manually feeding data
    write          : oboeBus(STREAM_DATA).emit,
    finish         : oboeBus(STREAM_END).emit,

    // initially return nothing for header and root
    header         : noop,
    root           : noop,

    source         : contentSource
  };
}

/**
 * This file sits just behind the API which is used to attain a new
 * Oboe instance. It creates the new components that are required
 * and introduces them to each other.
 */

function wire (httpMethodName, contentSource, body, headers, withCredentials){

   var oboeBus = pubSub();
   
   // Wire the input stream in if we are given a content source.
   // This will usually be the case. If not, the instance created
   // will have to be passed content from an external source.
  
   if( contentSource ) {

      streamingHttp( oboeBus,
                     httpTransport(), 
                     httpMethodName,
                     contentSource,
                     body,
                     headers,
                     withCredentials
      );
   }

   clarinet(oboeBus);

   ascentManager(oboeBus, incrementalContentBuilder(oboeBus));
      
   patternAdapter(oboeBus, jsonPathCompiler);      
      
   return instanceApi(oboeBus, contentSource);
}

function applyDefaults( passthrough, url, httpMethodName, body, headers, withCredentials, cached ){

   headers = headers ?
      // Shallow-clone the headers array. This allows it to be
      // modified without side effects to the caller. We don't
      // want to change objects that the user passes in.
      JSON.parse(JSON.stringify(headers))
      : {};

   if( body ) {
      if( !isString(body) ) {

         // If the body is not a string, stringify it. This allows objects to
         // be given which will be sent as JSON.
         body = JSON.stringify(body);

         // Default Content-Type to JSON unless given otherwise.
         headers['Content-Type'] = headers['Content-Type'] || 'application/json';
      }
   } else {
      body = null;
   }

   // support cache busting like jQuery.ajax({cache:false})
   function modifiedUrl(baseUrl, cached) {

      if( cached === false ) {

         if( baseUrl.indexOf('?') == -1 ) {
            baseUrl += '?';
         } else {
            baseUrl += '&';
         }

         baseUrl += '_=' + new Date().getTime();
      }
      return baseUrl;
   }

   return passthrough( httpMethodName || 'GET', modifiedUrl(url, cached), body, headers, withCredentials || false );
}

// export public API
function oboe(arg1) {

   // We use duck-typing to detect if the parameter given is a stream, with the
   // below list of parameters.
   // Unpipe and unshift would normally be present on a stream but this breaks
   // compatibility with Request streams.
   // See https://github.com/jimhigson/oboe.js/issues/65
   
   var nodeStreamMethodNames = list('resume', 'pause', 'pipe'),
       isStream = partialComplete(
                     hasAllProperties
                  ,  nodeStreamMethodNames
                  );
   
   if( arg1 ) {
      if (isStream(arg1) || isString(arg1)) {

         //  simple version for GETs. Signature is:
         //    oboe( url )
         //  or, under node:
         //    oboe( readableStream )
         return applyDefaults(
            wire,
            arg1 // url
         );

      } else {

         // method signature is:
         //    oboe({method:m, url:u, body:b, headers:{...}})

         return applyDefaults(
            wire,
            arg1.url,
            arg1.method,
            arg1.body,
            arg1.headers,
            arg1.withCredentials,
            arg1.cached
         );
         
      }
   } else {
      // wire up a no-AJAX, no-stream Oboe. Will have to have content 
      // fed in externally and using .emit.
      return wire();
   }
}

/* oboe.drop is a special value. If a node callback returns this value the
   parsed node is deleted from the JSON
 */
oboe.drop = function() {
   return oboe.drop;
};


   if ( typeof define === "function" && define.amd ) {
      define( "oboe", [], function () { return oboe; } );
   } else if (typeof exports === 'object') {
      module.exports = oboe;
   } else {
      window.oboe = oboe;
   }
})((function(){
   // Access to the window object throws an exception in HTML5 web workers so
   // point it to "self" if it runs in a web worker
      try {
         return window;
      } catch (e) {
         return self;
      }
   }()), Object, Array, Error, JSON);


'use strict';
if (tr.isVinn) {
  global.oboe = global.window.oboe;
  global.window = undefined;
} else if (tr.isNode) {
  // Use the node.js version instead.
  global.window = undefined;
  const path = HTMLImportsLoader.hrefToAbsolutePath('/oboe/dist/oboe-node.js');
  global.oboe = require(path);
}


'use strict';

tr.exportTo('tr.e.importer', function() {
  const STRING_ID_SUFFIX = '_sid';
  const PLURAL_STRING_ID_SUFFIX = '_sids';

  function isStringReference(s) {
    return s.endsWith(STRING_ID_SUFFIX) || s.endsWith(PLURAL_STRING_ID_SUFFIX);
  }

  function getStringReferenceName(name) {
    if (name.endsWith(PLURAL_STRING_ID_SUFFIX)) {
      return name.slice(0, -PLURAL_STRING_ID_SUFFIX.length);
    }
    return name.slice(0, -STRING_ID_SUFFIX.length);
  }

  function deferenceStrings(idToString, o) {
    const clone = Object.assign({}, o);
    for (const [key, value] of Object.entries(clone)) {
      if (isStringReference(key)) {
        const name = getStringReferenceName(key);
        clone[name] = idToString(value);
      }
    }
    return clone;
  }

  function singularize(word) {
    if (word.endsWith('s')) {
      return word.slice(0, -1);
    }
    return word;
  }

  function getMetadataPairs(dataJson) {
    const isMetadata = v => typeof v !== 'object' || Array.isArray(v);
    const pairs = Object.entries(dataJson);
    const metadataPairs = pairs.filter(([_, v]) => isMetadata(v));
    return metadataPairs;
  }

  function getGroupPairs(dataJson) {
    const pairs = Object.entries(dataJson);
    const nonMapPairs = pairs.filter(([k, _]) => k !== 'maps');
    const groupPairs = nonMapPairs.filter(([_, v]) => typeof v === 'object');
    return groupPairs;
  }

  function createMap(mapJson) {
    const map = new Map();
    for (const entry of mapJson) {
      if (entry.id === undefined) {
        throw new Error('Missing required key "id" in streaming event.');
      }
      map.set(entry.id, entry);
    }
    return map;
  }

  function createMaps(mapsJson) {
    const maps = new Map();
    for (const [name, mapJson] of Object.entries(mapsJson)) {
      maps.set(name, createMap(mapJson));
    }
    return maps;
  }

  function createGroup(groupJson, opt_startTime) {
    const entries = [];
    const n = Object.values(groupJson)[0].length;

    for (let i = 0; i < n; i++) {
      const entry = {};
      for (const name in groupJson) {
        entry[name] = groupJson[name][i];
      }
      entries.push(entry);
    }

    const timeDelta = groupJson.timeDelta;
    if (opt_startTime === undefined && timeDelta !== undefined) {
      throw new Error('Missing required key "startTime" in streaming event.');
    }

    if (opt_startTime) {
      let delta = 0;
      for (const entry of entries) {
        delta += entry.timeDelta ? entry.timeDelta : 0;
        entry.time = opt_startTime + delta;
      }
    }

    return entries;
  }

  function createGroups(groupsJson, opt_startTime) {
    const groups = new Map();
    for (const [name, groupJson] of Object.entries(groupsJson)) {
      groups.set(name, createGroup(groupJson, opt_startTime));
    }

    return groups;
  }

  function createMetadata(metadataPairs) {
    const metadata = new Map();
    for (const [name, value] of metadataPairs) {
      metadata.set(name, value);
    }
    if (metadata.get('version') === undefined) {
      throw new Error('Missing required key "version" in streaming event.');
    }
    return metadata;
  }

  /**
   * Extracts data from a profiling dictionary. See goo.gl/R0Ae4f.
   *
   * A profiling dictionary is a compressed format that is good for recording
   * sampling data. ProfilingDictionaryReader unpacks that data. To use the
   * ProfilingDictionaryReader first create an 'empty' reader using .empty()
   * then call #expandData(data) on your dictionary or the helper:
   * #expandEvent(event) on a tracing event containing the profiling dictionary.
   * ProfilingDictionaryReader is an immutable data structure so these methods
   * don't modify the ProfilingDictionaryReader instead they return new
   * ProfilingDictionaryReaders which wrap the data you passed. To access the
   * unpacked data use the #inflated property and the #getMapValue() method.
   *
   * Usage example, given input like:
   * $ let input = {
   *   version: 1,
   *   allocators: {
   *     books: {
   *       authors: [1, 1, 2],
   *       title_sid: [10, 11, 12],
   *     },
   *   },
   *   maps: {
   *     authors: [
   *       { id: 1, name_sid: 1 },
   *       { id: 2, name_sid: 2 },
   *     ],
   *     strings: [
   *       { id: 1, string: 'DFW' },
   *       { id: 2, string: 'C. Stross' },
   *       { id: 10, string: 'Book A' },
   *       { id: 11, string: 'Book B' },
   *       { id: 12, string: 'Book C' },
   *     ],
   *   }
   * };
   * We can create an empty reader:
   * $ let reader = ProfilingDictionaryReader.empty();
   * Then read in the input:
   * $ reader = reader.expandData(input);
   * Then view the expanded data:
   * $ console.log(reader.inflated);
   * {
   *   books: [
   *     { author: { id: 1, name: 'DFW' }, title: "Book A", },
   *     { author: { id: 2, name: 'C. Stross' }, title: "Book B", },
   *     { author: { id: 2, name: 'C. Stross' }, title: "Book C", },
   *   ],
   * }
   *
   */
  class ProfilingDictionaryReader {
    constructor(opt_metadata, opt_maps, opt_groups, opt_parent) {
      this.metadata = opt_metadata || new Map();
      this.maps = opt_maps || new Map();
      this.groups = opt_groups || new Map();
      this.parent_ = opt_parent || undefined;
      this.inflated_ = undefined;
      this.raw_ = undefined;
      this.boundGetString_ = this.getString.bind(this);
      this.deferenceStrings_ = o => deferenceStrings(this.boundGetString_, o);
    }

    /**
     * Creates an empty ProfilingDictionaryReader.
     */
    static empty() {
      return new ProfilingDictionaryReader();
    }

    /**
     * Returns the parent or null if this is the root ProfilingDictionaryReader.
     */
    get parent() {
      return this.parent_;
    }

    get raw() {
      if (this.raw_) return this.raw_;
      this.raw_ = {};
      for (const [name, group] of this.groups.entries()) {
        this.raw_[name] = group;
      }
      return this.raw_;
    }

    get inflated() {
      if (this.inflated_) return this.inflated_;
      this.inflated_ = {};
      for (const [name, group] of this.groups.entries()) {
        this.inflated_[name] = this.inflateGroup(group);
      }
      return this.inflated_;
    }

    /**
     * Get a map from the newest event by name.
     * If no map with that name was present returns an empty Map.
     */
    getNewMap(name) {
      return this.maps.get(name) || new Map();
    }

    /**
     * Get a record with the id |id| from the map with name |mapName|.
     * This method searches through the expanded events in reverse order of
     * expansion until it finds a matching value. If no value matches returns
     * undefined.
     */
    getMapValue(mapName, id) {
      let value = this.getNewMap(mapName).get(id);
      if (value === undefined && this.parent) {
        value = this.parent.getMapValue(mapName, id);
      }
      return value;
    }

    /**
     * Get the string with the id |id|.
     * This method searches through the expanded events in reverse order of
     * expansion until it finds a string with the matching id. If there is no
     * matching string with returns undefined.
     */
    getString(id) {
      const value = this.getMapValue('strings', id);
      if (value === undefined) return undefined;
      return value.string;
    }

    /**
     * True iff this or any parent has a map with name |name|.
     */
    hasMap(name) {
      if (this.maps.has(name)) return true;
      if (this.parent === undefined) return false;
      return this.parent.hasMap(name);
    }

    inflateGroup(group) {
      return group.map(this.inflateEntry.bind(this));
    }

    inflateEntry(entry) {
      const inflatedEntry = {};
      for (const [name, value] of Object.entries(entry)) {
        let inflatedValue;
        if (this.hasMap(name)) {
          const id = value;
          inflatedValue = this.deferenceStrings_(this.getMapValue(name, id));
        } else {
          inflatedValue = value;
        }
        inflatedEntry[singularize(name)] = inflatedValue;
      }
      return this.deferenceStrings_(inflatedEntry);
    }

    /**
     * Returns a new ProfilingDictionaryReader with this
     * ProfilingDictionaryReader as its parent and the fields 'maps', 'groups'
     * and 'metadata' filled in based on |data|.
     */
    expandData(data) {
      const mapsJson = data.maps || {};
      const groupsJson = data.allocators || {};
      const metadataPairs = getMetadataPairs(data);
      const metadata = createMetadata(metadataPairs);
      const opt_startTime = metadata.get('startTime');
      const maps = createMaps(mapsJson);
      const groups = createGroups(groupsJson, opt_startTime);
      return new ProfilingDictionaryReader(metadata, maps, groups, this);
    }

    /**
     * Convenience method for this.expandData(event.args.data).
     */
    expandEvent(event) {
      return this.expandData(event.args.data);
    }
  }

  return {
    ProfilingDictionaryReader,
    singularize,
    deferenceStringsForTest: deferenceStrings,
  };
});


'use strict';

tr.exportTo('tr.model.source_info', function() {
  function SourceInfo(file, opt_line, opt_column) {
    this.file_ = file;
    this.line_ = opt_line || -1;
    this.column_ = opt_column || -1;
  }

  SourceInfo.prototype = {
    get file() {
      return this.file_;
    },

    get line() {
      return this.line_;
    },

    get column() {
      return this.column_;
    },

    get domain() {
      if (!this.file_) return undefined;
      const domain = this.file_.match(/(.*:\/\/[^:\/]*)/i);
      return domain ? domain[1] : undefined;
    },

    toString() {
      let str = '';

      if (this.file_) {
        str += this.file_;
      }
      if (this.line_ > 0) {
        str += ':' + this.line_;
      }
      if (this.column_ > 0) {
        str += ':' + this.column_;
      }
      return str;
    }
  };

  return {
    SourceInfo,
  };
});


'use strict';

tr.exportTo('tr.model.source_info', function() {
  function JSSourceInfo(file, line, column, isNative, scriptId, state) {
    tr.model.source_info.SourceInfo.call(this, file, line, column);

    this.isNative_ = isNative;
    this.scriptId_ = scriptId;
    this.state_ = state;
  }

  JSSourceInfo.prototype = {
    __proto__: tr.model.source_info.SourceInfo.prototype,

    get state() {
      return this.state_;
    },

    get isNative() {
      return this.isNative_;
    },

    get scriptId() {
      return this.scriptId_;
    },

    toString() {
      const str = this.isNative_ ? '[native v8] ' : '';
      return str +
          tr.model.source_info.SourceInfo.prototype.toString.call(this);
    }
  };

  const JSSourceState = {
    COMPILED: 'compiled',
    OPTIMIZABLE: 'optimizable',
    OPTIMIZED: 'optimized',
    UNKNOWN: 'unknown',
  };

  return {
    JSSourceInfo,
    JSSourceState,
  };
});


'use strict';

/**
 * @fileoverview TraceCodeEntry is a wrapper around the V8 CodeEntry that
 * extracts extra context information for each item. This includes things like
 * the source file, line and if the function is a native method or not.
 */
tr.exportTo('tr.e.importer', function() {
  function TraceCodeEntry(address, size, name, scriptId) {
    this.id_ = tr.b.GUID.allocateSimple();
    this.address_ = address;
    this.size_ = size;

    // Stolen from DevTools TimelineJSProfileProcessor._buildCallFrame
    // Code states:
    // (empty) -> compiled
    //    ~    -> optimizable
    //    *    -> optimized
    const rePrefix = /^(\w*:)?([*~]?)(.*)$/m;
    const tokens = rePrefix.exec(name);
    const prefix = tokens[1];
    let state = tokens[2];
    const body = tokens[3];

    if (state === '*') {
      state = tr.model.source_info.JSSourceState.OPTIMIZED;
    } else if (state === '~') {
      state = tr.model.source_info.JSSourceState.OPTIMIZABLE;
    } else if (state === '') {
      state = tr.model.source_info.JSSourceState.COMPILED;
    } else {
      state = tr.model.source_info.JSSourceState.UNKNOWN;
    }

    let rawName;
    let rawUrl;
    if (prefix === 'Script:') {
      rawName = '';
      rawUrl = body;
    } else {
      const spacePos = body.lastIndexOf(' ');
      rawName = spacePos !== -1 ? body.substr(0, spacePos) : body;
      rawUrl = spacePos !== -1 ? body.substr(spacePos + 1) : '';
    }

    function splitLineAndColumn(url) {
      const lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
      const lineColumnMatch = lineColumnRegEx.exec(url);
      let lineNumber;
      let columnNumber;

      if (typeof(lineColumnMatch[1]) === 'string') {
        lineNumber = parseInt(lineColumnMatch[1], 10);
        // Immediately convert line and column to 0-based numbers.
        lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
      }
      if (typeof(lineColumnMatch[2]) === 'string') {
        columnNumber = parseInt(lineColumnMatch[2], 10);
        columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
      }

      return {
        url: url.substring(0, url.length - lineColumnMatch[0].length),
        lineNumber,
        columnNumber
      };
    }

    const nativeSuffix = ' native';
    const isNative = rawName.endsWith(nativeSuffix);
    this.name_ =
        isNative ? rawName.slice(0, -nativeSuffix.length) : rawName;

    const urlData = splitLineAndColumn(rawUrl);
    const url = urlData.url || '';
    const line = urlData.lineNumber || 0;
    const column = urlData.columnNumber || 0;

    this.sourceInfo_ = new tr.model.source_info.JSSourceInfo(
        url, line, column, isNative, scriptId, state);
  }

  TraceCodeEntry.prototype = {
    get id() {
      return this.id_;
    },

    get sourceInfo() {
      return this.sourceInfo_;
    },

    get name() {
      return this.name_;
    },

    set address(address) {
      this.address_ = address;
    },

    get address() {
      return this.address_;
    },

    set size(size) {
      this.size_ = size;
    },

    get size() {
      return this.size_;
    }
  };

  return {
    TraceCodeEntry,
  };
});


'use strict';

tr.exportTo('tr.e.importer', function() {
  // This code is a tracification of:
  // devtools/front_end/timeline/TimelineJSProfile.js
  function TraceCodeMap() {
    this.banks_ = new Map();
  }

  TraceCodeMap.prototype = {
    addEntry(addressHex, size, name, scriptId) {
      const entry = new tr.e.importer.TraceCodeEntry(
          this.getAddress_(addressHex), size, name, scriptId);

      this.addEntry_(addressHex, entry);
    },

    moveEntry(oldAddressHex, newAddressHex, size) {
      const entry = this.getBank_(oldAddressHex)
          .removeEntry(this.getAddress_(oldAddressHex));
      if (!entry) return;

      entry.address = this.getAddress_(newAddressHex);
      entry.size = size;
      this.addEntry_(newAddressHex, entry);
    },

    lookupEntry(addressHex) {
      return this.getBank_(addressHex)
          .lookupEntry(this.getAddress_(addressHex));
    },

    addEntry_(addressHex, entry) {
      // FIXME: Handle bank spanning addresses ...
      this.getBank_(addressHex).addEntry(entry);
    },

    getAddress_(addressHex) {
      // 13 hex digits === 52 bits, double mantissa fits 53 bits.
      const bankSizeHexDigits = 13;
      addressHex = addressHex.slice(2);  // cut 0x prefix.
      return parseInt(addressHex.slice(-bankSizeHexDigits), 16);
    },

    getBank_(addressHex) {
      addressHex = addressHex.slice(2);  // cut 0x prefix.

      // 13 hex digits === 52 bits, double mantissa fits 53 bits.
      const bankSizeHexDigits = 13;
      const maxHexDigits = 16;
      const bankName = addressHex.slice(-maxHexDigits, -bankSizeHexDigits);
      let bank = this.banks_.get(bankName);
      if (!bank) {
        bank = new TraceCodeBank();
        this.banks_.set(bankName, bank);
      }
      return bank;
    }
  };

  function TraceCodeBank() {
    this.entries_ = [];
  }

  TraceCodeBank.prototype = {
    removeEntry(address) {
      // findLowIndexInSortedArray returns 1 for empty. Just handle the
      // empty list and bail early.
      if (this.entries_.length === 0) return undefined;

      const index = tr.b.findLowIndexInSortedArray(
          this.entries_, function(entry) { return entry.address; }, address);
      const entry = this.entries_[index];
      if (!entry || entry.address !== address) return undefined;

      this.entries_.splice(index, 1);
      return entry;
    },

    lookupEntry(address) {
      const index = tr.b.findHighIndexInSortedArray(
          this.entries_, function(e) { return address - e.address; }) - 1;
      const entry = this.entries_[index];
      return entry &&
          address < entry.address + entry.size ? entry : undefined;
    },

    addEntry(newEntry) {
      // findLowIndexInSortedArray returns 1 for empty list. Just push the
      // new address as it's the only item.
      if (this.entries_.length === 0) {
        this.entries_.push(newEntry);
      }

      const endAddress = newEntry.address + newEntry.size;
      const lastIndex = tr.b.findLowIndexInSortedArray(
          this.entries_, function(entry) { return entry.address; }, endAddress);
      let index;
      for (index = lastIndex - 1; index >= 0; --index) {
        const entry = this.entries_[index];
        const entryEndAddress = entry.address + entry.size;
        if (entryEndAddress <= newEntry.address) break;
      }
      ++index;
      this.entries_.splice(index, lastIndex - index, newEntry);
    }
  };

  return {
    TraceCodeMap,
  };
});



'use strict';

tr.exportTo('tr.importer', function() {
  /**
   * The context processor consumes context events and maintains a set of
   * active contexts for a single thread.
   *
   * @constructor
   */
  function ContextProcessor(model) {
    this.model_ = model;
    this.activeContexts_ = [];
    this.stackPerType_ = {};
    // Cache of unique context objects.
    this.contextCache_ = {};
    // Cache of unique context object sets.
    this.contextSetCache_ = {};
    this.cachedEntryForActiveContexts_ = undefined;
    // All seen context object snapshots.
    this.seenSnapshots_ = {};
  }

  ContextProcessor.prototype = {
    enterContext(contextType, scopedId) {
      const newActiveContexts = [
        this.getOrCreateContext_(contextType, scopedId),
      ];
      for (const oldContext of this.activeContexts_) {
        if (oldContext.type === contextType) {
          // If a previous context of the same type is active, it is removed
          // and pushed onto the stack for this type.
          this.pushContext_(oldContext);
        } else {
          // Otherwise the old context is it is still active.
          newActiveContexts.push(oldContext);
        }
      }
      this.activeContexts_ = newActiveContexts;
      this.cachedEntryForActiveContexts_ = undefined;
    },

    leaveContext(contextType, scopedId) {
      this.leaveContextImpl_(context =>
          context.type === contextType &&
          context.snapshot.scope === scopedId.scope &&
          context.snapshot.idRef === scopedId.id);
    },

    destroyContext(scopedId) {
      // Remove all matching contexts from stacks.
      for (const stack of Object.values(this.stackPerType_)) {
        // Perform in-place filtering instead of Array.prototype.filter to
        // prevent creating a new array.
        let newLength = 0;
        for (let i = 0; i < stack.length; ++i) {
          if (stack[i].snapshot.scope !== scopedId.scope ||
              stack[i].snapshot.idRef !== scopedId.id) {
            stack[newLength++] = stack[i];
          }
        }
        stack.length = newLength;
      }

      // Remove all matching contexts from active context set.
      this.leaveContextImpl_(context =>
          context.snapshot.scope === scopedId.scope &&
          context.snapshot.idRef === scopedId.id);
    },

    leaveContextImpl_(predicate) {
      const newActiveContexts = [];
      for (const oldContext of this.activeContexts_) {
        if (predicate(oldContext)) {
          // If we left this context, remove it from the active set and
          // restore any previous context of the same type.
          const previousContext = this.popContext_(oldContext.type);
          if (previousContext) {
            newActiveContexts.push(previousContext);
          }
        } else {
          newActiveContexts.push(oldContext);
        }
      }
      this.activeContexts_ = newActiveContexts;
      this.cachedEntryForActiveContexts_ = undefined;
    },

    getOrCreateContext_(contextType, scopedId) {
      const context = {
        type: contextType,
        snapshot: {
          scope: scopedId.scope,
          idRef: scopedId.id
        }
      };
      const key = this.getContextKey_(context);
      if (key in this.contextCache_) {
        return this.contextCache_[key];
      }
      this.contextCache_[key] = context;
      const snapshotKey = this.getSnapshotKey_(scopedId);
      this.seenSnapshots_[snapshotKey] = true;
      return context;
    },

    pushContext_(context) {
      if (!(context.type in this.stackPerType_)) {
        this.stackPerType_[context.type] = [];
      }
      this.stackPerType_[context.type].push(context);
    },

    popContext_(contextType) {
      if (!(contextType in this.stackPerType_)) {
        return undefined;
      }
      return this.stackPerType_[contextType].pop();
    },

    getContextKey_(context) {
      return [
        context.type,
        context.snapshot.scope,
        context.snapshot.idRef
      ].join('\x00');
    },

    getSnapshotKey_(scopedId) {
      return [
        scopedId.scope,
        scopedId.idRef
      ].join('\x00');
    },

    get activeContexts() {
      // Keep a single instance for each unique set of active contexts to
      // reduce memory usage.
      if (this.cachedEntryForActiveContexts_ === undefined) {
        let key = [];
        for (const context of this.activeContexts_) {
          key.push(this.getContextKey_(context));
        }
        key.sort();
        key = key.join('\x00');
        if (key in this.contextSetCache_) {
          this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
        } else {
          this.activeContexts_.sort(function(a, b) {
            const keyA = this.getContextKey_(a);
            const keyB = this.getContextKey_(b);
            if (keyA < keyB) {
              return -1;
            }
            if (keyA > keyB) {
              return 1;
            }
            return 0;
          }.bind(this));
          this.contextSetCache_[key] = Object.freeze(this.activeContexts_);
          this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
        }
      }
      return this.cachedEntryForActiveContexts_;
    },

    invalidateContextCacheForSnapshot(scopedId) {
      const snapshotKey = this.getSnapshotKey_(scopedId);
      if (!(snapshotKey in this.seenSnapshots_)) return;

      this.contextCache_ = {};
      this.contextSetCache_ = {};
      this.cachedEntryForActiveContexts_ = undefined;
      this.activeContexts_ = this.activeContexts_.map(function(context) {
        // Do not alter unrelated contexts.
        if (context.snapshot.scope !== scopedId.scope ||
            context.snapshot.idRef !== scopedId.id) {
          return context;
        }
        // Replace the invalidated context by a deep copy.
        return {
          type: context.type,
          snapshot: {
            scope: context.snapshot.scope,
            idRef: context.snapshot.idRef
          }
        };
      });
      this.seenSnapshots_ = {};
    },
  };

  return {
    ContextProcessor,
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view responsible for drawing a single highlight rectangle box on
   * the timeline.
   * @extends {AnnotationView}
   * @constructor
   */
  function RectAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  RectAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw(ctx) {
      const dt = this.viewport_.currentDisplayTransform;
      const startCoords =
          this.annotation_.startLocation.toViewCoordinates(this.viewport_);
      const endCoords =
          this.annotation_.endLocation.toViewCoordinates(this.viewport_);

      // Prevent drawing into the ruler track by clamping the initial Y
      // point and the rect's Y size.
      let startY = startCoords.viewY - ctx.canvas.getBoundingClientRect().top;
      const sizeY = endCoords.viewY - startCoords.viewY;
      if (startY + sizeY < 0) {
        // In this case sizeY is negative. If final Y is negative,
        // overwrite startY so that the rectangle ends at y=0.
        startY = sizeY;
      } else if (startY < 0) {
        startY = 0;
      }

      ctx.fillStyle = this.annotation_.fillStyle;
      ctx.fillRect(startCoords.viewX, startY,
          endCoords.viewX - startCoords.viewX, sizeY);
    }
  };

  return {
    RectAnnotationView,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function RectAnnotation(start, end) {
    tr.model.Annotation.apply(this, arguments);

    this.startLocation_ = start; // Location of top-left corner.
    this.endLocation_ = end; // Location of bottom-right corner.
    this.fillStyle = 'rgba(255, 180, 0, 0.3)';
  }

  RectAnnotation.fromDict = function(dict) {
    const args = dict.args;
    const startLoc =
        new tr.model.Location(args.start.xWorld, args.start.yComponents);
    const endLoc =
        new tr.model.Location(args.end.xWorld, args.end.yComponents);
    return new tr.model.RectAnnotation(startLoc, endLoc);
  };

  RectAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    get startLocation() {
      return this.startLocation_;
    },

    get endLocation() {
      return this.endLocation_;
    },

    toDict() {
      return {
        typeName: 'rect',
        args: {
          start: this.startLocation.toDict(),
          end: this.endLocation.toDict()
        }
      };
    },

    createView_(viewport) {
      return new tr.ui.annotations.RectAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(RectAnnotation, {typeName: 'rect'});

  return {
    RectAnnotation,
  };
});


'use strict';

tr.exportTo('tr.ui.annotations', function() {
  /**
   * A view of a comment box consisting of a textarea and a line to the
   * actual location.
   * @extends {AnnotationView}
   * @constructor
   */
  function CommentBoxAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
    this.textArea_ = undefined;

    this.styleWidth = 250;
    this.styleHeight = 50;
    this.fontSize = 10;
    this.rightOffset = 50;
    this.topOffset = 25;
  }

  CommentBoxAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    removeTextArea() {
      Polymer.dom(Polymer.dom(this.textArea_).parentNode).removeChild(
          this.textArea_);
    },

    draw(ctx) {
      const coords = this.annotation_.location.toViewCoordinates(
          this.viewport_);
      if (coords.viewX < 0) {
        if (this.textArea_) {
          this.textArea_.style.visibility = 'hidden';
        }
        return;
      }

      // Set up textarea element.
      if (!this.textArea_) {
        this.textArea_ = document.createElement('textarea');
        this.textArea_.style.position = 'absolute';
        this.textArea_.readOnly = true;
        this.textArea_.value = this.annotation_.text;
        // Set the z-index so that this is shown on top of canvas.
        this.textArea_.style.zIndex = 1;
        Polymer.dom(Polymer.dom(ctx.canvas).parentNode)
            .appendChild(this.textArea_);
      }

      this.textArea_.style.width = this.styleWidth + 'px';
      this.textArea_.style.height = this.styleHeight + 'px';
      this.textArea_.style.fontSize = this.fontSize + 'px';
      this.textArea_.style.visibility = 'visible';

      // Update positions to latest coordinate.
      this.textArea_.style.left =
          coords.viewX + ctx.canvas.getBoundingClientRect().left +
          this.rightOffset + 'px';
      this.textArea_.style.top =
          coords.viewY - ctx.canvas.getBoundingClientRect().top -
          this.topOffset + 'px';

      // Draw pointer line from offset to actual location.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      tr.ui.b.drawLine(ctx, coords.viewX,
          coords.viewY - ctx.canvas.getBoundingClientRect().top,
          coords.viewX + this.rightOffset,
          coords.viewY - this.topOffset -
            ctx.canvas.getBoundingClientRect().top);
      ctx.stroke();
    }
  };

  return {
    CommentBoxAnnotationView,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function CommentBoxAnnotation(location, text) {
    tr.model.Annotation.apply(this, arguments);

    this.location = location;
    this.text = text;
  }

  CommentBoxAnnotation.fromDict = function(dict) {
    const args = dict.args;
    const location =
        new tr.model.Location(args.location.xWorld, args.location.yComponents);
    return new tr.model.CommentBoxAnnotation(location, args.text);
  };

  CommentBoxAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    onRemove() {
      this.view_.removeTextArea();
    },

    toDict() {
      return {
        typeName: 'comment_box',
        args: {
          text: this.text,
          location: this.location.toDict()
        }
      };
    },

    createView_(viewport) {
      return new tr.ui.annotations.CommentBoxAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(
      CommentBoxAnnotation, {typeName: 'comment_box'});

  return {
    CommentBoxAnnotation,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function ScopedId(scope, id, pid) {
    if (scope === undefined) {
      throw new Error('Scope should be defined. Use \'' +
                      tr.model.OBJECT_DEFAULT_SCOPE +
                      '\' as the default scope.');
    }
    this.scope = scope;
    this.id = id;
    this.pid = pid;
  }

  ScopedId.prototype = {
    toString() {
      const pidStr = this.pid === undefined ? '' : 'pid: ' + this.pid + ', ';
      return '{' + pidStr + 'scope: ' + this.scope + ', id: ' + this.id + '}';
    },

    toStringWithDelimiter(delim) {
      return (this.pid === undefined ? '' : this.pid) + delim +
          this.scope + delim + this.id;
    }
  };

  return {
    ScopedId,
  };
});


'use strict';

/**
 * @fileoverview TraceEventImporter imports TraceEvent-formatted data
 * into the provided model.
 */
tr.exportTo('tr.e.importer', function() {
  const Base64 = tr.b.Base64;
  const deepCopy = tr.b.deepCopy;
  const ColorScheme = tr.b.ColorScheme;
  const HeapDumpTraceEventImporter = tr.e.importer.HeapDumpTraceEventImporter;
  const LegacyHeapDumpTraceEventImporter =
      tr.e.importer.LegacyHeapDumpTraceEventImporter;
  const StreamingEventExpander = tr.e.importer.StreamingEventExpander;
  const ProfilingDictionaryReader = tr.e.importer.ProfilingDictionaryReader;

  function getEventColor(event, opt_customName) {
    if (event.cname) {
      return ColorScheme.getColorIdForReservedName(event.cname);
    } else if (opt_customName || event.name) {
      return ColorScheme.getColorIdForGeneralPurposeString(
          opt_customName || event.name);
    }
  }

  function isLegacyChromeClockSyncEvent(event) {
    return event.name !== undefined &&
        event.name.startsWith(LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX) &&
        ((event.ph === 'S') || (event.ph === 'F'));
  }

  const PRODUCER = 'producer';
  const CONSUMER = 'consumer';
  const STEP = 'step';

  const BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
  const LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
  const DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;
  const MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER = [undefined, BACKGROUND, LIGHT,
    DETAILED];

  const GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX = 'global/';

  const LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX = 'ClockSyncEvent.';

  // Map from raw memory dump byte stat names to model byte stat names. See
  // //base/trace_event/process_memory_maps.cc in Chromium.
  const BYTE_STAT_NAME_MAP = {
    'pc': 'privateCleanResident',
    'pd': 'privateDirtyResident',
    'sc': 'sharedCleanResident',
    'sd': 'sharedDirtyResident',
    'pss': 'proportionalResident',
    'sw': 'swapped'
  };

  // See tr.model.MemoryAllocatorDump 'weak' field and
  // base::trace_event::MemoryAllocatorDump::Flags::WEAK in the Chromium
  // codebase.
  const WEAK_MEMORY_ALLOCATOR_DUMP_FLAG = 1 << 0;

  // Object type name patterns for various compilers.
  const OBJECT_TYPE_NAME_PATTERNS = [
    {
      // Clang.
      prefix: 'const char *WTF::getStringWithTypeName() [T = ',
      suffix: ']'
    },
    {
      // GCC.
      prefix: 'const char* WTF::getStringWithTypeName() [with T = ',
      suffix: ']'
    },
    {
      // Microsoft Visual C++
      prefix: 'const char *__cdecl WTF::getStringWithTypeName<',
      suffix: '>(void)'
    }
  ];

  // The list of fields on the trace that are known to contain subtraces.
  const SUBTRACE_FIELDS = new Set([
    'powerTraceAsString',
    'systemTraceEvents',
  ]);

  // The complete list of fields on the trace that should not be treated as
  // trace metadata.
  const NON_METADATA_FIELDS = new Set([
    'displayTimeUnit',
    'samples',
    'stackFrames',
    'traceAnnotations',
    'traceEvents',
    ...SUBTRACE_FIELDS
  ]);

  function TraceEventImporter(model, eventData) {
    this.hasEvents_ = undefined;  // Set properly when importEvents is called.
    this.importPriority = 1;
    this.model_ = model;
    this.events_ = undefined;
    this.sampleEvents_ = undefined;
    this.stackFrameEvents_ = undefined;
    this.stackFrameTree_ = new tr.model.ProfileTree();
    this.subtraces_ = [];
    this.eventsWereFromString_ = false;
    this.softwareMeasuredCpuCount_ = undefined;


    this.allAsyncEvents_ = [];
    this.allFlowEvents_ = [];
    this.allObjectEvents_ = [];

    this.contextProcessorPerThread = {};

    this.traceEventSampleStackFramesByName_ = {};

    this.v8ProcessCodeMaps_ = {};
    this.v8ProcessRootStackFrame_ = {};
    this.v8SamplingData_ = [];

    // Profile Tree Map.
    // Type of Profile Tree -> Map(ID -> Profile Tree)
    this.profileTrees_ = new Map();
    // ID -> Info Object
    this.profileInfo_ = new Map();

    // For tracking async events that is used to create back-compat clock sync
    // event.
    this.legacyChromeClockSyncStartEvent_ = undefined;
    this.legacyChromeClockSyncFinishEvent_ = undefined;

    // Dump ID -> PID -> [process memory dump events].
    this.allMemoryDumpEvents_ = {};

    // Unpacks size, count, stackId and heapId from 'P' events. Also remembers
    // stack frame and type information.
    this.heapProfileExpander = new ProfilingDictionaryReader();

    // PID -> Object type ID -> Object type name.
    this.objectTypeNameMap_ = {};

    // For old Chrome traces with no clock domain metadata, just use a
    // placeholder clock domain.
    this.clockDomainId_ = tr.model.ClockDomainId.UNKNOWN_CHROME_LEGACY;
    // A function able to transform timestamps in |clockDomainId| to timestamps
    // in the model clock domain.
    this.toModelTime_ = undefined;

    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = eventData.trim();
      // If the event data begins with a [, then we know it should end with a ].
      // The reason we check for this is because some tracing implementations
      // cannot guarantee that a ']' gets written to the trace file. So, we are
      // forgiving and if this is obviously the case, we fix it up before
      // throwing the string at JSON.parse.
      if (eventData[0] === '[') {
        eventData = eventData.replace(/\s*,\s*$/, '');
        if (eventData[eventData.length - 1] !== ']') {
          eventData = eventData + ']';
        }
      }

      this.events_ = JSON.parse(eventData);
      this.eventsWereFromString_ = true;
    } else {
      this.events_ = eventData;
    }

    // Some trace_event implementations put the actual trace events
    // inside a container. E.g { ... , traceEvents: [ ] }
    // If we see that, just pull out the trace events.
    if (this.events_.traceEvents) {
      const container = this.events_;
      this.events_ = this.events_.traceEvents;

      for (const subtraceField of SUBTRACE_FIELDS) {
        if (container[subtraceField]) {
          this.storeSubtrace_(container[subtraceField]);
        }
      }
      this.storeSamples_(container.samples);
      this.storeStackFrames_(container.stackFrames);
      this.storeDisplayTimeUnit_(container.displayTimeUnit);
      this.storeTraceAnnotations_(container.traceAnnotations);
      this.storeMetadata_(container);
    } else if (this.events_ instanceof tr.b.TraceStream) {
      const parser = oboe()
          .node('{cat ph}', function(e) { return oboe.drop; })
          .node('!.powerTraceAsString', this.storeSubtrace_.bind(this))
          .node('!.systemTraceEvents', this.storeSubtrace_.bind(this))
          .node('!.samples', this.storeSamples_.bind(this))
          .node('!.stackFrames', this.storeStackFrames_.bind(this))
          .node('!.displayTimeUnit', this.storeDisplayTimeUnit_.bind(this))
          .node('!.traceAnnotations', this.storeTraceAnnotations_.bind(this))
          .done(this.storeMetadata_.bind(this));
      this.events_.rewind();
      while (this.events_.hasData) {
        parser.write(this.events_.readNumBytes());
      }
      parser.finish();
    }
  }

  /**
   * @return {boolean} Whether obj is a TraceEvent array.
   */
  TraceEventImporter.canImport = function(eventData) {
    // May be encoded JSON. But we dont want to parse it fully yet.
    // Use a simple heuristic:
    //   - eventData that starts with [ are probably trace_event
    //   - eventData that starts with { are probably trace_event
    // May be encoded JSON. Treat files that start with { as importable by us.
    if (eventData instanceof tr.b.TraceStream) {
      if (eventData.isBinary) return false;
      eventData = eventData.header;
    }

    if (typeof(eventData) === 'string' || eventData instanceof String) {
      eventData = eventData.trim();
      return eventData[0] === '{' || eventData[0] === '[';
    }

    // Might just be an array of events
    if (eventData instanceof Array && eventData.length && eventData[0].ph) {
      return true;
    }

    // Might be an object with a traceEvents field in it.
    if (eventData.traceEvents) {
      if (eventData.traceEvents instanceof Array) {
        if (eventData.traceEvents.length && eventData.traceEvents[0].ph) {
          return true;
        }
        if (eventData.samples && eventData.samples.length &&
            eventData.stackFrames !== undefined) {
          return true;
        }
      }
    }

    return false;
  };

  /**
   * Extracts a scoped ID from an event.
   *
   * In legacy trace files, the ID of an event is always stored in the 'id'
   * field and the event phase determines if the ID is process-local or
   * global. For example, async event IDs are considered global and object
   * event IDs are considered process-local.
   *
   * New trace files can explicitly specify whether an event ID is
   * process-local or global. These new IDs are stored in the 'id2' field so
   * that old trace importers that do not implement this logic break when they
   * try to import a new trace file. The value of id2 can be either of the
   * form '{global: 0x1000}' or of the form '{local: 0x1000}'.
   *
   * @param {!Object} event A trace event.
   * @return {!tr.model.ScopedId}
   */
  TraceEventImporter.scopedIdForEvent_ = function(event) {
    const scope = event.scope || tr.model.OBJECT_DEFAULT_SCOPE;
    let pid = undefined;
    if (event.id !== undefined) {
      if (event.id2 !== undefined) {
        throw new Error('Event has both id and id2');
      }
      pid = tr.model.LOCAL_ID_PHASES.has(event.ph) ? event.pid : undefined;
      return new tr.model.ScopedId(scope, event.id, pid);
    } else if (event.id2 !== undefined) {
      if (event.id2.global !== undefined) {
        return new tr.model.ScopedId(scope, event.id2.global);
      } else if (event.id2.local !== undefined) {
        return new tr.model.ScopedId(scope, event.id2.local, event.pid);
      }
      throw new Error(
          'Event that uses id2 must have either a global or local ID');
    }
    return undefined;
  };

  TraceEventImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'TraceEventImporter';
    },

    extractSubtraces() {
      // Because subtraces can be quite large, we need to make sure that we
      // don't hold a reference to the memory.
      const subtraces = this.subtraces_;
      this.subtraces_ = [];
      return subtraces;
    },

    /**
     * Deep copying is only needed if the trace was given to us as events.
     */
    deepCopyIfNeeded_(obj) {
      if (obj === undefined) obj = {};
      if (this.eventsWereFromString_) return obj;
      return deepCopy(obj);
    },

    /**
     * Always perform deep copying.
     */
    deepCopyAlways_(obj) {
      if (obj === undefined) obj = {};
      return deepCopy(obj);
    },

    /**
     * Helper to process an async event.
     */
    processAsyncEvent(event) {
      const thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allAsyncEvents_.push({
        sequenceNumber: this.allAsyncEvents_.length,
        event,
        thread
      });
    },

    /**
     * Helper to process a flow event.
     */
    processFlowEvent(event, opt_slice) {
      const thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allFlowEvents_.push({
        refGuid: tr.b.GUID.getLastSimpleGuid(),
        sequenceNumber: this.allFlowEvents_.length,
        event,
        slice: opt_slice,  // slice for events that have flow info
        thread
      });
    },

    /**
     * Helper that creates and adds samples to a Counter object based on
     * 'C' phase events.
     */
    processCounterEvent(event) {
      let ctrName;
      if (event.id !== undefined) {
        ctrName = event.name + '[' + event.id + ']';
      } else {
        ctrName = event.name;
      }

      const ctr = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateCounter(event.cat, ctrName);
      const reservedColorId = event.cname ? getEventColor(event) : undefined;

      // Initialize the counter's series fields if needed.
      if (ctr.numSeries === 0) {
        for (const seriesName in event.args) {
          const colorId = reservedColorId ||
              getEventColor(event, ctr.name + '.' + seriesName);
          ctr.addSeries(new tr.model.CounterSeries(seriesName, colorId));
        }

        if (ctr.numSeries === 0) {
          this.model_.importWarning({
            type: 'counter_parse_error',
            message: 'Expected counter ' + event.name +
                ' to have at least one argument to use as a value.'
          });

          // Drop the counter.
          delete ctr.parent.counters[ctr.name];
          return;
        }
      }

      const ts = this.toModelTimeFromUs_(event.ts);
      ctr.series.forEach(function(series) {
        const val = event.args[series.name] ? event.args[series.name] : 0;
        series.addCounterSample(ts, val);
      });
    },

    processObjectEvent(event) {
      const thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allObjectEvents_.push({
        sequenceNumber: this.allObjectEvents_.length,
        event,
        thread});
      if (thread.guid in this.contextProcessorPerThread) {
        const processor = this.contextProcessorPerThread[thread.guid];
        const scopedId = TraceEventImporter.scopedIdForEvent_(event);
        if (event.ph === 'D') {
          processor.destroyContext(scopedId);
        }
        // The context processor maintains a cache of unique context objects and
        // active context sets to reduce memory usage. If an object is modified,
        // we should invalidate this cache, because otherwise context sets from
        // before and after the modification may erroneously point to the same
        // context snapshot (as both are the same set/object instances).
        processor.invalidateContextCacheForSnapshot(scopedId);
      }
    },

    processContextEvent(event) {
      const thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      if (!(thread.guid in this.contextProcessorPerThread)) {
        this.contextProcessorPerThread[thread.guid] =
            new tr.importer.ContextProcessor(this.model_);
      }
      const scopedId = TraceEventImporter.scopedIdForEvent_(event);
      const contextType = event.name;
      const processor = this.contextProcessorPerThread[thread.guid];
      if (event.ph === '(') {
        processor.enterContext(contextType, scopedId);
      } else if (event.ph === ')') {
        processor.leaveContext(contextType, scopedId);
      } else {
        this.model_.importWarning({
          type: 'unknown_context_phase',
          message: 'Unknown context event phase: ' + event.ph + '.'
        });
      }
    },

    setContextsFromThread_(thread, slice) {
      if (thread.guid in this.contextProcessorPerThread) {
        slice.contexts =
            this.contextProcessorPerThread[thread.guid].activeContexts;
      }
    },

    processDurationEvent(event) {
      const thread = this.model_.getOrCreateProcess(event.pid)
        .getOrCreateThread(event.tid);
      const ts = this.toModelTimeFromUs_(event.ts);
      if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'duration_parse_error',
          message: 'Timestamps are moving backward.'
        });
        return;
      }

      if (event.ph === 'B') {
        const slice = thread.sliceGroup.beginSlice(
            event.cat, event.name, this.toModelTimeFromUs_(event.ts),
            this.deepCopyIfNeeded_(event.args),
            this.toModelTimeFromUs_(event.tts), event.argsStripped,
            getEventColor(event));
        slice.startStackFrame = this.getStackFrameForEvent_(event);
        this.setContextsFromThread_(thread, slice);
      } else if (event.ph === 'I' || event.ph === 'i' || event.ph === 'R') {
        if (event.s !== undefined && event.s !== 't') {
          throw new Error('This should never happen');
        }

        thread.sliceGroup.beginSlice(event.cat, event.name,
            this.toModelTimeFromUs_(event.ts),
            this.deepCopyIfNeeded_(event.args),
            this.toModelTimeFromUs_(event.tts),
            event.argsStripped,
            getEventColor(event));
        const slice = thread.sliceGroup.endSlice(
            this.toModelTimeFromUs_(event.ts),
            this.toModelTimeFromUs_(event.tts));
        slice.startStackFrame = this.getStackFrameForEvent_(event);
        slice.endStackFrame = undefined;
      } else {
        if (!thread.sliceGroup.openSliceCount) {
          this.model_.importWarning({
            type: 'duration_parse_error',
            message: 'E phase event without a matching B phase event.'
          });
          return;
        }

        const slice = thread.sliceGroup.endSlice(
            this.toModelTimeFromUs_(event.ts),
            this.toModelTimeFromUs_(event.tts),
            getEventColor(event));
        if (event.name && slice.title !== event.name) {
          this.model_.importWarning({
            type: 'title_match_error',
            message: 'Titles do not match. Title is ' +
                slice.title + ' in openSlice, and is ' +
                event.name + ' in endSlice'
          });
        }
        slice.endStackFrame = this.getStackFrameForEvent_(event);

        this.mergeArgsInto_(slice.args, event.args, slice.title);
      }
    },

    mergeArgsInto_(dstArgs, srcArgs, eventName) {
      for (const arg in srcArgs) {
        if (dstArgs[arg] !== undefined) {
          this.model_.importWarning({
            type: 'arg_merge_error',
            message: 'Different phases of ' + eventName +
                ' provided values for argument ' + arg + '.' +
                ' The last provided value will be used.'
          });
        }
        dstArgs[arg] = this.deepCopyIfNeeded_(srcArgs[arg]);
      }
    },

    processCompleteEvent(event) {
      // Preventing the overhead slices from making it into the model. This
      // only applies to legacy traces, as the overhead traces have been
      // removed from the chromium code.
      if (event.cat !== undefined &&
          event.cat.indexOf('trace_event_overhead') > -1) {
        return undefined;
      }

      const thread = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateThread(event.tid);

      if (event.flow_out) {
        if (event.flow_in) {
          event.flowPhase = STEP;
        } else {
          event.flowPhase = PRODUCER;
        }
      } else if (event.flow_in) {
        event.flowPhase = CONSUMER;
      }

      const slice = thread.sliceGroup.pushCompleteSlice(event.cat, event.name,

          this.toModelTimeFromUs_(event.ts),
          this.maybeToModelTimeFromUs_(event.dur),
          this.maybeToModelTimeFromUs_(event.tts),
          this.maybeToModelTimeFromUs_(event.tdur),
          this.deepCopyIfNeeded_(event.args),
          event.argsStripped,
          getEventColor(event),
          event.bind_id);
      slice.startStackFrame = this.getStackFrameForEvent_(event);
      slice.endStackFrame = this.getStackFrameForEvent_(event, true);
      this.setContextsFromThread_(thread, slice);

      return slice;
    },

    processJitCodeEvent(event) {
      if (this.v8ProcessCodeMaps_[event.pid] === undefined) {
        this.v8ProcessCodeMaps_[event.pid] = new tr.e.importer.TraceCodeMap();
      }
      const map = this.v8ProcessCodeMaps_[event.pid];

      const data = event.args.data;
      // TODO(dsinclair): There are _a lot_ of JitCode events so I'm skipping
      // the display for now. Can revisit later if we want to show them.
      // Handle JitCodeMoved and JitCodeAdded event.
      if (event.name === 'JitCodeMoved') {
        map.moveEntry(data.code_start, data.new_code_start, data.code_len);
      } else {  // event.name === 'JitCodeAdded'
        map.addEntry(data.code_start, data.code_len, data.name, data.script_id);
      }
    },

    processMetadataEvent(event) {
      // V8 JIT events are currently logged as phase 'M' so we need to
      // separate them out and handle specially.
      if (event.name === 'JitCodeAdded' || event.name === 'JitCodeMoved') {
        this.v8SamplingData_.push(event);
        return;
      }

      // The metadata events aren't useful without args.
      if (event.argsStripped) return;

      if (event.name === 'process_name') {
        const process = this.model_.getOrCreateProcess(event.pid);
        process.name = event.args.name;
      } else if (event.name === 'process_labels') {
        const process = this.model_.getOrCreateProcess(event.pid);
        const labels = event.args.labels.split(',');
        for (let i = 0; i < labels.length; i++) {
          process.addLabelIfNeeded(labels[i]);
        }
      } else if (event.name === 'process_uptime_seconds') {
        const process = this.model_.getOrCreateProcess(event.pid);
        process.uptime_seconds = event.args.uptime;
      } else if (event.name === 'process_sort_index') {
        const process = this.model_.getOrCreateProcess(event.pid);
        process.sortIndex = event.args.sort_index;
      } else if (event.name === 'thread_name') {
        const thread = this.model_.getOrCreateProcess(event.pid).
            getOrCreateThread(event.tid);
        thread.name = event.args.name;
      } else if (event.name === 'thread_sort_index') {
        const thread = this.model_.getOrCreateProcess(event.pid).
            getOrCreateThread(event.tid);
        thread.sortIndex = event.args.sort_index;
      } else if (event.name === 'num_cpus') {
        let n = event.args.number;
        // Not all render processes agree on the cpu count in trace_event. Some
        // processes will report 1, while others will report the actual cpu
        // count. To deal with this, take the max of what is reported.
        if (this.softwareMeasuredCpuCount_ !== undefined) {
          n = Math.max(n, this.softwareMeasuredCpuCount_);
        }
        this.softwareMeasuredCpuCount_ = n;
      } else if (event.name === 'stackFrames') {
        const stackFrames = event.args.stackFrames;
        if (stackFrames === undefined) {
          this.model_.importWarning({
            type: 'metadata_parse_error',
            message: 'No stack frames found in a \'' + event.name +
                '\' metadata event'
          });
        } else {
          this.importStackFrames_(stackFrames, 'p' + event.pid + ':');
        }
      } else if (event.name === 'typeNames') {
        const objectTypeNameMap = event.args.typeNames;
        if (objectTypeNameMap === undefined) {
          this.model_.importWarning({
            type: 'metadata_parse_error',
            message: 'No mapping from object type IDs to names found in a \'' +
                event.name + '\' metadata event'
          });
        } else {
          this.importObjectTypeNameMap_(objectTypeNameMap, event.pid);
        }
      } else if (event.name === 'TraceConfig') {
        this.model_.metadata.push(
              {name: 'TraceConfig', value: event.args.value});
      } else {
        this.model_.importWarning({
          type: 'metadata_parse_error',
          message: 'Unrecognized metadata name: ' + event.name
        });
      }
    },

    processInstantEvent(event) {
      // V8 JIT events were logged as phase 'I' in the old format,
      // so we need to separate them out and handle specially.
      if (event.name === 'JitCodeAdded' || event.name === 'JitCodeMoved') {
        this.v8SamplingData_.push(event);
        return;
      }

      // Thread-level instant events are treated as zero-duration slices.
      if (event.s === 't' || event.s === undefined) {
        this.processDurationEvent(event);
        return;
      }

      let constructor;
      switch (event.s) {
        case 'g':
          constructor = tr.model.GlobalInstantEvent;
          break;
        case 'p':
          constructor = tr.model.ProcessInstantEvent;
          break;
        default:
          this.model_.importWarning({
            type: 'instant_parse_error',
            message: 'I phase event with unknown "s" field value.'
          });
          return;
      }

      const instantEvent = new constructor(event.cat, event.name,
          getEventColor(event), this.toModelTimeFromUs_(event.ts),
          this.deepCopyIfNeeded_(event.args));

      switch (instantEvent.type) {
        case tr.model.InstantEventType.GLOBAL:
          this.model_.instantEvents.push(instantEvent);
          break;

        case tr.model.InstantEventType.PROCESS: {
          const process = this.model_.getOrCreateProcess(event.pid);
          process.instantEvents.push(instantEvent);
          break;
        }

        default:
          throw new Error('Unknown instant event type: ' + event.s);
      }
    },

    getOrCreateProfileTree_(sampleType, id) {
      if (!this.profileTrees_.has(sampleType)) {
        this.profileTrees_.set(sampleType, new Map());
      }
      const profileTreeMap = this.profileTrees_.get(sampleType);
      if (profileTreeMap.has(id)) {
        return profileTreeMap.get(id);
      }
      const profileTree = new tr.model.ProfileTree();
      profileTreeMap.set(id, profileTree);
      const info = this.profileInfo_.get(id);
      if (info !== undefined) {
        profileTree.startTime = info.startTime;
        profileTree.pid = info.pid;
        profileTree.tid = info.tid;
      }
      return profileTree;
    },

    processSample(event) {
      if (event.args === undefined || event.args.data === undefined) {
        return;
      }
      if (event.id === undefined) {
        throw new Error('No event ID in sample');
      }

      const data = event.args.data;
      // Sampling usually happens in a separate thread, but start time is issued
      // in the main thread, in order to get the correct thread object,
      // we should use pid and tid from main thread.
      if (data.startTime !== undefined) {
        this.profileInfo_.set(event.id, {
          startTime: data.startTime,
          pid: event.pid,
          tid: event.tid
        });
      }
      const timeDeltas = data.timeDeltas;
      for (const sampleType in data) {
        if (sampleType === 'timeDeltas' || sampleType === 'startTime') {
          continue;
        }
        // The length of samples array and the length of timeDeltas array
        // should be the same.
        if (data[sampleType].samples && timeDeltas &&
            data[sampleType].samples.length !== timeDeltas.length) {
          // eslint-disable-next-line
          throw new Error('samples and timeDeltas array should have same length');
        }

        const profileTree = this.getOrCreateProfileTree_(sampleType, event.id);
        const nodes = data[sampleType].nodes;
        const samples = data[sampleType].samples;
        if (nodes !== undefined) {
          for (const node of nodes) {
            // Get the sepcific ProfileNode type based on sampleType.
            const ProfileNodeType =
                tr.model.ProfileNode.subTypes.getConstructor(undefined,
                    sampleType);
            const profileNode = ProfileNodeType.constructFromObject(profileTree,
                node);
            if (profileNode === undefined) {
              continue;
            }
            profileTree.add(profileNode);
          }
        }
        // The samples array contains id pointing to the profile node.
        if (samples !== undefined) {
          const thread = this.model_.getOrCreateProcess(profileTree.pid)
              .getOrCreateThread(profileTree.tid);
          for (let i = 0, len = samples.length; i < len; ++i) {
            const node = profileTree.getNode(samples[i]);
            profileTree.endTime += timeDeltas[i];
            const start = this.toModelTimeFromUs_(profileTree.endTime);
            this.model_.samples.push(
                new tr.model.Sample(start, node.sampleTitle, node, thread));
          }
        }
      }
    },

    processLegacyV8Sample(event) {
      const data = event.args.data;
      const sampleType = 'legacySample';
      const ProfileNodeType =
          tr.model.ProfileNode.subTypes.getConstructor(undefined, sampleType);

      // As-per DevTools, the backend sometimes creates bogus samples. Skip it.
      if (data.vm_state === 'js' && !data.stack.length) return;

      const profileTree = this.getOrCreateProfileTree_(sampleType, event.pid);
      if (profileTree.getNode(-1) === undefined) {
        profileTree.add(
            new ProfileNodeType(-1, {
              url: '',
              scriptId: -1,
              functionName: 'unknown'
            }, undefined));
      }
      // There are several types of v8 sample events, gc, native, compiler, etc.
      // Some of these types have stacks and some don't, we handle those two
      // cases differently. For types that don't have any stack frames attached
      // we synthesize one based on the type of thing that's happening so when
      // we view all the samples we'll see something like 'external' or 'gc'
      // as a fraction of the time spent.
      let node = undefined;
      if (data.stack.length > 0 && this.v8ProcessCodeMaps_[event.pid]) {
        const map = this.v8ProcessCodeMaps_[event.pid];
        // Stacks have the leaf node first, flip them around so the root
        // comes first.
        data.stack.reverse();
        let parentNode = undefined;
        for (let i = 0; i < data.stack.length; i++) {
          const entry = map.lookupEntry(data.stack[i]);
          if (entry === undefined) {
            node = profileTree.getNode(-1);
          } else {
            node = profileTree.getNode(entry.id);
            if (node === undefined) {
              const sourceInfo = entry.sourceInfo;
              node = new ProfileNodeType(entry.id, {
                functionName: entry.name,
                url: entry.sourceInfo.file,
                lineNumber: sourceInfo.line !== -1 ? sourceInfo.line :
                                                     undefined,
                columnNumber: sourceInfo.column !== -1 ? sourceInfo.column :
                                                         undefined,
                scriptid: entry.sourceInfo.scriptId
              }, parentNode);
              profileTree.add(node);
            }
          }
          parentNode = node;
        }
      } else {
        node = profileTree.getNode(data.vm_state);
        if (node === undefined) {
          node = new ProfileNodeType(data.vm_state, {
            url: '',
            functionName: data.vm_state
          }, undefined);
          profileTree.add(node);
        }
      }

      const thread = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateThread(event.tid);

      this.model_.samples.push(
          new tr.model.Sample(this.toModelTimeFromUs_(event.ts),
                            node.sampleTitle, node, thread));
    },

    processTraceSampleEvent(event) {
      if (event.name === 'V8Sample' || event.name.startsWith('Profile')) {
        this.v8SamplingData_.push(event);
        return;
      }

      let node = this.stackFrameTree_.getNode(event.name);
      if (node === undefined && event.sf !== undefined) {
        node = this.stackFrameTree_.getNode('g' + event.sf);
      }

      if (node === undefined) {
        let id = event.name;
        if (event.sf) {
          id = 'g' + event.sf;
        }
        const ProfileNodeType =
            tr.model.ProfileNode.subTypes.getConstructor(undefined,
                'legacySample');
        node = this.stackFrameTree_.add(new ProfileNodeType(
          id, {
            functionName: event.name
          }, undefined
        ));
      }
      const thread = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateThread(event.tid);

      const sample = new tr.model.Sample(
        this.toModelTimeFromUs_(event.ts), 'Trace Event Sample',
        node, thread, undefined, 1,
        this.deepCopyIfNeeded_(event.args));
      this.setContextsFromThread_(thread, sample);
      this.model_.samples.push(sample);
    },

    processMemoryDumpEvent(event) {
      // TODO(chiniforooshan): Make memory dumps either use local or global IDs
      // instead of the generic IDs with different phases.
      // https://github.com/catapult-project/catapult/issues/2957
      if (event.ph !== 'v') {
        throw new Error('Invalid memory dump event phase "' + event.ph + '".');
      }

      const dumpId = event.id;
      if (dumpId === undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Memory dump event (phase \'' + event.ph +
              '\') without a dump ID.'
        });
        return;
      }

      const pid = event.pid;
      if (pid === undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Memory dump event (phase\'' + event.ph + '\', dump ID \'' +
              dumpId + '\') without a PID.'
        });
        return;
      }

      // Dump ID -> PID -> [process memory dump events].
      const allEvents = this.allMemoryDumpEvents_;

      // PID -> [process memory dump events].
      let dumpIdEvents = allEvents[dumpId];
      if (dumpIdEvents === undefined) {
        allEvents[dumpId] = dumpIdEvents = {};
      }

      // [process memory dump events].
      let processEvents = dumpIdEvents[pid];
      if (processEvents === undefined) {
        dumpIdEvents[pid] = processEvents = [];
      }

      processEvents.push(event);
    },

    processClockSyncEvent(event) {
      if (event.ph !== 'c') {
        throw new Error('Invalid clock sync event phase "' + event.ph + '".');
      }

      const syncId = event.args.sync_id;
      if (syncId === undefined) {
        this.model_.importWarning({
          type: 'clock_sync_parse_error',
          message: 'Clock sync at time ' + event.ts + ' without an ID.'
        });
        return;
      }

      if (event.args && event.args.issue_ts !== undefined) {
        // When Chrome is the tracing controller and is the requester of the
        // clock sync, the clock sync event looks like:
        //
        //   {
        //     "args": {
        //       "sync_id": "abc123",
        //       "issue_ts": 12340
        //     }
        //     "ph": "c"
        //     "ts": 12345
        //     ...
        //   }
        this.model_.clockSyncManager.addClockSyncMarker(
            this.clockDomainId_, syncId,
            tr.b.Unit.timestampFromUs(event.args.issue_ts),
            tr.b.Unit.timestampFromUs(event.ts));
      } else {
        // When Chrome is a tracing agent and is the recipient of the clock
        // sync request, the clock sync event looks like:
        //
        //   {
        //     "args": { "sync_id": "abc123" }
        //     "ph": "c"
        //     "ts": 12345
        //     ...
        //   }
        this.model_.clockSyncManager.addClockSyncMarker(
            this.clockDomainId_, syncId, tr.b.Unit.timestampFromUs(event.ts));
      }
    },

    processLegacyChromeClockSyncEvent(event) {
      // Older versions of Chrome don't support the devtools clock sync API, but
      // Telemetry can work around this by creating clock sync events via
      // console.time & console.timeEnd, which issue trace events as long as the
      // 'blink.console' category is enabled. When we encounter async events
      // with names starting with the prefix 'ClockSyncEvent.' , treat these as
      // clock sync markers.
      if (event.ph === 'S') {
        this.legacyChromeClockSyncStartEvent_ = event;
      } else if (event.ph === 'F') {
        this.legacyChromeClockSyncFinishEvent_ = event;
      }

      if (this.legacyChromeClockSyncStartEvent_ === undefined ||
          this.legacyChromeClockSyncFinishEvent_ === undefined) {
        return;
      }

      const startSyncId = this.legacyChromeClockSyncStartEvent_.name.substring(
          LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX.length);
      const finishSyncId =
        this.legacyChromeClockSyncFinishEvent_.name.substring(
            LEGACY_CHROME_CLOCK_SYNC_EVENT_NAME_PREFIX.length);

      if (startSyncId !== finishSyncId) {
        throw new Error(
            'Inconsistent clock sync ID of legacy Chrome clock sync events');
      }

      this.model_.clockSyncManager.addClockSyncMarker(
          this.clockDomainId_, startSyncId,
          tr.b.Unit.timestampFromUs(this.legacyChromeClockSyncStartEvent_.ts),
          tr.b.Unit.timestampFromUs(this.legacyChromeClockSyncFinishEvent_.ts));
    },

    // Because the order of Jit code events and V8 samples are not guaranteed,
    // We store them in an array, sort by timestamp, and then process them.
    processV8Events() {
      this.v8SamplingData_.sort(function(a, b) {
        if (a.ts !== b.ts) return a.ts - b.ts;
        if (a.ph === 'M' || a.ph === 'I') {
          return -1;
        } else if (b.ph === 'M' || b.ph === 'I') {
          return 1;
        }
        return 0;
      });
      const length = this.v8SamplingData_.length;
      for (let i = 0; i < length; ++i) {
        const event = this.v8SamplingData_[i];
        if (event.ph === 'M' || event.ph === 'I') {
          this.processJitCodeEvent(event);
        } else if (event.ph === 'P') {
          // The current sampling format and legacy sampling format
          // have the same ph, but the current sampling format will
          // start with 'Profile' in its name.
          if (event.name.startsWith('Profile')) {
            this.processSample(event);
          } else {
            this.processLegacyV8Sample(event);
          }
        }
      }
    },

    importClockSyncMarkers() {
      if (this.events_ instanceof tr.b.TraceStream) {
        const parser = oboe().node(
            '{cat ph}', this.importClockSyncMarker_.bind(this));
        this.events_.rewind();
        while (this.events_.hasData) {
          parser.write(this.events_.readNumBytes());
        }
        parser.finish();
      } else {
        for (let i = 0; i < this.events_.length; i++) {
          this.importClockSyncMarker_(this.events_[i]);
        }
      }
    },

    importClockSyncMarker_(event) {
      const isLegacyChromeClockSync = isLegacyChromeClockSyncEvent(event);
      if (event.ph !== 'c' && !isLegacyChromeClockSync) return;

      const eventSizeInBytes =
          this.model_.importOptions.trackDetailedModelStats ?
              JSON.stringify(event).length : undefined;

      this.model_.stats.willProcessBasicTraceEvent(
          'clock_sync', event.cat, event.name, event.ts, eventSizeInBytes);

      if (isLegacyChromeClockSync) {
        this.processLegacyChromeClockSyncEvent(event);
      } else {
        this.processClockSyncEvent(event);
      }
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents() {
      this.hasEvents_ = false;
      if (this.stackFrameEvents_) {
        this.importStackFrames_(this.stackFrameEvents_, 'g');
      }

      if (this.traceAnnotations_) this.importAnnotations_();

      if (this.events_ instanceof tr.b.TraceStream) {
        const parser = oboe().node('{cat ph}', this.processEvent_.bind(this));
        this.events_.rewind();
        while (this.events_.hasData) {
          parser.write(this.events_.readNumBytes());
        }
        parser.finish();
      } else {
        for (let eI = 0; eI < this.events_.length; eI++) {
          this.processEvent_(this.events_[eI]);
        }
      }

      // Import calls importEvents then autoCloseOpenSlices then finalizeImport.
      // AsyncSlices must be created in importEvents so they can be auto-closed.
      this.createAsyncSlices_();

      this.processV8Events();

      // Remove all the root stack frame children as they should
      // already be added.
      for (const frame of Object.values(this.v8ProcessRootStackFrame_)) {
        frame.removeAllChildren();
      }
    },

    // Some trace authors store subtraces as specific properties of the trace.
    storeSubtrace_(subtrace) {
      this.subtraces_.push(subtrace);
      return oboe.drop;
    },

    storeSamples_(samples) {
      this.sampleEvents_ = samples;
      return oboe.drop;
    },

    storeStackFrames_(stackFrames) {
      this.stackFrameEvents_ = stackFrames;
      return oboe.drop;
    },

    // Some implementations specify displayTimeUnit
    storeDisplayTimeUnit_(unitName) {
      if (!unitName) return;
      const unit = tr.b.TimeDisplayModes[unitName];
      if (unit === undefined) {
        throw new Error('Unit ' + unitName + ' is not supported.');
      }
      this.model_.intrinsicTimeUnit = unit;
      return oboe.drop;
    },

    storeTraceAnnotations_(traceAnnotations) {
      this.traceAnnotations_ = traceAnnotations;
      return oboe.drop;
    },

    // Any fields in the container that is not in NON_METADATA_FIELDS should be
    // treated as metadata.
    storeMetadata_(container) {
      for (const fieldName of Object.keys(container)) {
        if (NON_METADATA_FIELDS.has(fieldName)) continue;
        this.model_.metadata.push(
            { name: fieldName, value: container[fieldName] });
        if (fieldName !== 'metadata') continue;
        const metadata = container[fieldName];
        if (metadata['highres-ticks']) {
          this.model_.isTimeHighResolution = metadata['highres-ticks'];
        }
        if (metadata['clock-domain']) {
          this.clockDomainId_ = metadata['clock-domain'];
        }
      }
      return oboe.drop;
    },

    processEvent_(event) {
      this.hasEvents_ = true;
      const importOptions = this.model_.importOptions;
      const trackDetailedModelStats = importOptions.trackDetailedModelStats;
      const modelStats = this.model_.stats;

      if (event.args === '__stripped__') {
        event.argsStripped = true;
        event.args = undefined;
      }

      let eventSizeInBytes = undefined;
      if (trackDetailedModelStats) {
        eventSizeInBytes = JSON.stringify(event).length;
      }

      switch (event.ph) {
        case 'B':
        case 'E':
          modelStats.willProcessBasicTraceEvent(
              'begin_end (non-compact)', event.cat, event.name, event.ts,
              eventSizeInBytes);
          this.processDurationEvent(event);
          break;

        case 'X': {
          modelStats.willProcessBasicTraceEvent(
              'begin_end (compact)', event.cat, event.name, event.ts,
              eventSizeInBytes);
          const slice = this.processCompleteEvent(event);
          // TODO(yuhaoz): If Chrome supports creating other events with flow,
          // we will need to call processFlowEvent for them also.
          // https://github.com/catapult-project/catapult/issues/1259
          if (slice !== undefined && event.bind_id !== undefined) {
            this.processFlowEvent(event, slice);
          }
          break;
        }

        case 'b':
        case 'e':
        case 'n':
        case 'S':
        case 'F':
        case 'T':
        case 'p':
          modelStats.willProcessBasicTraceEvent(
              'async', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processAsyncEvent(event);
          break;

        // Note, I is historic. The instant event marker got changed, but we
        // want to support loading old trace files so we have both I and i.
        case 'I':
        case 'i':
        case 'R':
          modelStats.willProcessBasicTraceEvent(
              'instant', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processInstantEvent(event);
          break;

        case 'P':
          modelStats.willProcessBasicTraceEvent(
              'samples', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processTraceSampleEvent(event);
          break;

        case 'C':
          modelStats.willProcessBasicTraceEvent(
              'counters', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processCounterEvent(event);
          break;

        case 'M':
          modelStats.willProcessBasicTraceEvent(
              'metadata', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processMetadataEvent(event);
          break;

        case 'N':
        case 'D':
        case 'O':
          modelStats.willProcessBasicTraceEvent(
              'objects', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processObjectEvent(event);
          break;

        case 's':
        case 't':
        case 'f':
          modelStats.willProcessBasicTraceEvent(
              'flows', event.cat, event.name, event.ts, eventSizeInBytes);
          this.processFlowEvent(event);
          break;

        case 'v':
          modelStats.willProcessBasicTraceEvent(
              'memory_dumps', event.cat, event.name, event.ts,
              eventSizeInBytes);
          this.processMemoryDumpEvent(event);
          break;

        case '(':
        case ')':
          this.processContextEvent(event);
          break;

        // No-op. Clock sync events have already been processed in
        // importClockSyncMarkers().
        case 'c':
          break;

        default:
          modelStats.willProcessBasicTraceEvent(
              'unknown', event.cat, event.name, event.ts, eventSizeInBytes);
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unrecognized event phase: ' +
                event.ph + ' (' + event.name + ')'
          });
      }
      return oboe.drop;
    },

    importStackFrames_(rawStackFrames, idPrefix) {
      const model = this.model_;

      for (const id in rawStackFrames) {
        const rawStackFrame = rawStackFrames[id];
        const fullId = idPrefix + id;
        const textForColor = rawStackFrame.category ?
            rawStackFrame.category : rawStackFrame.name;
        const stackFrame = new tr.model.StackFrame(
            undefined /* parentFrame */, fullId, rawStackFrame.name,
            ColorScheme.getColorIdForGeneralPurposeString(textForColor));
        model.addStackFrame(stackFrame);
      }

      for (const id in rawStackFrames) {
        const fullId = idPrefix + id;
        const stackFrame = model.stackFrames[fullId];
        if (stackFrame === undefined) {
          throw new Error('Internal error');
        }

        const rawStackFrame = rawStackFrames[id];
        const parentId = rawStackFrame.parent;
        let parentStackFrame;
        if (parentId === undefined) {
          parentStackFrame = undefined;
        } else {
          const parentFullId = idPrefix + parentId;
          parentStackFrame = model.stackFrames[parentFullId];
          if (parentStackFrame === undefined) {
            this.model_.importWarning({
              type: 'metadata_parse_error',
              message: 'Missing parent frame with ID ' + parentFullId +
                  ' for stack frame \'' + stackFrame.name + '\' (ID ' + fullId +
                  ').'
            });
          }
        }
        stackFrame.parentFrame = parentStackFrame;
      }

      // This section is a reimplementation of the above behaviour but using
      // the new ProfileNode type instead of StackFrame.
      // We keep the StackFrame version for compatibility for now.
      const ProfileNodeType =
          tr.model.ProfileNode.subTypes.getConstructor(undefined,
              'legacySample');
      if (idPrefix === 'g') {
        for (const id in rawStackFrames) {
          const rawStackFrame = rawStackFrames[id];
          const textForColor = rawStackFrame.category ?
              rawStackFrame.category : rawStackFrame.name;
          const node = this.stackFrameTree_.add(new ProfileNodeType(
            'g' + id, {
              functionName: rawStackFrame.name
            }, undefined));
          node.colorId =
            ColorScheme.getColorIdForGeneralPurposeString(textForColor);
          node.parentId = rawStackFrame.parent;
        }

        for (const id in rawStackFrames) {
          const node = this.stackFrameTree_.getNode('g' + id);
          const parentId = node.parentId;
          let parentNode = undefined;
          if (parentId !== undefined) {
            parentNode = this.stackFrameTree_.getNode('g' + parentId);
            if (parentNode === undefined) {
              this.model_.importWarning({
                type: 'metadata_parse_error',
                message: 'Missing parent frame with ID ' + parentId +
                  ' for stack frame \'' + node.name + '\' (ID ' + node.id +
                  ').'
              });
            }
            node.parentNode = parentNode;
          }
        }
      }
    },

    importObjectTypeNameMap_(rawObjectTypeNameMap, pid) {
      if (pid in this.objectTypeNameMap_) {
        this.model_.importWarning({
          type: 'metadata_parse_error',
          message: 'Mapping from object type IDs to names provided for pid=' +
              pid + ' multiple times.'
        });
        return;
      }

      let objectTypeNamePrefix = undefined;
      let objectTypeNameSuffix = undefined;
      const objectTypeNameMap = {};
      for (const objectTypeId in rawObjectTypeNameMap) {
        const rawObjectTypeName = rawObjectTypeNameMap[objectTypeId];

        // If we haven't figured out yet which compiler the object type names
        // come from, we try to do it now.
        if (objectTypeNamePrefix === undefined) {
          for (let i = 0; i < OBJECT_TYPE_NAME_PATTERNS.length; i++) {
            const pattern = OBJECT_TYPE_NAME_PATTERNS[i];
            if (rawObjectTypeName.startsWith(pattern.prefix) &&
                rawObjectTypeName.endsWith(pattern.suffix)) {
              objectTypeNamePrefix = pattern.prefix;
              objectTypeNameSuffix = pattern.suffix;
              break;
            }
          }
        }

        if (objectTypeNamePrefix !== undefined &&
            rawObjectTypeName.startsWith(objectTypeNamePrefix) &&
            rawObjectTypeName.endsWith(objectTypeNameSuffix)) {
          // With compiler-specific prefix and suffix (automatically annotated
          // object types).
          objectTypeNameMap[objectTypeId] = rawObjectTypeName.substring(
              objectTypeNamePrefix.length,
              rawObjectTypeName.length - objectTypeNameSuffix.length);
        } else {
          // Without compiler-specific prefix and suffix (manually annotated
          // object types and '[unknown]').
          objectTypeNameMap[objectTypeId] = rawObjectTypeName;
        }
      }

      this.objectTypeNameMap_[pid] = objectTypeNameMap;
    },

    importAnnotations_() {
      for (const id in this.traceAnnotations_) {
        const annotation = tr.model.Annotation.fromDictIfPossible(
            this.traceAnnotations_[id]);
        if (!annotation) {
          this.model_.importWarning({
            type: 'annotation_warning',
            message: 'Unrecognized traceAnnotation typeName \"' +
                this.traceAnnotations_[id].typeName + '\"'
          });
          continue;
        }
        this.model_.addAnnotation(annotation);
      }
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport() {
      if (this.softwareMeasuredCpuCount_ !== undefined) {
        this.model_.kernel.softwareMeasuredCpuCount =
            this.softwareMeasuredCpuCount_;
      }
      this.createFlowSlices_();
      this.createExplicitObjects_();
      this.createImplicitObjects_();
      this.createMemoryDumps_();
    },

    /* Events can have one or more stack frames associated with them, but
     * that frame might be encoded either as a stack trace of program counters,
     * or as a direct stack frame reference. This handles either case and
     * if found, returns the stackframe.
     */
    getStackFrameForEvent_(event, opt_lookForEndEvent) {
      let sf;
      let stack;
      if (opt_lookForEndEvent) {
        sf = event.esf;
        stack = event.estack;
      } else {
        sf = event.sf;
        stack = event.stack;
      }
      if (stack !== undefined && sf !== undefined) {
        this.model_.importWarning({
          type: 'stack_frame_and_stack_error',
          message: 'Event at ' + event.ts +
              ' cannot have both a stack and a stackframe.'
        });
        return undefined;
      }

      if (stack !== undefined) {
        return this.model_.resolveStackToStackFrame_(event.pid, stack);
      }
      if (sf === undefined) return undefined;

      const stackFrame = this.model_.stackFrames['g' + sf];
      if (stackFrame === undefined) {
        this.model_.importWarning({
          type: 'sample_import_error',
          message: 'No frame for ' + sf
        });
        return;
      }
      return stackFrame;
    },

    resolveStackToStackFrame_(pid, stack) {
      // TODO(alph,fmeawad): Add codemap resolution code here.
      return undefined;
    },

    importSampleData() {
      if (!this.sampleEvents_) return;
      const m = this.model_;

      // If this is the only importer, then fake-create the threads.
      const events = this.sampleEvents_;
      if (this.hasEvents_ === undefined) {
        throw new Error('importEvents is not run before importSampleData');
      } else if (!this.hasEvents_) {
        for (let i = 0; i < events.length; i++) {
          const event = events[i];
          m.getOrCreateProcess(event.tid).getOrCreateThread(event.tid);
        }
      }

      const threadsByTid = {};
      m.getAllThreads().forEach(function(t) {
        threadsByTid[t.tid] = t;
      });

      for (let i = 0; i < events.length; i++) {
        const event = events[i];
        const thread = threadsByTid[event.tid];
        if (thread === undefined) {
          m.importWarning({
            type: 'sample_import_error',
            message: 'Thread ' + events.tid + 'not found'
          });
          continue;
        }

        let cpu;
        if (event.cpu !== undefined) {
          cpu = m.kernel.getOrCreateCpu(event.cpu);
        }

        const leafNode = this.stackFrameTree_.getNode('g' + event.sf);

        const sample = new tr.model.Sample(
          this.toModelTimeFromUs_(event.ts),
          event.name,
          leafNode,
          thread,
          cpu,
          event.weight
        );
        m.samples.push(sample);
      }
    },

    createAsyncSlices_() {
      if (this.allAsyncEvents_.length === 0) return;

      this.allAsyncEvents_.sort(function(x, y) {
        const d = x.event.ts - y.event.ts;
        if (d !== 0) return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      const legacyEvents = [];
      // Group nestable async events by ID. Events with the same ID should
      // belong to the same parent async event.
      const nestableAsyncEventsByKey = {};
      const nestableMeasureAsyncEventsByKey = {};
      for (let i = 0; i < this.allAsyncEvents_.length; i++) {
        const asyncEventState = this.allAsyncEvents_[i];
        const event = asyncEventState.event;
        if (event.ph === 'S' || event.ph === 'F' || event.ph === 'T' ||
            event.ph === 'p') {
          legacyEvents.push(asyncEventState);
          continue;
        }
        if (event.cat === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require a ' +
                'cat parameter.'
          });
          continue;
        }

        if (event.name === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require a ' +
                'name parameter.'
          });
          continue;
        }

        const id = TraceEventImporter.scopedIdForEvent_(event);
        if (id === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Nestable async events (ph: b, e, or n) require an ' +
                'id parameter.'
          });
          continue;
        }

        if (event.cat === 'blink.user_timing') {
          const matched = /([^\/:]+):([^\/:]+)\/?(.*)/.exec(event.name);
          if (matched !== null) {
            const key = matched[1] + ':' + event.cat;
            event.args = JSON.parse(Base64.atob(matched[3]) || '{}');
            if (nestableMeasureAsyncEventsByKey[key] === undefined) {
              nestableMeasureAsyncEventsByKey[key] = [];
            }
            nestableMeasureAsyncEventsByKey[key].push(asyncEventState);
            continue;
          }
        }

        const key = event.cat + ':' + id.toStringWithDelimiter(':');
        if (nestableAsyncEventsByKey[key] === undefined) {
          nestableAsyncEventsByKey[key] = [];
        }
        nestableAsyncEventsByKey[key].push(asyncEventState);
      }
      // Handle legacy async events.
      this.createLegacyAsyncSlices_(legacyEvents);

      // Parse nestable measure async events into AsyncSlices.
      this.createNestableAsyncSlices_(nestableMeasureAsyncEventsByKey);

      // Parse nestable async events into AsyncSlices.
      this.createNestableAsyncSlices_(nestableAsyncEventsByKey);
    },

    createLegacyAsyncSlice_(events) {
      const asyncEventState = events[events.length - 1];
      const event = asyncEventState.event;
      const name = event.name;
      const id = TraceEventImporter.scopedIdForEvent_(event);
      const key = id.toStringWithDelimiter(':');
      const asyncSliceConstructor = tr.model.AsyncSlice.subTypes.getConstructor(
          events[0].event.cat, name);
      let duration;
      if (event.ts !== undefined) {
        duration = this.toModelTimeFromUs_(event.ts - events[0].event.ts);
      }
      const slice = new asyncSliceConstructor(
          events[0].event.cat,
          name,
          getEventColor(events[0].event),
          this.toModelTimeFromUs_(events[0].event.ts),
          Object.assign({}, events[0].event.args, event.args),
          duration || 0,
          true,
          undefined,
          undefined,
          events[0].event.argsStripped);
      if (duration === undefined) {
        slice.didNotFinish = true;
        slice.error = 'Slice has no matching END. End time has been adjusted.';
        // End time will be adjusted by AsyncSliceGroup.autoCloseOpenSlices().
        this.model_.importWarning({
          type: 'async_slice_parse_error',
          message: 'Legacy async BEGIN event at ' +
            events[0].event.ts + ' with name="' +
            name + '" and id=' + key + ' was unmatched.'
        });
      }
      slice.startThread = events[0].thread;
      slice.endThread = asyncEventState.thread;
      slice.id = key;

      const stepType = events[1].event.ph;
      let isValid = true;

      // Create subSlices for each step. Skip the start and finish events,
      // which are always first and last respectively.
      for (let j = 1; j < events.length - 1; ++j) {
        if (events[j].event.ph === 'T' || events[j].event.ph === 'p') {
          isValid = this.assertStepTypeMatches_(stepType, events[j]);
          if (!isValid) break;
        }

        if (events[j].event.ph === 'S') {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'At ' + events[j].event.ts + ', a slice named "' +
                name + '" with id=' + id +
                ' had a step before the start event.'
          });
          continue;
        }

        if (events[j].event.ph === 'F') {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'At ' + events[j].event.ts + ', a slice named ' +
                name + ' with id=' + id +
                ' had a step after the finish event.'
          });
          continue;
        }

        const startIndex = j + (stepType === 'T' ? 0 : -1);
        const endIndex = startIndex + 1;

        let subName = name;
        if (!events[j].event.argsStripped &&
            (events[j].event.ph === 'T' || events[j].event.ph === 'p')) {
          subName = events[j].event.args.step;
        }

        const asyncSliceConstructor =
            tr.model.AsyncSlice.subTypes.getConstructor(
                events[0].event.cat,
                subName);
        let duration;
        if (events[endIndex].event.ts !== undefined) {
          duration = this.toModelTimeFromUs_(
              events[endIndex].event.ts - events[startIndex].event.ts);
        }
        const subSlice = new asyncSliceConstructor(
            events[0].event.cat,
            subName,
            getEventColor(events[0].event, subName + j),
            this.toModelTimeFromUs_(events[startIndex].event.ts),
            this.deepCopyIfNeeded_(events[j].event.args),
            duration || 0,
            undefined,
            undefined,
            events[startIndex].event.argsStripped);
        if (duration === undefined) {
          subSlice.didNotFinish = true;
          subSlice.error =
              'Slice has no matching END. End time has been adjusted.';
          // End time will be adjusted by AsyncSliceGroup.autoCloseOpenSlices().
        }
        subSlice.startThread = events[startIndex].thread;
        subSlice.endThread = events[endIndex].thread;
        subSlice.id = key;

        slice.subSlices.push(subSlice);
      }

      if (isValid) {
        // Add |slice| to the start-thread's asyncSlices.
        slice.startThread.asyncSliceGroup.push(slice);
      }
    },

    createLegacyAsyncSlices_(legacyEvents) {
      if (legacyEvents.length === 0) return;

      legacyEvents.sort(function(x, y) {
        const d = x.event.ts - y.event.ts;
        if (d !== 0) return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      const asyncEventStatesByNameThenID = {};

      for (let i = 0; i < legacyEvents.length; i++) {
        const asyncEventState = legacyEvents[i];

        const event = asyncEventState.event;
        const name = event.name;
        if (name === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Async events (ph: S, T, p, or F) require a name ' +
                ' parameter.'
          });
          continue;
        }

        const id = TraceEventImporter.scopedIdForEvent_(event);
        if (id === undefined) {
          this.model_.importWarning({
            type: 'async_slice_parse_error',
            message: 'Async events (ph: S, T, p, or F) require an id parameter.'
          });
          continue;
        }
        const key = id.toStringWithDelimiter(':');
        // TODO(simonjam): Add a synchronous tick on the appropriate thread.

        if (event.ph === 'S') {
          if (asyncEventStatesByNameThenID[name] === undefined) {
            asyncEventStatesByNameThenID[name] = {};
          }
          if (asyncEventStatesByNameThenID[name][key]) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'At ' + event.ts + ', a slice of the same id ' + id +
                  ' was alrady open.'
            });
            continue;
          }
          asyncEventStatesByNameThenID[name][key] = [];
          asyncEventStatesByNameThenID[name][key].push(asyncEventState);
        } else {
          if (asyncEventStatesByNameThenID[name] === undefined) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: `At ${event.ts}, no slice named "${name}" was open.`,
            });
            continue;
          }
          if (asyncEventStatesByNameThenID[name][key] === undefined) {
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message:
                `At ${event.ts}, no slice named "${name}" with id=${id} was ` +
                'open.',
            });
            continue;
          }
          const events = asyncEventStatesByNameThenID[name][key];
          events.push(asyncEventState);

          if (event.ph === 'F') {
            this.createLegacyAsyncSlice_(events);
            delete asyncEventStatesByNameThenID[name][key];
          }
        }
      }

      // Auto-close unmatched S events by creating a fake F event.
      for (const [name, statesByID] of
          Object.entries(asyncEventStatesByNameThenID)) {
        for (const [id, states] of Object.entries(statesByID)) {
          const startEvent = states[0].event;
          // Don't set 'ts' in the fake 'F' event. createLegacyAsyncSlice_ will
          // set duration=undefined and didNotFinish=true.
          // AsyncSliceGroup.autoCloseOpenSlices() will set duration so that the
          // AsyncSlice ends when the trace ends.
          states.push({
            sequenceNumber: 1 + states[states.length - 1].sequenceNumber,
            event: {
              ph: 'F',
              name,
              id: startEvent.id,
              id2: startEvent.id2,
              scope: startEvent.scope,
              pid: startEvent.pid,
              tid: startEvent.tid,
              cat: startEvent.cat,
              args: {},
            },
            thread: this.model_.getOrCreateProcess(startEvent.pid).
                getOrCreateThread(startEvent.tid),
          });
          this.createLegacyAsyncSlice_(states);
        }
      }
    },

    createNestableAsyncSlices_(nestableEventsByKey) {
      for (const key in nestableEventsByKey) {
        const eventStateEntries = nestableEventsByKey[key];
        // Stack of enclosing BEGIN events.
        const parentStack = [];
        for (let i = 0; i < eventStateEntries.length; ++i) {
          const eventStateEntry = eventStateEntries[i];
          // If this is the end of an event, match it to the start.
          if (eventStateEntry.event.ph === 'e') {
            // Walk up the parent stack to find the corresponding BEGIN for
            // this END.
            let parentIndex = -1;
            for (let k = parentStack.length - 1; k >= 0; --k) {
              if (parentStack[k].event.name === eventStateEntry.event.name) {
                parentIndex = k;
                break;
              }
            }
            if (parentIndex === -1) {
              // Unmatched end.
              eventStateEntry.finished = false;
            } else {
              parentStack[parentIndex].end = eventStateEntry;
              // Pop off all enclosing unmatched BEGINs util parentIndex.
              while (parentIndex < parentStack.length) {
                parentStack.pop();
              }
            }
          }
          // Inherit the current parent.
          if (parentStack.length > 0) {
            eventStateEntry.parentEntry = parentStack[parentStack.length - 1];
          }
          if (eventStateEntry.event.ph === 'b') {
            parentStack.push(eventStateEntry);
          }
        }
        const topLevelSlices = [];
        for (let i = 0; i < eventStateEntries.length; ++i) {
          const eventStateEntry = eventStateEntries[i];
          // Skip matched END, as its slice will be created when we
          // encounter its corresponding BEGIN.
          if (eventStateEntry.event.ph === 'e' &&
              eventStateEntry.finished === undefined) {
            continue;
          }
          let startState = undefined;
          let endState = undefined;
          let sliceArgs = eventStateEntry.event.args || {};
          let sliceError = undefined;
          const id = TraceEventImporter.scopedIdForEvent_(
              eventStateEntry.event);
          if (eventStateEntry.event.ph === 'n') {
            startState = eventStateEntry;
            endState = eventStateEntry;
          } else if (eventStateEntry.event.ph === 'b') {
            if (eventStateEntry.end === undefined) {
              // Unmatched BEGIN. End it when last event with this ID ends.
              eventStateEntry.end =
                eventStateEntries[eventStateEntries.length - 1];
              sliceError =
                'Slice has no matching END. End time has been adjusted.';
              this.model_.importWarning({
                type: 'async_slice_parse_error',
                message: 'Nestable async BEGIN event at ' +
                  eventStateEntry.event.ts + ' with name="' +
                  eventStateEntry.event.name + '" and id=' + id +
                  ' was unmatched.'
              });
            } else {
              // Include args for both END and BEGIN for a matched pair.
              function concatenateArguments(args1, args2) {
                if (args1.params === undefined || args2.params === undefined) {
                  return Object.assign({}, args1, args2);
                }
                // Make an argument object to hold the combined params.
                const args3 = {};
                args3.params = Object.assign({}, args1.params, args2.params);
                return Object.assign({}, args1, args2, args3);
              }
              const endArgs = eventStateEntry.end.event.args || {};
              sliceArgs = concatenateArguments(sliceArgs, endArgs);
            }
            startState = eventStateEntry;
            endState = eventStateEntry.end;
          } else {
            // Unmatched END. Start it at the first event with this ID starts.
            sliceError =
              'Slice has no matching BEGIN. Start time has been adjusted.';
            this.model_.importWarning({
              type: 'async_slice_parse_error',
              message: 'Nestable async END event at ' +
                eventStateEntry.event.ts + ' with name=' +
                eventStateEntry.event.name +
                ' and id=' + id + ' was unmatched.'
            });
            startState = eventStateEntries[0];
            endState = eventStateEntry;
          }

          const isTopLevel = (eventStateEntry.parentEntry === undefined);
          const asyncSliceConstructor =
              tr.model.AsyncSlice.subTypes.getConstructor(
                  eventStateEntry.event.cat,
                  eventStateEntry.event.name);

          let threadStart = undefined;
          let threadDuration = undefined;
          if (startState.event.tts && startState.event.use_async_tts) {
            threadStart = this.toModelTimeFromUs_(startState.event.tts);
            if (endState.event.tts) {
              const threadEnd = this.toModelTimeFromUs_(endState.event.tts);
              threadDuration = threadEnd - threadStart;
            }
          }

          const slice = new asyncSliceConstructor(
            eventStateEntry.event.cat,
            eventStateEntry.event.name,
            getEventColor(endState.event),
            this.toModelTimeFromUs_(startState.event.ts),
            sliceArgs,
            this.toModelTimeFromUs_(endState.event.ts - startState.event.ts),
            isTopLevel,
            threadStart,
            threadDuration,
            startState.event.argsStripped);

          slice.startThread = startState.thread;
          slice.endThread = endState.thread;

          slice.startStackFrame = this.getStackFrameForEvent_(startState.event);
          slice.endStackFrame = this.getStackFrameForEvent_(endState.event);

          slice.id = key;
          if (sliceError !== undefined) {
            slice.error = sliceError;
          }
          eventStateEntry.slice = slice;
          // Add the slice to the topLevelSlices array if there is no parent.
          // Otherwise, add the slice to the subSlices of its parent.
          if (isTopLevel) {
            topLevelSlices.push(slice);
          } else if (eventStateEntry.parentEntry.slice !== undefined) {
            eventStateEntry.parentEntry.slice.subSlices.push(slice);
          }
        }
        for (let si = 0; si < topLevelSlices.length; si++) {
          topLevelSlices[si].startThread.asyncSliceGroup.push(
              topLevelSlices[si]);
        }
      }
    },

    assertStepTypeMatches_(stepType, event) {
      if (stepType !== event.event.ph) {
        this.model_.importWarning({
          type: 'async_slice_parse_error',
          message: 'At ' + event.event.ts + ', a slice named ' +
              event.event.name + ' with id=' +
              TraceEventImporter.scopedIdForEvent_(event.event) +
              ' had both begin and end steps, which is not allowed.'
        });
        return false;
      }
      return true;
    },

    validateFlowEvent_(event) {
      if (event.name === undefined) {
        this.model_.importWarning({
          type: 'flow_slice_parse_error',
          message: 'Flow events (ph: s, t or f) require a name parameter.'
        });
        return false;
      }

      // Support Flow API v1.
      if (event.ph === 's' || event.ph === 'f' || event.ph === 't') {
        if (event.id === undefined) {
          this.model_.importWarning({
            type: 'flow_slice_parse_error',
            message: 'Flow events (ph: s, t or f) require an id parameter.'
          });
          return false;
        }
        return true;
      }

      // Support Flow API v2.
      if (event.bind_id) {
        if (event.flow_in === undefined && event.flow_out === undefined) {
          this.model_.importWarning({
            type: 'flow_slice_parse_error',
            message: 'Flow producer or consumer require flow_in or flow_out.'
          });
          return false;
        }
        return true;
      }

      return false;
    },

    createFlowSlices_() {
      if (this.allFlowEvents_.length === 0) return;

      const createFlowEvent = function(thread, event, opt_slice) {
        let startSlice;
        let flowId;
        let flowStartTs;

        if (event.bind_id) {
          // Support Flow API v2.
          startSlice = opt_slice;
          flowId = event.bind_id;
          flowStartTs = this.toModelTimeFromUs_(event.ts + event.dur);
        } else {
          // Support Flow API v1.
          const ts = this.toModelTimeFromUs_(event.ts);
          startSlice = thread.sliceGroup.findSliceAtTs(ts);
          if (startSlice === undefined) return undefined;
          flowId = event.id;
          flowStartTs = ts;
        }

        const flowEvent = new tr.model.FlowEvent(
            event.cat,
            flowId,
            event.name,
            getEventColor(event),
            flowStartTs,
            this.deepCopyAlways_(event.args));
        flowEvent.startSlice = startSlice;
        flowEvent.startStackFrame = this.getStackFrameForEvent_(event);
        flowEvent.endStackFrame = undefined;
        startSlice.outFlowEvents.push(flowEvent);
        return flowEvent;
      }.bind(this);

      const finishFlowEventWith = function(
          flowEvent, thread, event, refGuid, bindToParent, opt_slice) {
        let endSlice;

        if (event.bind_id) {
          // Support Flow API v2.
          endSlice = opt_slice;
        } else {
          // Support Flow API v1.
          const ts = this.toModelTimeFromUs_(event.ts);
          if (bindToParent) {
            endSlice = thread.sliceGroup.findSliceAtTs(ts);
          } else {
            endSlice = thread.sliceGroup.findNextSliceAfter(ts, refGuid);
          }
          if (endSlice === undefined) return false;
        }

        endSlice.inFlowEvents.push(flowEvent);
        flowEvent.endSlice = endSlice;
        flowEvent.duration =
            this.toModelTimeFromUs_(event.ts) - flowEvent.start;
        flowEvent.endStackFrame = this.getStackFrameForEvent_(event);
        this.mergeArgsInto_(flowEvent.args, event.args, flowEvent.title);
        return true;
      }.bind(this);

      const processFlowConsumer = function(
          flowIdToEvent, sliceGuidToEvent, event, slice) {
        let flowEvent = flowIdToEvent[event.bind_id];
        if (flowEvent === undefined) {
          this.model_.importWarning({
            type: 'flow_slice_ordering_error',
            message: 'Flow consumer ' + event.bind_id + ' does not have ' +
                  'a flow producer'});
          return false;
        } else if (flowEvent.endSlice) {
          // One flow producer can have more than one flow consumers.
          // In this case, create a new flow event using the flow producer.
          const flowProducer = flowEvent.startSlice;
          flowEvent = createFlowEvent(undefined,
              sliceGuidToEvent[flowProducer.guid], flowProducer);
        }

        const refGuid = undefined;
        const ok = finishFlowEventWith(flowEvent, undefined, event,
            refGuid, undefined, slice);
        if (ok) {
          this.model_.flowEvents.push(flowEvent);
        } else {
          this.model_.importWarning({
            type: 'flow_slice_end_error',
            message: 'Flow consumer ' + event.bind_id + ' does not end ' +
                  'at an actual slice, so cannot be created.'});
          return false;
        }

        return true;
      }.bind(this);

      const processFlowProducer = function(
          flowIdToEvent, flowStatus, event, slice) {
        if (flowIdToEvent[event.bind_id] &&
            flowStatus[event.bind_id]) {
          // Can't open the same flow again while it's still open.
          // This is essentially the multi-producer case which we don't support
          this.model_.importWarning({
            type: 'flow_slice_start_error',
            message: 'Flow producer ' + event.bind_id + ' already seen'});
          return false;
        }

        const flowEvent = createFlowEvent(undefined, event, slice);
        if (!flowEvent) {
          this.model_.importWarning({
            type: 'flow_slice_start_error',
            message: 'Flow producer ' + event.bind_id + ' does not start' +
                  'a flow'});
          return false;
        }
        flowIdToEvent[event.bind_id] = flowEvent;
      }.bind(this);

      // Actual import.
      this.allFlowEvents_.sort(function(x, y) {
        const d = x.event.ts - y.event.ts;
        if (d !== 0) return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      const flowIdToEvent = {};
      const sliceGuidToEvent = {};
      const flowStatus = {}; // true: open; false: closed.
      for (let i = 0; i < this.allFlowEvents_.length; ++i) {
        const data = this.allFlowEvents_[i];
        const refGuid = data.refGuid;
        const event = data.event;
        const thread = data.thread;

        if (!this.validateFlowEvent_(event)) continue;

        // Support for Flow API v2.
        if (event.bind_id) {
          const slice = data.slice;
          sliceGuidToEvent[slice.guid] = event;

          if (event.flowPhase === PRODUCER) {
            if (!processFlowProducer(flowIdToEvent, flowStatus, event, slice)) {
              continue;
            }
            flowStatus[event.bind_id] = true; // open the flow.
          } else {
            if (!processFlowConsumer(flowIdToEvent, sliceGuidToEvent,
                event, slice)) {
              continue;
            }
            flowStatus[event.bind_id] = false; // close the flow.

            if (event.flowPhase === STEP) {
              if (!processFlowProducer(flowIdToEvent, flowStatus,
                  event, slice)) {
                continue;
              }
              flowStatus[event.bind_id] = true; // open the flow again.
            }
          }
          continue;
        }

        // Support for Flow API v1.
        let flowEvent;
        if (event.ph === 's') {
          if (flowIdToEvent[event.id]) {
            this.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'event id ' + event.id + ' already seen when ' +
                  'encountering start of flow event.'});
            continue;
          }
          flowEvent = createFlowEvent(thread, event);
          if (!flowEvent) {
            this.model_.importWarning({
              type: 'flow_slice_start_error',
              message: 'event id ' + event.id + ' does not start ' +
                  'at an actual slice, so cannot be created.'});
            continue;
          }
          flowIdToEvent[event.id] = flowEvent;
        } else if (event.ph === 't' || event.ph === 'f') {
          flowEvent = flowIdToEvent[event.id];
          if (flowEvent === undefined) {
            this.model_.importWarning({
              type: 'flow_slice_ordering_error',
              message: 'Found flow phase ' + event.ph + ' for id: ' + event.id +
                  ' but no flow start found.'
            });
            continue;
          }

          let bindToParent = event.ph === 't';

          if (event.ph === 'f') {
            if (event.bp === undefined) {
              // TODO(yuhaoz): In flow V2, there is no notion of binding point.
              // Removal of binding point is tracked in
              // https://github.com/google/trace-viewer/issues/991.
              if (event.cat.indexOf('input') > -1) {
                bindToParent = true;
              } else if (event.cat.indexOf('ipc.flow') > -1) {
                bindToParent = true;
              }
            } else {
              if (event.bp !== 'e') {
                this.model_.importWarning({
                  type: 'flow_slice_bind_point_error',
                  message: 'Flow event with invalid binding point (event.bp).'
                });
                continue;
              }
              bindToParent = true;
            }
          }

          const ok = finishFlowEventWith(flowEvent, thread, event,
              refGuid, bindToParent);
          if (ok) {
            this.model_.flowEvents.push(flowEvent);
          } else {
            this.model_.importWarning({
              type: 'flow_slice_end_error',
              message: 'event id ' + event.id + ' does not end ' +
                  'at an actual slice, so cannot be created.'});
          }
          flowIdToEvent[event.id] = undefined;

          // If this is a step, then create another flow event.
          if (ok && event.ph === 't') {
            flowEvent = createFlowEvent(thread, event);
            flowIdToEvent[event.id] = flowEvent;
          }
        }
      }
    },

    /**
     * This function creates objects described via the N, D, and O phase
     * events.
     */
    createExplicitObjects_() {
      if (this.allObjectEvents_.length === 0) return;

      const processEvent = function(objectEventState) {
        const event = objectEventState.event;
        const scopedId = TraceEventImporter.scopedIdForEvent_(event);
        const thread = objectEventState.thread;
        if (event.name === undefined) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: 'While processing ' + JSON.stringify(event) + ': ' +
                'Object events require an name parameter.'
          });
        }

        if (scopedId === undefined || scopedId.id === undefined) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: 'While processing ' + JSON.stringify(event) + ': ' +
                'Object events require an id parameter.'
          });
        }
        const process = thread.parent;
        const ts = this.toModelTimeFromUs_(event.ts);
        let instance;
        if (event.ph === 'N') {
          try {
            instance = process.objects.idWasCreated(
                scopedId, event.cat, event.name, ts);
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing create of ' +
                  scopedId + ' at ts=' + ts + ': ' + e
            });
            return;
          }
        } else if (event.ph === 'O') {
          if (event.args.snapshot === undefined) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing ' + scopedId + ' at ts=' + ts + ': ' +
                  'Snapshots must have args: {snapshot: ...}'
            });
            return;
          }
          let snapshot;
          try {
            const args = this.deepCopyIfNeeded_(event.args.snapshot);
            let cat;
            if (args.cat) {
              cat = args.cat;
              delete args.cat;
            } else {
              cat = event.cat;
            }

            let baseTypename;
            if (args.base_type) {
              baseTypename = args.base_type;
              delete args.base_type;
            } else {
              baseTypename = undefined;
            }
            snapshot = process.objects.addSnapshot(
                scopedId, cat, event.name, ts, args, baseTypename);
            snapshot.snapshottedOnThread = thread;
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing snapshot of ' +
                  scopedId + ' at ts=' + ts + ': ' + e
            });
            return;
          }
          instance = snapshot.objectInstance;
        } else if (event.ph === 'D') {
          try {
            process.objects.idWasDeleted(scopedId, event.cat, event.name, ts);
            const instanceMap = process.objects.getOrCreateInstanceMap_(
                scopedId);
            instance = instanceMap.lastInstance;
          } catch (e) {
            this.model_.importWarning({
              type: 'object_parse_error',
              message: 'While processing delete of ' +
                  scopedId + ' at ts=' + ts + ': ' + e
            });
            return;
          }
        }

        if (instance) {
          instance.colorId = getEventColor(event, instance.typeName);
        }
      }.bind(this);

      this.allObjectEvents_.sort(function(x, y) {
        const d = x.event.ts - y.event.ts;
        if (d !== 0) return d;
        return x.sequenceNumber - y.sequenceNumber;
      });

      const allObjectEvents = this.allObjectEvents_;
      for (let i = 0; i < allObjectEvents.length; i++) {
        const objectEventState = allObjectEvents[i];
        try {
          processEvent.call(this, objectEventState);
        } catch (e) {
          this.model_.importWarning({
            type: 'object_parse_error',
            message: e.message
          });
        }
      }
    },

    createImplicitObjects_() {
      for (const proc of Object.values(this.model_.processes)) {
        this.createImplicitObjectsForProcess_(proc);
      }
    },

    // Here, we collect all the snapshots that internally contain a
    // Javascript-level object inside their args list that has an "id" field,
    // and turn that into a snapshot of the instance referred to by id.
    createImplicitObjectsForProcess_(process) {
      function processField(referencingObject,
          referencingObjectFieldName,
          referencingObjectFieldValue,
          containingSnapshot) {
        if (!referencingObjectFieldValue) return;

        if (referencingObjectFieldValue instanceof
            tr.model.ObjectSnapshot) {
          return null;
        }
        if (referencingObjectFieldValue.id === undefined) return;

        const implicitSnapshot = referencingObjectFieldValue;

        const rawId = implicitSnapshot.id;
        const m = /(.+)\/(.+)/.exec(rawId);
        if (!m) {
          throw new Error('Implicit snapshots must have names.');
        }
        delete implicitSnapshot.id;
        const name = m[1];
        const id = m[2];
        let res;

        let cat;
        if (implicitSnapshot.cat !== undefined) {
          cat = implicitSnapshot.cat;
        } else {
          cat = containingSnapshot.objectInstance.category;
        }

        let baseTypename;
        if (implicitSnapshot.base_type) {
          baseTypename = implicitSnapshot.base_type;
        } else {
          baseTypename = undefined;
        }

        const scope = containingSnapshot.objectInstance.scopedId.scope;

        try {
          res = process.objects.addSnapshot(
              new tr.model.ScopedId(scope, id), cat,
              name, containingSnapshot.ts,
              implicitSnapshot, baseTypename);
        } catch (e) {
          this.model_.importWarning({
            type: 'object_snapshot_parse_error',
            message: 'While processing implicit snapshot of ' +
                rawId + ' at ts=' + containingSnapshot.ts + ': ' + e
          });
          return;
        }
        res.objectInstance.hasImplicitSnapshots = true;
        res.containingSnapshot = containingSnapshot;
        res.snapshottedOnThread = containingSnapshot.snapshottedOnThread;
        referencingObject[referencingObjectFieldName] = res;
        if (!(res instanceof tr.model.ObjectSnapshot)) {
          throw new Error('Created object must be instanceof snapshot');
        }
        return res.args;
      }

      /**
       * Iterates over the fields in the object, calling func for every
       * field/value found.
       *
       * @return {object} If the function does not want the field's value to be
       * iterated, return null. If iteration of the field value is desired, then
       * return either undefined (if the field value did not change) or the new
       * field value if it was changed.
       */
      function iterObject(object, func, containingSnapshot, thisArg) {
        if (!(object instanceof Object)) return;

        if (object instanceof Array) {
          for (let i = 0; i < object.length; i++) {
            const res = func.call(thisArg, object, i, object[i],
                containingSnapshot);
            if (res === null) continue;
            if (res) {
              iterObject(res, func, containingSnapshot, thisArg);
            } else {
              iterObject(object[i], func, containingSnapshot, thisArg);
            }
          }
          return;
        }

        for (const key in object) {
          const res = func.call(thisArg, object, key, object[key],
              containingSnapshot);
          if (res === null) continue;
          if (res) {
            iterObject(res, func, containingSnapshot, thisArg);
          } else {
            iterObject(object[key], func, containingSnapshot, thisArg);
          }
        }
      }

      // TODO(nduca): We may need to iterate the instances in sorted order by
      // creationTs.
      process.objects.iterObjectInstances(function(instance) {
        instance.snapshots.forEach(function(snapshot) {
          if (snapshot.args.id !== undefined) {
            throw new Error('args cannot have an id field inside it');
          }
          iterObject(snapshot.args, processField, snapshot, this);
        }, this);
      }, this);
    },

    // Takes an object of type: PID -> [process memory dump events]
    // Returns smallest timestamp among events or Infinity if there are none.
    minimalTimestampInPidToEvents_(pidToEvents) {
      let smallestTs = Infinity;
      for (const events of Object.values(pidToEvents)) {
        for (const event of events) {
          if (event.ts < smallestTs) {
            smallestTs = event.ts;
          }
        }
      }
      return smallestTs;
    },

    createMemoryDumps_() {
      // We must create the global dumps in chronological order since later
      // heap dumps can depend on earlier ones. Not all events within a single
      // global dump have the same timestamp but events for two different
      // global dumps can not be interspersed. However, for consistency,
      // we sort the global dumps by the earliest timestamp present in an event
      // in that dump.
      const pairs = Object.entries(this.allMemoryDumpEvents_);
      const key = x => this.minimalTimestampInPidToEvents_(x);
      pairs.sort((x, y) => key(x[1]) - key(y[1]));
      for (const [dumpId, pidToEvents] of pairs) {
        this.createGlobalMemoryDump_(pidToEvents, dumpId);
      }
    },

    createGlobalMemoryDump_(dumpIdEvents, dumpId) {
      // 1. Create a GlobalMemoryDump for the provided process memory dump
      // the events, all of which have the same dump ID.

      // Calculate the range of the global memory dump.
      const globalRange = new tr.b.math.Range();
      for (const pid in dumpIdEvents) {
        const processEvents = dumpIdEvents[pid];
        for (let i = 0; i < processEvents.length; i++) {
          globalRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));
        }
      }
      if (globalRange.isEmpty) {
        throw new Error('Internal error: Global memory dump without events');
      }

      // Create the global memory dump.
      const globalMemoryDump = new tr.model.GlobalMemoryDump(
          this.model_, globalRange.min);
      globalMemoryDump.duration = globalRange.range;
      this.model_.globalMemoryDumps.push(globalMemoryDump);

      const globalMemoryAllocatorDumpsByFullName = {};
      const levelsOfDetail = {};
      const allMemoryAllocatorDumpsByGuid = {};

      // 2. Create a ProcessMemoryDump for each PID in the provided process
      // memory dump events. Everything except for edges between memory
      // allocator dumps is parsed from the process memory dump trace events at
      // this step.
      for (const pid in dumpIdEvents) {
        this.createProcessMemoryDump_(globalMemoryDump,
            globalMemoryAllocatorDumpsByFullName, levelsOfDetail,
            allMemoryAllocatorDumpsByGuid, dumpIdEvents[pid], pid, dumpId);
      }

      // 3. Set the level of detail and memory allocator dumps of the
      // GlobalMemoryDump, which come from the process memory dump trace
      // events parsed in the prebvious step.
      globalMemoryDump.levelOfDetail = levelsOfDetail.global;

      // Find the root allocator dumps and establish the parent links of
      // the global memory dump.
      globalMemoryDump.memoryAllocatorDumps =
          this.inferMemoryAllocatorDumpTree_(
              globalMemoryAllocatorDumpsByFullName);

      // 4. Finally, parse the edges between all memory allocator dumps within
      // the GlobalMemoryDump. This can only be done once all memory allocator
      // dumps have been parsed (i.e. it is necessary to iterate over the
      // process memory dump trace events once more).
      this.parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid,
          dumpIdEvents, dumpId);
    },

    createProcessMemoryDump_(globalMemoryDump,
        globalMemoryAllocatorDumpsByFullName, levelsOfDetail,
        allMemoryAllocatorDumpsByGuid, processEvents, pid, dumpId) {
      // Calculate the range of the process memory dump.
      const processRange = new tr.b.math.Range();
      for (let i = 0; i < processEvents.length; i++) {
        processRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));
      }
      if (processRange.isEmpty) {
        throw new Error('Internal error: Process memory dump without events');
      }

      // Create the process memory dump.
      const process = this.model_.getOrCreateProcess(pid);
      const processMemoryDump = new tr.model.ProcessMemoryDump(
          globalMemoryDump, process, processRange.min);
      processMemoryDump.duration = processRange.range;
      process.memoryDumps.push(processMemoryDump);
      globalMemoryDump.processMemoryDumps[pid] = processMemoryDump;

      const processMemoryAllocatorDumpsByFullName = {};

      // Parse all process memory dump trace events for the newly created
      // ProcessMemoryDump.
      for (let i = 0; i < processEvents.length; i++) {
        const processEvent = processEvents[i];

        const dumps = processEvent.args.dumps;
        if (dumps === undefined) {
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: '\'dumps\' field not found in a process memory dump' +
                ' event for PID=' + pid + ' and dump ID=' + dumpId + '.'
          });
          continue;
        }

        // Totals, VM regions, and heap dumps for the newly created
        // ProcessMemoryDump should be present in at most one event, so they
        // can be added to the ProcessMemoryDump immediately.
        this.parseMemoryDumpTotals_(processMemoryDump, dumps, pid, dumpId);
        this.parseMemoryDumpVmRegions_(processMemoryDump, dumps, pid, dumpId);
        this.parseMemoryDumpHeapDumps_(processMemoryDump, dumps, pid, dumpId);

        // All process memory dump trace events for the newly created
        // ProcessMemoryDump must be processed before level of detail and
        // allocator dumps can be added to it.
        this.parseMemoryDumpLevelOfDetail_(levelsOfDetail, dumps, pid,
            dumpId);
        this.parseMemoryDumpAllocatorDumps_(processMemoryDump, globalMemoryDump,
            processMemoryAllocatorDumpsByFullName,
            globalMemoryAllocatorDumpsByFullName,
            allMemoryAllocatorDumpsByGuid, dumps, pid, dumpId);
      }

      if (levelsOfDetail.process === undefined) {
        // Infer level of detail from the presence of VM regions in legacy
        // traces (where raw process memory dump events don't contain the
        // level_of_detail field). These traces will not have BACKGROUND mode.
        levelsOfDetail.process = processMemoryDump.vmRegions ? DETAILED : LIGHT;
      }
      if (!this.updateMemoryDumpLevelOfDetail_(
          levelsOfDetail, 'global', levelsOfDetail.process)) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'diffent levels of detail provided for global memory' +
              ' dump (dump ID=' + dumpId + ').'
        });
      }
      processMemoryDump.levelOfDetail = levelsOfDetail.process;
      delete levelsOfDetail.process;  // Reused for all process dumps.

      // Find the root allocator dumps and establish the parent links of
      // the process memory dump.
      processMemoryDump.memoryAllocatorDumps =
          this.inferMemoryAllocatorDumpTree_(
              processMemoryAllocatorDumpsByFullName);
    },

    parseMemoryDumpTotals_(processMemoryDump, dumps, pid, dumpId) {
      const rawTotals = dumps.process_totals;
      if (rawTotals === undefined) return;

      if (processMemoryDump.totals !== undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Process totals provided multiple times for' +
              ' process memory dump for PID=' + pid +
              ' and dump ID=' + dumpId + '.'
        });
        return;
      }

      const totals = {};
      let platformSpecificTotals = undefined;

      for (const rawTotalName in rawTotals) {
        const rawTotalValue = rawTotals[rawTotalName];
        if (rawTotalValue === undefined) continue;

        // Total resident bytes.
        if (rawTotalName === 'resident_set_bytes') {
          totals.residentBytes = parseInt(rawTotalValue, 16);
          continue;
        }

        // Peak resident bytes.
        if (rawTotalName === 'peak_resident_set_bytes') {
          totals.peakResidentBytes = parseInt(rawTotalValue, 16);
          continue;
        }
        if (rawTotalName === 'is_peak_rss_resetable') {
          totals.arePeakResidentBytesResettable = !!rawTotalValue;
          continue;
        }

        // OS-specific totals (e.g. private resident on Mac).
        if (platformSpecificTotals === undefined) {
          platformSpecificTotals = {};
          totals.platformSpecific = platformSpecificTotals;
        }
        platformSpecificTotals[rawTotalName] = parseInt(rawTotalValue, 16);
      }

      // Either both peak_resident_set_bytes and is_peak_rss_resetable should
      // be present in the trace, or neither.
      if (totals.peakResidentBytes === undefined &&
          totals.arePeakResidentBytesResettable !== undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Optional field peak_resident_set_bytes found' +
                ' but is_peak_rss_resetable not found in' +
                ' process memory dump for PID=' + pid +
                ' and dump ID=' + dumpId + '.'
        });
      }
      if (totals.arePeakResidentBytesResettable !== undefined &&
          totals.peakResidentBytes === undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Optional field is_peak_rss_resetable found' +
                ' but peak_resident_set_bytes not found in' +
                ' process memory dump for PID=' + pid +
                ' and dump ID=' + dumpId + '.'
        });
      }

      processMemoryDump.totals = totals;
    },

    parseMemoryDumpVmRegions_(processMemoryDump, dumps, pid, dumpId) {
      const rawProcessMmaps = dumps.process_mmaps;
      if (rawProcessMmaps === undefined) return;

      const rawVmRegions = rawProcessMmaps.vm_regions;
      if (rawVmRegions === undefined) return;

      if (processMemoryDump.vmRegions !== undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'VM regions provided multiple times for' +
              ' process memory dump for PID=' + pid +
              ' and dump ID=' + dumpId + '.'
        });
        return;
      }

      // See //base/trace_event/process_memory_maps.cc in Chromium.
      const vmRegions = new Array(rawVmRegions.length);
      for (let i = 0; i < rawVmRegions.length; i++) {
        const rawVmRegion = rawVmRegions[i];

        const byteStats = {};
        const rawByteStats = rawVmRegion.bs;
        for (const rawByteStatName in rawByteStats) {
          const rawByteStatValue = rawByteStats[rawByteStatName];
          if (rawByteStatValue === undefined) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Byte stat \'' + rawByteStatName + '\' of VM region ' +
                  i + ' (' + rawVmRegion.mf + ') in process memory dump for ' +
                  'PID=' + pid + ' and dump ID=' + dumpId +
                  ' does not have a value.'
            });
            continue;
          }
          const byteStatName = BYTE_STAT_NAME_MAP[rawByteStatName];
          if (byteStatName === undefined) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Unknown byte stat name \'' + rawByteStatName + '\' (' +
                  rawByteStatValue + ') of VM region ' + i + ' (' +
                  rawVmRegion.mf + ') in process memory dump for PID=' + pid +
                  ' and dump ID=' + dumpId + '.'
            });
            continue;
          }
          byteStats[byteStatName] = parseInt(rawByteStatValue, 16);
          // OSX does not report PSS and instead emits all zeros.
          // Zero is a valid value for some byteStats but not PSS so this could
          // could to confusion when we later compute with and display the PSS.
          // To avoid this we ignore zero PSS values (since PSS should never
          // be zero). See: github.com/catapult-project/catapult/issues/3501
          if (byteStatName === 'proportionalResident' &&
              byteStats[byteStatName] === 0) {
            byteStats[byteStatName] = undefined;
          }
        }

        vmRegions[i] = new tr.model.VMRegion(
            parseInt(rawVmRegion.sa, 16),  // startAddress
            parseInt(rawVmRegion.sz, 16),  // sizeInBytes
            rawVmRegion.pf,  // protectionFlags
            rawVmRegion.mf,  // mappedFile
            byteStats);
      }

      processMemoryDump.vmRegions =
          tr.model.VMRegionClassificationNode.fromRegions(vmRegions);
    },

    parseMemoryDumpHeapDumps_(processMemoryDump, dumps, pid, dumpId) {
      const idPrefix = 'p' + pid + ':';
      let importer;
      if (dumps.heaps) {
        const processTypeMap = this.objectTypeNameMap_[pid];
        if (processTypeMap === undefined) {
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Missing mapping from object type IDs to names.'
          });
        }
        importer = new LegacyHeapDumpTraceEventImporter(this.model_,
            processMemoryDump, processTypeMap, idPrefix, dumpId, dumps.heaps);
      } else if (dumps.heaps_v2) {
        const data = dumps.heaps_v2;
        this.heapProfileExpander = this.heapProfileExpander.expandData(data);
        // TODO(hjd): Unify how we are reading & inflating stack frame data.
        this.addNewStackFramesFromExpander_(this.heapProfileExpander, idPrefix);
        importer = new HeapDumpTraceEventImporter(this.heapProfileExpander,
            this.model_.stackFrames, processMemoryDump, idPrefix, this.model_);
      }

      if (!importer) return;

      const heapDumps = importer.parse();
      if (!heapDumps) return;

      if (processMemoryDump.heapDumps !== undefined) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'Heap dumps provided multiple times for' +
              ' process memory dump for PID=' + pid +
              ' and dump ID=' + dumpId + '.'
        });
        return;
      }

      if (Object.keys(heapDumps).length > 0) {
        processMemoryDump.heapDumps = heapDumps;
      }
    },

    addNewStackFramesFromExpander_(expander, idPrefix) {
      const nodeMap = expander.getNewMap('nodes');
      const newStackFrames = {};
      for (const [id, stackFrame] of nodeMap.entries()) {
        if (!this.model_.stackFrames[idPrefix + id]) {
          newStackFrames[id] = {
            id,
            name: expander.getString(stackFrame.name_sid),
          };
          if (stackFrame.parent) newStackFrames[id].parent = stackFrame.parent;
        }
      }
      this.importStackFrames_(newStackFrames, idPrefix);
    },

    parseMemoryDumpLevelOfDetail_(levelsOfDetail, dumps, pid,
        dumpId) {
      const rawLevelOfDetail = dumps.level_of_detail;
      let level;
      switch (rawLevelOfDetail) {
        case 'background':
          level = BACKGROUND;
          break;
        case 'light':
          level = LIGHT;
          break;
        case 'detailed':
          level = DETAILED;
          break;
        case undefined:
          level = undefined;
          break;
        default:
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: 'unknown raw level of detail \'' + rawLevelOfDetail +
                '\' of process memory dump for PID=' + pid +
                ' and dump ID=' + dumpId + '.'
          });
          return;
      }

      if (!this.updateMemoryDumpLevelOfDetail_(
          levelsOfDetail, 'process', level)) {
        this.model_.importWarning({
          type: 'memory_dump_parse_error',
          message: 'diffent levels of detail provided for process memory' +
              ' dump for PID=' + pid + ' (dump ID=' + dumpId + ').'
        });
      }
    },

    updateMemoryDumpLevelOfDetail_(levelsOfDetail, scope, level) {
      // If all process memory dump events have the same level of detail (for
      // the particular 'process' or 'global' scope), return true.
      if (!(scope in levelsOfDetail) || level === levelsOfDetail[scope]) {
        levelsOfDetail[scope] = level;
        return true;
      }

      // If the process memory dump events have different levels of detail (for
      // the particular 'process' or 'global' scope), use the highest level and
      // return false.
      if (MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(level) >
          MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(levelsOfDetail[scope])) {
        levelsOfDetail[scope] = level;
      }
      return false;
    },

    parseMemoryDumpAllocatorDumps_(processMemoryDump,
        globalMemoryDump, processMemoryAllocatorDumpsByFullName,
        globalMemoryAllocatorDumpsByFullName, allMemoryAllocatorDumpsByGuid,
        dumps, pid, dumpId) {
      const rawAllocatorDumps = dumps.allocators;
      if (rawAllocatorDumps === undefined) return;

      // Construct the MemoryAllocatorDump objects without parent links
      // and add them to the processMemoryAllocatorDumpsByName and
      // globalMemoryAllocatorDumpsByName indices appropriately.
      for (let fullName in rawAllocatorDumps) {
        const rawAllocatorDump = rawAllocatorDumps[fullName];

        // Every memory allocator dump should have a GUID. If not, then
        // it cannot be associated with any edges.
        const guid = rawAllocatorDump.guid;
        if (guid === undefined) {
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Memory allocator dump ' + fullName + ' for PID=' + pid +
                ' and dump ID=' + dumpId + ' does not have a GUID.'
          });
        }

        // A memory allocator dump can have optional flags.
        const flags = rawAllocatorDump.flags || 0;
        const isWeakDump = !!(flags & WEAK_MEMORY_ALLOCATOR_DUMP_FLAG);

        // Determine if this is a global memory allocator dump (check if
        // it's prefixed with 'global/').
        let containerMemoryDump;
        let dstIndex;
        if (fullName.startsWith(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX)) {
          // Global memory allocator dump.
          fullName = fullName.substring(
              GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX.length);
          containerMemoryDump = globalMemoryDump;
          dstIndex = globalMemoryAllocatorDumpsByFullName;
        } else {
          // Process memory allocator dump.
          containerMemoryDump = processMemoryDump;
          dstIndex = processMemoryAllocatorDumpsByFullName;
        }

        // Construct or retrieve a memory allocator dump with the provided
        // GUID.
        let allocatorDump = allMemoryAllocatorDumpsByGuid[guid];
        if (allocatorDump === undefined) {
          if (fullName in dstIndex) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Multiple GUIDs provided for' +
                  ' memory allocator dump ' + fullName + ': ' +
                  dstIndex[fullName].guid + ', ' + guid + ' (ignored) for' +
                  ' PID=' + pid + ' and dump ID=' + dumpId + '.'
            });
            continue;
          }
          allocatorDump = new tr.model.MemoryAllocatorDump(
              containerMemoryDump, fullName, guid);
          allocatorDump.weak = isWeakDump;
          dstIndex[fullName] = allocatorDump;
          if (guid !== undefined) {
            allMemoryAllocatorDumpsByGuid[guid] = allocatorDump;
          }
        } else {
          // A memory allocator dump with this GUID has already been
          // dumped (so we will only add new attributes). Check that it
          // belonged to the same process or was also global.
          if (allocatorDump.containerMemoryDump !== containerMemoryDump) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Memory allocator dump ' + fullName +
                ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                dumpId + ' dumped in different contexts.'
            });
            continue;
          }
          // Check that the names of the memory allocator dumps match.
          if (allocatorDump.fullName !== fullName) {
            this.model_.importWarning({
              type: 'memory_dump_parse_error',
              message: 'Memory allocator dump with GUID=' + guid + ' for PID=' +
                pid + ' and dump ID=' + dumpId + ' has multiple names: ' +
                allocatorDump.fullName + ', ' + fullName + ' (ignored).'
            });
            continue;
          }
          if (!isWeakDump) {
            // A MemoryAllocatorDump is non-weak if at least one process dumped
            // it without WEAK_MEMORY_ALLOCATOR_DUMP_FLAG.
            allocatorDump.weak = false;
          }
        }

        // Add all new attributes to the memory allocator dump.
        let attributes = rawAllocatorDump.attrs;
        if (attributes === undefined) {
          this.model_.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Memory allocator dump ' + fullName + ' (GUID=' + guid +
                ') for PID=' + pid + ' and dump ID=' + dumpId +
                ' does not have attributes.'
          });
          attributes = {};
        }

        for (const attrName in attributes) {
          const attrArgs = attributes[attrName];
          const attrType = attrArgs.type;
          const attrValue = attrArgs.value;

          switch (attrType) {
            case 'scalar': {
              if (attrName in allocatorDump.numerics) {
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Multiple values provided for scalar attribute ' +
                    attrName + ' of memory allocator dump ' + fullName +
                    ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                    dumpId + '.'
                });
                break;
              }
              const unit = attrArgs.units === 'bytes' ?
                  tr.b.Unit.byName.sizeInBytes_smallerIsBetter :
                  tr.b.Unit.byName.unitlessNumber_smallerIsBetter;
              const value = parseInt(attrValue, 16);
              allocatorDump.addNumeric(attrName,
                  new tr.b.Scalar(unit, value));
              break;
            }

            case 'string':
              if (attrName in allocatorDump.diagnostics) {
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Multiple values provided for string attribute ' +
                    attrName + ' of memory allocator dump ' + fullName +
                    ' (GUID=' + guid + ') for PID=' + pid + ' and dump ID=' +
                    dumpId + '.'
                });
                break;
              }
              allocatorDump.addDiagnostic(attrName, attrValue);
              break;

            default:
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Unknown type provided for attribute ' + attrName +
                  ' of memory allocator dump ' + fullName + ' (GUID=' + guid +
                  ') for PID=' + pid + ' and dump ID=' + dumpId + ': ' +
                  attrType
              });
              break;
          }
        }
      }
    },

    inferMemoryAllocatorDumpTree_(memoryAllocatorDumpsByFullName) {
      const rootAllocatorDumps = [];

      const fullNames = Object.keys(memoryAllocatorDumpsByFullName);
      fullNames.sort();
      for (let i = 0; i < fullNames.length; i++) {
        let fullName = fullNames[i];
        let allocatorDump = memoryAllocatorDumpsByFullName[fullName];

        // This is a loop because we might need to build implicit
        // ancestors in case they were not present in the trace.
        while (true) {
          const lastSlashIndex = fullName.lastIndexOf('/');
          if (lastSlashIndex === -1) {
            // If the dump is a root, add it to the top-level
            // rootAllocatorDumps list.
            rootAllocatorDumps.push(allocatorDump);
            break;
          }

          // If the dump is not a root, find its parent.
          const parentFullName = fullName.substring(0, lastSlashIndex);
          let parentAllocatorDump =
              memoryAllocatorDumpsByFullName[parentFullName];

          // If the parent dump does not exist yet, we build an implicit
          // one and continue up the ancestor chain.
          let parentAlreadyExisted = true;
          if (parentAllocatorDump === undefined) {
            parentAlreadyExisted = false;
            parentAllocatorDump = new tr.model.MemoryAllocatorDump(
                allocatorDump.containerMemoryDump, parentFullName);
            if (allocatorDump.weak !== false) {
              // If we are inferring a parent dump (e.g. 'root/parent') of a
              // current dump (e.g. 'root/parent/current') which is weak (or
              // was also inferred and we don't know yet whether it's weak or
              // not), then we clear the weak flag on the parent dump because
              // we don't know yet whether it should be weak or non-weak:
              //
              //   * We can't mark the parent as non-weak straightaway because
              //     the parent might have no non-weak descendants (in which
              //     case we want the inferred parent to be weak, so that it
              //     would be later removed like the current dump).
              //   * We can't mark the parent as weak immediately either. If we
              //     did and later encounter a non-weak child of the parent
              //     (e.g. 'root/parent/another_child'), then we couldn't
              //     retroactively mark the inferred parent dump as non-weak
              //     because we couldn't tell whether the parent dump was
              //     dumped in the trace as weak (in which case it should stay
              //     weak and be subsequently removed) or whether it was
              //     inferred as weak (in which case it should be changed to
              //     non-weak).
              //
              // Therefore, we defer marking the inferred parent as
              // weak/non-weak. If an inferred parent dump does not have any
              // non-weak child, it will be marked as weak at the end of this
              // method.
              //
              // Note that this should not be confused with the recursive
              // propagation of the weak flag from parent dumps to their
              // children and from owned dumps to their owners, which is
              // performed in GlobalMemoryDump.prototype.removeWeakDumps().
              parentAllocatorDump.weak = undefined;
            }
            memoryAllocatorDumpsByFullName[parentFullName] =
                parentAllocatorDump;
          }

          // Setup the parent <-> children relationships
          allocatorDump.parent = parentAllocatorDump;
          parentAllocatorDump.children.push(allocatorDump);

          // If the parent already existed, then its ancestors were/will be
          // constructed in another iteration of the forEach loop.
          if (parentAlreadyExisted) {
            if (!allocatorDump.weak) {
              // If the current dump is non-weak, then we must ensure that all
              // its inferred ancestors are also non-weak.
              while (parentAllocatorDump !== undefined &&
                     parentAllocatorDump.weak === undefined) {
                parentAllocatorDump.weak = false;
                parentAllocatorDump = parentAllocatorDump.parent;
              }
            }
            break;
          }

          fullName = parentFullName;
          allocatorDump = parentAllocatorDump;
        }
      }

      // All inferred ancestor dumps that have a non-weak child have already
      // been marked as non-weak. We now mark the rest as weak.
      for (const fullName in memoryAllocatorDumpsByFullName) {
        const allocatorDump = memoryAllocatorDumpsByFullName[fullName];
        if (allocatorDump.weak === undefined) {
          allocatorDump.weak = true;
        }
      }

      return rootAllocatorDumps;
    },

    parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid,
        dumpIdEvents, dumpId) {
      for (const pid in dumpIdEvents) {
        const processEvents = dumpIdEvents[pid];

        for (let i = 0; i < processEvents.length; i++) {
          const processEvent = processEvents[i];

          const dumps = processEvent.args.dumps;
          if (dumps === undefined) continue;

          const rawEdges = dumps.allocators_graph;
          if (rawEdges === undefined) continue;

          for (let j = 0; j < rawEdges.length; j++) {
            const rawEdge = rawEdges[j];

            const sourceGuid = rawEdge.source;
            const sourceDump = allMemoryAllocatorDumpsByGuid[sourceGuid];
            if (sourceDump === undefined) {
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Edge for PID=' + pid + ' and dump ID=' + dumpId +
                    ' is missing source memory allocator dump (GUID=' +
                    sourceGuid + ').'
              });
              continue;
            }

            const targetGuid = rawEdge.target;
            const targetDump = allMemoryAllocatorDumpsByGuid[targetGuid];
            if (targetDump === undefined) {
              this.model_.importWarning({
                type: 'memory_dump_parse_error',
                message: 'Edge for PID=' + pid + ' and dump ID=' + dumpId +
                    ' is missing target memory allocator dump (GUID=' +
                    targetGuid + ').'
              });
              continue;
            }

            const importance = rawEdge.importance;
            const edge = new tr.model.MemoryAllocatorDumpLink(
                sourceDump, targetDump, importance);

            switch (rawEdge.type) {
              case 'ownership':
                if (sourceDump.owns !== undefined) {
                  this.model_.importWarning({
                    type: 'memory_dump_parse_error',
                    message: 'Memory allocator dump ' + sourceDump.fullName +
                        ' (GUID=' + sourceGuid + ') already owns a memory' +
                        ' allocator dump (' +
                        sourceDump.owns.target.fullName + ').'
                  });
                } else {
                  sourceDump.owns = edge;
                  targetDump.ownedBy.push(edge);
                }
                break;

              case 'retention':
                sourceDump.retains.push(edge);
                targetDump.retainedBy.push(edge);
                break;

              default:
                this.model_.importWarning({
                  type: 'memory_dump_parse_error',
                  message: 'Invalid edge type: ' + rawEdge.type +
                      ' (PID=' + pid + ', dump ID=' + dumpId +
                      ', source=' + sourceGuid + ', target=' + targetGuid +
                      ', importance=' + importance + ').'
                });
            }
          }
        }
      }
    },

    /**
     * Converts |ts| (in microseconds) to a timestamp in the model clock domain
     * (in milliseconds).
     */
    toModelTimeFromUs_(ts) {
      if (!this.toModelTime_) {
        this.toModelTime_ =
            this.model_.clockSyncManager.getModelTimeTransformer(
                this.clockDomainId_);
      }

      return this.toModelTime_(tr.b.Unit.timestampFromUs(ts));
    },

    /**
     * Converts |ts| (in microseconds) to a timestamp in the model clock domain
     * (in milliseconds). If |ts| is undefined, undefined is returned.
     */
    maybeToModelTimeFromUs_(ts) {
      if (ts === undefined) {
        return undefined;
      }

      return this.toModelTimeFromUs_(ts);
    }
  };

  tr.importer.Importer.register(TraceEventImporter);

  return {
    TraceEventImporter,
  };
});


'use strict';

tr.exportTo('tr.e.measure', function() {
  const AsyncSlice = tr.model.AsyncSlice;

  function MeasureAsyncSlice() {
    this.groupTitle_ = 'Ungrouped Measure';
    const matched = /([^\/:]+):([^\/:]+)\/?(.*)/.exec(arguments[1]);
    if (matched !== null) {
      arguments[1] = matched[2];
      this.groupTitle_ = matched[1];
    }
    AsyncSlice.apply(this, arguments);
  }

  MeasureAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    get viewSubGroupTitle() {
      return this.groupTitle_;
    },

    get title() {
      return this.title_;
    },

    set title(title) {
      this.title_ = title;
    }
  };

  AsyncSlice.subTypes.register(
      MeasureAsyncSlice,
      {
        categoryParts: ['blink.user_timing']
      });

  return {
    MeasureAsyncSlice,
  };
});


'use strict';

tr.exportTo('tr.e.net', function() {
  const AsyncSlice = tr.model.AsyncSlice;

  function NetAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    this.url_ = undefined;
    this.byteCount_ = undefined;
    // Boolean variables indicating whether we have computed corresponding
    // fields. Computing these fields needs iteration through all sub-slices and
    // so recomputation will be costly.
    this.isTitleComputed_ = false;
    this.isUrlComputed_ = false;
  }

  NetAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    get viewSubGroupTitle() {
      return 'NetLog';
    },

    get title() {
      if (this.isTitleComputed_ || !this.isTopLevel) {
        return this.title_;
      }

      if (this.url !== undefined && this.url.length > 0) {
        // Set the title so we do not have to recompute when it is redrawn.
        this.title_ = this.url;
      } else if (this.args !== undefined &&
                 this.args.source_type !== undefined) {
        // We do not have a URL, use the source type as the title.
        this.title_ = this.args.source_type;
      }
      this.isTitleComputed_ = true;
      return this.title_;
    },

    set title(title) {
      this.title_ = title;
    },

    // A recursive helper function that gets the url param of a slice or its
    // nested subslices if there is one.
    get url() {
      if (this.isUrlComputed_) {
        return this.url_;
      }
      if (this.args !== undefined && this.args.params !== undefined &&
          this.args.params.url !== undefined) {
        this.url_ = this.args.params.url;
      } else if (this.subSlices !== undefined && this.subSlices.length > 0) {
        for (let i = 0; i < this.subSlices.length && ! this.url_; i++) {
          if (this.subSlices[i].url !== undefined) {
            this.url_ = this.subSlices[i].url;
          }
        }
      }
      this.isUrlComputed_ = true;
      return this.url_;
    },

    get byteCount() {
      if (this.byteCount_ !== undefined) {
        return this.byteCount_;
      }

      this.byteCount_ = 0;
      if ((this.originalTitle === 'URL_REQUEST_JOB_FILTERED_BYTES_READ' ||
           this.originalTitle === 'URL_REQUEST_JOB_BYTES_READ') &&
           this.args !== undefined && this.args.params !== undefined &&
           this.args.params.byte_count !== undefined) {
        this.byteCount_ = this.args.params.byte_count;
      }
      for (let i = 0; i < this.subSlices.length; i++) {
        this.byteCount_ += this.subSlices[i].byteCount;
      }
      return this.byteCount_;
    }
  };

  AsyncSlice.subTypes.register(
      NetAsyncSlice,
      {
        categoryParts: ['netlog', 'disabled-by-default-netlog']
      });

  return {
    NetAsyncSlice,
  };
});


'use strict';

/**
 * @fileoverview Base class for linux perf event parsers.
 *
 * The linux perf trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. SchedParser implements
 * parsing of sched:* kernel trace events.  Parser subclasses must
 * call Parser.register to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tr.e.importer.linux_perf.Parser;
 *
 * function WorkqueueParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler('workqueue_execute_start',
 *       WorkqueueParser.prototype.executeStartEvent.bind(this));
 *   importer.registerEventHandler('workqueue_execute_end',
 *       WorkqueueParser.prototype.executeEndEvent.bind(this));
 * }
 *
 * Parser.register(WorkqueueParser);
 *
 * When a registered event name is found in the data stream the associated
 * event handler is invoked:
 *
 *   executeStartEvent: function(eventName, cpuNumber, ts, eventBase)
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.model.importWarning.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 * Trace events generated by writing to the trace_marker file are expected
 * to have a leading text marker followed by a ':'; e.g. the trace clock
 * synchronization event is:
 *
 *  tracing_mark_write: trace_event_clock_sync: parent_ts=0
 *
 * To register an event handler for these events, prepend the marker with
 * 'tracing_mark_write:'; e.g.
 *
 *    this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
 *
 * All subclasses should depend on importer.linux_perf.parser, e.g.
 *
 * tr.defineModule('importer.linux_perf.workqueue_parser')
 *   .dependsOn('importer.linux_perf.parser')
 *   .exportsTo('tracing', function()
 *
 * and be listed in the dependsOn of FTraceImporter.  Beware that after adding a
 * new subclass you must run build/generate_about_tracing_contents.py to
 * regenerate tr.ui.e.about_tracing.*.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  /**
   * Parses linux perf events.
   * @constructor
   */
  function Parser(importer) {
    this.importer = importer;
    this.model = importer.model;
  }

  Parser.prototype = {
    __proto__: Object.prototype
  };

  const options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.mandatoryBaseClass = Parser;
  tr.b.decorateExtensionRegistry(Parser, options);

  return {
    Parser,
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function AndroidParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('tracing_mark_write:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));
    importer.registerEventHandler('0:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  function parseArgs(argsString) {
    const args = {};
    if (argsString) {
      const argsArray = argsString.split(';');
      for (let i = 0; i < argsArray.length; ++i) {
        const parts = argsArray[i].split('=');
        if (parts[0]) {
          args[parts.shift()] = parts.join('=');
        }
      }
    }
    return args;
  }

  AndroidParser.prototype = {
    __proto__: Parser.prototype,

    openAsyncSlice(thread, category, name, cookie, ts, args) {
      const asyncSliceConstructor =
         tr.model.AsyncSlice.subTypes.getConstructor(
             category, name);
      const slice = new asyncSliceConstructor(
          category, name,
          ColorScheme.getColorIdForGeneralPurposeString(name), ts, args);
      const key = category + ':' + name + ':' + cookie;
      slice.id = cookie;
      slice.startThread = thread;

      if (!this.openAsyncSlices) {
        this.openAsyncSlices = { };
      }
      this.openAsyncSlices[key] = slice;
    },

    closeAsyncSlice(thread, category, name, cookie, ts, args) {
      if (!this.openAsyncSlices) {
        // No async slices have been started.
        return;
      }

      const key = category + ':' + name + ':' + cookie;
      const slice = this.openAsyncSlices[key];
      if (!slice) {
        // No async slices w/ this key have been started.
        return;
      }

      for (const arg in args) {
        if (slice.args[arg] !== undefined) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Both the S and F events of ' + slice.title +
                ' provided values for argument ' + arg + '.' +
                ' The value of the F event will be used.'
          });
        }
        slice.args[arg] = args[arg];
      }

      slice.endThread = thread;
      slice.duration = ts - slice.start;
      slice.startThread.asyncSliceGroup.push(slice);
      delete this.openAsyncSlices[key];
    },

    traceMarkWriteAndroidEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const eventData = eventBase.details.split('|');
      switch (eventData[0]) {
        case 'B': {
          const ppid = parseInt(eventData[1]);
          const title = eventData[2];
          const args = parseArgs(eventData[3]);
          let category = eventData[4];
          if (category === undefined) category = 'android';

          const thread = this.model_.getOrCreateProcess(ppid)
              .getOrCreateThread(pid);
          thread.name = eventBase.threadName;
          if (!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)) {
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Timestamps are moving backward.'
            });
            return false;
          }

          this.ppids_[pid] = ppid;
          thread.sliceGroup.beginSlice(category, title, ts, args);

          break;
        }

        case 'E': {
          const ppid = this.ppids_[pid];
          if (ppid === undefined) {
            // Silently ignore unmatched E events.
            break;
          }

          const thread = this.model_.getOrCreateProcess(ppid)
              .getOrCreateThread(pid);
          if (!thread.sliceGroup.openSliceCount) {
            // Silently ignore unmatched E events.
            break;
          }

          const slice = thread.sliceGroup.endSlice(ts);

          const args = parseArgs(eventData[3]);
          for (const arg in args) {
            if (slice.args[arg] !== undefined) {
              this.model_.importWarning({
                type: 'parse_error',
                message: 'Both the B and E events of ' + slice.title +
                    ' provided values for argument ' + arg + '.' +
                    ' The value of the E event will be used.'
              });
            }
            slice.args[arg] = args[arg];
          }

          break;
        }

        case 'C': {
          const ppid = parseInt(eventData[1]);
          const name = eventData[2];
          const value = parseInt(eventData[3]);
          let category = eventData[4];
          if (category === undefined) category = 'android';

          const ctr = this.model_.getOrCreateProcess(ppid)
              .getOrCreateCounter(category, name);
          // Initialize the counter's series fields if needed.
          if (ctr.numSeries === 0) {
            ctr.addSeries(new tr.model.CounterSeries(value,
                ColorScheme.getColorIdForGeneralPurposeString(
                    ctr.name + '.' + 'value')));
          }

          ctr.series.forEach(function(series) {
            series.addCounterSample(ts, value);
          });

          break;
        }

        case 'S': {
          const ppid = parseInt(eventData[1]);
          const name = eventData[2];
          const cookie = parseInt(eventData[3]);
          const args = parseArgs(eventData[4]);
          let category = eventData[5];
          if (category === undefined) category = 'android';

          const thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          thread.name = eventBase.threadName;

          this.ppids_[pid] = ppid;
          this.openAsyncSlice(thread, category, name, cookie, ts, args);

          break;
        }

        case 'F': {
          // Note: An async slice may end on a different thread from the one
          // that started it so this thread may not have been seen yet.
          const ppid = parseInt(eventData[1]);

          const name = eventData[2];
          const cookie = parseInt(eventData[3]);
          const args = parseArgs(eventData[4]);
          let category = eventData[5];
          if (category === undefined) category = 'android';

          const thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          thread.name = eventBase.threadName;

          this.ppids_[pid] = ppid;
          this.closeAsyncSlice(thread, category, name, cookie, ts, args);

          break;
        }

        default:
          return false;
      }

      return true;
    }
  };

  Parser.register(AndroidParser);

  return {
    AndroidParser,
  };
});


'use strict';

/**
 * @fileoverview Parses Binder events
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  // Matches binder transactions:
  // transaction=%d dest_node=%d dest_proc=%d dest_thread=%d reply=%d flags=0x%x
  // code=0x%x
  const binderTransRE = new RegExp('transaction=(\\d+) dest_node=(\\d+) ' +
                                 'dest_proc=(\\d+) dest_thread=(\\d+) ' +
                                 'reply=(\\d+) flags=(0x[0-9a-fA-F]+) ' +
                                 'code=(0x[0-9a-fA-F]+)');

  const binderTransReceivedRE = /transaction=(\d+)/;

  function isBinderThread(name) {
    return (name.indexOf('Binder') > -1);
  }

  // Taken from kernel source: include/uapi/linux/android/binder.h.
  const TF_ONE_WAY = 0x01;
  const TF_ROOT_OBJECT = 0x04;
  const TF_STATUS_CODE = 0x08;
  const TF_ACCEPT_FDS = 0x10;
  const NO_FLAGS = 0;

  function binderFlagsToHuman(num) {
    const flag = parseInt(num, 16);
    let str = '';

    if (flag & TF_ONE_WAY) {
      str += 'this is a one-way call: async, no return; ';
    }
    if (flag & TF_ROOT_OBJECT) {
      str += 'contents are the components root object; ';
    }
    if (flag & TF_STATUS_CODE) {
      str += 'contents are a 32-bit status code; ';
    }
    if (flag & TF_ACCEPT_FDS) {
      str += 'allow replies with file descriptors; ';
    }
    if (flag === NO_FLAGS) {
      str += 'No Flags Set';
    }

    return str;
  }

  function isReplyToOrigin(calling, called) {
    return (called.dest_proc === calling.calling_pid ||
            called.dest_thread === calling.calling_pid);
  }

  function binderCodeToHuman(code) {
    return 'Java Layer Dependent';
  }

  function doInternalSlice(trans, slice, ts) {
    if (slice.subSlices.length !== 0) {
      /* We want to make sure we keep moving the small slice to the end of
         the big slice or else the arrows will not point to the end.
      */
      slice.subSlices[0].start = ts;
      return slice.subSlices[0];
    }
    const kthread = trans.calling_kthread.thread;
    const internalSlice = kthread.sliceGroup.pushCompleteSlice('binder',
        slice.title,
        ts, .001, 0, 0,
        slice.args);

    internalSlice.title = slice.title;
    internalSlice.id = slice.id;
    internalSlice.colorId = slice.colorId;
    slice.subSlices.push(internalSlice);
    return internalSlice;
  }

  function generateBinderArgsForSlice(trans, cThreadName) {
    return {
      'Transaction Id': trans.transaction_key,
      'Destination Node': trans.dest_node,
      'Destination Process': trans.dest_proc,
      'Destination Thread': trans.dest_thread,
      'Destination Name': cThreadName,
      'Reply transaction?': trans.is_reply_transaction,
      'Flags': trans.flags + ' ' +
           binderFlagsToHuman(trans.flags),

      'Code': trans.code + ' ' +
           binderCodeToHuman(trans.code),

      'Calling PID': trans.calling_pid,
      'Calling tgid': trans.calling_kthread.thread.parent.pid
    };
  }

  /** @constructor */
  function BinderTransaction(events, callingPid, callingTs, callingKthread) {
    this.transaction_key = parseInt(events[1]);
    this.dest_node = parseInt(events[2]);
    this.dest_proc = parseInt(events[3]);
    this.dest_thread = parseInt(events[4]);
    this.is_reply_transaction = parseInt(events[5]) === 1 ? true : false;
    this.expect_reply = ((this.is_reply_transaction === false) &&
        (parseInt(events[6], 16) & TF_ONE_WAY) === 0);

    this.flags = events[6];
    this.code = events[7];
    this.calling_pid = callingPid;
    this.calling_ts = callingTs;
    this.calling_kthread = callingKthread;
  }


  /** @constructor */
  function BinderParser(importer) {
    Parser.call(this, importer);
    importer.registerEventHandler('binder_locked',
        BinderParser.prototype.
            binderLocked.bind(this));
    importer.registerEventHandler('binder_unlock',
        BinderParser.prototype.
            binderUnlock.bind(this));
    importer.registerEventHandler('binder_lock',
        BinderParser.prototype.binderLock.bind(this));
    importer.registerEventHandler('binder_transaction',
        BinderParser.prototype.
            binderTransaction.bind(this));
    importer.registerEventHandler('binder_transaction_received',
        BinderParser.prototype.
            binderTransactionReceived.bind(this));

    this.model_ = importer.model;
    this.kthreadlookup = {};
    this.importer_ = importer;
    this.transWaitingRecv = {};
    this.syncTransWaitingCompletion = {};
    this.recursiveSyncTransWaitingCompletion_ByPID = {};
    this.receivedTransWaitingConversion = {};
  }

  BinderParser.prototype = {
    __proto__: Parser.prototype,

    binderLock(eventName, cpuNumber, pid, ts, eventBase) {
      const tgid = parseInt(eventBase.tgid);
      if (isNaN(tgid)) return false;

      this.doNameMappings(pid, tgid, eventName.threadName);

      const kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      kthread.binderAttemptLockTS = ts;
      kthread.binderOpenTsA = ts;
      return true;
    },

    binderLocked(eventName, cpuNumber, pid, ts, eventBase) {
      const tgid = parseInt(eventBase.tgid);
      if (isNaN(tgid)) return false;

      const binderThread = isBinderThread(eventBase.threadName);
      const name = eventBase.threadName;

      const kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      this.doNameMappings(pid, tgid, name);

      const rthread = kthread.thread;
      kthread.binderLockAquiredTS = ts;

      if (kthread.binderAttemptLockTS === undefined) return false;

      const args = this.generateArgsForSlice(tgid, pid, name, kthread);
      rthread.sliceGroup.pushCompleteSlice('binder', 'binder lock waiting',
          kthread.binderAttemptLockTS,
          ts - kthread.binderAttemptLockTS,
          0, 0, args);

      kthread.binderAttemptLockTS = undefined;
      return true;
    },

    binderUnlock(eventName, cpuNumber, pid, ts, eventBase) {
      const tgid = parseInt(eventBase.tgid);
      if (isNaN(tgid)) return false;

      const kthread = this.importer_.
          getOrCreateBinderKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.binderLockAquiredTS === undefined) return false;

      const args = this.generateArgsForSlice(tgid, pid, eventBase.threadName,
          kthread);
      kthread.thread.sliceGroup.pushCompleteSlice(
          'binder',
          'binder lock held',
          kthread.binderLockAquiredTS,
          ts - kthread.binderLockAquiredTS,
          0, 0, args);

      kthread.binderLockAquiredTS = undefined;
      return true;
    },

    /** There are a few transaction status changes that signify
     *  progress through a binder transaction:
     *
     * Case One: Sync transaction.
     *  Thread A calls a blocking function on Thread B. We receive a
     *  binder_transaction msg From thread A stating that it is going to Call
     *  thread B. We create a slice and a binder object for this transaction and
     *  add it to addTransactionWaitingForRecv(transaction key, binder object)
     *  This notifies thread B and passes the slice, binder object and time
     *  stamp.
     *
     * Case Two: Async transaction.
     *  Thread A calls an async function on Thread B. Like above we receive a
     *  binder_transaction message, but the flags differ from above. The
     *  TF_ONEWAY flags are set so we know that when Thread B gets the
     *  binder_transaction_received with the same transaciton key the total
     *  transaction is complete.
     *
     * Case Three: 'Prior_receive'
     *  Prior_receive occurs when the thread being called (think A calls B),
     *  receives a binder_transaction_received message, but cannot correlate it
     *  to any current outstanding recursive transactions. That means the
     *  message it just received is the start of some communication, not some
     *  ongoing communication.
     *  Once the execution flow has been passed to thread B, from A:
     *  Thread B enters binder_transaction_received() we see that Thread A
     *  had notified us that it sent us a message by calling
     *  getTransactionWaitingForRecv(transaction key);
     *  What can happen now is either this was a simple Call reply,
     *  or this is a call -> recursion -> reply. We call modelPriorReceive()
     *  which sets up the slices accordingly.
     *  If this is a call -> recursion -> reply
     *  we will go to case 4 by calling addRecursiveSyncTransNeedingCompletion()
     *  The function takes B's PID, the binder object from A and the current
     *  binder object from B. This function adds outstanding non-complete
     *  transactions to a stack on thread B.
     *
     * Case Four: 'recursiveTrans'
     *  This case follows Like above:
     *  A sent binder_transaction
     *  B got binder_transaction_received
     *  B instead of replying to A can Call C or call 'into' A, ie recursion
     *  Case four also deals with setting up a large slice to 'contain'
     *  all the recursive transactions that happen until B finally replies to
     *  A.
     *
     *
     * An example: A-> B-> C-> B-> A
     *
     * (1) A starts a synchronous transaction to B.
     * (2) A enters binderTransaction() event handler, hits the else statement
     * (3) A calls addTransactionWaitingForRecv(trans key, object) to notify
     *     Thread B.
     * (4) B Enters binderTransactionReceived().
     * (5) B hits the second if after calling
     *     getTransactionWaitingForRecv(trans key)
     *     This function returns us the object set up in step (3).
     * (6) This is not an async transaction, B calls
     *      setCurrentReceiveOnPID(B's PID, [ts for (4), object from (3)]).
     *
     * (7) B enters binderTransaction() event handler, first if triggers after
     *     calling getPriorReceiveOnPID(B's PID) the tuple from (6) is returned.
     *
     * (8) Execution enters modelPriorReceive().
     * (8a) A slice is setup for this binder transaction in B's timeline.
     * (9) This is not a reply to thread A, B is going to call Thread C.
     * (10) else statement is hit.
     * (11) We set the tile from (8a) to be binder_reply this is the
     *     'containg slice' for the recursion
     * (12) We create a new slice 'binder_transaction' this slice is the
     *      recursive slice that will have arrows to Thread C's slice.
     * (13) addRecursiveSyncTransNeedingCompletion(B's PID,
     *                                            [obj from (3), obj from 7])
     *      this sets up notification that B's pid has outstanding recursive
     *      transactions that need to be completed.
     * (14) B notifies C that a transaction is waiting for it by calling
     *      addTransactionWaitingForRecv like in step (3).
     * (15) C enters binderTransactionReceived() step 5 6 7 8 8a happen, but in
     *      the context of Thread C.
     * (16) C is in modelPriorReceive(), it hits the first if statement,
     *      this transaction _IS_ a reply, and it is a reply to B.
     * (17) C calls addSyncTransNeedingCompletion(trans key,
     *                                       [object from(3), object from 15-5])
     * (18) B enters binderTransactionReceived() hits the first if after calling
     *      getSyncTransNeedingCompletion(trans key from (17)) the tuple from
     *     (17) gets returned.
     *
     * (19) B scales up the slice created in (12) and sets up flows from 15-8a
     *      slice.
     * (20) B enters BinderTransaction() event handler and the second if is hit
     *      after calling getRecursiveTransactionNeedingCompletion(B's pid).
     * (21) modelRecursiveTransactions() gets called, first if executes.
     * (22) slice durations are fixed up.
     * (23) B notifies A via
     *      addSyncTransNeedingCompletion(trans key, binder obj from 8a).
     * (24) B deletes the outstanding asynctrans via
     (      removeRecursiveTransaction(B's pid).
     * (25) A enters binderTransactionReceived() event handler and finishes up
     *      some flows, and slices.
     */
    binderTransaction(eventName, cpuNumber, pid, ts, eventBase) {
      const event = binderTransRE.exec(eventBase.details);
      if (event === undefined) return false;

      const tgid = parseInt(eventBase.tgid);
      if (isNaN(tgid)) return false;

      this.doNameMappings(pid, tgid, eventBase.threadName);

      const kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      const trans = new BinderTransaction(event, pid, ts, kthread);
      const args = generateBinderArgsForSlice(trans, eventBase.threadName);
      /**
       * This thread previously ack'd the transaction with a
       * transaction_received. That means someone sent us a message we processed
       * it and are now sending a transaction.
       * The transaction could be a response, or it could be recursive.
       */
      const priorReceive = this.getPriorReceiveOnPID(pid);

      if (priorReceive !== false) {
        return this.modelPriorReceive(priorReceive, ts, pid, tgid, kthread,
            trans, args, event);
      }
      /**
       * This Thread has an already established recursive slice. We will now
       * either complete the entire transaction, OR do more recursive calls.
       */
      const recursiveTrans = this.getRecursiveTransactionNeedingCompletion(pid);

      if (recursiveTrans !== false) {
        return this.modelRecursiveTransactions(recursiveTrans, ts, pid,
            kthread, trans, args);
      }

      /**
       * Start of a Transaction. This thread is the initiator of either a call
       * response, an async call -> ack, or a call -> recursion -> response.
       * Note, we put a fake duration into this slice and patch it up later.
       */
      const slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
          '', ts, .03, 0, 0, args);

      slice.colorId = ColorScheme.getColorIdForGeneralPurposeString(
          ts.toString());
      trans.slice = slice;

      if (trans.expect_reply) {
        slice.title = 'binder transaction';
      } else {
        slice.title = 'binder transaction async';
      }

      this.addTransactionWaitingForRecv(trans.transaction_key, trans);

      return true;
    },

    binderTransactionReceived(eventName, cpuNumber, pid, ts,
        eventBase) {
      const event = binderTransReceivedRE.exec(eventBase.details);
      if (event === undefined) return false;
      const tgid = parseInt(eventBase.tgid);
      if (isNaN(tgid)) return false;

      const transactionkey = parseInt(event[1]);
      const kthread = this.importer_.
          getOrCreateBinderKernelThread(eventBase.threadName, tgid, pid);

      const syncComplete = this.getSyncTransNeedsCompletion(transactionkey);

      if (syncComplete !== false) {
        /* This recv is the completion of a synchronous transaction.
         * We need to scale the slice up to the current ts and finish
         * creating some flows.
         */
        const syncTrans = syncComplete[0];
        const syncSlice = syncTrans.slice;
        const responseTrans = syncComplete[1];
        const responseSlice = responseTrans.slice;

        syncSlice.duration = ts - syncSlice.start;
        /** These calls are a little hack that places a very small slice at
         *  the end of the sync slice and the response slice. This allows us
         *  to hook flow events (arrows) from the start to the end of the
         *  slices.
         */
        const syncInternal = doInternalSlice(syncTrans, syncSlice, ts);
        const responseTs = responseSlice.start + responseSlice.duration;
        const responseInternal = doInternalSlice(responseTrans,
            responseSlice, responseTs);

        if (responseSlice.outFlowEvents.length === 0 ||
            syncSlice.inFlowEvents.length === 0) {
          const flow = this.generateFlow(responseInternal, syncInternal,
              responseTrans, syncTrans);

          syncSlice.inFlowEvents.push(flow);
          responseSlice.outFlowEvents.push(flow);
          this.model_.flowEvents.push(flow);
        }
        // Move flow arrows -- but not the first one.
        for (let i = 1; i < syncSlice.inFlowEvents.length; i++) {
          syncSlice.inFlowEvents[i].duration =
              ts - syncSlice.inFlowEvents[i].start;
        }
        return true;
      }

      const trForRecv = this.getTransactionWaitingForRecv(transactionkey);

      if (trForRecv !== false) {
        if (!trForRecv.expect_reply) {
          // This is an async call place an Async slice.
          const args = generateBinderArgsForSlice(trForRecv,
              eventBase.threadName);
          const slice = kthread.thread.sliceGroup.
              pushCompleteSlice('binder',
              'binder Async recv',
              ts, .03, 0, 0,
              args);

          const fakeEvent = [0, 0, 0, 0, 0, 0, 0];
          const fakeTrans = new BinderTransaction(fakeEvent, pid, ts, kthread);
          const flow = this.generateFlow(trForRecv.slice, slice,
              trForRecv, fakeTrans);

          this.model_.flowEvents.push(flow);
          trForRecv.slice.title = 'binder transaction async';
          trForRecv.slice.duration = .03;
          return true;
        }
        // Setup prior receive.
        trForRecv.slice.title = 'binder transaction';
        this.setCurrentReceiveOnPID(pid, [ts, trForRecv]);
        return true;
      }
      /** This case is when we received an ack for a transaction we have
       *  never seen before. This usually happens at the start of a trace.
       *  We will get incomplete transactions that started before started
       *  tracing. Just discard them.
       */
      return false;
    },

    // helper functions
    modelRecursiveTransactions(recursiveTrans, ts, pid, kthread,
        trans, args) {
      const recursiveSlice = recursiveTrans[1].slice;
      const origSlice = recursiveTrans[0].slice;
      recursiveSlice.duration = ts - recursiveSlice.start;
      trans.slice = recursiveSlice;

      if (trans.is_reply_transaction) {
        /* Case one:
         * This transaction is finally the reply of the recursion.
         */
        origSlice.duration = ts - origSlice.start;
        this.addSyncTransNeedingCompletion(trans.transaction_key,
            recursiveTrans);

        if (isReplyToOrigin(recursiveTrans[0], trans)) {
          this.removeRecursiveTransaction(pid);
        }
      } else {
        /**
         *  Case two:
         *  This transaction is more recursive calls.
         *  This is a nested call within an already started transaction,
         *  it can either be a async or a normal sync transaction.
         */
        const slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
            '', ts, .03, 0,
            0, args);

        trans.slice = slice;
        this.addTransactionWaitingForRecv(trans.transaction_key, trans);
      }
      return true;
    },

    modelPriorReceive(priorReceive, ts, pid, tgid, kthread, trans,
        args, event) {
      const calleeSlice = priorReceive[1].slice;
      const calleeTrans = priorReceive[1];
      const recvTs = priorReceive[0];
      let slice = kthread.thread.sliceGroup.pushCompleteSlice('binder',
          '', recvTs, ts - recvTs, 0, 0, args);

      const flow = this.generateFlow(calleeSlice, slice, calleeTrans, trans);
      this.model_.flowEvents.push(flow);
      trans.slice = slice;

      if (trans.is_reply_transaction) {
        /* This is a response to a synchronous or a recursive sync
         * transaction.
         */
        slice.title = 'binder reply';
        /* Notify this transaction key that when it recv's it is completing
         * a sync transaction.
         */
        this.addSyncTransNeedingCompletion(trans.transaction_key,
            [calleeTrans, trans]);
      } else {
        /**
         * Recursive calls and or calls around, either way it's not
         * going to complete a transaction.
         */
        slice.title = 'binder reply';
          /* Since this is a recursive transaction we want to create the main
           * large slice which will contain all these recursive transactions.
           * For that we created the main slice above and this is a recursive
           * transaction that will be placed right below it. Note, that this
           * is only for the first recursive transaction. If more come they will
           * be handled below in the getRecursiveTransactionNeedingCompletion
           */
        const trans1 = new BinderTransaction(event, pid, ts, kthread);

        slice = kthread.thread.sliceGroup.
          pushCompleteSlice('binder',
            'binder transaction',
            recvTs,
              (ts - recvTs), 0,
            0, args);

          /* could be a async trans if so set the length to be a small one */
        if (!trans.expect_reply) {
          slice.title = 'binder transaction async';
          slice.duration = .03;
        } else {
            /* stupid hack to stop merging of AIDL slices and
             * this slice. This is currently disabled, if AIDL tracing is on we
             * will see merging of this slice and the AIDL slice. Once upstream
             * has a solution for flow events to be placed in the middle of
             * slices this part can be fixed.
             *
             * This is commented out because AIDL tracing doesn't exit yet.
             */
            // slice.start += .15;
        }
        trans1.slice = slice;
        this.addRecursiveSyncTransNeedingCompletion(pid,
              [calleeTrans, trans]);
        this.addTransactionWaitingForRecv(trans.transaction_key, trans1);
      }
      return true;
    },

    getRecursiveTransactionNeedingCompletion(pid) {
      if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined) {
        return false;
      }

      const len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
      if (len === 0) return false;

      return this.recursiveSyncTransWaitingCompletion_ByPID[pid][len - 1];
    },

    addRecursiveSyncTransNeedingCompletion(pid, tuple) {
      if (this.recursiveSyncTransWaitingCompletion_ByPID[pid] === undefined) {
        this.recursiveSyncTransWaitingCompletion_ByPID[pid] = [];
      }

      this.recursiveSyncTransWaitingCompletion_ByPID[pid].push(tuple);
    },

    removeRecursiveTransaction(pid) {
      const len = this.recursiveSyncTransWaitingCompletion_ByPID[pid].length;
      if (len === 0) {
        delete this.recursiveSyncTransWaitingCompletion_ByPID[pid];
        return;
      }

      this.recursiveSyncTransWaitingCompletion_ByPID[pid].splice(len - 1, 1);
    },

    setCurrentReceiveOnPID(pid, tuple) {
      if (this.receivedTransWaitingConversion[pid] === undefined) {
        this.receivedTransWaitingConversion[pid] = [];
      }
      this.receivedTransWaitingConversion[pid].push(tuple);
    },

    getPriorReceiveOnPID(pid) {
      if (this.receivedTransWaitingConversion[pid] === undefined) {
        return false;
      }

      const len = this.receivedTransWaitingConversion[pid].length;
      if (len === 0) return false;

      return this.receivedTransWaitingConversion[pid].splice(len - 1, 1)[0];
    },

    addSyncTransNeedingCompletion(transactionkey, tuple) {
      const dict = this.syncTransWaitingCompletion;
      dict[transactionkey] = tuple;
    },

    getSyncTransNeedsCompletion(transactionkey) {
      const ret = this.syncTransWaitingCompletion[transactionkey];
      if (ret === undefined) return false;

      delete this.syncTransWaitingCompletion[transactionkey];
      return ret;
    },

    getTransactionWaitingForRecv(transactionkey) {
      const ret = this.transWaitingRecv[transactionkey];
      if (ret === undefined) return false;

      delete this.transWaitingRecv[transactionkey];
      return ret;
    },

    addTransactionWaitingForRecv(transactionkey, transaction) {
      this.transWaitingRecv[transactionkey] = transaction;
    },

    generateFlow(from, to, fromTrans, toTrans) {
      const title = 'Transaction from : ' +
        this.pid2name(fromTrans.calling_pid) +
        ' From PID: ' + fromTrans.calling_pid + ' to pid: ' +
        toTrans.calling_pid +
        ' Thread Name: ' + this.pid2name(toTrans.calling_pid);

      const ts = from.start;
      const flow = new tr.model.FlowEvent('binder', 'binder',
          title, 1, ts, []);
      flow.startSlice = from;
      flow.endSlice = to;
      flow.start = from.start;
      flow.duration = to.start - ts;

      from.outFlowEvents.push(flow);
      to.inFlowEvents.push(flow);

      return flow;
    },

    generateArgsForSlice(tgid, pid, name, kthread) {
      return {
        'Thread Name': name,
        pid,
        'gid': tgid
      };
    },

    pid2name(pid) {
      return this.kthreadlookup[pid];
    },

    doNameMappings(pid, tgid, name) {
      this.registerPidName(pid, name);
      this.registerPidName(tgid, name);
    },

    registerPidName(pid, name) {
      if (this.pid2name(pid) === undefined) {
        this.kthreadlookup[pid] = name;
      }
    }
  };

  Parser.register(BinderParser);
  return {
    BinderParser,
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function BusParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('memory_bus_usage',
        BusParser.prototype.traceMarkWriteBusEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  BusParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteBusEvent(eventName, cpuNumber, pid, ts,
        eventBase, threadName) {
      const re = new RegExp('bus=(\\S+) rw_bytes=(\\d+) r_bytes=(\\d+) ' +
                            'w_bytes=(\\d+) cycles=(\\d+) ns=(\\d+)');
      const event = re.exec(eventBase.details);

      const name = event[1];
      const rwBytes = parseInt(event[2]);
      const rBytes = parseInt(event[3]);
      const wBytes = parseInt(event[4]);
      const cycles = parseInt(event[5]);
      const ns = parseInt(event[6]);

      // BW in MiB/s.
      const sec = tr.b.convertUnit(ns, tr.b.UnitPrefixScale.METRIC.NANO,
          tr.b.UnitPrefixScale.METRIC.NONE);
      const readBandwidthInBps = rBytes / sec;
      const readBandwidthInMiBps = tr.b.convertUnit(readBandwidthInBps,
          tr.b.UnitPrefixScale.BINARY.NONE,
          tr.b.UnitPrefixScale.BINARY.MEBI);
      const writeBandwidthInBps = wBytes / sec;
      const writeBandwidthInMiBps = tr.b.convertUnit(writeBandwidthInBps,
          tr.b.UnitPrefixScale.BINARY.NONE,
          tr.b.UnitPrefixScale.BINARY.MEBI);

      let ctr = this.model_.kernel
              .getOrCreateCounter(null, 'bus ' + name + ' read');
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            ColorScheme.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, readBandwidthInMiBps);
      });

      ctr = this.model_.kernel
              .getOrCreateCounter(null, 'bus ' + name + ' write');
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            ColorScheme.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, writeBandwidthInMiBps);
      });

      return true;
    }
  };

  Parser.register(BusParser);

  return {
    BusParser,
  };
});


'use strict';

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function ClockParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('clock_set_rate',
        ClockParser.prototype.traceMarkWriteClockEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  ClockParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteClockEvent(eventName, cpuNumber, pid, ts,
        eventBase, threadName) {
      const event = /(\S+) state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);


      const name = event[1];
      const rate = parseInt(event[2]);

      const ctr = this.model_.kernel
              .getOrCreateCounter(null, name);
      // Initialize the counter's series fields if needed.
      if (ctr.numSeries === 0) {
        ctr.addSeries(new tr.model.CounterSeries('value',
            ColorScheme.getColorIdForGeneralPurposeString(
                ctr.name + '.' + 'value')));
      }
      ctr.series.forEach(function(series) {
        series.addCounterSample(ts, rate);
      });

      return true;
    }
  };

  Parser.register(ClockParser);

  return {
    ClockParser,
  };
});


'use strict';

/**
 * @fileoverview Parses cpufreq events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function CpufreqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('cpufreq_interactive_up',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_down',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_already',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_notyet',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_setspeed',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_target',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_boost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_unboost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
  }

  function splitData(input) {
    // TODO(sleffler) split by cpu
    const data = {};
    const args = input.split(/\s+/);
    const len = args.length;
    for (let i = 0; i < len; i++) {
      const item = args[i].split('=');
      data[item[0]] = parseInt(item[1]);
    }
    return data;
  }

  CpufreqParser.prototype = {
    __proto__: Parser.prototype,

    cpufreqSlice(ts, eventName, cpu, args) {
      // TODO(sleffler) should be per-cpu
      const kthread = this.importer.getOrCreatePseudoThread('cpufreq');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    cpufreqBoostSlice(ts, eventName, args) {
      const kthread = this.importer.getOrCreatePseudoThread('cpufreq_boost');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses cpufreq events and sets up state in the importer.
     */
    cpufreqUpDownEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqTargetEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqBoostUnboostEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      this.cpufreqBoostSlice(ts, eventName,
          {
            type: eventBase.details
          });
      return true;
    }
  };

  Parser.register(CpufreqParser);

  return {
    CpufreqParser,
  };
});


'use strict';

/**
 * @fileoverview Parses filesystem and block device events in the Linux event
 * trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux filesystem and block device trace events.
   * @constructor
   */
  function DiskParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('f2fs_write_begin',
        DiskParser.prototype.f2fsWriteBeginEvent.bind(this));
    importer.registerEventHandler('f2fs_write_end',
        DiskParser.prototype.f2fsWriteEndEvent.bind(this));
    importer.registerEventHandler('f2fs_sync_file_enter',
        DiskParser.prototype.f2fsSyncFileEnterEvent.bind(this));
    importer.registerEventHandler('f2fs_sync_file_exit',
        DiskParser.prototype.f2fsSyncFileExitEvent.bind(this));
    importer.registerEventHandler('ext4_sync_file_enter',
        DiskParser.prototype.ext4SyncFileEnterEvent.bind(this));
    importer.registerEventHandler('ext4_sync_file_exit',
        DiskParser.prototype.ext4SyncFileExitEvent.bind(this));
    importer.registerEventHandler('ext4_da_write_begin',
        DiskParser.prototype.ext4WriteBeginEvent.bind(this));
    importer.registerEventHandler('ext4_da_write_end',
        DiskParser.prototype.ext4WriteEndEvent.bind(this));
    importer.registerEventHandler('block_rq_issue',
        DiskParser.prototype.blockRqIssueEvent.bind(this));
    importer.registerEventHandler('block_rq_complete',
        DiskParser.prototype.blockRqCompleteEvent.bind(this));
  }

  DiskParser.prototype = {
    __proto__: Parser.prototype,

    openAsyncSlice(ts, category, threadName, pid, key, name) {
      const kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      const asyncSliceConstructor =
         tr.model.AsyncSlice.subTypes.getConstructor(
             category, name);
      const slice = new asyncSliceConstructor(
          category, name,
          ColorScheme.getColorIdForGeneralPurposeString(name),
          ts);
      slice.startThread = kthread.thread;

      if (!kthread.openAsyncSlices) {
        kthread.openAsyncSlices = { };
      }
      kthread.openAsyncSlices[key] = slice;
    },

    closeAsyncSlice(ts, category, threadName, pid, key, args) {
      const kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      if (kthread.openAsyncSlices) {
        const slice = kthread.openAsyncSlices[key];
        if (slice) {
          slice.duration = ts - slice.start;
          slice.args = args;
          slice.endThread = kthread.thread;
          slice.subSlices = [
            new tr.model.AsyncSlice(category, slice.title,
                slice.colorId, slice.start, slice.args, slice.duration)
          ];
          kthread.thread.asyncSliceGroup.push(slice);
          delete kthread.openAsyncSlices[key];
        }
      }
    },

    /**
     * Parses events and sets up state in the importer.
     */
    f2fsWriteBeginEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), flags = (\d+)/. // @suppress longLineCheck
          exec(eventBase.details);
      if (!event) return false;
      const device = event[1];
      const inode = parseInt(event[2]);
      const pos = parseInt(event[3]);
      const len = parseInt(event[4]);
      const key = device + '-' + inode + '-' + pos + '-' + len;
      this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, 'f2fs_write');
      return true;
    },

    f2fsWriteEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev = \((\d+,\d+)\), ino = (\d+), pos = (\d+), len = (\d+), copied = (\d+)/. // @suppress longLineCheck
          exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const pos = parseInt(event[3]);
      const len = parseInt(event[4]);
      const error = parseInt(event[5]) !== len;
      const key = device + '-' + inode + '-' + pos + '-' + len;
      this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, {
            device,
            inode,
            error
          });
      return true;
    },

    ext4WriteBeginEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) flags (\d+)/.
          exec(eventBase.details);
      if (!event) return false;
      const device = event[1];
      const inode = parseInt(event[2]);
      const pos = parseInt(event[3]);
      const len = parseInt(event[4]);
      const key = device + '-' + inode + '-' + pos + '-' + len;
      this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, 'ext4_write');
      return true;
    },

    ext4WriteEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev (\d+,\d+) ino (\d+) pos (\d+) len (\d+) copied (\d+)/.
          exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const pos = parseInt(event[3]);
      const len = parseInt(event[4]);
      const error = parseInt(event[5]) !== len;
      const key = device + '-' + inode + '-' + pos + '-' + len;
      this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, {
            device,
            inode,
            error
          });
      return true;
    },

    f2fsSyncFileEnterEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = new RegExp(
          'dev = \\((\\d+,\\d+)\\), ino = (\\d+), pino = (\\d+), i_mode = (\\S+), ' + // @suppress longLineCheck
          'i_size = (\\d+), i_nlink = (\\d+), i_blocks = (\\d+), i_advise = (\\d+)'). // @suppress longLineCheck
          exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const key = device + '-' + inode;
      this.openAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, 'fsync');
      return true;
    },

    f2fsSyncFileExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = new RegExp('dev = \\((\\d+,\\d+)\\), ino = (\\d+), checkpoint is (\\S+), ' + // @suppress longLineCheck
          'datasync = (\\d+), ret = (\\d+)').
          exec(eventBase.details.replace('not needed', 'not_needed'));
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const error = parseInt(event[5]);
      const key = device + '-' + inode;
      this.closeAsyncSlice(ts, 'f2fs', eventBase.threadName, eventBase.pid,
          key, {
            device,
            inode,
            error
          });
      return true;
    },

    ext4SyncFileEnterEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev (\d+,\d+) ino (\d+) parent (\d+) datasync (\d+)/.
          exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const datasync = (event[4] === '1') || (event[4] === 1);
      const key = device + '-' + inode;
      const action = datasync ? 'fdatasync' : 'fsync';
      this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    ext4SyncFileExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev (\d+,\d+) ino (\d+) ret (\d+)/.exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const inode = parseInt(event[2]);
      const error = parseInt(event[3]);
      const key = device + '-' + inode;
      this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, {
            device,
            inode,
            error
          });
      return true;
    },

    blockRqIssueEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\d+ \\(.*\\) (\\d+) \\+ (\\d+) \\[.*\\]').exec(eventBase.details);
      if (!event) return false;

      let action;
      switch (event[3]) {
        case 'D':
          action = 'discard';
          break;
        case 'W':
          action = 'write';
          break;
        case 'R':
          action = 'read';
          break;
        case 'N':
          action = 'none';
          break;
        default:
          action = 'unknown';
          break;
      }

      if (event[2]) {
        action += ' flush';
      }
      if (event[4] === 'F') {
        action += ' fua';
      }
      if (event[5] === 'A') {
        action += ' ahead';
      }
      if (event[6] === 'S') {
        action += ' sync';
      }
      if (event[7] === 'M') {
        action += ' meta';
      }
      const device = event[1];
      const sector = parseInt(event[8]);
      const numSectors = parseInt(event[9]);
      const key = device + '-' + sector + '-' + numSectors;
      this.openAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    blockRqCompleteEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\(.*\\) (\\d+) \\+ (\\d+) \\[(.*)\\]').exec(eventBase.details);
      if (!event) return false;

      const device = event[1];
      const sector = parseInt(event[8]);
      const numSectors = parseInt(event[9]);
      const error = parseInt(event[10]);
      const key = device + '-' + sector + '-' + numSectors;
      this.closeAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, {
            device,
            sector,
            numSectors,
            error
          });
      return true;
    }
  };

  Parser.register(DiskParser);

  return {
    DiskParser,
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux drm trace events.
   * @constructor
   */
  function DrmParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('drm_vblank_event',
        DrmParser.prototype.vblankEvent.bind(this));
  }

  DrmParser.prototype = {
    __proto__: Parser.prototype,

    drmVblankSlice(ts, eventName, args) {
      const kthread = this.importer.getOrCreatePseudoThread('drm_vblank');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses drm driver events and sets up state in the importer.
     */
    vblankEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /crtc=(\d+), seq=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const crtc = parseInt(event[1]);
      const seq = parseInt(event[2]);
      this.drmVblankSlice(ts, 'vblank:' + crtc,
          {
            crtc,
            seq
          });
      return true;
    }
  };

  Parser.register(DrmParser);

  return {
    DrmParser,
  };
});


'use strict';

/**
 * @fileoverview Parses exynos events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux exynos trace events.
   * @constructor
   */
  function ExynosParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('exynos_busfreq_target_int',
        ExynosParser.prototype.busfreqTargetIntEvent.bind(this));
    importer.registerEventHandler('exynos_busfreq_target_mif',
        ExynosParser.prototype.busfreqTargetMifEvent.bind(this));

    importer.registerEventHandler('exynos_page_flip_state',
        ExynosParser.prototype.pageFlipStateEvent.bind(this));
  }

  ExynosParser.prototype = {
    __proto__: Parser.prototype,

    exynosBusfreqSample(name, ts, frequency) {
      const targetCpu = this.importer.getOrCreateCpu(0);
      const counter = targetCpu.getOrCreateCounter('', name);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries('frequency',
            ColorScheme.getColorIdForGeneralPurposeString(
                counter.name + '.' + 'frequency')));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, frequency);
      });
    },

    /**
     * Parses exynos_busfreq_target_int events and sets up state.
     */
    busfreqTargetIntEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      this.exynosBusfreqSample('INT Frequency', ts, parseInt(event[1]));
      return true;
    },

    /**
     * Parses exynos_busfreq_target_mif events and sets up state.
     */
    busfreqTargetMifEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      this.exynosBusfreqSample('MIF Frequency', ts, parseInt(event[1]));
      return true;
    },

    exynosPageFlipStateOpenSlice(ts, pipe, fb, state) {
      const kthread = this.importer.getOrCreatePseudoThread(
          'exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
      kthread.openSliceTS = ts;
      kthread.openSlice = state;
    },

    exynosPageFlipStateCloseSlice(ts, pipe, fb, args) {
      const kthread = this.importer.getOrCreatePseudoThread(
          'exynos_flip_state (pipe:' + pipe + ', fb:' + fb + ')');
      if (kthread.openSlice) {
        const slice = new tr.model.ThreadSlice('', kthread.openSlice,
            ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);
        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    /**
     * Parses page_flip_state events and sets up state in the importer.
     */
    pageFlipStateEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /pipe=(\d+), fb=(\d+), state=(.*)/.exec(eventBase.details);
      if (!event) return false;

      const pipe = parseInt(event[1]);
      const fb = parseInt(event[2]);
      const state = event[3];

      this.exynosPageFlipStateCloseSlice(ts, pipe, fb,
          {
            pipe,
            fb
          });
      if (state !== 'flipped') {
        this.exynosPageFlipStateOpenSlice(ts, pipe, fb, state);
      }
      return true;
    }
  };

  Parser.register(ExynosParser);

  return {
    ExynosParser,
  };
});


'use strict';

/**
 * @fileoverview Parses gesture events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses trace events generated by gesture library for touchpad.
   * @constructor
   */
  function GestureParser(importer) {
    Parser.call(this, importer);
    importer.registerEventHandler('tracing_mark_write:log',
        GestureParser.prototype.logEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:SyncInterpret',
        GestureParser.prototype.syncEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:HandleTimer',
        GestureParser.prototype.timerEvent.bind(this));
  }

  GestureParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parse events generate by gesture library.
     * gestureOpenSlice and gestureCloseSlice are two common
     * functions to store the begin time and end time for all
     * events in gesture library
     */
    gestureOpenSlice(title, ts, opt_args) {
      const thread = this.importer.getOrCreatePseudoThread('gesture').thread;
      thread.sliceGroup.beginSlice(
          'touchpad_gesture', title, ts, opt_args);
    },

    gestureCloseSlice(title, ts) {
      const thread = this.importer.getOrCreatePseudoThread('gesture').thread;
      if (thread.sliceGroup.openSliceCount) {
        const slice = thread.sliceGroup.mostRecentlyOpenedPartialSlice;
        if (slice.title !== title) {
          this.importer.model.importWarning({
            type: 'title_match_error',
            message: 'Titles do not match. Title is ' +
                slice.title + ' in openSlice, and is ' +
                title + ' in endSlice'
          });
        } else {
          thread.sliceGroup.endSlice(ts);
        }
      }
    },

    /**
     * For log events, events will come in pairs with a tag log:
     * like this:
     * tracing_mark_write: log: start: TimerLogOutputs
     * tracing_mark_write: log: end: TimerLogOutputs
     * which represent the start and the end time of certain log behavior
     * Take these logs above for example, they are the start and end time
     * of logging Output for HandleTimer function
     */
    logEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const innerEvent =
          /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('GestureLog', ts, {name: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('GestureLog', ts);
      }
      return true;
    },

    /**
     * For SyncInterpret events, events will come in pairs with
     * a tag SyncInterpret:
     * like this:
     * tracing_mark_write: SyncInterpret: start: ClickWiggleFilterInterpreter
     * tracing_mark_write: SyncInterpret: end: ClickWiggleFilterInterpreter
     * which represent the start and the end time of SyncInterpret function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the SyncInterpret function inside ClickWiggleFilterInterpreter
     */
    syncEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('SyncInterpret', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('SyncInterpret', ts);
      }
      return true;
    },

    /**
     * For HandleTimer events, events will come in pairs with
     * a tag HandleTimer:
     * like this:
     * tracing_mark_write: HandleTimer: start: LookaheadFilterInterpreter
     * tracing_mark_write: HandleTimer: end: LookaheadFilterInterpreter
     * which represent the start and the end time of HandleTimer function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the HandleTimer function inside LookaheadFilterInterpreter
     */
    timerEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('HandleTimer', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('HandleTimer', ts);
      }
      return true;
    }
  };

  Parser.register(GestureParser);

  return {
    GestureParser,
  };
});


'use strict';

/**
 * @fileoverview Parses i2c driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux i2c trace events.
   * @constructor
   */
  function I2cParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('i2c_write',
        I2cParser.prototype.i2cWriteEvent.bind(this));
    importer.registerEventHandler('i2c_read',
        I2cParser.prototype.i2cReadEvent.bind(this));
    importer.registerEventHandler('i2c_reply',
        I2cParser.prototype.i2cReplyEvent.bind(this));
    importer.registerEventHandler('i2c_result',
        I2cParser.prototype.i2cResultEvent.bind(this));
  }

  // Matches the i2c_write and i2c_reply records
  const i2cWriteReplyRE = new RegExp(
      'i2c-(\\d+) #(\\d+) a=([\\da-fA-F]+) f=([\\da-fA-F]+) l=(\\d+) ' +
      '(\\[[\\da-fA-F\\-]+\\])');
  // Matches the i2c_read record
  const i2cReadRE = /i2c-(\d+) #(\d+) a=([\da-fA-F]+) f=([\da-fA-F]+) l=(\d+)/;
  // Matches the i2c_result record
  const i2cResultRE = /i2c-(\d+) n=(\d+) ret=(\d+)/;

  I2cParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses i2c events and sets up state in the importer.
     */
    i2cWriteEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = i2cWriteReplyRE.exec(eventBase.details);
      if (!event) return false;

      const adapterNumber = parseInt(event[1]);
      const messageNumber = event[2];
      const address = event[3];
      const flags = event[4];
      const dataLength = event[5];
      const data = event[6];
      const thread = this.importer.getOrCreatePseudoThread(
          'i2c adapter ' + adapterNumber);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'i2c write';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Message number': messageNumber,
        'Address': address,
        'Flags': flags,
        'Data Length': dataLength,
        'Data': data
      };

      return true;
    },

    i2cReadEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = i2cReadRE.exec(eventBase.details);
      if (!event) return false;

      const adapterNumber = parseInt(event[1]);
      const messageNumber = event[2];
      const address = event[3];
      const flags = event[4];
      const dataLength = event[5];
      const thread = this.importer.getOrCreatePseudoThread(
          'i2c adapter ' + adapterNumber);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'i2c read';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Message number': messageNumber,
        'Address': address,
        'Flags': flags,
        'Data Length': dataLength
      };

      return true;
    },

    i2cReplyEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = i2cWriteReplyRE.exec(eventBase.details);
      if (!event) return false;

      const adapterNumber = parseInt(event[1]);
      const messageNumber = event[2];
      const address = event[3];
      const flags = event[4];
      const dataLength = event[5];
      const data = event[6];
      const thread = this.importer.getOrCreatePseudoThread(
          'i2c adapter ' + adapterNumber);

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = 'i2c reply';
      thread.lastEntryTs = ts;
      thread.lastEntryArgs = {
        'Message number': messageNumber,
        'Address': address,
        'Flags': flags,
        'Data Length': dataLength,
        'Data': data
      };

      return true;
    },

    i2cResultEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = i2cResultRE.exec(eventBase.details);
      if (!event) return false;

      const adapterNumber = parseInt(event[1]);
      const numMessages = event[2];
      const ret = event[3];
      const thread = this.importer.getOrCreatePseudoThread(
          'i2c adapter ' + adapterNumber);

      const args = thread.lastEntryArgs;
      if (args !== undefined) {
        args['Number of messages'] = numMessages;
        args.Return = ret;
      }

      pushLastSliceIfNeeded(thread, event[1], ts);

      thread.lastEntryTitle = undefined;
      thread.lastEntryTs = undefined;
      thread.lastEntryArgs = undefined;

      return true;
    },
  };

  function pushLastSliceIfNeeded(thread, id, currentTs) {
    if (thread.lastEntryTs !== undefined) {
      const duration = currentTs - thread.lastEntryTs;
      const slice = new tr.model.ThreadSlice(
            '', thread.lastEntryTitle,
            ColorScheme.getColorIdForGeneralPurposeString(id),
            thread.lastEntryTs, thread.lastEntryArgs, duration);
      thread.thread.sliceGroup.pushSlice(slice);
    }
  }

  Parser.register(I2cParser);

  return {
    I2cParser,
  };
});


'use strict';

/**
 * @fileoverview Parses i915 driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux i915 trace events.
   * @constructor
   */
  function I915Parser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('i915_gem_object_create',
        I915Parser.prototype.gemObjectCreateEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_bind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_unbind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_change_domain',
        I915Parser.prototype.gemObjectChangeDomainEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pread',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pwrite',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_fault',
        I915Parser.prototype.gemObjectFaultEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_clflush',
        // NB: reuse destroy handler
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_destroy',
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_dispatch',
        I915Parser.prototype.gemRingDispatchEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_flush',
        I915Parser.prototype.gemRingFlushEvent.bind(this));
    importer.registerEventHandler('i915_gem_request',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_add',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_complete',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_retire',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_begin',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_end',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_begin',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_end',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_reg_rw',
        I915Parser.prototype.regRWEvent.bind(this));
    importer.registerEventHandler('i915_flip_request',
        I915Parser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('i915_flip_complete',
        I915Parser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('intel_gpu_freq_change',
        I915Parser.prototype.gpuFrequency.bind(this));
  }

  I915Parser.prototype = {
    __proto__: Parser.prototype,

    i915FlipOpenSlice(ts, obj, plane) {
      // use i915_flip_obj_plane?
      const kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      kthread.openSliceTS = ts;
      kthread.openSlice = 'flip:' + obj + '/' + plane;
    },

    i915FlipCloseSlice(ts, args) {
      const kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      if (kthread.openSlice) {
        const slice = new tr.model.ThreadSlice('', kthread.openSlice,
            ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);

        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    i915GemObjectSlice(ts, eventName, obj, args) {
      const kthread = this.importer.getOrCreatePseudoThread('i915_gem');
      kthread.openSlice = eventName + ':' + obj;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915GemRingSlice(ts, eventName, dev, ring, args) {
      const kthread = this.importer.getOrCreatePseudoThread('i915_gem_ring');
      kthread.openSlice = eventName + ':' + dev + '.' + ring;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915RegSlice(ts, eventName, reg, args) {
      const kthread = this.importer.getOrCreatePseudoThread('i915_reg');
      kthread.openSlice = eventName + ':' + reg;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    i915FreqChangeSlice(ts, eventName, args) {
      const kthread = this.importer.getOrCreatePseudoThread('i915_gpu_freq');
      kthread.openSlice = eventName;
      const slice = new tr.model.ThreadSlice('', kthread.openSlice,
          ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
          ts, args, 0);

      kthread.thread.sliceGroup.pushSlice(slice);
    },

    /**
     * Parses i915 driver events and sets up state in the importer.
     */
    gemObjectCreateEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /obj=(\w+), size=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const obj = event[1];
      const size = parseInt(event[2]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj,
            size
          });
      return true;
    },

    gemObjectBindEvent(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) mappable
      const event = /obj=(\w+), offset=(\w+), size=(\d+)/.exec(
          eventBase.details);
      if (!event) return false;

      const obj = event[1];
      const offset = event[2];
      const size = parseInt(event[3]);
      this.i915ObjectGemSlice(ts, eventName + ':' + obj,
          {
            obj,
            offset,
            size
          });
      return true;
    },

    gemObjectChangeDomainEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const event = /obj=(\w+), read=(\w+=>\w+), write=(\w+=>\w+)/.exec(
          eventBase.details);
      if (!event) return false;

      const obj = event[1];
      const read = event[2];
      const write = event[3];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj,
            read,
            write
          });
      return true;
    },

    gemObjectPreadWriteEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const event = /obj=(\w+), offset=(\d+), len=(\d+)/.exec(
          eventBase.details);
      if (!event) return false;

      const obj = event[1];
      const offset = parseInt(event[2]);
      const len = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj,
            offset,
            len
          });
      return true;
    },

    gemObjectFaultEvent(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) writable
      const event = /obj=(\w+), (\w+) index=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const obj = event[1];
      const type = event[2];
      const index = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj,
            type,
            index
          });
      return true;
    },

    gemObjectDestroyEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /obj=(\w+)/.exec(eventBase.details);
      if (!event) return false;

      const obj = event[1];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj
          });
      return true;
    },

    gemRingDispatchEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(
          eventBase.details);
      if (!event) return false;

      const dev = parseInt(event[1]);
      const ring = parseInt(event[2]);
      const seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev,
            ring,
            seqno
          });
      return true;
    },

    gemRingFlushEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev=(\d+), ring=(\w+), invalidate=(\w+), flush=(\w+)/
          .exec(eventBase.details);
      if (!event) return false;

      const dev = parseInt(event[1]);
      const ring = parseInt(event[2]);
      const invalidate = event[3];
      const flush = event[4];
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev,
            ring,
            invalidate,
            flush
          });
      return true;
    },

    gemRequestEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(
          eventBase.details);
      if (!event) return false;

      const dev = parseInt(event[1]);
      const ring = parseInt(event[2]);
      const seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev,
            ring,
            seqno
          });
      return true;
    },

    gemRingWaitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /dev=(\d+), ring=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const dev = parseInt(event[1]);
      const ring = parseInt(event[2]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev,
            ring
          });
      return true;
    },

    regRWEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /(\w+) reg=(\w+), len=(\d+), val=(\(\w+, \w+\))/
          .exec(eventBase.details);
      if (!event) return false;

      const rw = event[1];
      const reg = event[2];
      const len = event[3];
      const data = event[3];
      this.i915RegSlice(ts, rw, reg,
          {
            rw,
            reg,
            len,
            data
          });
      return true;
    },

    flipEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /plane=(\d+), obj=(\w+)/.exec(eventBase.details);
      if (!event) return false;

      const plane = parseInt(event[1]);
      const obj = event[2];
      if (eventName === 'i915_flip_request') {
        this.i915FlipOpenSlice(ts, obj, plane);
      } else {
        this.i915FlipCloseSlice(ts,
            {
              obj,
              plane
            });
      }
      return true;
    },

    gpuFrequency(eventName, cpuNumver, pid, ts, eventBase) {
      const event = /new_freq=(\d+)/.exec(eventBase.details);
      if (!event) return false;
      const freq = parseInt(event[1]);

      this.i915FreqChangeSlice(ts, eventName, {
        freq
      });
      return true;
    }
  };

  Parser.register(I915Parser);

  return {
    I915Parser,
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux irq trace events.
   * @constructor
   */
  function IrqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('irq_handler_entry',
        IrqParser.prototype.irqHandlerEntryEvent.bind(this));
    importer.registerEventHandler('irq_handler_exit',
        IrqParser.prototype.irqHandlerExitEvent.bind(this));
    importer.registerEventHandler('softirq_raise',
        IrqParser.prototype.softirqRaiseEvent.bind(this));
    importer.registerEventHandler('softirq_entry',
        IrqParser.prototype.softirqEntryEvent.bind(this));
    importer.registerEventHandler('softirq_exit',
        IrqParser.prototype.softirqExitEvent.bind(this));
    importer.registerEventHandler('ipi_entry',
        IrqParser.prototype.ipiEntryEvent.bind(this));
    importer.registerEventHandler('ipi_exit',
        IrqParser.prototype.ipiExitEvent.bind(this));
  }

  // Matches the irq_handler_entry record
  const irqHandlerEntryRE = /irq=(\d+) name=(.+)/;

  // Matches the irq_handler_exit record
  const irqHandlerExitRE = /irq=(\d+) ret=(.+)/;

  // Matches the softirq_raise record
  const softirqRE = /vec=(\d+) \[action=(.+)\]/;

  // Matches the ipi_exit_
  const ipiHandlerExitRE = /\((.+)\)/;

  IrqParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses irq events and sets up state in the mporter.
     */
    irqHandlerEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = irqHandlerEntryRE.exec(eventBase.details);
      if (!event) return false;

      const irq = parseInt(event[1]);
      const name = event[2];

      const thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);
      thread.lastEntryTs = ts;
      thread.irqName = name;

      return true;
    },

    irqHandlerExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = irqHandlerExitRE.exec(eventBase.details);
      if (!event) return false;

      const irq = parseInt(event[1]);
      const ret = event[2];
      const thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.ThreadSlice(
            '',
            'IRQ (' + thread.irqName + ')',
            ColorScheme.getColorIdForGeneralPurposeString(event[1]),
            thread.lastEntryTs, { ret },
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      thread.irqName = undefined;
      return true;
    },

    softirqRaiseEvent(eventName, cpuNumber, pid, ts, eventBase) {
      return true;
    },

    softirqEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = softirqRE.exec(eventBase.details);
      if (!event) return false;

      const action = event[2];
      const thread = this.importer.getOrCreatePseudoThread(
          'softirq cpu ' + cpuNumber);
      thread.lastEntryTs = ts;

      return true;
    },

    softirqExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = softirqRE.exec(eventBase.details);
      if (!event) return false;

      const vec = parseInt(event[1]);
      const action = event[2];
      const thread = this.importer.getOrCreatePseudoThread(
          'softirq cpu ' + cpuNumber);

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.ThreadSlice(
            '', action,
            ColorScheme.getColorIdForGeneralPurposeString(event[1]),
            thread.lastEntryTs, { vec },
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    },
    /**
     * Parses ipi events and sets up state in the mporter.
     */
    ipiEntryEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);
      thread.lastEntryTs = ts;

      return true;
    },

    ipiExitEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = ipiHandlerExitRE.exec(eventBase.details);
      if (!event) return false;

      const ipiName = event[1];
      const thread = this.importer.getOrCreatePseudoThread(
          'irqs cpu ' + cpuNumber);

      if (thread.lastEntryTs !== undefined) {
        const duration = ts - thread.lastEntryTs;
        const slice = new tr.model.ThreadSlice(
            '',
            'IPI (' + ipiName + ')',
            ColorScheme.getColorIdForGeneralPurposeString(ipiName),
            thread.lastEntryTs,
            {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastEntryTs = undefined;
      return true;
    }
  };

  Parser.register(IrqParser);

  return {
    IrqParser,
  };
});


'use strict';

/**
 * @fileoverview Parses graph_ent and graph_ret events that were inserted by
 * the Linux kernel's function graph trace.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const LinuxPerfParser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses graph_ent and graph_ret events that were inserted by the Linux
   * kernel's function graph trace.
   * @constructor
   */
  function KernelFuncParser(importer) {
    LinuxPerfParser.call(this, importer);

    importer.registerEventHandler('graph_ent',
        KernelFuncParser.prototype.traceKernelFuncEnterEvent.
            bind(this));
    importer.registerEventHandler('graph_ret',
        KernelFuncParser.prototype.traceKernelFuncReturnEvent.
            bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  const TestExports = {};

  const funcEnterRE = new RegExp('func=(.+)');
  TestExports.funcEnterRE = funcEnterRE;

  KernelFuncParser.prototype = {
    __proto__: LinuxPerfParser.prototype,

    traceKernelFuncEnterEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const eventData = funcEnterRE.exec(eventBase.details);
      if (!eventData) return false;

      if (eventBase.tgid === undefined) {
        return false;
      }

      const tgid = parseInt(eventBase.tgid);
      const name = eventData[1];
      const thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;

      const slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      const slice = slices.beginSlice(null, name, ts, {});

      return true;
    },

    traceKernelFuncReturnEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      if (eventBase.tgid === undefined) {
        return false;
      }

      const tgid = parseInt(eventBase.tgid);
      const thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;

      const slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      if (slices.openSliceCount > 0) {
        slices.endSlice(ts);
      }

      return true;
    }
  };

  LinuxPerfParser.register(KernelFuncParser);

  return {
    KernelFuncParser,
  };
});


'use strict';

/**
 * @fileoverview Parses Mali DDK/kernel events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses Mali DDK/kernel trace events.
   * @constructor
   */
  function MaliParser(importer) {
    Parser.call(this, importer);

    // kernel DVFS events
    importer.registerEventHandler('mali_dvfs_event',
        MaliParser.prototype.dvfsEventEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_clock',
        MaliParser.prototype.dvfsSetClockEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_voltage',
        MaliParser.prototype.dvfsSetVoltageEvent.bind(this));

    // kernel Mali hw counter events
    this.addJMCounter('mali_hwc_MESSAGES_SENT', 'Messages Sent');
    this.addJMCounter('mali_hwc_MESSAGES_RECEIVED', 'Messages Received');
    this.addJMCycles('mali_hwc_GPU_ACTIVE', 'GPU Active');
    this.addJMCycles('mali_hwc_IRQ_ACTIVE', 'IRQ Active');

    for (let i = 0; i < 7; i++) {
      const jobStr = 'JS' + i;
      const jobHWCStr = 'mali_hwc_' + jobStr;
      this.addJMCounter(jobHWCStr + '_JOBS', jobStr + ' Jobs');
      this.addJMCounter(jobHWCStr + '_TASKS', jobStr + ' Tasks');
      this.addJMCycles(jobHWCStr + '_ACTIVE', jobStr + ' Active');
      this.addJMCycles(jobHWCStr + '_WAIT_READ', jobStr + ' Wait Read');
      this.addJMCycles(jobHWCStr + '_WAIT_ISSUE', jobStr + ' Wait Issue');
      this.addJMCycles(jobHWCStr + '_WAIT_DEPEND', jobStr + ' Wait Depend');
      this.addJMCycles(jobHWCStr + '_WAIT_FINISH', jobStr + ' Wait Finish');
    }

    this.addTilerCounter('mali_hwc_TRIANGLES', 'Triangles');
    this.addTilerCounter('mali_hwc_QUADS', 'Quads');
    this.addTilerCounter('mali_hwc_POLYGONS', 'Polygons');
    this.addTilerCounter('mali_hwc_POINTS', 'Points');
    this.addTilerCounter('mali_hwc_LINES', 'Lines');
    this.addTilerCounter('mali_hwc_VCACHE_HIT', 'VCache Hit');
    this.addTilerCounter('mali_hwc_VCACHE_MISS', 'VCache Miss');
    this.addTilerCounter('mali_hwc_FRONT_FACING', 'Front Facing');
    this.addTilerCounter('mali_hwc_BACK_FACING', 'Back Facing');
    this.addTilerCounter('mali_hwc_PRIM_VISIBLE', 'Prim Visible');
    this.addTilerCounter('mali_hwc_PRIM_CULLED', 'Prim Culled');
    this.addTilerCounter('mali_hwc_PRIM_CLIPPED', 'Prim Clipped');

    this.addTilerCounter('mali_hwc_WRBUF_HIT', 'Wrbuf Hit');
    this.addTilerCounter('mali_hwc_WRBUF_MISS', 'Wrbuf Miss');
    this.addTilerCounter('mali_hwc_WRBUF_LINE', 'Wrbuf Line');
    this.addTilerCounter('mali_hwc_WRBUF_PARTIAL', 'Wrbuf Partial');
    this.addTilerCounter('mali_hwc_WRBUF_STALL', 'Wrbuf Stall');

    this.addTilerCycles('mali_hwc_ACTIVE', 'Tiler Active');
    this.addTilerCycles('mali_hwc_INDEX_WAIT', 'Index Wait');
    this.addTilerCycles('mali_hwc_INDEX_RANGE_WAIT', 'Index Range Wait');
    this.addTilerCycles('mali_hwc_VERTEX_WAIT', 'Vertex Wait');
    this.addTilerCycles('mali_hwc_PCACHE_WAIT', 'Pcache Wait');
    this.addTilerCycles('mali_hwc_WRBUF_WAIT', 'Wrbuf Wait');
    this.addTilerCycles('mali_hwc_BUS_READ', 'Bus Read');
    this.addTilerCycles('mali_hwc_BUS_WRITE', 'Bus Write');

    this.addTilerCycles('mali_hwc_TILER_UTLB_STALL', 'Tiler UTLB Stall');
    this.addTilerCycles('mali_hwc_TILER_UTLB_HIT', 'Tiler UTLB Hit');

    this.addFragCycles('mali_hwc_FRAG_ACTIVE', 'Active');
    /* NB: don't propagate spelling mistakes to labels */
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES', 'Primitives');
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES_DROPPED',
        'Primitives Dropped');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_DESC', 'Descriptor Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_PLR', 'PLR Processing??');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_VERT', 'Vertex Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_TRISETUP', 'Triangle Setup');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_RAST', 'Rasterization???');
    this.addFragCounter('mali_hwc_FRAG_THREADS', 'Threads');
    this.addFragCounter('mali_hwc_FRAG_DUMMY_THREADS', 'Dummy Threads');
    this.addFragCounter('mali_hwc_FRAG_QUADS_RAST', 'Quads Rast');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_TEST', 'Quads EZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_KILLED', 'Quads EZS Killed');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_TEST', 'Quads LZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_KILLED', 'Quads LZS Killed');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_NO_TILE', 'No Tiles');
    this.addFragCounter('mali_hwc_FRAG_NUM_TILES', 'Tiles');
    this.addFragCounter('mali_hwc_FRAG_TRANS_ELIM', 'Transactions Eliminated');

    this.addComputeCycles('mali_hwc_COMPUTE_ACTIVE', 'Active');
    this.addComputeCounter('mali_hwc_COMPUTE_TASKS', 'Tasks');
    this.addComputeCounter('mali_hwc_COMPUTE_THREADS', 'Threads Started');
    this.addComputeCycles('mali_hwc_COMPUTE_CYCLES_DESC',
        'Waiting for Descriptors');

    this.addTripipeCycles('mali_hwc_TRIPIPE_ACTIVE', 'Active');

    this.addArithCounter('mali_hwc_ARITH_WORDS', 'Instructions (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_REG',
        'Reg scheduling stalls (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_L0',
        'L0 cache miss stalls (/Pipes)');
    this.addArithCounter('mali_hwc_ARITH_FRAG_DEPEND',
        'Frag dep check failures (/Pipes)');

    this.addLSCounter('mali_hwc_LS_WORDS', 'Instruction Words Completed');
    this.addLSCounter('mali_hwc_LS_ISSUES', 'Full Pipeline Issues');
    this.addLSCounter('mali_hwc_LS_RESTARTS', 'Restarts (unpairable insts)');
    this.addLSCounter('mali_hwc_LS_REISSUES_MISS',
        'Pipeline reissue (cache miss/uTLB)');
    this.addLSCounter('mali_hwc_LS_REISSUES_VD',
        'Pipeline reissue (varying data)');
    /* TODO(sleffler) fix kernel event typo */
    this.addLSCounter('mali_hwc_LS_REISSUE_ATTRIB_MISS',
        'Pipeline reissue (attribute cache miss)');
    this.addLSCounter('mali_hwc_LS_REISSUE_NO_WB', 'Writeback not used');

    this.addTexCounter('mali_hwc_TEX_WORDS', 'Words');
    this.addTexCounter('mali_hwc_TEX_BUBBLES', 'Bubbles');
    this.addTexCounter('mali_hwc_TEX_WORDS_L0', 'Words L0');
    this.addTexCounter('mali_hwc_TEX_WORDS_DESC', 'Words Desc');
    this.addTexCounter('mali_hwc_TEX_THREADS', 'Threads');
    this.addTexCounter('mali_hwc_TEX_RECIRC_FMISS', 'Recirc due to Full Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_DESC', 'Recirc due to Desc Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_MULTI', 'Recirc due to Multipass');
    this.addTexCounter('mali_hwc_TEX_RECIRC_PMISS',
        'Recirc due to Partial Cache Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_CONF',
        'Recirc due to Cache Conflict');

    this.addLSCCounter('mali_hwc_LSC_READ_HITS', 'Read Hits');
    this.addLSCCounter('mali_hwc_LSC_READ_MISSES', 'Read Misses');
    this.addLSCCounter('mali_hwc_LSC_WRITE_HITS', 'Write Hits');
    this.addLSCCounter('mali_hwc_LSC_WRITE_MISSES', 'Write Misses');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_HITS', 'Atomic Hits');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_MISSES', 'Atomic Misses');
    this.addLSCCounter('mali_hwc_LSC_LINE_FETCHES', 'Line Fetches');
    this.addLSCCounter('mali_hwc_LSC_DIRTY_LINE', 'Dirty Lines');
    this.addLSCCounter('mali_hwc_LSC_SNOOPS', 'Snoops');

    this.addAXICounter('mali_hwc_AXI_TLB_STALL', 'Address channel stall');
    this.addAXICounter('mali_hwc_AXI_TLB_MISS', 'Cache Miss');
    this.addAXICounter('mali_hwc_AXI_TLB_TRANSACTION', 'Transactions');
    this.addAXICounter('mali_hwc_LS_TLB_MISS', 'LS Cache Miss');
    this.addAXICounter('mali_hwc_LS_TLB_HIT', 'LS Cache Hit');
    this.addAXICounter('mali_hwc_AXI_BEATS_READ', 'Read Beats');
    this.addAXICounter('mali_hwc_AXI_BEATS_WRITE', 'Write Beats');

    this.addMMUCounter('mali_hwc_MMU_TABLE_WALK', 'Page Table Walks');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_MISS',
        'Cache Miss from Replay Buffer');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_FULL', 'Replay Buffer Full');
    this.addMMUCounter('mali_hwc_MMU_NEW_MISS', 'Cache Miss on New Request');
    this.addMMUCounter('mali_hwc_MMU_HIT', 'Cache Hit');

    this.addMMUCycles('mali_hwc_UTLB_STALL', 'UTLB Stalled');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_MISS', 'UTLB Replay Miss');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_FULL', 'UTLB Replay Full');
    this.addMMUCycles('mali_hwc_UTLB_NEW_MISS', 'UTLB New Miss');
    this.addMMUCycles('mali_hwc_UTLB_HIT', 'UTLB Hit');

    this.addL2Counter('mali_hwc_L2_READ_BEATS', 'Read Beats');
    this.addL2Counter('mali_hwc_L2_WRITE_BEATS', 'Write Beats');
    this.addL2Counter('mali_hwc_L2_ANY_LOOKUP', 'Any Lookup');
    this.addL2Counter('mali_hwc_L2_READ_LOOKUP', 'Read Lookup');
    this.addL2Counter('mali_hwc_L2_SREAD_LOOKUP', 'Shareable Read Lookup');
    this.addL2Counter('mali_hwc_L2_READ_REPLAY', 'Read Replayed');
    this.addL2Counter('mali_hwc_L2_READ_SNOOP', 'Read Snoop');
    this.addL2Counter('mali_hwc_L2_READ_HIT', 'Read Cache Hit');
    this.addL2Counter('mali_hwc_L2_CLEAN_MISS', 'CleanUnique Miss');
    this.addL2Counter('mali_hwc_L2_WRITE_LOOKUP', 'Write Lookup');
    this.addL2Counter('mali_hwc_L2_SWRITE_LOOKUP', 'Shareable Write Lookup');
    this.addL2Counter('mali_hwc_L2_WRITE_REPLAY', 'Write Replayed');
    this.addL2Counter('mali_hwc_L2_WRITE_SNOOP', 'Write Snoop');
    this.addL2Counter('mali_hwc_L2_WRITE_HIT', 'Write Cache Hit');
    this.addL2Counter('mali_hwc_L2_EXT_READ_FULL', 'ExtRD with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_READ_HALF', 'ExtRD with BIU >1/2 Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_FULL', 'ExtWR with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_HALF', 'ExtWR with BIU >1/2 Full');

    this.addL2Counter('mali_hwc_L2_EXT_READ', 'External Read (ExtRD)');
    this.addL2Counter('mali_hwc_L2_EXT_READ_LINE', 'ExtRD (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE', 'External Write (ExtWR)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_LINE', 'ExtWR (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_SMALL', 'ExtWR (burst size <64B)');
    this.addL2Counter('mali_hwc_L2_EXT_BARRIER', 'External Barrier');
    this.addL2Counter('mali_hwc_L2_EXT_AR_STALL', 'Address Read stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_BUF_FULL',
        'Response Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_RD_BUF_FULL',
        'Read Data Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_RAW', 'RAW hazard stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_STALL', 'Write Data stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_BUF_FULL', 'Write Data Buffer full');
    this.addL2Counter('mali_hwc_L2_EXT_R_W_HAZARD', 'WAW or WAR hazard stalls');
    this.addL2Counter('mali_hwc_L2_TAG_HAZARD', 'Tag hazard replays');
    this.addL2Cycles('mali_hwc_L2_SNOOP_FULL', 'Snoop buffer full');
    this.addL2Cycles('mali_hwc_L2_REPLAY_FULL', 'Replay buffer full');

    // DDK events (from X server)
    importer.registerEventHandler('tracing_mark_write:mali_driver',
        MaliParser.prototype.maliDDKEvent.bind(this));

    this.model_ = importer.model_;
  }

  MaliParser.prototype = {
    __proto__: Parser.prototype,

    maliDDKOpenSlice(pid, tid, ts, func, blockinfo) {
      const thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      const funcArgs = /^([\w\d_]*)(?:\(\))?:?\s*(.*)$/.exec(func);
      thread.sliceGroup.beginSlice('gpu-driver', funcArgs[1], ts,
          { 'args': funcArgs[2],
            blockinfo });
    },

    maliDDKCloseSlice(pid, tid, ts, args, blockinfo) {
      const thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      if (!thread.sliceGroup.openSliceCount) {
        // Discard unmatched ends.
        return;
      }
      thread.sliceGroup.endSlice(ts);
    },

    /**
     * Deduce the format of Mali perf events.
     *
     * @return {RegExp} the regular expression for parsing data when the format
     * is recognized; otherwise null.
     */
    autoDetectLineRE(line) {
      // Matches Mali perf events with thread info
      const lineREWithThread =
          /^\s*\(([\w\-]*)\)\s*(\w+):\s*([\w\\\/\.\-]*@\d*):?\s*(.*)$/;
      if (lineREWithThread.test(line)) {
        return lineREWithThread;
      }

      // Matches old-style Mali perf events
      const lineRENoThread = /^s*()(\w+):\s*([\w\\\/.\-]*):?\s*(.*)$/;
      if (lineRENoThread.test(line)) {
        return lineRENoThread;
      }
      return null;
    },

    lineRE: null,

    /**
     * Parses maliDDK events and sets up state in the importer.
     * events will come in pairs with a cros_trace_print_enter
     * like this (line broken here for formatting):
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_enter: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505: gles2_texturep_upload
     *
     * and a cros_trace_print_exit like this:
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_exit: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505:
     */
    maliDDKEvent(eventName, cpuNumber, pid, ts, eventBase) {
      if (this.lineRE === null) {
        this.lineRE = this.autoDetectLineRE(eventBase.details);
        if (this.lineRE === null) return false;
      }
      const maliEvent = this.lineRE.exec(eventBase.details);
      // Old-style Mali perf events have no thread id, so make one.
      const tid = (maliEvent[1] === '' ? 'mali' : maliEvent[1]);
      switch (maliEvent[2]) {
        case 'cros_trace_print_enter':
          this.maliDDKOpenSlice(pid, tid, ts, maliEvent[4],
              maliEvent[3]);
          break;
        case 'cros_trace_print_exit':
          this.maliDDKCloseSlice(pid, tid, ts, [], maliEvent[3]);
      }
      return true;
    },

    /*
     * Kernel event support.
     */

    dvfsSample(counterName, seriesName, ts, s) {
      const value = parseInt(s);
      const counter = this.model_.kernel.
          getOrCreateCounter('DVFS', counterName);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries(seriesName,
            ColorScheme.getColorIdForGeneralPurposeString(counter.name)));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, value);
      });
    },

    dvfsEventEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /utilization=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      this.dvfsSample('DVFS Utilization', 'utilization', ts, event[1]);
      return true;
    },

    dvfsSetClockEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      this.dvfsSample('DVFS Frequency', 'frequency', ts, event[1]);
      return true;
    },

    dvfsSetVoltageEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /voltage=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      this.dvfsSample('DVFS Voltage', 'voltage', ts, event[1]);
      return true;
    },

    hwcSample(cat, counterName, seriesName, ts, eventBase) {
      const event = /val=(\d+)/.exec(eventBase.details);
      if (!event) return false;
      const value = parseInt(event[1]);

      const counter = this.model_.kernel.
          getOrCreateCounter(cat, counterName);
      if (counter.numSeries === 0) {
        counter.addSeries(new tr.model.CounterSeries(seriesName,
            ColorScheme.getColorIdForGeneralPurposeString(counter.name)));
      }
      counter.series.forEach(function(series) {
        series.addCounterSample(ts, value);
      });
      return true;
    },

    /*
     * Job Manager block counters.
     */
    jmSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:jm', 'JM: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addJMCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addJMCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tiler block counters.
     */
    tilerSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:tiler', 'Tiler: ' + ctrName, seriesName,
          ts, eventBase);
    },
    addTilerCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addTilerCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Fragment counters.
     */
    fragSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:fragment', 'Fragment: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addFragCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addFragCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Compute counters.
     */
    computeSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:compute', 'Compute: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addComputeCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addComputeCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tripipe counters.
     */
    addTripipeCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:shader', 'Tripipe: ' + hwcTitle, 'cycles',
            ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Arith counters.
     */
    arithSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:arith', 'Arith: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addArithCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addArithCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Load/Store counters.
     */
    addLSCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:ls', 'LS: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Texture counters.
     */
    textureSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:texture', 'Texture: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addTexCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.textureSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * LSC counters.
     */
    addLSCCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:lsc', 'LSC: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * TLB counters.
     */
    addAXICounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:axi', 'AXI: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * MMU counters.
     */
    mmuSample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:mmu', 'MMU: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addMMUCounter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addMMUCycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * L2 counters.
     */
    l2Sample(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:l2', 'L2: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addL2Counter(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addL2Cycles(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    }
  };

  Parser.register(MaliParser);

  return {
    MaliParser,
  };
});


'use strict';

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux vmscan trace events.
   * @constructor
   */
  function MemReclaimParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('mm_vmscan_kswapd_wake',
        MemReclaimParser.prototype.kswapdWake.bind(this));
    importer.registerEventHandler('mm_vmscan_kswapd_sleep',
        MemReclaimParser.prototype.kswapdSleep.bind(this));
    importer.registerEventHandler('mm_vmscan_direct_reclaim_begin',
        MemReclaimParser.prototype.reclaimBegin.bind(this));
    importer.registerEventHandler('mm_vmscan_direct_reclaim_end',
        MemReclaimParser.prototype.reclaimEnd.bind(this));
    importer.registerEventHandler('lowmemory_kill',
        MemReclaimParser.prototype.lowmemoryKill.bind(this));
  }

  // Matches the mm_vmscan_kswapd_wake record
  //  mm_vmscan_kswapd_wake: nid=%d order=%d
  const kswapdWakeRE = /nid=(\d+) order=(\d+)/;

  // Matches the mm_vmscan_kswapd_sleep record
  //  mm_vmscan_kswapd_sleep: order=%d
  const kswapdSleepRE = /nid=(\d+)/;

  // Matches the mm_vmscan_direct_reclaim_begin record
  //  mm_vmscan_direct_reclaim_begin: order=%d may_writepage=%d gfp_flags=%s
  const reclaimBeginRE = /order=(\d+) may_writepage=\d+ gfp_flags=(.+)/;

  // Matches the mm_vmscan_direct_reclaim_end record
  //  mm_vmscan_direct_reclaim_end: nr_reclaimed=%lu
  const reclaimEndRE = /nr_reclaimed=(\d+)/;

  // Matches the lowmemory_kill record
  const lowmemoryRE =
    /([^ ]+) \((\d+)\), page cache (\d+)kB \(limit (\d+)kB\), free (-?\d+)Kb/;

  MemReclaimParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses memreclaim events and sets up state in the importer.
     */
    kswapdWake(eventName, cpuNumber, pid, ts, eventBase) {
      const event = kswapdWakeRE.exec(eventBase.details);
      if (!event) return false;

      const tgid = parseInt(eventBase.tgid);

      const nid = parseInt(event[1]);
      const order = parseInt(event[2]);

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS) {
        if (order > kthread.order) {
          kthread.order = order;
        }
      } else {
        kthread.openSliceTS = ts;
        kthread.order = order;
      }
      return true;
    },

    kswapdSleep(eventName, cpuNumber, pid, ts, eventBase) {
      const tgid = parseInt(eventBase.tgid);

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS) {
        kthread.thread.sliceGroup.pushCompleteSlice(
            'memreclaim', eventBase.threadName, kthread.openSliceTS,
            ts - kthread.openSliceTS, 0, 0,
            {
              order: kthread.order
            });
      }
      kthread.openSliceTS = undefined;
      kthread.order = undefined;
      return true;
    },

    reclaimBegin(eventName, cpuNumber, pid, ts, eventBase) {
      const event = reclaimBeginRE.exec(eventBase.details);
      if (!event) return false;

      const order = parseInt(event[1]);
      const gfp = event[2];
      const tgid = parseInt(eventBase.tgid);

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      kthread.openSliceTS = ts;
      kthread.order = order;
      kthread.gfp = gfp;
      return true;
    },

    reclaimEnd(eventName, cpuNumber, pid, ts, eventBase) {
      const event = reclaimEndRE.exec(eventBase.details);
      if (!event) return false;

      const nrReclaimed = parseInt(event[1]);
      const tgid = parseInt(eventBase.tgid);

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      if (kthread.openSliceTS !== undefined) {
        kthread.thread.sliceGroup.pushCompleteSlice('memreclaim',
            'direct reclaim', kthread.openSliceTS, ts - kthread.openSliceTS,
            0, 0,
            {
              order: kthread.order,
              gfp: kthread.gfp,
              nr_reclaimed: nrReclaimed
            });
      }
      kthread.openSliceTS = undefined;
      kthread.order = undefined;
      kthread.gfp = undefined;
      return true;
    },

    lowmemoryKill(eventName, cpuNumber, pid, ts, eventBase) {
      const event = lowmemoryRE.exec(eventBase.details);
      if (!event) return false;

      const tgid = parseInt(eventBase.tgid);
      const killedName = event[1];
      const killedPid = parseInt(event[2]);
      const cache = parseInt(event[3]);
      const free = parseInt(event[5]);

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, tgid, pid);

      kthread.thread.sliceGroup.pushCompleteSlice('lowmemory',
          'low memory kill', ts, 0,
          0, 0,
          {
            killed_name: killedName,
            killed_pid: killedPid,
            cache,
            free
          });
      return true;
    }
  };

  Parser.register(MemReclaimParser);

  return {
    MemReclaimParser,
  };
});


'use strict';

/**
 * @fileoverview Parses power events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux power trace events.
   * @constructor
   */
  function PowerParser(importer) {
    Parser.call(this, importer);

    // NB: old-style power events, deprecated
    importer.registerEventHandler('power_start',
        PowerParser.prototype.powerStartEvent.bind(this));
    importer.registerEventHandler('power_frequency',
        PowerParser.prototype.powerFrequencyEvent.bind(this));

    importer.registerEventHandler('cpu_frequency',
        PowerParser.prototype.cpuFrequencyEvent.bind(this));
    importer.registerEventHandler('cpu_frequency_limits',
        PowerParser.prototype.cpuFrequencyLimitsEvent.bind(this));
    importer.registerEventHandler('cpu_idle',
        PowerParser.prototype.cpuIdleEvent.bind(this));
  }

  PowerParser.prototype = {
    __proto__: Parser.prototype,

    cpuStateSlice(ts, targetCpuNumber, eventType, cpuState) {
      const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      if (eventType !== '1') {
        this.importer.model.importWarning({
          type: 'parse_error',
          message: 'Don\'t understand power_start events of ' +
              'type ' + eventType
        });
        return;
      }
      const powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            ColorScheme.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'state')));
      }
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, cpuState);
      });
    },

    cpuIdleSlice(ts, targetCpuNumber, cpuState) {
      const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      const powerCounter = targetCpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            ColorScheme.getColorIdForGeneralPurposeString(powerCounter.name)));
      }
      // NB: 4294967295/-1 means an exit from the current state
      const val = (cpuState !== 4294967295 ? cpuState + 1 : 0);
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, val);
      });
    },

    cpuFrequencySlice(ts, targetCpuNumber, powerState) {
      const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      const powerCounter =
          targetCpu.getOrCreateCounter('', 'Clock Frequency');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('state',
            ColorScheme.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'state')));
      }
      powerCounter.series.forEach(function(series) {
        series.addCounterSample(ts, powerState);
      });
    },

    cpuFrequencyLimitsSlice(ts, targetCpuNumber, minFreq, maxFreq) {
      const targetCpu = this.importer.getOrCreateCpu(targetCpuNumber);
      const powerCounter =
          targetCpu.getOrCreateCounter('', 'Clock Frequency Limits');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('Min Frequency',
            ColorScheme.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'Min Frequency')));
        powerCounter.addSeries(new tr.model.CounterSeries('Max Frequency',
            ColorScheme.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'Max Frequency')));
      }
      powerCounter.series.forEach(function(series) {
        if (series.name === 'Min Frequency') {
          series.addCounterSample(ts, minFreq);
        }
        if (series.name === 'Max Frequency') {
          series.addCounterSample(ts, maxFreq);
        }
      });
    },

    /**
     * Parses power events and sets up state in the importer.
     */
    powerStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /type=(\d+) state=(\d) cpu_id=(\d+)/.exec(
          eventBase.details);
      if (!event) return false;

      const targetCpuNumber = parseInt(event[3]);
      const cpuState = parseInt(event[2]);
      this.cpuStateSlice(ts, targetCpuNumber, event[1], cpuState);
      return true;
    },

    powerFrequencyEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /type=(\d+) state=(\d+) cpu_id=(\d+)/
          .exec(eventBase.details);
      if (!event) return false;

      const targetCpuNumber = parseInt(event[3]);
      const powerState = parseInt(event[2]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuFrequencyEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const targetCpuNumber = parseInt(event[2]);
      const powerState = parseInt(event[1]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuFrequencyLimitsEvent(eventName, cpu, pid, ts, eventBase) {
      const event = /min=(\d+) max=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const targetCpuNumber = parseInt(event[3]);
      const minFreq = parseInt(event[1]);
      const maxFreq = parseInt(event[2]);
      this.cpuFrequencyLimitsSlice(ts, targetCpuNumber, minFreq, maxFreq);
      return true;
    },

    cpuIdleEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      const targetCpuNumber = parseInt(event[2]);
      const cpuState = parseInt(event[1]);
      this.cpuIdleSlice(ts, targetCpuNumber, cpuState);
      return true;
    }
  };

  Parser.register(PowerParser);

  return {
    PowerParser,
  };
});


'use strict';

/**
 * @fileoverview Parses regulator events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux regulator trace events.
   * @constructor
   */
  function RegulatorParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('regulator_enable',
        RegulatorParser.prototype.regulatorEnableEvent.bind(this));
    importer.registerEventHandler('regulator_enable_delay',
        RegulatorParser.prototype.regulatorEnableDelayEvent.bind(this));
    importer.registerEventHandler('regulator_enable_complete',
        RegulatorParser.prototype.regulatorEnableCompleteEvent.bind(this));
    importer.registerEventHandler('regulator_disable',
        RegulatorParser.prototype.regulatorDisableEvent.bind(this));
    importer.registerEventHandler('regulator_disable_complete',
        RegulatorParser.prototype.regulatorDisableCompleteEvent.bind(this));
    importer.registerEventHandler('regulator_set_voltage',
        RegulatorParser.prototype.regulatorSetVoltageEvent.bind(this));
    importer.registerEventHandler('regulator_set_voltage_complete',
        RegulatorParser.prototype.regulatorSetVoltageCompleteEvent.bind(this));

    this.model_ = importer.model_;
  }

  // Matches the regulator_enable record
  const regulatorEnableRE = /name=(.+)/;

  // Matches the regulator_disable record
  const regulatorDisableRE = /name=(.+)/;

  // Matches the regulator_set_voltage_complete record
  const regulatorSetVoltageCompleteRE = /name=(\S+), val=(\d+)/;

  RegulatorParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Get or create a counter with one series.
     */
    getCtr_(ctrName, valueName) {
      const ctr = this.model_.kernel
        .getOrCreateCounter(null, 'vreg ' + ctrName + ' ' + valueName);
      // Initialize the counter's series fields if needed.
      if (ctr.series[0] === undefined) {
        ctr.addSeries(new tr.model.CounterSeries(valueName,
        ColorScheme.getColorIdForGeneralPurposeString(
            ctrName + '.' + valueName)));
      }
      return ctr;
    },

    /**
     * Parses regulator events and sets up state in the importer.
     */
    regulatorEnableEvent(eventName, cpuNum, pid, ts, eventBase) {
      const event = regulatorEnableRE.exec(eventBase.details);
      if (!event) return false;

      const name = event[1];

      const ctr = this.getCtr_(name, 'enabled');
      ctr.series[0].addCounterSample(ts, 1);

      return true;
    },

    regulatorEnableDelayEvent(eventName, cpuNum, pid, ts, eventBase) {
      return true;
    },

    regulatorEnableCompleteEvent(eventName, cpuNum, pid, ts,
        eventBase) {
      return true;
    },

    regulatorDisableEvent(eventName, cpuNum, pid, ts, eventBase) {
      const event = regulatorDisableRE.exec(eventBase.details);
      if (!event) return false;

      const name = event[1];

      const ctr = this.getCtr_(name, 'enabled');
      ctr.series[0].addCounterSample(ts, 0);

      return true;
    },

    regulatorDisableCompleteEvent(eventName, cpuNum, pid, ts,
        eventBase) {
      return true;
    },

    regulatorSetVoltageEvent(eventName, cpuNum, pid, ts, eventBase) {
      return true;
    },

    regulatorSetVoltageCompleteEvent(eventName, cpuNum, pid, ts,
        eventBase) {
      const event = regulatorSetVoltageCompleteRE.exec(eventBase.details);
      if (!event) return false;

      const name = event[1];
      const voltage = parseInt(event[2]);

      const ctr = this.getCtr_(name, 'voltage');
      ctr.series[0].addCounterSample(ts, voltage);

      return true;
    }

  };

  Parser.register(RegulatorParser);

  return {
    RegulatorParser,
  };
});


'use strict';

/**
 * @fileoverview Parses scheduler events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux sched trace events.
   * @constructor
   */
  function SchedParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('sched_switch',
        SchedParser.prototype.schedSwitchEvent.bind(this));
    importer.registerEventHandler('sched_wakeup',
        SchedParser.prototype.schedWakeupEvent.bind(this));
    importer.registerEventHandler('sched_blocked_reason',
        SchedParser.prototype.schedBlockedEvent.bind(this));
    importer.registerEventHandler('sched_cpu_hotplug',
        SchedParser.prototype.schedCpuHotplugEvent.bind(this));
  }

  const TestExports = {};

  // Matches the sched_switch record
  const schedSwitchRE = new RegExp(
      'prev_comm=(.+) prev_pid=(\\d+) prev_prio=(\\d+) ' +
      'prev_state=(\\S\\+?|\\S\\|\\S) ==> ' +
      'next_comm=(.+) next_pid=(\\d+) next_prio=(\\d+)');

  // Matches sched_blocked_reason record
  const schedBlockedRE = new RegExp('pid=(\\d+) iowait=(\\d) caller=(.+)');
  TestExports.schedSwitchRE = schedSwitchRE;

  // Matches the sched_wakeup record
  // success=? is optional not all kernels report it, so don't include
  // it in the capture groups
  const schedWakeupRE =
      /comm=(.+) pid=(\d+) prio=(\d+)(?: success=\d+)? target_cpu=(\d+)/;
  TestExports.schedWakeupRE = schedWakeupRE;

  SchedParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses scheduler events and sets up state in the CPUs of the importer.
     */
    schedSwitchEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = schedSwitchRE.exec(eventBase.details);
      if (!event) return false;

      const prevState = event[4];
      const nextComm = event[5];
      const nextPid = parseInt(event[6]);
      const nextPrio = parseInt(event[7]);

      if (eventBase.tgid !== undefined) {
        const tgid = parseInt(eventBase.tgid);
        const process = this.importer.model_.getOrCreateProcess(tgid);
        if (!process.getThread(pid)) {
          const thread = process.getOrCreateThread(pid);
          thread.name = eventBase.threadName;
        }
      }

      const nextThread = this.importer.threadsByLinuxPid[nextPid];
      let nextName;
      if (nextThread) {
        nextName = nextThread.userFriendlyName;
      } else {
        nextName = nextComm;
      }

      const cpu = this.importer.getOrCreateCpu(cpuNumber);
      cpu.switchActiveThread(
          ts,
          {stateWhenDescheduled: prevState},
          nextPid,
          nextName,
          {
            comm: nextComm,
            tid: nextPid,
            prio: nextPrio
          });

      return true;
    },

    schedWakeupEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = schedWakeupRE.exec(eventBase.details);
      if (!event) return false;

      const fromPid = pid;
      const comm = event[1];
      pid = parseInt(event[2]);
      const prio = parseInt(event[3]);
      this.importer.markPidRunnable(ts, pid, comm, prio, fromPid);
      return true;
    },

    schedCpuHotplugEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = /cpu (\d+) (.+) error=(\d+)/.exec(eventBase.details);
      if (!event) return false;

      cpuNumber = event[1];
      const state = event[2];
      const targetCpu = this.importer.getOrCreateCpu(cpuNumber);

      const powerCounter = targetCpu.getOrCreateCounter('', 'Cpu Hotplug');
      if (powerCounter.numSeries === 0) {
        powerCounter.addSeries(new tr.model.CounterSeries('State',
            tr.b.ColorScheme.getColorIdForGeneralPurposeString(
                powerCounter.name + '.' + 'State')));
      }
      powerCounter.series.forEach(function(series) {
        if (series.name === 'State') {
          series.addCounterSample(ts, state.localeCompare('offline') ? 0 : 1);
        }
      });
      return true;
    },

    schedBlockedEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = schedBlockedRE.exec(eventBase.details);
      if (!event) return false;

      pid = parseInt(event[1]);
      const iowait = parseInt(event[2]);
      const caller = event[3];

      this.importer.addPidBlockedReason(ts, pid, iowait, caller);
      return true;
    }
  };

  Parser.register(SchedParser);

  return {
    SchedParser,
    _SchedParserTestExports: TestExports
  };
});


'use strict';

/**
 * @fileoverview Parses sync events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux sync trace events.
   * @constructor
   */
  function SyncParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler(
        'sync_timeline',
        SyncParser.prototype.timelineEvent.bind(this));
    importer.registerEventHandler(
        'sync_wait',
        SyncParser.prototype.syncWaitEvent.bind(this));
    importer.registerEventHandler(
        'sync_pt',
        SyncParser.prototype.syncPtEvent.bind(this));
    this.model_ = importer.model_;
  }

  const syncTimelineRE = /name=(\S+) value=(\S*)/;
  const syncWaitRE = /(\S+) name=(\S+) state=(\d+)/;
  const syncPtRE = /name=(\S+) value=(\S*)/;

  SyncParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses sync events and sets up state in the importer.
     */
    timelineEvent(eventName, cpuNumber, pid,
        ts, eventBase) {
      const event = syncTimelineRE.exec(eventBase.details);
      if (!event) return false;

      const thread = this.importer.getOrCreatePseudoThread(event[1]);

      if (thread.lastActiveTs !== undefined) {
        const duration = ts - thread.lastActiveTs;
        let value = thread.lastActiveValue;
        if (value === undefined) value = ' ';
        const slice = new tr.model.ThreadSlice(
            '', value,
            ColorScheme.getColorIdForGeneralPurposeString(value),
            thread.lastActiveTs, {},
            duration);
        thread.thread.sliceGroup.pushSlice(slice);
      }
      thread.lastActiveTs = ts;
      thread.lastActiveValue = event[2];
      return true;
    },

    syncWaitEvent(eventName, cpuNumber, pid, ts,
        eventBase) {
      const event = syncWaitRE.exec(eventBase.details);
      if (!event) return false;

      if (eventBase.tgid === undefined) {
        return false;
      }

      const tgid = parseInt(eventBase.tgid);
      const thread = this.model_.getOrCreateProcess(tgid)
        .getOrCreateThread(pid);
      thread.name = eventBase.threadName;
      const slices = thread.kernelSliceGroup;
      if (!slices.isTimestampValidForBeginOrEnd(ts)) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Timestamps are moving backward.'
        });
        return false;
      }

      const name = 'fence_wait("' + event[2] + '")';
      if (event[1] === 'begin') {
        const slice = slices.beginSlice(null, name, ts, {
          'Start state': event[3]
        });
      } else if (event[1] === 'end') {
        if (slices.openSliceCount > 0) {
          slices.endSlice(ts);
        }
      } else {
        return false;
      }

      return true;
    },

    syncPtEvent(eventName, cpuNumber, pid, ts, eventBase) {
      return !!syncPtRE.exec(eventBase.details);
    }
  };

  Parser.register(SyncParser);

  return {
    SyncParser,
  };
});


'use strict';

/**
 * @fileoverview Parses workqueue events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const ColorScheme = tr.b.ColorScheme;
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses linux workqueue trace events.
   * @constructor
   */
  function WorkqueueParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('workqueue_execute_start',
        WorkqueueParser.prototype.executeStartEvent.bind(this));
    importer.registerEventHandler('workqueue_execute_end',
        WorkqueueParser.prototype.executeEndEvent.bind(this));
    importer.registerEventHandler('workqueue_queue_work',
        WorkqueueParser.prototype.executeQueueWork.bind(this));
    importer.registerEventHandler('workqueue_activate_work',
        WorkqueueParser.prototype.executeActivateWork.bind(this));
  }

  // Matches the workqueue_execute_start record
  //  workqueue_execute_start: work struct c7a8a89c: function MISRWrapper
  const workqueueExecuteStartRE = /work struct (.+): function (\S+)/;

  // Matches the workqueue_execute_start record
  //  workqueue_execute_end: work struct c7a8a89c
  const workqueueExecuteEndRE = /work struct (.+)/;

  WorkqueueParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses workqueue events and sets up state in the importer.
     */
    executeStartEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = workqueueExecuteStartRE.exec(eventBase.details);
      if (!event) return false;

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, pid, pid);
      kthread.openSliceTS = ts;
      kthread.openSlice = event[2];
      return true;
    },

    executeEndEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = workqueueExecuteEndRE.exec(eventBase.details);
      if (!event) return false;

      const kthread = this.importer.getOrCreateKernelThread(
          eventBase.threadName, pid, pid);
      if (kthread.openSlice) {
        const slice = new tr.model.ThreadSlice('', kthread.openSlice,
            ColorScheme.getColorIdForGeneralPurposeString(kthread.openSlice),
            kthread.openSliceTS,
            {},
            ts - kthread.openSliceTS);

        kthread.thread.sliceGroup.pushSlice(slice);
      }
      kthread.openSlice = undefined;
      return true;
    },

    executeQueueWork(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    },

    executeActivateWork(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    }

  };

  Parser.register(WorkqueueParser);

  return {
    WorkqueueParser,
  };
});


/**
 * @fileoverview Imports text files in the Linux event trace format into the
 * Model. This format is output both by sched_trace and by Linux's perf tool.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 *
 * Linux scheduler traces use a definition for 'pid' that is different than
 * tracing uses. Whereas tracing uses pid to identify a specific process, a pid
 * in a linux trace refers to a specific thread within a process. Within this
 * file, we the definition used in Linux traces, as it improves the importing
 * code's readability.
 */
'use strict';

tr.exportTo('tr.e.importer.linux_perf', function() {
  const MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID =
      'linux_clock_monotonic_to_ftrace_global';

  const IMPORT_PRIORITY = 2;

  /**
   * Imports linux perf events into a specified model.
   * @constructor
   */
  function FTraceImporter(model, events) {
    this.importPriority = IMPORT_PRIORITY;
    this.model_ = model;
    this.events_ = events;
    this.wakeups_ = [];
    this.blockedReasons_ = [];
    this.kernelThreadStates_ = {};
    this.buildMapFromLinuxPidsToThreads_();
    this.lines_ = [];
    this.pseudoThreadCounter = 1;
    this.parsers_ = [];
    this.eventHandlers_ = {};
    this.haveClockSyncedMonotonicToGlobal_ = false;
    this.clockDomainId_ = tr.model.ClockDomainId.LINUX_FTRACE_GLOBAL;
  }

  const TestExports = {};

  // Matches the trace record in 3.2 and later with the print-tgid option:
  //          <idle>-0    0 [001] d...  1.23: sched_switch
  //
  // A TGID (Thread Group ID) is basically what the Linux kernel calls what
  // userland refers to as a process ID (as opposed to a Linux pid, which is
  // what userland calls a thread ID).
  const lineREWithTGID = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\(\\s*(\\d+|-+)\\)\\s\\[(\\d+)\\]' +
      '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  const lineParserWithTGID = function(line) {
    const groups = lineREWithTGID.exec(line);
    if (!groups) return groups;

    let tgid = groups[3];
    if (tgid[0] === '-') tgid = undefined;

    return {
      threadName: groups[1],
      pid: groups[2],
      tgid,
      cpuNumber: groups[4],
      timestamp: groups[5],
      eventName: groups[6],
      details: groups[7]
    };
  };
  TestExports.lineParserWithTGID = lineParserWithTGID;

  // Matches the default trace record in 3.2 and later (includes irq-info):
  //          <idle>-0     [001] d...  1.23: sched_switch
  const lineREWithIRQInfo = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\[(\\d+)\\]' +
      '\\s+[dX.][Nnp.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  const lineParserWithIRQInfo = function(line) {
    const groups = lineREWithIRQInfo.exec(line);
    if (!groups) return groups;
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  };
  TestExports.lineParserWithIRQInfo = lineParserWithIRQInfo;

  // Matches the default trace record pre-3.2:
  //          <idle>-0     [001]  1.23: sched_switch
  const lineREWithLegacyFmt =
      /^\s*(.+)-(\d+)\s+\[(\d+)\]\s*(\d+\.\d+):\s+(\S+):\s(.*)$/;
  const lineParserWithLegacyFmt = function(line) {
    const groups = lineREWithLegacyFmt.exec(line);
    if (!groups) {
      return groups;
    }
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  };
  TestExports.lineParserWithLegacyFmt = lineParserWithLegacyFmt;

  // Matches the trace_event_clock_sync marker:
  //  0: trace_event_clock_sync: parent_ts=19581477508
  const traceEventClockSyncRE = /trace_event_clock_sync: parent_ts=(\d+\.?\d*)/;
  TestExports.traceEventClockSyncRE = traceEventClockSyncRE;

  const realTimeClockSyncRE = /trace_event_clock_sync: realtime_ts=(\d+)/;
  const genericClockSyncRE = /trace_event_clock_sync: name=([\w\-]+)/;

  // Some kernel trace events are manually classified in slices and
  // hand-assigned a pseudo PID.
  const pseudoKernelPID = 0;

  /**
   * Deduce the format of trace data. Linux kernels prior to 3.3 used one
   * format (by default); 3.4 and later used another.  Additionally, newer
   * kernels can optionally trace the TGID.
   *
   * @return {function} the function for parsing data when the format is
   * recognized; otherwise undefined.
   */
  function autoDetectLineParser(line) {
    if (line[0] === '{') return false;
    if (lineREWithTGID.test(line)) return lineParserWithTGID;
    if (lineREWithIRQInfo.test(line)) return lineParserWithIRQInfo;
    if (lineREWithLegacyFmt.test(line)) return lineParserWithLegacyFmt;
    return undefined;
  }
  TestExports.autoDetectLineParser = autoDetectLineParser;

  /**
   * Guesses whether the provided events is a Linux perf string.
   * Looks for the magic string "# tracer" at the start of the file,
   * or the typical task-pid-cpu-timestamp-function sequence of a typical
   * trace's body.
   *
   * @return {boolean} True when events is a linux perf array.
   */
  FTraceImporter.canImport = function(events) {
    if (events instanceof tr.b.TraceStream) events = events.header;

    if (!(typeof(events) === 'string' || events instanceof String)) {
      return false;
    }

    if (FTraceImporter._extractEventsFromSystraceHTML(events, false).ok) {
      return true;
    }

    if (FTraceImporter._extractEventsFromSystraceMultiHTML(events, false).ok) {
      return true;
    }

    if (/^# tracer:/.test(events)) return true;

    const lineBreakIndex = events.indexOf('\n');
    if (lineBreakIndex > -1) events = events.substring(0, lineBreakIndex);

    if (autoDetectLineParser(events)) return true;

    return false;
  };

  FTraceImporter._extractEventsFromSystraceHTML = function(
      incomingEvents, produceResult) {
    const failure = {ok: false};
    if (produceResult === undefined) produceResult = true;

    const header = incomingEvents instanceof tr.b.TraceStream ?
        incomingEvents.header : incomingEvents;
    if (!/^<!DOCTYPE html>/.test(header)) return failure;
    const r = new tr.importer.SimpleLineReader(incomingEvents);

    // Try to find the data...
    if (!r.advanceToLineMatching(/^  <script>$/)) return failure;
    if (!r.advanceToLineMatching(/^  var linuxPerfData = "\\$/)) return failure;

    const eventsBeginAtLine = r.curLineNumber + 1;
    r.beginSavingLines();
    if (!r.advanceToLineMatching(/^  <\/script>$/)) return failure;

    let rawEvents = r.endSavingLinesAndGetResult();

    // Drop off first and last event as it contains the tag.
    rawEvents = rawEvents.slice(1, rawEvents.length - 1);

    if (!r.advanceToLineMatching(/^<\/body>$/)) return failure;
    if (!r.advanceToLineMatching(/^<\/html>$/)) return failure;

    function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function stripSuffix(str, suffix) {
      if (!endsWith(str, suffix)) return str;
      return str.substring(str, str.length - suffix.length);
    }

    // Strip off escaping in the file needed to preserve linebreaks.
    let events = [];
    if (produceResult) {
      for (let i = 0; i < rawEvents.length; i++) {
        let event = rawEvents[i];
        event = stripSuffix(event, '\\n\\');
        events.push(event);
      }
    } else {
      events = [rawEvents[rawEvents.length - 1]];
    }

    // Last event ends differently. Strip that off too,
    // treating absence of that trailing string as a failure.
    const oldLastEvent = events[events.length - 1];
    const newLastEvent = stripSuffix(oldLastEvent, '\\n";');
    if (newLastEvent === oldLastEvent) return failure;
    events[events.length - 1] = newLastEvent;

    return {ok: true,
      lines: produceResult ? events : undefined,
      eventsBeginAtLine};
  };

  FTraceImporter._extractEventsFromSystraceMultiHTML = function(
      incomingEvents, produceResult) {
    const failure = {ok: false};
    if (produceResult === undefined) produceResult = true;

    const header = incomingEvents instanceof tr.b.TraceStream ?
        incomingEvents.header : incomingEvents;
    if (!(new RegExp('^<!DOCTYPE HTML>', 'i').test(header))) return failure;

    const r = new tr.importer.SimpleLineReader(incomingEvents);

    // Try to find the Linux perf trace in any of the trace-data tags
    let events = [];
    let eventsBeginAtLine;
    while (!/^# tracer:/.test(events)) {
      if (!r.advanceToLineMatching(
          /^  <script class="trace-data" type="application\/text">$/)) {
        return failure;
      }

      eventsBeginAtLine = r.curLineNumber + 1;

      r.beginSavingLines();
      if (!r.advanceToLineMatching(/^  <\/script>$/)) return failure;

      events = r.endSavingLinesAndGetResult();

      // Drop off first and last event as it contains the tag.
      events = events.slice(1, events.length - 1);
    }

    if (!r.advanceToLineMatching(/^<\/body>$/)) return failure;
    if (!r.advanceToLineMatching(/^<\/html>$/)) return failure;

    return {
      ok: true,
      lines: produceResult ? events : undefined,
      eventsBeginAtLine,
    };
  };

  FTraceImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'FTraceImporter';
    },

    get model() {
      return this.model_;
    },

    /**
     * Imports clock sync markers into model_.
     */
    importClockSyncMarkers() {
      this.lazyInit_();
      this.forEachLine_(function(text, eventBase, cpuNumber, pid, ts) {
        const eventName = eventBase.eventName;
        if (eventName !== 'tracing_mark_write' && eventName !== '0') return;

        if (traceEventClockSyncRE.exec(eventBase.details) ||
            genericClockSyncRE.exec(eventBase.details)) {
          this.traceClockSyncEvent_(eventName, cpuNumber, pid, ts, eventBase);
        } else if (realTimeClockSyncRE.exec(eventBase.details)) {
          // TODO(charliea): Migrate this sync to ClockSyncManager.
          // This entry syncs CLOCK_REALTIME with CLOCK_MONOTONIC. Store the
          // offset between the two in the model so that importers parsing files
          // with CLOCK_REALTIME timestamps can map back to CLOCK_MONOTONIC.
          const match = realTimeClockSyncRE.exec(eventBase.details);
          this.model_.realtime_to_monotonic_offset_ms = ts - match[1];
        }
      }.bind(this));
    },

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents() {
      const modelTimeTransformer =
          this.model_.clockSyncManager.getModelTimeTransformer(
              this.clockDomainId_);

      this.importCpuData_(modelTimeTransformer);
      this.buildMapFromLinuxPidsToThreads_();
      this.buildPerThreadCpuSlicesFromCpuState_();
    },

    /**
     * Registers a linux perf event parser used by importCpuData_.
     */
    registerEventHandler(eventName, handler) {
      // TODO(sleffler) how to handle conflicts?
      this.eventHandlers_[eventName] = handler;
    },

    /**
     * @return {Cpu} A Cpu corresponding to the given cpuNumber.
     */
    getOrCreateCpu(cpuNumber) {
      return this.model_.kernel.getOrCreateCpu(cpuNumber);
    },

    /**
     * @return {TimelineThread} A thread corresponding to the kernelThreadName.
     */
    getOrCreateKernelThread(kernelThreadName, pid, tid) {
      if (!this.kernelThreadStates_[kernelThreadName]) {
        const thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(
            tid);
        thread.name = kernelThreadName;
        this.kernelThreadStates_[kernelThreadName] = {
          pid,
          thread,
          openSlice: undefined,
          openSliceTS: undefined
        };
        this.threadsByLinuxPid[pid] = thread;
      }
      return this.kernelThreadStates_[kernelThreadName];
    },

    /**
     * Processes can have multiple binder threads.
     * Binder thread names are not unique across processes we therefore need to
     * keep more information in order to return the correct threads.
     */
    getOrCreateBinderKernelThread(kernelThreadName, pid, tid) {
      const key = kernelThreadName + pid + tid;
      if (!this.kernelThreadStates_[key]) {
        const thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(
            tid);
        thread.name = kernelThreadName;
        this.kernelThreadStates_[key] = {
          pid,
          thread,
          openSlice: undefined,
          openSliceTS: undefined
        };
        this.threadsByLinuxPid[pid] = thread;
      }
      return this.kernelThreadStates_[key];
    },

    /**
     * @return {TimelineThread} A pseudo thread corresponding to the
     * threadName.  Pseudo threads are for events that we want to break
     * out to a separate timeline but would not otherwise happen.
     * These threads are assigned to pseudoKernelPID and given a
     * unique (incrementing) TID.
     */
    getOrCreatePseudoThread(threadName) {
      let thread = this.kernelThreadStates_[threadName];
      if (!thread) {
        thread = this.getOrCreateKernelThread(threadName, pseudoKernelPID,
            this.pseudoThreadCounter);
        this.pseudoThreadCounter++;
      }
      return thread;
    },

    /**
     * Records the fact that a pid has become runnable. This data will
     * eventually get used to derive each thread's timeSlices array.
     */
    markPidRunnable(ts, pid, comm, prio, fromPid) {
      // The the pids that get passed in to this function are Linux kernel
      // pids, which identify threads.  The rest of trace-viewer refers to
      // these as tids, so the change of nomenclature happens in the following
      // construction of the wakeup object.
      this.wakeups_.push({ts, tid: pid, fromTid: fromPid});
    },

    /**
     * Records the reason why a pid has gone into uninterruptible sleep.
     */
    addPidBlockedReason(ts, pid, iowait, caller) {
      // The the pids that get passed in to this function are Linux kernel
      // pids, which identify threads.  The rest of trace-viewer refers to
      // these as tids, so the change of nomenclature happens in the following
      // construction of the wakeup object.
      this.blockedReasons_.push({ts, tid: pid, iowait,
        caller});
    },

    /**
     * Precomputes a lookup table from linux pids back to existing
     * Threads. This is used during importing to add information to each
     * thread about whether it was running, descheduled, sleeping, et
     * cetera.
     */
    buildMapFromLinuxPidsToThreads_() {
      this.threadsByLinuxPid = {};
      this.model_.getAllThreads().forEach(
          function(thread) {
            this.threadsByLinuxPid[thread.tid] = thread;
          }.bind(this));
    },

    /**
     * Builds the timeSlices array on each thread based on our knowledge of what
     * each Cpu is doing.  This is done only for Threads that are
     * already in the model, on the assumption that not having any traced data
     * on a thread means that it is not of interest to the user.
     */
    buildPerThreadCpuSlicesFromCpuState_() {
      const SCHEDULING_STATE = tr.model.SCHEDULING_STATE;

      // Push the cpu slices to the threads that they run on.
      for (const cpuNumber in this.model_.kernel.cpus) {
        const cpu = this.model_.kernel.cpus[cpuNumber];

        for (let i = 0; i < cpu.slices.length; i++) {
          const cpuSlice = cpu.slices[i];

          const thread = this.threadsByLinuxPid[cpuSlice.args.tid];
          if (!thread) continue;

          cpuSlice.threadThatWasRunning = thread;

          if (!thread.tempCpuSlices) {
            thread.tempCpuSlices = [];
          }
          thread.tempCpuSlices.push(cpuSlice);
        }
      }

      for (const i in this.wakeups_) {
        const wakeup = this.wakeups_[i];
        const thread = this.threadsByLinuxPid[wakeup.tid];
        if (!thread) continue;
        thread.tempWakeups = thread.tempWakeups || [];
        thread.tempWakeups.push(wakeup);
      }
      for (const i in this.blockedReasons_) {
        const reason = this.blockedReasons_[i];
        const thread = this.threadsByLinuxPid[reason.tid];
        if (!thread) continue;
        thread.tempBlockedReasons = thread.tempBlockedReasons || [];
        thread.tempBlockedReasons.push(reason);
      }

      // Create slices for when the thread is not running.
      this.model_.getAllThreads().forEach(function(thread) {
        if (thread.tempCpuSlices === undefined) return;
        const origSlices = thread.tempCpuSlices;
        delete thread.tempCpuSlices;

        origSlices.sort(function(x, y) {
          return x.start - y.start;
        });

        const wakeups = thread.tempWakeups || [];
        delete thread.tempWakeups;
        wakeups.sort(function(x, y) {
          return x.ts - y.ts;
        });

        const reasons = thread.tempBlockedReasons || [];
        delete thread.tempBlockedReasons;
        reasons.sort(function(x, y) {
          return x.ts - y.ts;
        });

        // Walk the slice list and put slices between each original slice to
        // show when the thread isn't running.
        const slices = [];

        if (origSlices.length) {
          const slice = origSlices[0];

          if (wakeups.length && wakeups[0].ts < slice.start) {
            const wakeup = wakeups.shift();
            const wakeupDuration = slice.start - wakeup.ts;
            const args = {'wakeup from tid': wakeup.fromTid};
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.RUNNABLE, '',
                wakeup.ts, args, wakeupDuration));
          }

          const runningSlice = new tr.model.ThreadTimeSlice(
              thread, SCHEDULING_STATE.RUNNING, '',
              slice.start, {}, slice.duration);
          runningSlice.cpuOnWhichThreadWasRunning = slice.cpu;
          slices.push(runningSlice);
        }

        let wakeup = undefined;
        for (let i = 1; i < origSlices.length; i++) {
          const prevSlice = origSlices[i - 1];
          const nextSlice = origSlices[i];
          let midDuration = nextSlice.start - prevSlice.end;
          while (wakeups.length && wakeups[0].ts < nextSlice.start) {
            const w = wakeups.shift();
            if (wakeup === undefined && w.ts > prevSlice.end) {
              wakeup = w;
            }
          }
          let blockedReason = undefined;
          while (reasons.length && reasons[0].ts < prevSlice.end) {
            const r = reasons.shift();
          }
          if (wakeup !== undefined &&
              reasons.length &&
              reasons[0].ts < wakeup.ts) {
            blockedReason = reasons.shift();
          }

          // Push a sleep slice onto the slices list, interrupting it with a
          // wakeup if appropriate.
          const pushSleep = function(state) {
            if (wakeup !== undefined) {
              midDuration = wakeup.ts - prevSlice.end;
            }

            if (blockedReason !== undefined) {
              const args = {
                'kernel callsite when blocked:': blockedReason.caller
              };
              if (blockedReason.iowait) {
                switch (state) {
                  case SCHEDULING_STATE.UNINTR_SLEEP:
                    state = SCHEDULING_STATE.UNINTR_SLEEP_IO;
                    break;
                  case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
                    state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;
                    break;
                  case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
                    state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;
                    break;
                  default:
                }
              }
              slices.push(new tr.model.ThreadTimeSlice(
                  thread,
                  state, '', prevSlice.end, args, midDuration));
            } else {
              slices.push(new tr.model.ThreadTimeSlice(
                  thread,
                  state, '', prevSlice.end, {}, midDuration));
            }
            if (wakeup !== undefined) {
              const wakeupDuration = nextSlice.start - wakeup.ts;
              const args = {'wakeup from tid': wakeup.fromTid};
              slices.push(new tr.model.ThreadTimeSlice(
                  thread, SCHEDULING_STATE.RUNNABLE, '',
                  wakeup.ts, args, wakeupDuration));
              wakeup = undefined;
            }
          };

          if (prevSlice.args.stateWhenDescheduled === 'S') {
            pushSleep(SCHEDULING_STATE.SLEEPING);
          } else if (prevSlice.args.stateWhenDescheduled === 'R' ||
                     prevSlice.args.stateWhenDescheduled === 'R+') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.RUNNABLE, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'D') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP);
          } else if (prevSlice.args.stateWhenDescheduled === 'T') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.STOPPED, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 't') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.DEBUG, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'Z') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.ZOMBIE, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'X') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.EXIT_DEAD, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'x') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.TASK_DEAD, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'K') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.WAKE_KILL, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'W') {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.WAKING, '',
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled === 'D|K') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL);
          } else if (prevSlice.args.stateWhenDescheduled === 'D|W') {
            pushSleep(SCHEDULING_STATE.UNINTR_SLEEP_WAKING);
          } else {
            slices.push(new tr.model.ThreadTimeSlice(
                thread, SCHEDULING_STATE.UNKNOWN, '',
                prevSlice.end, {}, midDuration));
            this.model_.importWarning({
              type: 'parse_error',
              message: 'Unrecognized sleep state: ' +
                  prevSlice.args.stateWhenDescheduled
            });
          }

          const runningSlice = new tr.model.ThreadTimeSlice(
              thread, SCHEDULING_STATE.RUNNING, '',
              nextSlice.start, {}, nextSlice.duration);
          runningSlice.cpuOnWhichThreadWasRunning = prevSlice.cpu;
          slices.push(runningSlice);
        }
        thread.timeSlices = slices;
      }, this);
    },

    /**
     * Creates an instance of each registered linux perf event parser.
     * This allows the parsers to register handlers for the events they
     * understand.  We also register our own special handlers (for the
     * timestamp synchronization markers).
     */
    createParsers_() {
      // Instantiate the parsers; this will register handlers for known events
      const allTypeInfos = tr.e.importer.linux_perf.
          Parser.getAllRegisteredTypeInfos();
      const parsers = allTypeInfos.map(
          function(typeInfo) {
            return new typeInfo.constructor(this);
          }, this);

      return parsers;
    },

    registerDefaultHandlers_() {
      this.registerEventHandler('tracing_mark_write',
          FTraceImporter.prototype.traceMarkingWriteEvent_.bind(this));
      // NB: old-style trace markers; deprecated
      this.registerEventHandler('0',
          FTraceImporter.prototype.traceMarkingWriteEvent_.bind(this));
      // Register dummy clock sync handlers to avoid warnings in the log.
      this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
          function() { return true; });
      this.registerEventHandler('0:trace_event_clock_sync',
          function() { return true; });
    },

    /**
     * Processes a trace_event_clock_sync event.
     */
    traceClockSyncEvent_(eventName, cpuNumber, pid, ts, eventBase) {
      // Check to see if we have a normal clock sync marker that contains a
      // sync ID and the current time according to the "ftrace global" clock.
      let event = /name=(\w+?)\s(.+)/.exec(eventBase.details);
      if (event) {
        // TODO(alexandermont): This section of code seems to be broken. It
        // creates an "args" variable, but doesn't seem to do anything with it.
        const name = event[1];
        const pieces = event[2].split(' ');
        const args = {
          perfTs: ts
        };
        for (let i = 0; i < pieces.length; i++) {
          const parts = pieces[i].split('=');
          if (parts.length !== 2) {
            throw new Error('omgbbq');
          }
          args[parts[0]] = parts[1];
        }

        this.model_.clockSyncManager.addClockSyncMarker(
            this.clockDomainId_, name, ts);
        return true;
      }

      // Check to see if we have a "new style" clock sync marker that contains
      // only a sync ID.
      event = /name=([\w\-]+)/.exec(eventBase.details);
      if (event) {
        this.model_.clockSyncManager.addClockSyncMarker(
            this.clockDomainId_, event[1], ts);
        return true;
      }

      // Check to see if we have a special clock sync marker that contains both
      // the current "ftrace global" time and the current CLOCK_MONOTONIC time.
      event = /parent_ts=(\d+\.?\d*)/.exec(eventBase.details);
      if (!event) return false;

      let monotonicTs = event[1] * 1000;
      // A monotonic timestamp of zero is used as a sentinel value to indicate
      // that CLOCK_MONOTONIC and the ftrace global clock are identical.
      if (monotonicTs === 0) monotonicTs = ts;

      if (this.haveClockSyncedMonotonicToGlobal_) {
        // ftrace sometimes includes multiple clock syncs between the monotonic
        // and global clocks within a single trace. We protect against this by
        // only taking the first one into account.
        return true;
      }

      // We have a clock sync event that contains two timestamps: a timestamp
      // according to the ftrace 'global' clock, and that same timestamp
      // according to clock_gettime(CLOCK_MONOTONIC).
      this.model_.clockSyncManager.addClockSyncMarker(
          this.clockDomainId_,
          MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID, ts);
      this.model_.clockSyncManager.addClockSyncMarker(
          tr.model.ClockDomainId.LINUX_CLOCK_MONOTONIC,
          MONOTONIC_TO_FTRACE_GLOBAL_SYNC_ID, monotonicTs);

      this.haveClockSyncedMonotonicToGlobal_ = true;
      return true;
    },

    /**
     * Processes a trace_marking_write event.
     */
    traceMarkingWriteEvent_(eventName, cpuNumber, pid, ts, eventBase,
        threadName) {
      // Some profiles end up with a \n\ on the end of each line. Strip it
      // before we do the comparisons.
      eventBase.details = eventBase.details.replace(/\\n.*$/, '');

      const event = /^\s*(\w+):\s*(.*)$/.exec(eventBase.details);
      if (!event) {
        // Check if the event matches events traced by the Android framework
        const tag = eventBase.details.substring(0, 2);
        if (tag === 'B|' || tag === 'E' || tag === 'E|' || tag === 'X|' ||
            tag === 'C|' || tag === 'S|' || tag === 'F|') {
          eventBase.subEventName = 'android';
        } else {
          return false;
        }
      } else {
        eventBase.subEventName = event[1];
        eventBase.details = event[2];
      }

      const writeEventName = eventName + ':' + eventBase.subEventName;
      const handler = this.eventHandlers_[writeEventName];
      if (!handler) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Unknown trace_marking_write event ' + writeEventName
        });
        return true;
      }
      return handler(writeEventName, cpuNumber, pid, ts, eventBase, threadName);
    },

    /**
     * Walks the this.events_ structure and creates Cpu objects.
     */
    importCpuData_(modelTimeTransformer) {
      this.forEachLine_(function(text, eventBase, cpuNumber, pid, ts) {
        const eventName = eventBase.eventName;
        const handler = this.eventHandlers_[eventName];
        if (!handler) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unknown event ' + eventName + ' (' + text + ')'
          });
          return;
        }
        ts = modelTimeTransformer(ts);
        if (!handler(eventName, cpuNumber, pid, ts, eventBase)) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Malformed ' + eventName + ' event (' + text + ')'
          });
        }
      }.bind(this));
    },

    /**
     * Walks the this.events_ structure and populates this.lines_.
     */
    parseLines_() {
      let extractResult = FTraceImporter._extractEventsFromSystraceHTML(
          this.events_, true);
      if (!extractResult.ok) {
        extractResult = FTraceImporter._extractEventsFromSystraceMultiHTML(
            this.events_, true);
      }
      let lineParser = undefined;
      if (extractResult.ok) {
        for (const line of extractResult.lines) {
          lineParser = this.parseLine_(line, lineParser);
        }
      } else {
        const r = new tr.importer.SimpleLineReader(this.events_);
        for (const line of r) {
          lineParser = this.parseLine_(line, lineParser);
        }
      }
    },

    parseLine_(line, lineParser) {
      line = line.trim();
      if (line.length === 0) return lineParser;
      if (/^#/.test(line)) {
        const clockType = /^# clock_type=([A-Z_]+)$/.exec(line);
        // This allows the clock domain to be specified through a comment,
        // Ex. "# clock_type=LINUX_CLOCK_MONOTONIC".
        // This is used in the WALT trace agent.
        if (clockType) {
          this.clockDomainId_ = clockType[1];
        }
        return lineParser;
      }

      if (!lineParser) {
        lineParser = autoDetectLineParser(line);
        if (!lineParser) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Cannot parse line: ' + line
          });
          return lineParser;
        }
      }

      const eventBase = lineParser(line);
      if (!eventBase) {
        this.model_.importWarning({
          type: 'parse_error',
          message: 'Unrecognized line: ' + line
        });
        return lineParser;
      }

      this.lines_.push([
        line,
        eventBase,
        parseInt(eventBase.cpuNumber),
        parseInt(eventBase.pid),
        parseFloat(eventBase.timestamp) * 1000
      ]);
      return lineParser;
    },

    /**
     * Calls |handler| for every parsed line.
     */
    forEachLine_(handler) {
      for (let i = 0; i < this.lines_.length; ++i) {
        const line = this.lines_[i];
        handler.apply(this, line);
      }
    },

    /**
     * Initializes the ftrace importer. This initialization can't be done in the
     * constructor because all trace event handlers may not have been registered
     * by that point.
     */
    lazyInit_() {
      this.parsers_ = this.createParsers_();
      this.registerDefaultHandlers_();
      this.parseLines_();
    }
  };

  tr.importer.Importer.register(FTraceImporter);

  return {
    FTraceImporter,
    _FTraceImporterTestExports: TestExports,
    IMPORT_PRIORITY,
  };
});


'use strict';

tr.exportTo('tr.e.importer.android.atrace_process_dump', function() {
  const IMPORT_PRIORITY = tr.e.importer.linux_perf.IMPORT_PRIORITY + 1;
  const HEADER = 'ATRACE_PROCESS_DUMP';

  const PROTECTION_FLAG_LETTERS = {
    '-': 0,
    'r': tr.model.VMRegion.PROTECTION_FLAG_READ,
    'w': tr.model.VMRegion.PROTECTION_FLAG_WRITE,
    'x': tr.model.VMRegion.PROTECTION_FLAG_EXECUTE,
    's': tr.model.VMRegion.PROTECTION_FLAG_MAYSHARE,
  };

  class AtraceProcessDumpImporter extends tr.importer.Importer {
    constructor(model, data) {
      super(model, data);
      this.importPriority = IMPORT_PRIORITY;
      this.model_ = model;
      this.raw_data_ = data;
      this.clock_sync_markers_ = {};
      this.snapshots_ = [];
      this.processes_ = {};
    }

    static canImport(events) {
      if (!(typeof(events) === 'string' || events instanceof String)) {
        return false;
      }
      return events.startsWith(HEADER);
    }

    get importerName() {
      return 'AtraceProcessDumpImporter';
    }

    get model() {
      return this.model_;
    }

    lazyParseData() {
      if (this.raw_data_ === undefined) {
        return;
      }
      const dump = JSON.parse(this.raw_data_.slice(HEADER.length + 1));
      this.clock_sync_markers_ = dump.clock_sync_markers;
      this.snapshots_ = dump.dump.snapshots;
      this.processes_ = dump.dump.processes;
      this.raw_data_ = undefined;
    }

    importClockSyncMarkers() {
      this.lazyParseData();
      for (const syncId in this.clock_sync_markers_) {
        const ts = parseInt(this.clock_sync_markers_[syncId]);
        this.model_.clockSyncManager.addClockSyncMarker(
            tr.model.ClockDomainId.LINUX_CLOCK_MONOTONIC, syncId, ts);
      }
    }

    setProcessMemoryDumpTotals_(pmd, processInfo) {
      pmd.totals = {
        'residentBytes': processInfo.rss * 1024,
        'platformSpecific': {
          'vm': processInfo.vm * 1024
        }
        // TODO(kraynov): Add OOM scores and make UI able to show it.
      };
      const totals = pmd.totals.platformSpecific;

      function importGpuMetric(name) {
        if (processInfo[name] !== undefined && processInfo[name] > 0) {
          totals[name] = processInfo[name] * 1024;
          totals[name + '_pss'] = processInfo[name + '_pss'] * 1024;
        }
      }
      importGpuMetric('gpu_egl');
      importGpuMetric('gpu_gl');
      importGpuMetric('gpu_etc');

      if (processInfo.pss !== undefined) {
        // Full stats.
        totals.pss = processInfo.pss * 1024;
        totals.swp = processInfo.swp * 1024;
        totals.pc = processInfo.pc * 1024;
        totals.pd = processInfo.pd * 1024;
        totals.sc = processInfo.sc * 1024;
        totals.sd = processInfo.sd * 1024;
      }
    }

    setProcessMemoryDumpVmRegions_(pmd, processInfo) {
      if (processInfo.mmaps === undefined) {
        return;
      }
      const vmRegions = [];
      for (const memoryMap of processInfo.mmaps) {
        const addr = memoryMap.vm.split('-').map(x => parseInt(x, 16));
        let flags = 0;
        for (const letter of memoryMap.flags) {
          flags |= PROTECTION_FLAG_LETTERS[letter];
        }
        const totals = {
          'proportionalResident': memoryMap.pss * 1024,
          'privateCleanResident': memoryMap.pc * 1024,
          'privateDirtyResident': memoryMap.pd * 1024,
          'sharedCleanResident': memoryMap.sc * 1024,
          'sharedDirtyResident': memoryMap.sd * 1024,
          'swapped': memoryMap.swp * 1024,
        };
        vmRegions.push(new tr.model.VMRegion(
            addr[0], addr[1] - addr[0], flags, memoryMap.file, totals));
      }
      pmd.vmRegions =
          tr.model.VMRegionClassificationNode.fromRegions(vmRegions);
    }

    importEvents() {
      this.lazyParseData();
      // Assign process and thread names.
      for (const [pid, process] of Object.entries(this.processes_)) {
        const modelProcess = this.model_.getProcess(pid);
        if (modelProcess === undefined) {
          continue;
        }
        modelProcess.name = process.name;

        const threads = process.threads;
        if (threads === undefined) {
          continue;
        }
        for (const [tid, thread] of Object.entries(threads)) {
          const modelThread = modelProcess.threads[tid];
          if (modelThread === undefined) {
            continue;
          }
          modelThread.name = thread.name;
        }
      }

      // Memory dumps.
      const memCounter =
          this.model_.kernel.getOrCreateCounter('global', 'SystemMemory');
      const memUsedSeries = new tr.model.CounterSeries('Used (KB)', 0);
      const memSwappedSeries = new tr.model.CounterSeries('Swapped (KB)', 0);
      memCounter.addSeries(memUsedSeries);
      memCounter.addSeries(memSwappedSeries);

      for (const snapshot of this.snapshots_) {
        const ts = parseInt(snapshot.ts);
        const memoryDump = snapshot.memdump;

        if (memoryDump === undefined) {
          const memInfo = snapshot.meminfo;
          if (memInfo === undefined) {
            continue;
          }

          // See Android com.android.server.am.ActivityManagerService class
          // for calculation formula in 'dumpsys meminfo'.
          //
          // The formula below excludes Cached PSS because it's too expensive
          // to calculate and it's not volatile during short systrace run.
          // Cached PSS is a total PSS of apps being primary targets for
          // OOM killer and treated by 'dumpsys meminfo' as a free memory.
          const memCaches = memInfo.Buffers + memInfo.Cached - memInfo.Mapped;
          const memUsed = memInfo.MemTotal - memInfo.MemFree - memCaches;
          const memSwapped = memInfo.SwapTotal - memInfo.SwapFree;

          memUsedSeries.addCounterSample(ts, memUsed);
          memSwappedSeries.addCounterSample(ts, memSwapped);
          continue;
        }

        const gmd = new tr.model.GlobalMemoryDump(this.model_, ts);
        this.model_.globalMemoryDumps.push(gmd);

        for (const [pid, processInfo] of Object.entries(memoryDump)) {
          if (processInfo.rss === undefined) {
            // Memory stats aren't available.
            continue;
          }
          const modelProcess = this.model_.getProcess(pid);
          if (modelProcess === undefined) {
            continue;
          }
          const pmd = new tr.model.ProcessMemoryDump(gmd, modelProcess, ts);
          gmd.processMemoryDumps[pid] = pmd;
          modelProcess.memoryDumps.push(pmd);
          this.setProcessMemoryDumpTotals_(pmd, processInfo);
          this.setProcessMemoryDumpVmRegions_(pmd, processInfo);
        }
      }
    }
  }

  tr.importer.Importer.register(AtraceProcessDumpImporter);

  return {
    AtraceProcessDumpImporter,
  };
});


'use strict';

/**
 * @fileoverview Class representing a user activity that is running
 * in the process.
 * On the Android platform, activities are mapped to Android Activities
 * running in the foreground of the process.
 * On Windows/OS X this could for example represent
 * the currently active window of the process.
 */
tr.exportTo('tr.model', function() {
  const ColorScheme = tr.b.ColorScheme;

  /**
   * @constructor
   * @param {String} name Name of the activity
   * @param {String} category Category of the activities
   * @param {String} range The time range where the activity was running
   * @param {String} args Additional arguments
   */
  function Activity(name, category, range, args) {
    tr.model.TimedEvent.call(this, range.min);
    this.title = name;
    this.category = category;
    this.colorId = ColorScheme.getColorIdForGeneralPurposeString(name);
    this.duration = range.duration;
    this.args = args;
    this.name = name;
  }

  Activity.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    shiftTimestampsForward(amount) {
      this.start += amount;
    },

    addBoundsToRange(range) {
      range.addValue(this.start);
      range.addValue(this.end);
    }
  };
  return {
    Activity,
  };
});


/**
 * @fileoverview Imports android event log data into the trace model.
 * Android event log data contains information about activities that
 * are launched/paused, processes that are started, memory usage, etc.
 *
 * The current implementation only parses activity events, with the goal of
 * determining which Activity is running in the foreground for a process.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 */
'use strict';

tr.exportTo('tr.e.importer.android', function() {
  const Importer = tr.importer.Importer;

  const ACTIVITY_STATE = {
    NONE: 'none',
    CREATED: 'created',
    STARTED: 'started',
    RESUMED: 'resumed',
    PAUSED: 'paused',
    STOPPED: 'stopped',
    DESTROYED: 'destroyed'
  };

  const activityMap = {};

  /**
   * Imports android event log data (adb logcat -b events)
   * @constructor
   */
  function EventLogImporter(model, events) {
    this.model_ = model;
    this.events_ = events;
    this.importPriority = 3;
  }

  // Generic format of event log entries.
  // Sample event log entry that this matches (split over 2 lines):
  // 08-11 13:12:31.405   880  2645 I am_focused_activity: [0,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL] // @suppress longLineCheck
  const eventLogActivityRE = new RegExp(
      '(\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d+)' +
      '\\s+(\\d+)\\s+(\\d+)\\s+([A-Z])\\s*' +
      '(am_\\w+)\\s*:(.*)');

  // 08-28 03:58:21.834   888  3177 I am_create_activity: [0,5972200,30,com.nxp.taginfolite/.activities.MainView,android.intent.action.MAIN,NULL,NULL,270532608] // @suppress longLineCheck
  // Store the name of the created activity only
  const amCreateRE = new RegExp('\s*\\[.*,.*,.*,(.*),.*,.*,.*,.*\\]');

  // 07-22 12:22:19.504   920  2504 I am_focused_activity: [0,com.android.systemui/.recents.RecentsActivity] // @suppress longLineCheck
  // Store the name of the focused activity only
  const amFocusedRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 07-21 19:56:12.315   920  2261 I am_proc_start: [0,19942,10062,com.google.android.talk,broadcast,com.google.android.talk/com.google.android.apps.hangouts.realtimechat.RealTimeChatService$AlarmReceiver] // @suppress longLineCheck
  // We care about proc starts on behalf of activities, and store the activity
  const amProcStartRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,.*,activity,(.*)\\]');

  // 07-22 12:21:43.490  2893  2893 I am_on_resume_called: [0,com.google.android.launcher.GEL] // @suppress longLineCheck
  // Store the activity name only
  const amOnResumeRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 07-22 12:22:19.545  2893  2893 I am_on_paused_called: [0,com.google.android.launcher.GEL] // @suppress longLineCheck
  // Store the activity name only
  const amOnPauseRE = new RegExp('\s*\\[\\d+,(.*)\\]');

  // 08-28 03:51:54.456   888   907 I am_activity_launch_time: [0,185307115,com.google.android.googlequicksearchbox/com.google.android.launcher.GEL,1174,1174] // @suppress longLineCheck
  // Store the activity name and launch times
  const amLaunchTimeRE = new RegExp('\s*\\[\\d+,\\d+,(.*),(\\d+),(\\d+)');

  // 08-28 03:58:15.854   888   902 I am_destroy_activity: [0,203516597,29,com.android.chrome/com.google.android.apps.chrome.Main,finish-idle] // @suppress longLineCheck
  // Store the activity name only
  const amDestroyRE = new RegExp('\s*\\[\\d+,\\d+,\\d+,(.*)\\]');

  /**
   * @return {boolean} True when events is an android event log array.
   */
  EventLogImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String)) {
      return false;
    }

    // Prevent the importer from matching this file in vulcanized traces.
    if (/^<!DOCTYPE html>/.test(events)) return false;

    return eventLogActivityRE.test(events);
  };

  EventLogImporter.prototype = {
    __proto__: Importer.prototype,

    get importerName() {
      return 'EventLogImporter';
    },

    get model() {
      return this.model_;
    },

    /**
     * @return {string} the full activity name (including package) from
     * a component
     */
    getFullActivityName(component) {
      const componentSplit = component.split('/');
      if (componentSplit[1].startsWith('.')) {
        return componentSplit[0] + componentSplit[1];
      }

      return componentSplit[1];
    },

    /**
     * @return {string} the process name of a component
     */
    getProcName(component) {
      const componentSplit = component.split('/');
      return componentSplit[0];
    },

    findOrCreateActivity(activityName) {
      if (activityName in activityMap) {
        return activityMap[activityName];
      }
      const activity = {
        state: ACTIVITY_STATE.NONE,
        name: activityName
      };
      activityMap[activityName] = activity;
      return activity;
    },

    deleteActivity(activityName) {
      delete activityMap[activityName];
    },

    handleCreateActivity(ts, activityName) {
      const activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.CREATED;
      activity.createdTs = ts;
    },

    handleFocusActivity(ts, procName, activityName) {
      const activity = this.findOrCreateActivity(activityName);
      activity.lastFocusedTs = ts;
    },

    handleProcStartForActivity(ts, activityName) {
      const activity = this.findOrCreateActivity(activityName);
      activity.procStartTs = ts;
    },

    handleOnResumeCalled(ts, pid, activityName) {
      const activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.RESUMED;
      activity.lastResumeTs = ts;
      // on_resume_called shows the actual PID; use this
      // to link the activity up with a process later
      activity.pid = pid;
    },

    handleOnPauseCalled(ts, activityName) {
      const activity = this.findOrCreateActivity(activityName);
      activity.state = ACTIVITY_STATE.PAUSED;
      activity.lastPauseTs = ts;
      // Create a new AndroidActivity representing the foreground state,
      // but only if the pause happened within the model bounds
      if (ts > this.model_.bounds.min && ts < this.model_.bounds.max) {
        this.addActivityToProcess(activity);
      }
    },

    handleLaunchTime(ts, activityName, launchTime) {
      const activity = this.findOrCreateActivity(activityName);
      activity.launchTime = launchTime;
    },

    handleDestroyActivity(ts, activityName) {
      this.deleteActivity(activityName);
    },

    addActivityToProcess(activity) {
      if (activity.pid === undefined) return;
      const process = this.model_.getOrCreateProcess(activity.pid);
      // The range of the activity is the time from resume to time
      // of pause; limit the start time to the beginning of the model
      const range = tr.b.math.Range.fromExplicitRange(
          Math.max(this.model_.bounds.min, activity.lastResumeTs),
          activity.lastPauseTs);
      const newActivity = new tr.model.Activity(activity.name,
          'Android Activity', range,
          {created: activity.createdTs,
            procstart: activity.procStartTs,
            lastfocus: activity.lastFocusedTs});
      process.activities.push(newActivity);
    },

    parseAmLine_(line) {
      let match = eventLogActivityRE.exec(line);
      if (!match) return;

      // Possible activity life-cycles:
      // 1) Launch from scratch:
      //   - am_create_activity
      //   - am_focused_activity
      //   - am_proc_start
      //   - am_proc_bound
      //   - am_restart_activity
      //   - am_on_resume_called
      // 2) Re-open existing activity
      //   - am_focused_activity
      //   - am_on_resume_called

      // HACK: event log date format is "MM-DD" and doesn't contain the year;
      // to figure out the year, take the min bound of the model, convert
      // to real-time and use that as the year.
      // The Android event log will eventually contain the year once this
      // CL is in a release:
      // https://android-review.googlesource.com/#/c/168900
      const firstRealtimeTs = this.model_.bounds.min -
          this.model_.realtime_to_monotonic_offset_ms;
      const year = new Date(firstRealtimeTs).getFullYear();
      const ts = match[1].substring(0, 5) + '-' + year + ' ' +
          match[1].substring(5, match[1].length);

      const monotonicTs = Date.parse(ts) +
          this.model_.realtime_to_monotonic_offset_ms;

      const pid = match[2];
      const action = match[5];
      const data = match[6];

      if (action === 'am_create_activity') {
        match = amCreateRE.exec(data);
        if (match && match.length >= 2) {
          this.handleCreateActivity(monotonicTs,
              this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_focused_activity') {
        match = amFocusedRE.exec(data);
        if (match && match.length >= 2) {
          this.handleFocusActivity(monotonicTs,
              this.getProcName(match[1]), this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_proc_start') {
        match = amProcStartRE.exec(data);
        if (match && match.length >= 2) {
          this.handleProcStartForActivity(monotonicTs,
              this.getFullActivityName(match[1]));
        }
      } else if (action === 'am_on_resume_called') {
        match = amOnResumeRE.exec(data);
        if (match && match.length >= 2) {
          this.handleOnResumeCalled(monotonicTs, pid, match[1]);
        }
      } else if (action === 'am_on_paused_called') {
        match = amOnPauseRE.exec(data);
        if (match && match.length >= 2) {
          this.handleOnPauseCalled(monotonicTs, match[1]);
        }
      } else if (action === 'am_activity_launch_time') {
        match = amLaunchTimeRE.exec(data);
        this.handleLaunchTime(monotonicTs,
            this.getFullActivityName(match[1]), match[2]);
      } else if (action === 'am_destroy_activity') {
        match = amDestroyRE.exec(data);
        if (match && match.length === 2) {
          this.handleDestroyActivity(monotonicTs,
              this.getFullActivityName(match[1]));
        }
      }
    },

    importEvents() {
      // Check if we have a mapping from real-time to CLOCK_MONOTONIC
      if (isNaN(this.model_.realtime_to_monotonic_offset_ms)) {
        this.model_.importWarning({
          type: 'eveng_log_clock_sync',
          message: 'Need a trace_event_clock_sync to map realtime to import.'
        });
        return;
      }
      // Since the event log typically spans a much larger timeframe
      // than the ftrace data, we want to calculate the bounds of the existing
      // model, and dump all event log data outside of those bounds
      this.model_.updateBounds();

      const lines = this.events_.split('\n');
      lines.forEach(this.parseAmLine_, this);

      // Iterate over all created activities that are not destroyed yet
      for (const activityName in activityMap) {
        const activity = activityMap[activityName];
        // If we're still in the foreground, store the activity anyway
        if (activity.state === ACTIVITY_STATE.RESUMED) {
          // Set the pause timestamp to the end of the model bounds
          activity.lastPauseTs = this.model_.bounds.max;
          this.addActivityToProcess(activity);
        }
      }
    }
  };

  Importer.register(EventLogImporter);

  return {
    EventLogImporter,
  };
});


/**
 * @fileoverview
 */
'use strict';

tr.exportTo('tr.e.importer.android.process_data', function() {
  const Importer = tr.importer.Importer;

  const PROCESS_DUMP_HEADER = 'PROCESS DUMP';

  /**
   * Imports android process data
   * @constructor
   */
  function ProcessDataImporter(model, processData) {
    this.model_ = model;
    this.processDataLines = processData.split('\n');
    this.importPriority = 3;
  }

  /**
   * @return {boolean}
   */
  ProcessDataImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String)) {
      return false;
    }

    if (events.split('\n')[0] === PROCESS_DUMP_HEADER) {
      return true;
    }

    return false;
  };

  ProcessDataImporter.prototype = {
    __proto__: Importer.prototype,

    get importerName() {
      return 'ProcessDataImporter';
    },

    get model() {
      return this.model_;
    },

    parseEventData(data) {
      const allDumpedProcesses = {};

      let parseProcesses = false;
      let parseThreads = false;
      let legacy = false;

      // Skip header on line 1.
      for (let i = 1; i < data.length; i++) {
        const cols = data[i].split(/\s+/);
        if (cols[0].startsWith('USER')) {
          if (parseProcesses) {
            parseProcesses = false;
            parseThreads = true;
          } else {
            parseThreads = false;
            parseProcesses = true;
          }

          const colCount = cols.length;
          if (parseProcesses && colCount === 9) {
            legacy = false;
          } else if (parseProcesses && colCount === 8) {
            legacy = true;
          }
          continue;
        }

        if (parseProcesses) {
          const pid = Number(cols[1]);
          if (allDumpedProcesses[pid] === undefined) {
            allDumpedProcesses[pid] = {};
          }
          allDumpedProcesses[pid] = {
            'name': cols[8], pid, 'comm': cols[9]
          };
          continue;
        }

        if (parseThreads) {
          let pid;
          let tid;
          let name;

          // In legacy ps dumps, the PID is actually shown in the PPID column
          // for thread lines, but PID column for the process line
          if (legacy) {
            pid = Number(cols[1]);
            if (allDumpedProcesses[pid] !== undefined) {
              // this is a process line in the dump.
              tid = pid;
            } else {
              // Thread line, so swap.
              tid = pid;
              pid = Number(cols[2]);  // i.e. the PPID column.
            }
            name = cols.slice(8).join(' ');
          } else {
            pid = Number(cols[1]);
            tid = Number(cols[2]);
            name = cols.slice(3).join(' ');
          }

          // Thread data for a process we didn't identify, skip.
          if (allDumpedProcesses[pid] === undefined) continue;

          if (allDumpedProcesses[pid].threads === undefined) {
            allDumpedProcesses[pid].threads = {};
          }
          allDumpedProcesses[pid].threads[tid] = {tid, name};
          continue;
        }
      }
      return allDumpedProcesses;
    },

    importEvents() {
      // Merge the snapshots into a single object, indexable by PID.

      const allDumpedProcesses = this.parseEventData(this.processDataLines);

      // Update the model with the new process / thread name data.
      const modelProcesses = this.model_.getAllProcesses();
      for (let i = 0; i < modelProcesses.length; i++) {
        const modelProcess = modelProcesses[i];
        const pid = modelProcess.pid;
        const dumpedProcess = allDumpedProcesses[pid];
        if (dumpedProcess === undefined) {
          // There's a process in the model that the ps dump doesn't know about,
          // nothing we can do so skip it.
          continue;
        }

        modelProcess.name = dumpedProcess.name;
        const processDumpThreads = dumpedProcess.threads;
        if (processDumpThreads !== undefined) {
          for (const tid in modelProcess.threads) {
            const modelThread = modelProcess.threads[tid];
            if (Number(pid) === Number(tid)) {
              modelThread.name = 'UI thread';
            } else if (modelThread.name === '<...>') {
              if (processDumpThreads[tid] !== undefined) {
                // Use the stored thread name that we have.
                modelThread.name = processDumpThreads[tid].name;
              }
            }
          }
        }
      }
    }
  };

  Importer.register(ProcessDataImporter);

  return {
    ProcessDataImporter,
  };
});


/**
 * @fileoverview Imports text files in the BattOr format into the
 * Model. This format is output by the battor_agent executable and library.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 */
'use strict';

tr.exportTo('tr.e.importer.battor', function() {
  /**
   * Imports a BattOr power trace into a specified model.
   * @constructor
   */
  function BattorImporter(model, events) {
    this.importPriority = 3; // runs after the linux_perf importer
    this.model_ = model;

    // The list of power samples contained within the trace.
    this.samples_ = [];
    // The clock sync markers contained within the trace.
    this.syncTimestampsById_ = new Map();

    this.parseTrace_(events);
  }

  const battorDataLineRE = new RegExp(
      '^(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)' +
      '(?:\\s+<(\\S+)>)?$'
  );
  const battorHeaderLineRE = /^# BattOr/;

  /**
   * Guesses whether the provided events is a BattOr string.
   * Looks for the magic string "# BattOr" at the start of the file,
   *
   * @return {boolean} True when events is a BattOr array.
   */
  BattorImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String)) {
      return false;
    }

    return battorHeaderLineRE.test(events);
  };

  BattorImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'BattorImporter';
    },

    get model() {
      return this.model_;
    },

    /**
     * Imports clock sync markers from the trace into into this.model_.
     */
    importClockSyncMarkers() {
      for (const [syncId, ts] of this.syncTimestampsById_) {
        this.model_.clockSyncManager.addClockSyncMarker(
            tr.model.ClockDomainId.BATTOR, syncId, ts);
      }
    },

    /**
     * Imports the events from the trace into this.model_.
     */
    importEvents() {
      if (this.model_.device.powerSeries) {
        this.model_.importWarning({
          type: 'import_error',
          message: 'Power counter exists, can not import BattOr power trace.'
        });
        return;
      }

      const modelTimeTransformer =
          this.model_.clockSyncManager.getModelTimeTransformer(
              tr.model.ClockDomainId.BATTOR);

      const powerSeries = this.model_.device.powerSeries =
          new tr.model.PowerSeries(this.model_.device);
      for (let i = 0; i < this.samples_.length; i++) {
        const sample = this.samples_[i];
        powerSeries.addPowerSample(
            modelTimeTransformer(sample.ts), sample.powerInW);
      }
    },

    /**
     * Given the BattOr trace as a string, parse it and store the results in
     * this.samples_ and this.syncTimestampsById_.
     */
    parseTrace_(trace) {
      const lines = trace.split('\n');

      for (let line of lines) {
        line = line.trim();

        if (line.length === 0) continue;

        if (line.startsWith('#')) continue;

        // Parse power sample.
        const groups = battorDataLineRE.exec(line);
        if (!groups) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'Unrecognized line in BattOr trace: ' + line
          });
          continue;
        }

        const ts = parseFloat(groups[1]);
        const voltageInV = tr.b.convertUnit(parseFloat(groups[2]),
            tr.b.UnitPrefixScale.METRIC.MILLI,
            tr.b.UnitPrefixScale.METRIC.NONE);
        const currentInA = tr.b.convertUnit(parseFloat(groups[3]),
            tr.b.UnitPrefixScale.METRIC.MILLI,
            tr.b.UnitPrefixScale.METRIC.NONE);
        const syncId = groups[4];

        if (syncId) {
          this.syncTimestampsById_.set(syncId, ts);
        }

        if (voltageInV < 0 || currentInA < 0) {
          this.model_.importWarning({
            type: 'parse_error',
            message: 'The following line in the BattOr trace has a negative ' +
                'voltage or current, neither of which are allowed: ' + line +
                '. A common cause of this is that the device is charging ' +
                'while the trace is being recorded.'
          });
          continue;
        }

        this.samples_.push(new Sample(ts, voltageInV, currentInA));
      }
    }
  };

  /**
   * A sample recorded by a BattOr.
   *
   * @param {number} ts The timestamp (in milliseconds) of the sample.
   * @param {number} voltage The voltage (in volts) at the specified time.
   * @param {number} current The current (in amps) at the specified time.
   *
   * @constructor
   */
  function Sample(ts, voltageInV, currentInA) {
    this.ts = ts;
    this.voltageInV = voltageInV;
    this.currentInA = currentInA;
  }

  Sample.prototype = {
    /** Returns the instantaneous power consumption (in Watts). */
    get powerInW() { return this.voltageInV * this.currentInA; }
  };

  tr.importer.Importer.register(BattorImporter);

  return {
    BattorImporter,
  };
});



/**
 * @fileoverview Blah.
 */
'use strict';

tr.exportTo('tr.e.importer.ddms', function() {
  const kPid = 0;
  const kCategory = 'java';
  const kMethodLutEndMarker = '\n*end\n';
  const kThreadsStart = '\n*threads\n';
  const kMethodsStart = '\n*methods\n';

  const kTraceMethodEnter = 0x00;       // method entry
  const kTraceMethodExit = 0x01;        // method exit
  const kTraceUnroll = 0x02;            // method exited by exception unrolling
  // 0x03 currently unused
  const kTraceMethodActionMask = 0x03;  // two bits

  const kTraceHeaderLength = 32;
  const kTraceMagicValue = 0x574f4c53;
  const kTraceVersionSingleClock = 2;
  const kTraceVersionDualClock = 3;
  const kTraceRecordSizeSingleClock = 10;  // using v2
  const kTraceRecordSizeDualClock = 14;  // using v3 with two timestamps

  function Reader(stringPayload) {
    this.position_ = 0;
    this.data_ = JSZip.utils.transformTo('uint8array', stringPayload);
  }

  Reader.prototype = {
    __proto__: Object.prototype,

    uint8() {
      const result = this.data_[this.position_];
      this.position_ += 1;
      return result;
    },

    uint16() {
      let result = 0;
      result += this.uint8();
      result += this.uint8() << 8;
      return result;
    },

    uint32() {
      let result = 0;
      result += this.uint8();
      result += this.uint8() << 8;
      result += this.uint8() << 16;
      result += this.uint8() << 24;
      return result;
    },

    uint64() {
      // Javascript isn't able to manage 64-bit numeric values.
      const low = this.uint32();
      const high = this.uint32();
      const lowStr = ('0000000' + low.toString(16)).substr(-8);
      const highStr = ('0000000' + high.toString(16)).substr(-8);
      const result = highStr + lowStr;
      return result;
    },

    seekTo(position) {
      this.position_ = position;
    },

    hasMore() {
      return this.position_ < this.data_.length;
    }
  };

  /**
   * Imports DDMS method tracing events into a specified model.
   * @constructor
   */
  function DdmsImporter(model, data) {
    this.importPriority = 3;
    this.model_ = model;
    this.data_ = data;
  }

  /**
   * Guesses whether the provided events is from a DDMS method trace.
   * @return {boolean} True when events is a DDMS method trace.
   */
  DdmsImporter.canImport = function(data) {
    if (typeof(data) === 'string' || data instanceof String) {
      const header = data.slice(0, 1000);
      return header.startsWith('*version\n') &&
        header.indexOf('\nvm=') >= 0 &&
        header.indexOf(kThreadsStart) >= 0;
    }
    /* key bit */
    return false;
  };

  DdmsImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'DdmsImporter';
    },

    get model() {
      return this.model_;
    },

    /**
     * Imports the data in this.data_ into this.model_.
     */
    importEvents() {
      const divider = this.data_.indexOf(kMethodLutEndMarker) +
          kMethodLutEndMarker.length;
      this.metadata_ = this.data_.slice(0, divider);
      this.methods_ = {};
      this.parseThreads();
      this.parseMethods();

      const traceReader = new Reader(this.data_.slice(divider));
      const magic = traceReader.uint32();
      if (magic !== kTraceMagicValue) {
        throw Error('Failed to match magic value');
      }
      this.version_ = traceReader.uint16();
      if (this.version_ !== kTraceVersionDualClock) {
        throw Error('Unknown version');
      }
      const dataOffest = traceReader.uint16();
      const startDateTime = traceReader.uint64();
      const recordSize = traceReader.uint16();

      traceReader.seekTo(dataOffest);

      while (traceReader.hasMore()) {
        this.parseTraceEntry(traceReader);
      }
    },

    parseTraceEntry(reader) {
      const tid = reader.uint16();
      const methodPacked = reader.uint32();
      const cpuSinceStart = reader.uint32();
      const wallClockSinceStart = reader.uint32();
      let method = methodPacked & ~kTraceMethodActionMask;
      const action = methodPacked & kTraceMethodActionMask;
      const thread = this.getTid(tid);
      method = this.getMethodName(method);
      if (action === kTraceMethodEnter) {
        thread.sliceGroup.beginSlice(kCategory, method, wallClockSinceStart,
            undefined, cpuSinceStart);
      } else if (thread.sliceGroup.openSliceCount) {
        thread.sliceGroup.endSlice(wallClockSinceStart, cpuSinceStart);
      }
    },

    parseThreads() {
      let threads = this.metadata_.slice(this.metadata_.indexOf(kThreadsStart) +
          kThreadsStart.length);
      threads = threads.slice(0, threads.indexOf('\n*'));
      threads = threads.split('\n');
      threads.forEach(this.parseThread.bind(this));
    },

    parseThread(threadLine) {
      const tid = threadLine.slice(0, threadLine.indexOf('\t'));
      const thread = this.getTid(parseInt(tid));
      thread.name = threadLine.slice(threadLine.indexOf('\t') + 1);
    },

    getTid(tid) {
      return this.model_.getOrCreateProcess(kPid)
          .getOrCreateThread(tid);
    },

    parseMethods() {
      let methods = this.metadata_.slice(this.metadata_.indexOf(kMethodsStart) +
          kMethodsStart.length);
      methods = methods.slice(0, methods.indexOf('\n*'));
      methods = methods.split('\n');
      methods.forEach(this.parseMethod.bind(this));
    },

    parseMethod(methodLine) {
      const data = methodLine.split('\t');
      const methodId = parseInt(data[0]);
      const methodName = data[1] + '.' + data[2] + data[3];
      this.addMethod(methodId, methodName);
    },

    addMethod(methodId, methodName) {
      this.methods_[methodId] = methodName;
    },

    getMethodName(methodId) {
      return this.methods_[methodId];
    }
  };

  // Register the DdmsImporter to the Importer.
  tr.importer.Importer.register(DdmsImporter);

  return {
    DdmsImporter,
  };
});


'use strict';
tr.exportTo('tr.e.audits', function() {
  /**
   * Auditor that analyzes the model and annotates low memory events.
   */
  class LowMemoryAuditor extends tr.c.Auditor {

    constructor(model) {
      super();
      this.model_ = model;
    }

    runAnnotate() {
      this.model_.device.lowMemoryEvents = this.getLowMemoryEvents_();
    }

    /**
     * Returns a list of low memory killer events.
     */
    getLowMemoryEvents_() {
      const model = this.model_;
      const result = [];
      for (const process of model.getAllProcesses()) {
        for (const e of process.getDescendantEvents()) {
          // low memory killer events are 0-duration events.
          if (!(e instanceof tr.model.ThreadSlice) || e.duration !== 0) {
            continue;
          }

          if (e.category !== 'lowmemory') {
            continue;
          }

          result.push(e);
        }
      }
      return result;
    }
  }

  tr.c.Auditor.register(LowMemoryAuditor);

  return {
    LowMemoryAuditor
  };
});


'use strict';

function filterDuplicateTimestamps(timestamps) {
  const dedupedTimestamps = [];
  let lastTs = 0;
  for (const ts of timestamps) {
    if (ts - lastTs >= 1) {
      dedupedTimestamps.push(ts);
      lastTs = ts;
    }
  }
  return dedupedTimestamps;
}

tr.exportTo('tr.e.audits', function() {
  const VSYNC_COUNTER_PRECISIONS = {
    // Android. Some versions have VSYNC split out into VSYNC-app and VSYNC-sf.
    // Requires "gfx" systrace category to be enabled.
    'android.VSYNC-app': 15,
    'android.VSYNC': 15
  };

  const VSYNC_SLICE_PRECISIONS = {
    // Android.
    'RenderWidgetHostViewAndroid::OnVSync': 5,
    // Android. Very precise. Requires "gfx" systrace category to be enabled.
    'VSYNC': 10,
    // Linux. Very precise. Requires "gpu" tracing category to be enabled.
    'vblank': 10,
    // Mac. Derived from a Mac callback (CVDisplayLinkSetOutputCallback).
    'DisplayLinkMac::GetVSyncParameters': 5
  };

  const BEGIN_FRAME_SLICE_PRECISION = {
    'DisplayScheduler::BeginFrame': 10
  };

  /**
   * Auditor that analyzes the model and, if possible, adds data to it
   * indicating when vertical sync events took place.
   *
   * @constructor
   * @extends {tr.c.Auditor}
   */
  function VSyncAuditor(model) {
    tr.c.Auditor.call(this, model);
  }

  VSyncAuditor.prototype = {
    __proto__: tr.c.Auditor.prototype,

    runAnnotate() {
      this.model.device.vSyncTimestamps = this.findVSyncTimestamps(this.model);
    },

    /**
     * Returns an array of the most accurate VSync times available in the model.
     */
    findVSyncTimestamps(model) {
      let times = [];

      // Only keep the most precise VSync data.
      let maxPrecision = Number.NEGATIVE_INFINITY;
      let maxTitle = undefined;

      function useInstead(title, precisions) {
        const precision = precisions[title];
        if (precision === undefined) return false;

        if (title === maxTitle) return true;

        if (precision <= maxPrecision) {
          if (precision === maxPrecision) {
            model.importWarning({
              type: 'VSyncAuditor',
              message: 'Encountered two different VSync events (' +
                  maxTitle + ', ' + title + ') with the same precision, ' +
                  'ignoring the newer one (' + title + ')',
              showToUser: false,
            });
          }
          return false;
        }
        maxPrecision = precision;
        maxTitle = title;
        times = [];

        return true;
      }

      for (const pid in model.processes) {
        const process = model.processes[pid];
        // Traverse process counters.
        for (const cid in process.counters) {
          if (useInstead(cid, VSYNC_COUNTER_PRECISIONS)) {
            const counter = process.counters[cid];
            for (let i = 0; i < counter.series.length; i++) {
              const series = counter.series[i];
              Array.prototype.push.apply(times, series.timestamps);
            }
          }
        }

        // Traverse thread slices.
        for (const tid in process.threads) {
          const thread = process.threads[tid];
          for (let i = 0; i < thread.sliceGroup.slices.length; i++) {
            const slice = thread.sliceGroup.slices[i];
            if (useInstead(slice.title, VSYNC_SLICE_PRECISIONS)) {
              times.push(slice.start);
            } else if (useInstead(slice.title, BEGIN_FRAME_SLICE_PRECISION) &&
                       slice.args.args && slice.args.args.frame_time_us) {
              // We need to check not only that we have a Scheduler::BeginFrame
              // event, but also that we have one that has a frame time
              // associated with it.
              // Older versions of Scheduler::BeginFrame don't have one.
              times.push(slice.args.args.frame_time_us / 1000.0);
            }
          }
        }
      }
      times.sort(function(x, y) { return x - y; });
      return filterDuplicateTimestamps(times);
    }
  };

  tr.c.Auditor.register(VSyncAuditor);

  return {
    VSyncAuditor,
  };
});


'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
tr.exportTo('tr.importer', function() {
  /**
   * Importer for empty strings and arrays.
   * @constructor
   */
  function EmptyImporter(events) {
    this.importPriority = 0;
  }

  EmptyImporter.canImport = function(eventData) {
    if (eventData instanceof Array && eventData.length === 0) {
      return true;
    }
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      return eventData.length === 0;
    }
    return false;
  };

  EmptyImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'EmptyImporter';
    }
  };

  tr.importer.Importer.register(EmptyImporter);

  return {
    EmptyImporter,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  // This global instant event marks the start of a navigation.
  const NAVIGATION_START = 'NavigationTiming navigationStart';

  // This render-process instant event marks the first contentful paint in a
  // main frame.
  const FIRST_CONTENTFUL_PAINT_TITLE = 'firstContentfulPaint';

  function findLoadExpectations(modelHelper) {
    const events = [];
    for (const event of modelHelper.model.getDescendantEvents()) {
      if ((event.title === NAVIGATION_START) ||
          (event.title === FIRST_CONTENTFUL_PAINT_TITLE)) {
        events.push(event);
      }
    }
    events.sort(tr.importer.compareEvents);

    const loads = [];
    let startEvent = undefined;
    // TODO(alexandermont): What's supposed to happen if there are two
    // NAVIGATION_STARTs with no FIRST_CONTENTFUL_PAINT_TITLE between
    // them? Are you supposed to just "lose" the first NAVIGATION_START,
    // like what's happening now?
    for (const event of events) {
      if (event.title === NAVIGATION_START) {
        startEvent = event;
      } else if (event.title === FIRST_CONTENTFUL_PAINT_TITLE) {
        if (startEvent) {
          loads.push(new tr.model.um.LoadExpectation(
              modelHelper.model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL,
              startEvent.start, event.start - startEvent.start));
          startEvent = undefined;
        }
      }
    }

    // If the trace ended between navigation start and first contentful paint,
    // then make a LoadExpectation that ends at the end of the trace.
    if (startEvent) {
      loads.push(new tr.model.um.LoadExpectation(
            modelHelper.model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL,
            startEvent.start, modelHelper.model.bounds.max - startEvent.start));
    }

    return loads;
  }

  return {
    findLoadExpectations,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  function StartupExpectation(parentModel, start, duration) {
    tr.model.um.UserExpectation.call(
        this, parentModel, '', start, duration);
  }

  StartupExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: StartupExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(StartupExpectation, {
    stageTitle: 'Startup',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('startup')
  });

  return {
    StartupExpectation,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  function getAllFrameEvents(modelHelper) {
    const frameEvents = [];
    frameEvents.push.apply(frameEvents,
        modelHelper.browserHelper.getFrameEventsInRange(
            tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));

    for (const renderer of Object.values(modelHelper.rendererHelpers)) {
      frameEvents.push.apply(frameEvents, renderer.getFrameEventsInRange(
          tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));
    }
    return frameEvents.sort(tr.importer.compareEvents);
  }

  // If a thread contains a typical initialization slice, then the first event
  // on that thread is a startup event.
  function getStartupEvents(modelHelper) {
    function isStartupSlice(slice) {
      return slice.title === 'BrowserMainLoop::CreateThreads';
    }
    const events = modelHelper.browserHelper.getAllAsyncSlicesMatching(
        isStartupSlice);
    const deduper = new tr.model.EventSet();
    events.forEach(function(event) {
      const sliceGroup = event.parentContainer.sliceGroup;
      const slice = sliceGroup && sliceGroup.findFirstSlice();
      if (slice) {
        deduper.push(slice);
      }
    });
    return deduper.toArray();
  }

  // Match every event in |openingEvents| to the first following event from
  // |closingEvents| and return an array containing a load interaction record
  // for each pair.
  function findStartupExpectations(modelHelper) {
    const openingEvents = getStartupEvents(modelHelper);
    const closingEvents = getAllFrameEvents(modelHelper);
    const startups = [];
    openingEvents.forEach(function(openingEvent) {
      closingEvents.forEach(function(closingEvent) {
        // Ignore opening event that already have a closing event.
        if (openingEvent.closingEvent) return;

        // Ignore closing events that already belong to an opening event.
        if (closingEvent.openingEvent) return;

        // Ignore closing events before |openingEvent|.
        if (closingEvent.start <= openingEvent.start) return;

        // Ignore events from different threads.
        if (openingEvent.parentContainer.parent.pid !==
            closingEvent.parentContainer.parent.pid) {
          return;
        }

        // This is the first closing event for this opening event, record it.
        openingEvent.closingEvent = closingEvent;
        closingEvent.openingEvent = openingEvent;
        const se = new tr.model.um.StartupExpectation(
            modelHelper.model, openingEvent.start,
            closingEvent.end - openingEvent.start);
        se.associatedEvents.push(openingEvent);
        se.associatedEvents.push(closingEvent);
        startups.push(se);
      });
    });
    return startups;
  }

  return {
    findStartupExpectations,
  };
});


'use strict';

tr.exportTo('tr.model', function() {
  function getAssociatedEvents(irs) {
    const allAssociatedEvents = new tr.model.EventSet();
    irs.forEach(function(ir) {
      ir.associatedEvents.forEach(function(event) {
        // FlowEvents don't have parentContainers or cpuDurations, and it's
        // annoying to highlight them.
        if (event instanceof tr.model.FlowEvent) return;
        allAssociatedEvents.push(event);
      });
    });
    return allAssociatedEvents;
  }

  function getUnassociatedEvents(model, associatedEvents) {
    const unassociatedEvents = new tr.model.EventSet();
    // The set of unassociated events contains only events that are not in
    // the set of associated events.
    // Only add event to the set of unassociated events if it is not in
    // the set of associated events.
    for (const proc of model.getAllProcesses()) {
      for (const thread of Object.values(proc.threads)) {
        for (const event of thread.sliceGroup.getDescendantEvents()) {
          if (!associatedEvents.contains(event)) {
            unassociatedEvents.push(event);
          }
        }
      }
    }
    return unassociatedEvents;
  }

  function getTotalCpuDuration(events) {
    let cpuMs = 0;
    events.forEach(function(event) {
      // Add up events' cpu self time if they have any.
      if (event.cpuSelfTime) {
        cpuMs += event.cpuSelfTime;
      }
    });
    return cpuMs;
  }

  function getIRCoverageFromModel(model) {
    const associatedEvents = getAssociatedEvents(model.userModel.expectations);

    if (!associatedEvents.length) return undefined;

    const unassociatedEvents = getUnassociatedEvents(
        model, associatedEvents);

    const associatedCpuMs = getTotalCpuDuration(associatedEvents);
    const unassociatedCpuMs = getTotalCpuDuration(unassociatedEvents);

    const totalEventCount = associatedEvents.length + unassociatedEvents.length;
    const totalCpuMs = associatedCpuMs + unassociatedCpuMs;
    let coveredEventsCpuTimeRatio = undefined;
    if (totalCpuMs !== 0) {
      coveredEventsCpuTimeRatio = associatedCpuMs / totalCpuMs;
    }

    return {
      associatedEventsCount: associatedEvents.length,
      unassociatedEventsCount: unassociatedEvents.length,
      associatedEventsCpuTimeMs: associatedCpuMs,
      unassociatedEventsCpuTimeMs: unassociatedCpuMs,
      coveredEventsCountRatio: associatedEvents.length / totalEventCount,
      coveredEventsCpuTimeRatio
    };
  }

  return {
    getIRCoverageFromModel,
    getAssociatedEvents,
    getUnassociatedEvents,
  };
});


'use strict';

tr.exportTo('tr.model.um', function() {
  function IdleExpectation(parentModel, start, duration) {
    const initiatorTitle = '';
    tr.model.um.UserExpectation.call(
        this, parentModel, initiatorTitle, start, duration);
  }

  IdleExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: IdleExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(IdleExpectation, {
    stageTitle: 'Idle',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_idle')
  });

  return {
    IdleExpectation,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  const INSIGNIFICANT_MS = 1;

  class UserModelBuilder {
    constructor(model) {
      this.model = model;
      this.modelHelper = model.getOrCreateHelper(
          tr.model.helpers.ChromeModelHelper);
    }

    static supportsModelHelper(modelHelper) {
      return modelHelper.browserHelper !== undefined;
    }

    /**
     * This is called during the trace model import process.
     */
    buildUserModel() {
      if (!this.modelHelper || !this.modelHelper.browserHelper) return;

      try {
        for (const ue of this.findUserExpectations()) {
          // This is an EventSet, not an Array, so it can't use push(...).
          // https://github.com/catapult-project/catapult/issues/3157
          this.model.userModel.expectations.push(ue);
        }
        this.model.userModel.segments.push(...this.findSegments());
        // There are not currently any known cases when this could throw,
        // but there have been in the past and there could be again, so
        // keep handling exceptions here to be friendly to the future.
      } catch (error) {
        this.model.importWarning({
          type: 'UserModelBuilder',
          message: error,
          showToUser: true
        });
      }
    }

    /**
     * Returns an array of Segments covering the trace Model. A Segment
     * represents a range of time during which the set of active
     * UserExpectations does not change. Because of this, segments are
     * guaranteed to not overlap, whereas UserExpectations can.
     *
     * @return {!Array.<!tr.model.um.Segment>}
     */
    findSegments() {
      let timestamps = new Set();
      for (const expectation of this.model.userModel.expectations) {
        timestamps.add(expectation.start);
        timestamps.add(expectation.end);
      }
      timestamps = [...timestamps];
      timestamps.sort((x, y) => x - y);
      const segments = [];
      for (let i = 0; i < timestamps.length - 1; ++i) {
        const segment = new tr.model.um.Segment(
            timestamps[i], timestamps[i + 1] - timestamps[i]);
        segments.push(segment);
        const segmentRange = tr.b.math.Range.fromExplicitRange(
            segment.start, segment.end);
        for (const expectation of this.model.userModel.expectations) {
          const expectationRange = tr.b.math.Range.fromExplicitRange(
              expectation.start, expectation.end);
          if (segmentRange.intersectsRangeExclusive(expectationRange)) {
            segment.expectations.push(expectation);
          }
        }
      }
      return segments;
    }

    /**
     * Returns an array of UserExpectations covering the trace Model. A
     * UserExpectation represents a range of time during which the user is
     * expecting something from Chrome, either to startup or load a page or
     * respond to input or play an animation, or just sit there idle. Users can
     * have multiple expectations at any given time, so UserExpectations can
     * overlap.
     *
     * @return {!Array.<!tr.model.um.UserExpectation>}
     */
    findUserExpectations() {
      const expectations = [];
      expectations.push.apply(expectations, tr.importer.findStartupExpectations(
          this.modelHelper));
      expectations.push.apply(expectations, tr.importer.findLoadExpectations(
          this.modelHelper));
      expectations.push.apply(expectations, tr.importer.findInputExpectations(
          this.modelHelper));
      // findIdleExpectations must be called last!
      expectations.push.apply(
          expectations, this.findIdleExpectations(expectations));
      this.collectUnassociatedEvents_(expectations);
      return expectations;
    }

    // Find all unassociated top-level ThreadSlices. If they start during an
    // Idle or Load UE, then add their entire hierarchy to that UE.
    collectUnassociatedEvents_(expectations) {
      const vacuumUEs = [];
      for (const expectation of expectations) {
        if (expectation instanceof tr.model.um.IdleExpectation ||
            expectation instanceof tr.model.um.LoadExpectation ||
            expectation instanceof tr.model.um.StartupExpectation) {
          vacuumUEs.push(expectation);
        }
      }
      if (vacuumUEs.length === 0) return;

      const allAssociatedEvents = tr.model.getAssociatedEvents(expectations);
      const unassociatedEvents = tr.model.getUnassociatedEvents(
          this.model, allAssociatedEvents);

      for (const event of unassociatedEvents) {
        if (!(event instanceof tr.model.ThreadSlice)) continue;

        if (!event.isTopLevel) continue;

        for (let index = 0; index < vacuumUEs.length; ++index) {
          const expectation = vacuumUEs[index];

          if ((event.start >= expectation.start) &&
              (event.start < expectation.end)) {
            expectation.associatedEvents.addEventSet(event.entireHierarchy);
            break;
          }
        }
      }
    }

    // Fill in the empty space between UEs with IdleUEs.
    findIdleExpectations(otherUEs) {
      if (this.model.bounds.isEmpty) return;

      const emptyRanges = tr.b.math.findEmptyRangesBetweenRanges(
          tr.b.math.convertEventsToRanges(otherUEs),
          this.model.bounds);
      const expectations = [];
      const model = this.model;
      for (const range of emptyRanges) {
        // Ignore insignificantly tiny idle ranges.
        if (range.max < (range.min + INSIGNIFICANT_MS)) continue;

        expectations.push(new tr.model.um.IdleExpectation(
            model, range.min, range.max - range.min));
      }
      return expectations;
    }
  }

  function createCustomizeModelLinesFromModel(model) {
    const modelLines = [];
    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {title: \'model start\', start: 0, end: 1});');

    const typeNames = {};
    for (const typeName in tr.e.cc.INPUT_EVENT_TYPE_NAMES) {
      typeNames[tr.e.cc.INPUT_EVENT_TYPE_NAMES[typeName]] = typeName;
    }

    let modelEvents = new tr.model.EventSet();
    for (const ue of model.userModel.expectations) {
      modelEvents.addEventSet(ue.sourceEvents);
    }
    modelEvents = modelEvents.toArray();
    modelEvents.sort(tr.importer.compareEvents);

    for (const event of modelEvents) {
      const startAndEnd = 'start: ' + parseInt(event.start) + ', ' +
                        'end: ' + parseInt(event.end) + '});';
      if (event instanceof tr.e.cc.InputLatencyAsyncSlice) {
        modelLines.push('      audits.addInputEvent(model, INPUT_TYPE.' +
                        typeNames[event.typeName] + ',');
      } else if (event.title === 'RenderFrameImpl::didCommitProvisionalLoad') {
        modelLines.push('      audits.addCommitLoadEvent(model,');
      } else if (event.title ===
                 'InputHandlerProxy::HandleGestureFling::started') {
        modelLines.push('      audits.addFlingAnimationEvent(model,');
      } else if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) {
        modelLines.push('      audits.addFrameEvent(model,');
      } else if (event.title === tr.importer.CSS_ANIMATION_TITLE) {
        modelLines.push('      audits.addEvent(model.rendererMain, {');
        modelLines.push('        title: \'Animation\', ' + startAndEnd);
        return;
      } else {
        throw new Error(
            'You must extend createCustomizeModelLinesFromModel()' +
            'to support this event:\n' + event.title + '\n');
      }
      modelLines.push('          {' + startAndEnd);
    }

    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {' +
                    'title: \'model end\', ' +
                    'start: ' + (parseInt(model.bounds.max) - 1) + ', ' +
                    'end: ' + parseInt(model.bounds.max) + '});');
    return modelLines;
  }

  function createExpectedUELinesFromModel(model) {
    const expectedLines = [];
    const ueCount = model.userModel.expectations.length;
    for (let index = 0; index < ueCount; ++index) {
      const expectation = model.userModel.expectations[index];
      let ueString = '      {';
      ueString += 'title: \'' + expectation.title + '\', ';
      ueString += 'start: ' + parseInt(expectation.start) + ', ';
      ueString += 'end: ' + parseInt(expectation.end) + ', ';
      ueString += 'eventCount: ' + expectation.sourceEvents.length;
      ueString += '}';
      if (index < (ueCount - 1)) ueString += ',';
      expectedLines.push(ueString);
    }
    return expectedLines;
  }

  function createUEFinderTestCaseStringFromModel(model) {
    const filename = window.location.hash.substr(1);
    let testName = filename.substr(filename.lastIndexOf('/') + 1);
    testName = testName.substr(0, testName.indexOf('.'));

    // createCustomizeModelLinesFromModel() throws an error if there's an
    // unsupported event.
    try {
      const testLines = [];
      testLines.push('  /*');
      testLines.push('    This test was generated from');
      testLines.push('    ' + filename + '');
      testLines.push('   */');
      testLines.push('  test(\'' + testName + '\', function() {');
      testLines.push('    const verifier = new UserExpectationVerifier();');
      testLines.push('    verifier.customizeModelCallback = function(model) {');
      testLines.push.apply(testLines,
          createCustomizeModelLinesFromModel(model));
      testLines.push('    };');
      testLines.push('    verifier.expectedUEs = [');
      testLines.push.apply(testLines, createExpectedUELinesFromModel(model));
      testLines.push('    ];');
      testLines.push('    verifier.verify();');
      testLines.push('  });');
      return testLines.join('\n');
    } catch (error) {
      return error;
    }
  }

  return {
    UserModelBuilder,
    createUEFinderTestCaseStringFromModel,
  };
});


'use strict';

tr.exportTo('tr.importer', function() {
  const Timing = tr.b.Timing;

  function ImportOptions() {
    this.shiftWorldToZero = true;
    this.pruneEmptyContainers = true;
    this.showImportWarnings = true;
    this.trackDetailedModelStats = false;

    // Callback called after
    // importers run in which more data can be added to the model, before it is
    // finalized.
    this.customizeModelCallback = undefined;

    const auditorTypes = tr.c.Auditor.getAllRegisteredTypeInfos();
    this.auditorConstructors = auditorTypes.map(function(typeInfo) {
      return typeInfo.constructor;
    });
  }

  function Import(model, opt_options) {
    if (model === undefined) {
      throw new Error('Must provide model to import into.');
    }

    // TODO(dsinclair): Check the model is empty.

    this.importing_ = false;
    this.importOptions_ = opt_options || new ImportOptions();

    this.model_ = model;
    this.model_.importOptions = this.importOptions_;
  }

  Import.prototype = {
    __proto__: Object.prototype,

    /**
     * Imports the provided traces into the model. The eventData type
     * is undefined and will be passed to all the importers registered
     * via Importer.register. The first importer that returns true
     * for canImport(events) will be used to import the events.
     *
     * The primary trace is provided via the eventData variable. If multiple
     * traces are to be imported, specify the first one as events, and the
     * remainder in the opt_additionalEventData array.
     *
     * @param {Array} traces An array of eventData to be imported. Each
     * eventData should correspond to a single trace file and will be handled by
     * a separate importer.
     */
    importTraces(traces) {
      const progressMeter = {
        update(msg) {}
      };

      tr.b.Task.RunSynchronously(
          this.createImportTracesTask(progressMeter, traces));
    },

    /**
     * Imports a trace with the usual options from importTraces, but
     * does so using idle callbacks, putting up an import dialog
     * during the import process.
     */
    importTracesWithProgressDialog(traces) {
      if (tr.isHeadless) {
        throw new Error('Cannot use this method in headless mode.');
      }

      const overlay = tr.ui.b.Overlay();
      overlay.title = 'Importing...';
      overlay.userCanClose = false;
      overlay.msgEl = document.createElement('div');
      Polymer.dom(overlay).appendChild(overlay.msgEl);
      overlay.msgEl.style.margin = '20px';
      overlay.update = function(msg) {
        Polymer.dom(this.msgEl).textContent = msg;
      };
      overlay.visible = true;

      const promise =
          tr.b.Task.RunWhenIdle(this.createImportTracesTask(overlay, traces));
      promise.then(
          function() { overlay.visible = false; },
          function(err) { overlay.visible = false; }
      );
      return promise;
    },

    /**
     * Creates a task that will import the provided traces into the model,
     * updating the progressMeter as it goes. Parameters are as defined in
     * importTraces.
     */
    createImportTracesTask(progressMeter, traces) {
      const importStartTimeMs = performance.now();
      if (this.importing_) {
        throw new Error('Already importing.');
      }
      this.importing_ = true;

      // Just some simple setup. It is useful to have a no-op first
      // task so that we can set up the lastTask = lastTask.after()
      // pattern that follows.
      const importTask = new tr.b.Task(function prepareImport() {
        progressMeter.update('I will now import your traces for you...');
      }, this);
      let lastTask = importTask;

      const importers = [];

      function addImportStage(title, callback) {
        lastTask = lastTask.after(() => progressMeter.update(title));
        lastTask.updatesUi = true;
        lastTask = lastTask.after(callback);
      }

      function addStageForEachImporter(title, callback) {
        lastTask = lastTask.after((task) => {
          importers.forEach((importer, index) => {
            const uiSubTask = task.subTask(() => {
              progressMeter.update(
                  `${title} ${index + 1} of ${importers.length}`);
            });
            uiSubTask.updatesUi = true;
            task.subTask(() => callback(importer));
          });
        });
      }

      addImportStage('Creating importers...', () => {
        // Copy the traces array, we may mutate it.
        traces = traces.slice(0);
        progressMeter.update('Creating importers...');
        // Figure out which importers to use.
        for (let i = 0; i < traces.length; ++i) {
          importers.push(this.createImporter_(traces[i]));
        }

        // Some traces have other traces inside them. Before doing the full
        // import, ask the importer if it has any subtraces, and if so, create
        // importers for them, also.
        for (let i = 0; i < importers.length; i++) {
          const subtraces = importers[i].extractSubtraces();
          for (let j = 0; j < subtraces.length; j++) {
            try {
              traces.push(subtraces[j]);
              importers.push(this.createImporter_(subtraces[j]));
            } catch (error) {
              this.model_.importWarning({
                type: error.name,
                message: error.message,
                showToUser: true,
              });
              continue;
            }
          }
        }

        if (traces.length && !this.hasEventDataDecoder_(importers)) {
          throw new Error(
              'Could not find an importer for the provided eventData.');
        }

        // Sort them on priority. This ensures importing happens in a
        // predictable order, e.g. ftrace_importer before
        // trace_event_importer.
        importers.sort(function(x, y) {
          return x.importPriority - y.importPriority;
        });
      });

      // We import clock sync markers before all other events. This is necessary
      // because we need the clock sync markers in order to know by how much we
      // need to shift the timestamps of other events.
      addStageForEachImporter('Importing clock sync markers',
          importer => importer.importClockSyncMarkers());

      addStageForEachImporter('Importing', importer => importer.importEvents());

      // Run the cusomizeModelCallback if needed.
      if (this.importOptions_.customizeModelCallback) {
        addImportStage('Customizing', () => {
          this.importOptions_.customizeModelCallback(this.model_);
        });
      }

      // Import sample data.
      addStageForEachImporter('Importing sample data',
          importer => importer.importSampleData());

      // Autoclose open slices and create subSlices.
      addImportStage('Autoclosing open slices...', () => {
        this.model_.autoCloseOpenSlices();
        this.model_.createSubSlices();
      });

      // Finalize import.
      addStageForEachImporter('Finalizing import',
          importer => importer.finalizeImport());

      // Run preinit.
      addImportStage('Initializing objects (step 1/2)...',
          () => this.model_.preInitializeObjects());

      // Prune empty containers.
      if (this.importOptions_.pruneEmptyContainers) {
        addImportStage('Pruning empty containers...',
            () => this.model_.pruneEmptyContainers());
      }

      // Merge kernel and userland slices on each thread.
      addImportStage('Merging kernel with userland...',
          () => this.model_.mergeKernelWithUserland());

      // Create auditors
      let auditors = [];
      addImportStage('Adding arbitrary data to model...', () => {
        auditors = this.importOptions_.auditorConstructors.map(
            auditorConstructor => new auditorConstructor(this.model_));
        auditors.forEach((auditor) => {
          auditor.runAnnotate();
          auditor.installUserFriendlyCategoryDriverIfNeeded();
        });
      });

      addImportStage('Computing final world bounds...', () => {
        this.model_.computeWorldBounds(this.importOptions_.shiftWorldToZero);
      });

      addImportStage('Building flow event map...',
          () => this.model_.buildFlowEventIntervalTree());

      // Join refs.
      addImportStage('Joining object refs...', () => this.model_.joinRefs());

      // Delete any undeleted objects.
      addImportStage('Cleaning up undeleted objects...',
          () => this.model_.cleanupUndeletedObjects());

      // Sort global and process memory dumps.
      addImportStage('Sorting memory dumps...',
          () => this.model_.sortMemoryDumps());

      // Finalize memory dump graphs.
      addImportStage('Finalizing memory dump graphs...',
          () => this.model_.finalizeMemoryGraphs());

      // Run initializers.
      addImportStage('Initializing objects (step 2/2)...',
          () => this.model_.initializeObjects());

      // Build event indices mapping from an event id to all flow events.
      addImportStage('Building event indices...',
          () => this.model_.buildEventIndices());

      // Build the UserModel.
      addImportStage('Building UserModel...', () => {
        const userModelBuilder = new tr.importer.UserModelBuilder(this.model_);
        userModelBuilder.buildUserModel();
      });

      // Sort Expectations.
      addImportStage('Sorting user expectations...',
          () => this.model_.userModel.sortExpectations());

      // Run audits.
      addImportStage('Running auditors...', () => {
        auditors.forEach(auditor => auditor.runAudit());
      });

      addImportStage('Updating alerts...', () => this.model_.sortAlerts());

      addImportStage('Update bounds...', () => this.model_.updateBounds());

      addImportStage('Looking for warnings...', () => {
        // Log an import warning if the clock is low resolution.
        if (!this.model_.isTimeHighResolution) {
          this.model_.importWarning({
            type: 'low_resolution_timer',
            message: 'Trace time is low resolution, trace may be unusable.',
            showToUser: true
          });
        }
      });

      // Cleanup.
      lastTask.after(() => {
        this.importing_ = false;
        this.model_.stats.traceImportDurationMs =
            performance.now() - importStartTimeMs;
      });
      return importTask;
    },

    createImporter_(eventData) {
      const importerConstructor = tr.importer.Importer.findImporterFor(
          eventData);
      if (!importerConstructor) {
        throw new Error('Couldn\'t create an importer for the provided ' +
                        'eventData.');
      }
      return new importerConstructor(this.model_, eventData);
    },

    hasEventDataDecoder_(importers) {
      for (let i = 0; i < importers.length; ++i) {
        if (!importers[i].isTraceDataContainer()) return true;
      }

      return false;
    }
  };

  return {
    ImportOptions,
    Import,
  };
});


'use strict';

tr.exportTo('tr.e.v8', function() {
  const ThreadSlice = tr.model.ThreadSlice;

  function V8GCStatsThreadSlice() {
    ThreadSlice.apply(this, arguments);
    this.liveObjects_ = JSON.parse(this.args.live);
    delete this.args.live;
    this.deadObjects_ = JSON.parse(this.args.dead);
    delete this.args.dead;
  }

  V8GCStatsThreadSlice.prototype = {
    __proto__: ThreadSlice.prototype,

    get liveObjects() {
      return this.liveObjects_;
    },

    get deadObjects() {
      return this.deadObjects_;
    }
  };

  ThreadSlice.subTypes.register(
      V8GCStatsThreadSlice,
      {
        categoryParts: ['disabled-by-default-v8.gc_stats'],
        name: 'v8 gc stats slice',
        pluralName: 'v8 gc stats slices'
      }
  );

  return {
    V8GCStatsThreadSlice,
  };
});


'use strict';

tr.exportTo('tr.e.v8', function() {
  const ThreadSlice = tr.model.ThreadSlice;

  function V8ICStatsThreadSlice() {
    ThreadSlice.apply(this, arguments);
    this.icStats_ = undefined;
    if (this.args['ic-stats']) {
      this.icStats_ = this.args['ic-stats'].data;
      delete this.args['ic-stats'];
    }
  }

  V8ICStatsThreadSlice.prototype = {
    __proto__: ThreadSlice.prototype,

    get icStats() {
      return this.icStats_;
    }
  };

  ThreadSlice.subTypes.register(
      V8ICStatsThreadSlice,
      {
        categoryParts: ['disabled-by-default-v8.ic_stats'],
        name: 'v8 ic stats slice',
        pluralName: 'v8 ic stats slices'
      }
  );

  return {
    V8ICStatsThreadSlice,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * @constructor
   */
  function PictureAsImageData(picture, errorOrImageData) {
    this.picture_ = picture;
    if (errorOrImageData instanceof ImageData) {
      this.error_ = undefined;
      this.imageData_ = errorOrImageData;
    } else {
      this.error_ = errorOrImageData;
      this.imageData_ = undefined;
    }
  }

  /**
   * Creates a new pending PictureAsImageData (no image data and no error).
   *
   * @return {PictureAsImageData} a new pending PictureAsImageData.
   */
  PictureAsImageData.Pending = function(picture) {
    return new PictureAsImageData(picture, undefined);
  };

  PictureAsImageData.prototype = {
    get picture() {
      return this.picture_;
    },

    get error() {
      return this.error_;
    },

    get imageData() {
      return this.imageData_;
    },

    isPending() {
      return this.error_ === undefined && this.imageData_ === undefined;
    },

    asCanvas() {
      if (!this.imageData_) return;

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = this.imageData_.width;
      canvas.height = this.imageData_.height;
      ctx.putImageData(this.imageData_, 0, 0);
      return canvas;
    }
  };

  return {
    PictureAsImageData,
  };
});



'use strict';

tr.exportTo('tr.e.cc', function() {
  const convertedNameCache = {};
  function convertNameToJSConvention(name) {
    if (name in convertedNameCache) {
      return convertedNameCache[name];
    }

    if (name[0] === '_' ||
        name[name.length - 1] === '_') {
      convertedNameCache[name] = name;
      return name;
    }

    const words = name.split('_');
    if (words.length === 1) {
      convertedNameCache[name] = words[0];
      return words[0];
    }

    for (let i = 1; i < words.length; i++) {
      words[i] = words[i][0].toUpperCase() + words[i].substring(1);
    }

    convertedNameCache[name] = words.join('');
    return convertedNameCache[name];
  }

  function moveRequiredFieldsFromArgsToToplevel(object, fields) {
    for (let i = 0; i < fields.length; i++) {
      const key = fields[i];
      if (object.args[key] === undefined) {
        throw Error('Expected field ' + key + ' not found in args');
      }
      if (object[key] !== undefined) {
        throw Error('Field ' + key + ' already in object');
      }
      object[key] = object.args[key];
      delete object.args[key];
    }
  }

  function moveOptionalFieldsFromArgsToToplevel(object, fields) {
    for (let i = 0; i < fields.length; i++) {
      const key = fields[i];
      if (object.args[key] === undefined) continue;
      if (object[key] !== undefined) {
        throw Error('Field ' + key + ' already in object');
      }
      object[key] = object.args[key];
      delete object.args[key];
    }
  }

  function preInitializeObject(object) {
    preInitializeObjectInner(object.args, false);
  }

  function preInitializeObjectInner(object, hasRecursed) {
    if (!(object instanceof Object)) return;

    if (object instanceof Array) {
      for (let i = 0; i < object.length; i++) {
        preInitializeObjectInner(object[i], true);
      }
      return;
    }

    if (hasRecursed &&
        (object instanceof tr.model.ObjectSnapshot ||
         object instanceof tr.model.ObjectInstance)) {
      return;
    }

    for (let key in object) {
      const newKey = convertNameToJSConvention(key);
      if (newKey !== key) {
        const value = object[key];
        delete object[key];
        object[newKey] = value;
        key = newKey;
      }

      // Convert objects with keys ending with Quad to tr.b.math.Quad type.
      if (/Quad$/.test(key) && !(object[key] instanceof tr.b.math.Quad)) {
        let q;
        try {
          q = tr.b.math.Quad.from8Array(object[key]);
        } catch (e) {
        }
        object[key] = q;
        continue;
      }

      // Convert objects with keys ending with Rect to tr.b.math.Rect type.
      if (/Rect$/.test(key) && !(object[key] instanceof tr.b.math.Rect)) {
        let r;
        try {
          r = tr.b.math.Rect.fromArray(object[key]);
        } catch (e) {
        }
        object[key] = r;
      }

      preInitializeObjectInner(object[key], true);
    }
  }

  return {
    preInitializeObject,
    convertNameToJSConvention,
    moveRequiredFieldsFromArgsToToplevel,
    moveOptionalFieldsFromArgsToToplevel,
  };
});


'use strict';
/* eslint-disable no-console */

tr.exportTo('tr.e.cc', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  // Number of pictures created. Used as an uniqueId because we are immutable.
  const PictureCount = 0;
  const OPS_TIMING_ITERATIONS = 3;

  function Picture(skp64, layerRect) {
    this.skp64_ = skp64;
    this.layerRect_ = layerRect;

    this.guid_ = tr.b.GUID.allocateSimple();
  }

  Picture.prototype = {
    get canSave() {
      return true;
    },

    get layerRect() {
      return this.layerRect_;
    },

    get guid() {
      return this.guid_;
    },

    getBase64SkpData() {
      return this.skp64_;
    },

    getOps() {
      if (!PictureSnapshot.CanGetOps()) {
        console.error(PictureSnapshot.HowToEnablePictureDebugging());
        return undefined;
      }

      const ops = window.chrome.skiaBenchmarking.getOps({
        skp64: this.skp64_,
        params: {
          layer_rect: this.layerRect_.toArray()
        }
      });

      if (!ops) {
        console.error('Failed to get picture ops.');
      }

      return ops;
    },

    getOpTimings() {
      if (!PictureSnapshot.CanGetOpTimings()) {
        console.error(PictureSnapshot.HowToEnablePictureDebugging());
        return undefined;
      }

      const opTimings = window.chrome.skiaBenchmarking.getOpTimings({
        skp64: this.skp64_,
        params: {
          layer_rect: this.layerRect_.toArray()
        }
      });

      if (!opTimings) {
        console.error('Failed to get picture op timings.');
      }

      return opTimings;
    },

    /**
     * Tag each op with the time it takes to rasterize.
     *
     * FIXME: We should use real statistics to get better numbers here, see
     *        https://code.google.com/p/trace-viewer/issues/detail?id=357
     *
     * @param {Array} ops Array of Skia operations.
     * @return {Array} Skia ops where op.cmd_time contains the associated time
     *         for a given op.
     */
    tagOpsWithTimings(ops) {
      const opTimings = [];
      for (let iteration = 0; iteration < OPS_TIMING_ITERATIONS; iteration++) {
        opTimings[iteration] = this.getOpTimings();
        if (!opTimings[iteration] || !opTimings[iteration].cmd_times) {
          return ops;
        }
        if (opTimings[iteration].cmd_times.length !== ops.length) {
          return ops;
        }
      }

      for (let opIndex = 0; opIndex < ops.length; opIndex++) {
        let min = Number.MAX_VALUE;
        for (let i = 0; i < OPS_TIMING_ITERATIONS; i++) {
          min = Math.min(min, opTimings[i].cmd_times[opIndex]);
        }
        ops[opIndex].cmd_time = min;
      }

      return ops;
    },

    /**
     * Rasterize the picture.
     *
     * @param {{opt_stopIndex: number, params}} The SkPicture operation to
     *     rasterize up to. If not defined, the entire SkPicture is rasterized.
     * @param {{opt_showOverdraw: bool, params}} Defines whether pixel overdraw
           should be visualized in the image.
     * @param {function(tr.e.cc.PictureAsImageData)} The callback function that
     *     is called after rasterization is complete or fails.
     */
    rasterize(params, rasterCompleteCallback) {
      if (!PictureSnapshot.CanRasterize() || !PictureSnapshot.CanGetOps()) {
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(
            this, tr.e.cc.PictureSnapshot.HowToEnablePictureDebugging()));
        return;
      }

      const raster = window.chrome.skiaBenchmarking.rasterize(
          {
            skp64: this.skp64_,
            params: {
              layer_rect: this.layerRect_.toArray()
            }
          },
          {
            stop: params.stopIndex === undefined ? -1 : params.stopIndex,
            overdraw: !!params.showOverdraw,
            params: { }
          });

      if (raster) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = raster.width;
        canvas.height = raster.height;
        const imageData = ctx.createImageData(raster.width, raster.height);
        imageData.data.set(new Uint8ClampedArray(raster.data));
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this, imageData));
      } else {
        const error = 'Failed to rasterize picture. ' +
                'Your recording may be from an old Chrome version. ' +
                'The SkPicture format is not backward compatible.';
        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this, error));
      }
    }
  };

  function LayeredPicture(pictures) {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.pictures_ = pictures;
    this.layerRect_ = undefined;
  }

  LayeredPicture.prototype = {
    __proto__: Picture.prototype,

    get canSave() {
      return false;
    },

    get typeName() {
      return 'cc::LayeredPicture';
    },

    get layerRect() {
      if (this.layerRect_ !== undefined) {
        return this.layerRect_;
      }

      this.layerRect_ = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };

      for (let i = 0; i < this.pictures_.length; ++i) {
        const rect = this.pictures_[i].layerRect;
        this.layerRect_.x = Math.min(this.layerRect_.x, rect.x);
        this.layerRect_.y = Math.min(this.layerRect_.y, rect.y);
        this.layerRect_.width =
            Math.max(this.layerRect_.width, rect.x + rect.width);
        this.layerRect_.height =
            Math.max(this.layerRect_.height, rect.y + rect.height);
      }
      return this.layerRect_;
    },

    get guid() {
      return this.guid_;
    },

    getBase64SkpData() {
      throw new Error('Not available with a LayeredPicture.');
    },

    getOps() {
      let ops = [];
      for (let i = 0; i < this.pictures_.length; ++i) {
        ops = ops.concat(this.pictures_[i].getOps());
      }
      return ops;
    },

    getOpTimings() {
      const opTimings = this.pictures_[0].getOpTimings();
      for (let i = 1; i < this.pictures_.length; ++i) {
        const timings = this.pictures_[i].getOpTimings();
        opTimings.cmd_times = opTimings.cmd_times.concat(timings.cmd_times);
        opTimings.total_time += timings.total_time;
      }
      return opTimings;
    },

    tagOpsWithTimings(ops) {
      const opTimings = [];
      for (let iteration = 0; iteration < OPS_TIMING_ITERATIONS; iteration++) {
        opTimings[iteration] = this.getOpTimings();
        if (!opTimings[iteration] || !opTimings[iteration].cmd_times) {
          return ops;
        }
      }

      for (let opIndex = 0; opIndex < ops.length; opIndex++) {
        let min = Number.MAX_VALUE;
        for (let i = 0; i < OPS_TIMING_ITERATIONS; i++) {
          min = Math.min(min, opTimings[i].cmd_times[opIndex]);
        }
        ops[opIndex].cmd_time = min;
      }
      return ops;
    },

    rasterize(params, rasterCompleteCallback) {
      this.picturesAsImageData_ = [];
      const rasterCallback = function(pictureAsImageData) {
        this.picturesAsImageData_.push(pictureAsImageData);
        if (this.picturesAsImageData_.length !== this.pictures_.length) {
          return;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = this.layerRect.width;
        canvas.height = this.layerRect.height;

        // TODO(dsinclair): Verify these finish in the order started.
        //   Do the rasterize calls run sync or asyn? As the imageData
        //   going to be in the same order as the pictures_ list?
        for (let i = 0; i < this.picturesAsImageData_.length; ++i) {
          ctx.putImageData(this.picturesAsImageData_[i].imageData,
              this.pictures_[i].layerRect.x,
              this.pictures_[i].layerRect.y);
        }
        this.picturesAsImageData_ = [];

        rasterCompleteCallback(new tr.e.cc.PictureAsImageData(this,
            ctx.getImageData(this.layerRect.x, this.layerRect.y,
                this.layerRect.width, this.layerRect.height)));
      }.bind(this);

      for (let i = 0; i < this.pictures_.length; ++i) {
        this.pictures_[i].rasterize(params, rasterCallback);
      }
    }
  };


  /**
   * @constructor
   */
  function PictureSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  PictureSnapshot.HasSkiaBenchmarking = function() {
    return tr.isExported('chrome.skiaBenchmarking');
  };

  PictureSnapshot.CanRasterize = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking()) {
      return false;
    }
    if (!window.chrome.skiaBenchmarking.rasterize) {
      return false;
    }
    return true;
  };

  PictureSnapshot.CanGetOps = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking()) {
      return false;
    }
    if (!window.chrome.skiaBenchmarking.getOps) {
      return false;
    }
    return true;
  };

  PictureSnapshot.CanGetOpTimings = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking()) {
      return false;
    }
    if (!window.chrome.skiaBenchmarking.getOpTimings) {
      return false;
    }
    return true;
  };

  PictureSnapshot.CanGetInfo = function() {
    if (!PictureSnapshot.HasSkiaBenchmarking()) {
      return false;
    }
    if (!window.chrome.skiaBenchmarking.getInfo) {
      return false;
    }
    return true;
  };

  PictureSnapshot.HowToEnablePictureDebugging = function() {
    if (tr.isHeadless) {
      return 'Pictures only work in chrome';
    }

    const usualReason = [
      'For pictures to show up, you need to have Chrome running with ',
      '--enable-skia-benchmarking. Please restart chrome with this flag ',
      'and try again.'
    ].join('');

    if (!tr.isExported('global.chrome.skiaBenchmarking')) {
      return usualReason;
    }
    if (!global.chrome.skiaBenchmarking.rasterize) {
      return 'Your chrome is old';
    }
    if (!global.chrome.skiaBenchmarking.getOps) {
      return 'Your chrome is old: skiaBenchmarking.getOps not found';
    }
    if (!global.chrome.skiaBenchmarking.getOpTimings) {
      return 'Your chrome is old: skiaBenchmarking.getOpTimings not found';
    }
    if (!global.chrome.skiaBenchmarking.getInfo) {
      return 'Your chrome is old: skiaBenchmarking.getInfo not found';
    }
    return 'Rasterizing is on';
  };

  PictureSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);
      this.rasterResult_ = undefined;
    },

    initialize() {
      // If we have an alias args, that means this picture was represented
      // by an alias, and the real args is in alias.args.
      if (this.args.alias) {
        this.args = this.args.alias.args;
      }

      if (!this.args.params.layerRect) {
        throw new Error('Missing layer rect');
      }

      this.layerRect_ = this.args.params.layerRect;
      this.picture_ = new Picture(this.args.skp64, this.args.params.layerRect);
    },

    set picture(picture) {
      this.picture_ = picture;
    },

    get canSave() {
      return this.picture_.canSave;
    },

    get layerRect() {
      return this.layerRect_ ? this.layerRect_ : this.picture_.layerRect;
    },

    get guid() {
      return this.picture_.guid;
    },

    getBase64SkpData() {
      return this.picture_.getBase64SkpData();
    },

    getOps() {
      return this.picture_.getOps();
    },

    getOpTimings() {
      return this.picture_.getOpTimings();
    },

    tagOpsWithTimings(ops) {
      return this.picture_.tagOpsWithTimings(ops);
    },

    rasterize(params, rasterCompleteCallback) {
      this.picture_.rasterize(params, rasterCompleteCallback);
    }
  };

  ObjectSnapshot.subTypes.register(
      PictureSnapshot,
      {typeNames: ['cc::Picture']});

  return {
    PictureSnapshot,
    Picture,
    LayeredPicture,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  function DisplayItemList(skp64, layerRect) {
    tr.e.cc.Picture.apply(this, arguments);
  }

  DisplayItemList.prototype = {
    __proto__: tr.e.cc.Picture.prototype
  };

  /**
   * @constructor
   */
  function DisplayItemListSnapshot() {
    tr.e.cc.PictureSnapshot.apply(this, arguments);
  }

  DisplayItemListSnapshot.prototype = {
    __proto__: tr.e.cc.PictureSnapshot.prototype,

    initialize() {
      tr.e.cc.PictureSnapshot.prototype.initialize.call(this);
      this.displayItems_ = this.args.params.items;
    },

    get items() {
      return this.displayItems_;
    }
  };

  ObjectSnapshot.subTypes.register(
      DisplayItemListSnapshot,
      {typeNames: ['cc::DisplayItemList']});

  return {
    DisplayItemListSnapshot,
    DisplayItemList,
  };
});


'use strict';

/**
 * @fileoverview 2D bounding box computations.
 */
tr.exportTo('tr.b.math', function() {
  /**
   * Tracks a 2D bounding box.
   * @constructor
   */
  function BBox2() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  }

  BBox2.prototype = {
    __proto__: Object.prototype,

    reset() {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addBBox2(bbox2) {
      if (bbox2.isEmpty) return;
      this.addVec2(bbox2.min_);
      this.addVec2(bbox2.max_);
    },

    clone() {
      const bbox = new BBox2();
      bbox.addBBox2(this);
      return bbox;
    },

    /**
     * Adds x, y to the range.
     */
    addXY(x, y) {
      if (this.isEmpty_) {
        this.max_ = vec2.create();
        this.min_ = vec2.create();
        vec2.set(this.max_, x, y);
        vec2.set(this.min_, x, y);
        this.isEmpty_ = false;
        return;
      }
      this.max_[0] = Math.max(this.max_[0], x);
      this.max_[1] = Math.max(this.max_[1], y);
      this.min_[0] = Math.min(this.min_[0], x);
      this.min_[1] = Math.min(this.min_[1], y);
    },

    /**
     * Adds value_x, value_y in the form [value_x,value_y] to the range.
     */
    addVec2(value) {
      if (this.isEmpty_) {
        this.max_ = vec2.create();
        this.min_ = vec2.create();
        vec2.set(this.max_, value[0], value[1]);
        vec2.set(this.min_, value[0], value[1]);
        this.isEmpty_ = false;
        return;
      }
      this.max_[0] = Math.max(this.max_[0], value[0]);
      this.max_[1] = Math.max(this.max_[1], value[1]);
      this.min_[0] = Math.min(this.min_[0], value[0]);
      this.min_[1] = Math.min(this.min_[1], value[1]);
    },

    addQuad(quad) {
      this.addVec2(quad.p1);
      this.addVec2(quad.p2);
      this.addVec2(quad.p3);
      this.addVec2(quad.p4);
    },

    get minVec2() {
      if (this.isEmpty_) return undefined;
      return this.min_;
    },

    get maxVec2() {
      if (this.isEmpty_) return undefined;
      return this.max_;
    },

    get sizeAsVec2() {
      if (this.isEmpty_) {
        throw new Error('Empty BBox2 has no size');
      }
      const size = vec2.create();
      vec2.subtract(size, this.max_, this.min_);
      return size;
    },

    get size() {
      if (this.isEmpty_) {
        throw new Error('Empty BBox2 has no size');
      }
      return {width: this.max_[0] - this.min_[0],
        height: this.max_[1] - this.min_[1]};
    },

    get width() {
      if (this.isEmpty_) {
        throw new Error('Empty BBox2 has no width');
      }
      return this.max_[0] - this.min_[0];
    },

    get height() {
      if (this.isEmpty_) {
        throw new Error('Empty BBox2 has no width');
      }
      return this.max_[1] - this.min_[1];
    },

    toString() {
      if (this.isEmpty_) return 'empty';
      return 'min=(' + this.min_[0] + ',' + this.min_[1] + ') ' +
          'max=(' + this.max_[0] + ',' + this.max_[1] + ')';
    },

    asRect() {
      return tr.b.math.Rect.fromXYWH(
          this.min_[0],
          this.min_[1],
          this.max_[0] - this.min_[0],
          this.max_[1] - this.min_[1]);
    }
  };

  return {
    BBox2,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const constants = {};
  constants.ACTIVE_TREE = 0;
  constants.PENDING_TREE = 1;

  constants.HIGH_PRIORITY_BIN = 0;
  constants.LOW_PRIORITY_BIN = 1;

  constants.SEND_BEGIN_FRAME_EVENT =
    'ThreadProxy::ScheduledActionSendBeginMainFrame';
  constants.BEGIN_MAIN_FRAME_EVENT = 'ThreadProxy::BeginMainFrame';

  return {
    constants
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * @constructor
   */
  function Region() {
    this.rects = [];
  }

  Region.fromArray = function(array) {
    if (array.length % 4 !== 0) {
      throw new Error('Array must consist be a multiple of 4 in length');
    }

    const r = new Region();
    for (let i = 0; i < array.length; i += 4) {
      r.rects.push(tr.b.math.Rect.fromXYWH(array[i], array[i + 1],
          array[i + 2], array[i + 3]));
    }
    return r;
  };

  /**
   * @return {Region} If array is undefined, returns an empty region. Otherwise
   * returns Region.fromArray(array).
   */
  Region.fromArrayOrUndefined = function(array) {
    if (array === undefined) return new Region();
    return Region.fromArray(array);
  };

  Region.prototype = {
    __proto__: Region.prototype,

    rectIntersects(r) {
      for (let i = 0; i < this.rects.length; i++) {
        if (this.rects[i].intersects(r)) return true;
      }
      return false;
    },

    addRect(r) {
      this.rects.push(r);
    }
  };

  return {
    Region,
  };
});



'use strict';

tr.exportTo('tr.e.cc', function() {
  /**
   * This class represents a tile (from impl side) and its final rect on the
   * layer. Note that the rect is determined by what is needed to cover all
   * of the layer without overlap.
   * @constructor
   */
  function TileCoverageRect(rect, tile) {
    this.geometryRect = rect;
    this.tile = tile;
  }

  return {
    TileCoverageRect,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const constants = tr.e.cc.constants;
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function LayerImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);

      this.layerTreeImpl_ = undefined;
      this.parentLayer = undefined;
    },

    initialize() {
      // Defaults.
      this.invalidation = new tr.e.cc.Region();
      this.annotatedInvalidation = new tr.e.cc.Region();
      this.unrecordedRegion = new tr.e.cc.Region();
      this.pictures = [];

      // Import & validate this.args
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['layerId', 'layerQuad']);
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['children', 'maskLayer', 'replicaLayer',
            'idealContentsScale', 'geometryContentsScale',
            'layoutRects', 'usingGpuRasterization']);

      // Leave gpu memory usage in both places.
      this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;

      // Leave bounds in both places.
      this.bounds = tr.b.math.Rect.fromXYWH(
          0, 0,
          this.args.bounds.width, this.args.bounds.height);

      if (this.args.animationBounds) {
        // AnimationBounds[2] and [5] are the Z-component of the box.
        this.animationBoundsRect = tr.b.math.Rect.fromXYWH(
            this.args.animationBounds[0], this.args.animationBounds[1],
            this.args.animationBounds[3], this.args.animationBounds[4]);
      }

      // After Slimming Paint v2, compositor no longer knows hierarchy
      // information. If the children value is undefined, the tracing
      // data comes from the new version of cc, otherwise we set the
      // parentLayer as we did before SPv2.
      if (this.children) {
        for (let i = 0; i < this.children.length; i++) {
          this.children[i].parentLayer = this;
        }
      }
      if (this.maskLayer) {
        this.maskLayer.parentLayer = this;
      }
      if (this.replicaLayer) {
        this.replicaLayer.parentLayer = this;
      }
      if (!this.geometryContentsScale) {
        this.geometryContentsScale = 1.0;
      }
      if (!this.idealContentsScale) {
        this.idealContentsScale = 1.0;
      }

      this.touchEventHandlerRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.touchEventHandlerRegion);
      this.wheelEventHandlerRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.wheelEventHandlerRegion);
      this.nonFastScrollableRegion = tr.e.cc.Region.fromArrayOrUndefined(
          this.args.nonFastScrollableRegion);
    },

    get layerTreeImpl() {
      if (this.layerTreeImpl_) {
        return this.layerTreeImpl_;
      }
      if (this.parentLayer) {
        return this.parentLayer.layerTreeImpl;
      }
      return undefined;
    },
    set layerTreeImpl(layerTreeImpl) {
      this.layerTreeImpl_ = layerTreeImpl;
    },

    get activeLayer() {
      if (this.layerTreeImpl.whichTree === constants.ACTIVE_TREE) {
        return this;
      }
      const activeTree = this.layerTreeImpl.layerTreeHostImpl.activeTree;
      return activeTree.findLayerWithId(this.layerId);
    },

    get pendingLayer() {
      if (this.layerTreeImpl.whichTree === constants.PENDING_TREE) {
        return this;
      }
      const pendingTree = this.layerTreeImpl.layerTreeHostImpl.pendingTree;
      return pendingTree.findLayerWithId(this.layerId);
    }
  };

  /**
   * @constructor
   */
  function PictureLayerImplSnapshot() {
    LayerImplSnapshot.apply(this, arguments);
  }

  PictureLayerImplSnapshot.prototype = {
    __proto__: LayerImplSnapshot.prototype,

    initialize() {
      LayerImplSnapshot.prototype.initialize.call(this);

      if (this.args.invalidation) {
        this.invalidation = tr.e.cc.Region.fromArray(this.args.invalidation);
        delete this.args.invalidation;
      }
      if (this.args.annotatedInvalidationRects) {
        this.annotatedInvalidation = new tr.e.cc.Region();
        for (let i = 0; i < this.args.annotatedInvalidationRects.length; ++i) {
          const annotatedRect = this.args.annotatedInvalidationRects[i];
          const rect = annotatedRect.geometryRect;
          rect.reason = annotatedRect.reason;
          this.annotatedInvalidation.addRect(rect);
        }
        delete this.args.annotatedInvalidationRects;
      }
      if (this.args.unrecordedRegion) {
        this.unrecordedRegion = tr.e.cc.Region.fromArray(
            this.args.unrecordedRegion);
        delete this.args.unrecordedRegion;
      }
      if (this.args.pictures) {
        this.pictures = this.args.pictures;

        // The picture list comes in with an unknown ordering. We resort based
        // on timestamp order so we will draw the base picture first and the
        // various fixes on top of that.
        this.pictures.sort(function(a, b) { return a.ts - b.ts; });
      }

      this.tileCoverageRects = [];
      if (this.args.coverageTiles) {
        for (let i = 0; i < this.args.coverageTiles.length; ++i) {
          const rect = this.args.coverageTiles[i].geometryRect.scale(
              this.idealContentsScale);
          const tile = this.args.coverageTiles[i].tile;
          this.tileCoverageRects.push(new tr.e.cc.TileCoverageRect(rect, tile));
        }
        delete this.args.coverageTiles;
      }
    }
  };

  ObjectSnapshot.subTypes.register(
      PictureLayerImplSnapshot,
      {
        typeName: 'cc::PictureLayerImpl'
      });

  ObjectSnapshot.subTypes.register(
      LayerImplSnapshot,
      {
        typeNames: [
          'cc::LayerImpl',
          'cc::DelegatedRendererLayerImpl',
          'cc::HeadsUpDisplayLayerImpl',
          'cc::IOSurfaceLayerImpl',
          'cc::NinePatchLayerImpl',
          'cc::PictureImageLayerImpl',
          'cc::ScrollbarLayerImpl',
          'cc::SolidColorLayerImpl',
          'cc::SolidColorScrollbarLayerImpl',
          'cc::SurfaceLayerImpl',
          'cc::TextureLayerImpl',
          'cc::TiledLayerImpl',
          'cc::VideoLayerImpl',
          'cc::PaintedScrollbarLayerImpl',
          'ClankPatchLayer',
          'TabBorderLayer',
          'CounterLayer'
        ]
      });

  return {
    LayerImplSnapshot,
    PictureLayerImplSnapshot,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const constants = tr.e.cc.constants;
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function LayerTreeImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerTreeImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);
      this.layerTreeHostImpl = undefined;
      this.whichTree = undefined;
      this.sourceFrameNumber = undefined;
    },

    initialize() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['renderSurfaceLayerList']);
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['rootLayer', 'layers']);
      if (this.args.sourceFrameNumber) {
        this.sourceFrameNumber = this.args.sourceFrameNumber;
      }

      // Slimming Paint v2 removes the tree hierarchy and replace
      // it with a layer list. The tracing data should have either
      // rootLayer or layers available.
      if (this.rootLayer) {
        // The version before SPv2
        this.rootLayer.layerTreeImpl = this;
      } else {
        // The SPv2 version, where the layer list contains all
        // non-mask, non-replica layers.
        for (let i = 0; i < this.layers.length; i++) {
          this.layers[i].layerTreeImpl = this;
        }
      }

      if (this.args.swapPromiseTraceIds &&
          this.args.swapPromiseTraceIds.length) {
        this.tracedInputLatencies = [];

        const ownProcess = this.objectInstance.parent;
        const modelHelper = ownProcess.model.getOrCreateHelper(
            tr.model.helpers.ChromeModelHelper);
        if (modelHelper) {
          this._initializeTracedInputLatencies(modelHelper);
        }
      }
    },

    _initializeTracedInputLatencies(modelHelper) {
      const latencyEvents = modelHelper.browserHelper.getLatencyEventsInRange(
          modelHelper.model.bounds);

      // Convert all ids to InputLatency Async objects.
      latencyEvents.forEach(function(event) {
        for (let i = 0; i < this.args.swapPromiseTraceIds.length; i++) {
          if (!event.args.data || !event.args.data.trace_id) {
            continue;
          }
          if (parseInt(event.args.data.trace_id) ===
              this.args.swapPromiseTraceIds[i]) {
            this.tracedInputLatencies.push(event);
          }
        }
      }, this);
    },

    get hasSourceFrameBeenDrawnBefore() {
      if (this.whichTree === tr.e.cc.constants.PENDING_TREE) {
        return false;
      }

      // Old chrome's don't produce sourceFrameNumber.
      if (this.sourceFrameNumber === undefined) return;

      const thisLTHI = this.layerTreeHostImpl;
      const thisLTHIIndex = thisLTHI.objectInstance.snapshots.indexOf(
          thisLTHI);
      const prevLTHIIndex = thisLTHIIndex - 1;
      if (prevLTHIIndex < 0 ||
          prevLTHIIndex >= thisLTHI.objectInstance.snapshots.length) {
        return false;
      }
      const prevLTHI = thisLTHI.objectInstance.snapshots[prevLTHIIndex];
      if (!prevLTHI.activeTree) return false;

      // Old chrome's don't produce sourceFrameNumber.
      if (prevLTHI.activeTree.sourceFrameNumber === undefined) return;
      return prevLTHI.activeTree.sourceFrameNumber === this.sourceFrameNumber;
    },

    get otherTree() {
      const other = this.whichTree === constants.ACTIVE_TREE ?
          constants.PENDING_TREE : constants.ACTIVE_TREE;
      return this.layerTreeHostImpl.getTree(other);
    },

    get gpuMemoryUsageInBytes() {
      let totalBytes = 0;
      this.iterLayers(function(layer) {
        if (layer.gpuMemoryUsageInBytes !== undefined) {
          totalBytes += layer.gpuMemoryUsageInBytes;
        }
      });
      return totalBytes;
    },

    iterLayers(func, thisArg) {
      const visitedLayers = {};
      function visitLayer(layer, depth, isMask, isReplica) {
        if (visitedLayers[layer.layerId]) return;

        visitedLayers[layer.layerId] = true;
        func.call(thisArg, layer, depth, isMask, isReplica);
        if (layer.children) {
          for (let i = 0; i < layer.children.length; i++) {
            visitLayer(layer.children[i], depth + 1);
          }
        }
        if (layer.maskLayer) {
          visitLayer(layer.maskLayer, depth + 1, true, false);
        }
        if (layer.replicaLayer) {
          visitLayer(layer.replicaLayer, depth + 1, false, true);
        }
      }
      if (this.rootLayer) {
        visitLayer(this.rootLayer, 0, false, false);
      } else {
        for (let i = 0; i < this.layers.length; i++) {
          visitLayer(this.layers[i], 0, false, false);
        }
      }
    },
    findLayerWithId(id) {
      let foundLayer = undefined;
      function visitLayer(layer) {
        if (layer.layerId === id) {
          foundLayer = layer;
        }
      }
      this.iterLayers(visitLayer);
      return foundLayer;
    }
  };

  ObjectSnapshot.subTypes.register(
      LayerTreeImplSnapshot,
      {typeName: 'cc::LayerTreeImpl'});

  return {
    LayerTreeImplSnapshot,
  };
});


'use strict';

/**
 * @fileoverview Provides the LayerTreeHostImpl model-level objects.
 */
tr.exportTo('tr.e.cc', function() {
  const constants = tr.e.cc.constants;

  const ObjectSnapshot = tr.model.ObjectSnapshot;
  const ObjectInstance = tr.model.ObjectInstance;

  /**
   * @constructor
   */
  function LayerTreeHostImplSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  LayerTreeHostImplSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['deviceViewportSize',
            'activeTree']);
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['pendingTree']);

      // Move active_tiles into this.tiles. If that doesn't exist then, then as
      // a backward compatability move tiles into this.tiles.
      if (this.args.activeTiles !== undefined) {
        this.activeTiles = this.args.activeTiles;
        delete this.args.activeTiles;
      } else if (this.args.tiles !== undefined) {
        this.activeTiles = this.args.tiles;
        delete this.args.tiles;
      }

      if (!this.activeTiles) {
        this.activeTiles = [];
      }

      this.activeTree.layerTreeHostImpl = this;
      this.activeTree.whichTree = constants.ACTIVE_TREE;
      if (this.pendingTree) {
        this.pendingTree.layerTreeHostImpl = this;
        this.pendingTree.whichTree = constants.PENDING_TREE;
      }
    },

    /**
     * Get all of tile scales and their associated names.
     */
    getContentsScaleNames() {
      const scales = {};
      for (let i = 0; i < this.activeTiles.length; ++i) {
        const tile = this.activeTiles[i];
        // Return scale -> scale name mappings.
        // Example:
        //  0.25 -> LOW_RESOLUTION
        //  1.0 -> HIGH_RESOLUTION
        //  0.75 -> NON_IDEAL_RESOLUTION
        scales[tile.contentsScale] = tile.resolution;
      }
      return scales;
    },

    getTree(whichTree) {
      if (whichTree === constants.ACTIVE_TREE) {
        return this.activeTree;
      }
      if (whichTree === constants.PENDING_TREE) {
        return this.pendingTree;
      }
      throw new Exception('Unknown tree type + ' + whichTree);
    },

    get tilesHaveGpuMemoryUsageInfo() {
      if (this.tilesHaveGpuMemoryUsageInfo_ !== undefined) {
        return this.tilesHaveGpuMemoryUsageInfo_;
      }

      for (let i = 0; i < this.activeTiles.length; i++) {
        if (this.activeTiles[i].gpuMemoryUsageInBytes === undefined) {
          continue;
        }
        this.tilesHaveGpuMemoryUsageInfo_ = true;
        return true;
      }
      this.tilesHaveGpuMemoryUsageInfo_ = false;
      return false;
    },

    get gpuMemoryUsageInBytes() {
      if (!this.tilesHaveGpuMemoryUsageInfo) return;

      let usage = 0;
      for (let i = 0; i < this.activeTiles.length; i++) {
        const u = this.activeTiles[i].gpuMemoryUsageInBytes;
        if (u !== undefined) usage += u;
      }
      return usage;
    },

    get userFriendlyName() {
      let frameNumber;
      if (!this.activeTree) {
        frameNumber = this.objectInstance.snapshots.indexOf(this);
      } else {
        if (this.activeTree.sourceFrameNumber === undefined) {
          frameNumber = this.objectInstance.snapshots.indexOf(this);
        } else {
          frameNumber = this.activeTree.sourceFrameNumber;
        }
      }
      return 'cc::LayerTreeHostImpl frame ' + frameNumber;
    }
  };

  ObjectSnapshot.subTypes.register(
      LayerTreeHostImplSnapshot,
      {typeName: 'cc::LayerTreeHostImpl'});

  /**
   * @constructor
   */
  function LayerTreeHostImplInstance() {
    ObjectInstance.apply(this, arguments);

    this.allLayersBBox_ = undefined;
  }

  LayerTreeHostImplInstance.prototype = {
    __proto__: ObjectInstance.prototype,

    get allContentsScales() {
      if (this.allContentsScales_) {
        return this.allContentsScales_;
      }

      const scales = {};
      for (const tileID in this.allTileHistories_) {
        const tileHistory = this.allTileHistories_[tileID];
        scales[tileHistory.contentsScale] = true;
      }
      this.allContentsScales_ = Object.keys(scales);
      return this.allContentsScales_;
    },

    get allLayersBBox() {
      if (this.allLayersBBox_) {
        return this.allLayersBBox_;
      }
      const bbox = new tr.b.math.BBox2();
      function handleTree(tree) {
        tree.renderSurfaceLayerList.forEach(function(layer) {
          bbox.addQuad(layer.layerQuad);
        });
      }
      this.snapshots.forEach(function(lthi) {
        handleTree(lthi.activeTree);
        if (lthi.pendingTree) {
          handleTree(lthi.pendingTree);
        }
      });
      this.allLayersBBox_ = bbox;
      return this.allLayersBBox_;
    }
  };

  ObjectInstance.subTypes.register(
      LayerTreeHostImplInstance,
      {typeName: 'cc::LayerTreeHostImpl'});

  return {
    LayerTreeHostImplSnapshot,
    LayerTreeHostImplInstance,
  };
});


'use strict';

/**
 * @fileoverview Mapping of different tile configuration
 * to border colors and widths.
 */
tr.exportTo('tr.e.cc', function() {
  const tileTypes = {
    highRes: 'highRes',
    lowRes: 'lowRes',
    extraHighRes: 'extraHighRes',
    extraLowRes: 'extraLowRes',
    missing: 'missing',
    culled: 'culled',
    solidColor: 'solidColor',
    picture: 'picture',
    directPicture: 'directPicture',
    unknown: 'unknown'
  };

  const tileBorder = {
    highRes: {
      color: 'rgba(80, 200, 200, 0.7)',
      width: 1
    },
    lowRes: {
      color: 'rgba(212, 83, 192, 0.7)',
      width: 2
    },
    extraHighRes: {
      color: 'rgba(239, 231, 20, 0.7)',
      width: 2
    },
    extraLowRes: {
      color: 'rgba(93, 186, 18, 0.7)',
      width: 2
    },
    missing: {
      color: 'rgba(255, 0, 0, 0.7)',
      width: 1
    },
    culled: {
      color: 'rgba(160, 100, 0, 0.8)',
      width: 1
    },
    solidColor: {
      color: 'rgba(128, 128, 128, 0.7)',
      width: 1
    },
    picture: {
      color: 'rgba(64, 64, 64, 0.7)',
      width: 1
    },
    directPicture: {
      color: 'rgba(127, 255, 0, 1.0)',
      width: 1
    },
    unknown: {
      color: 'rgba(0, 0, 0, 1.0)',
      width: 2
    }
  };

  return {
    tileTypes,
    tileBorder
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function TileSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  TileSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize() {
      tr.e.cc.moveOptionalFieldsFromArgsToToplevel(
          this, ['layerId', 'contentsScale', 'contentRect']);
      if (this.args.managedState) {
        this.resolution = this.args.managedState.resolution;
        this.isSolidColor = this.args.managedState.isSolidColor;
        this.isUsingGpuMemory = this.args.managedState.isUsingGpuMemory;
        this.hasResource = this.args.managedState.hasResource;
        this.scheduledPriority = this.args.scheduledPriority;
        this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;
      } else {
        this.resolution = this.args.resolution;
        this.isSolidColor = this.args.drawInfo.isSolidColor;
        this.isUsingGpuMemory = this.args.isUsingGpuMemory;
        this.hasResource = this.args.hasResource;
        this.scheduledPriority = this.args.scheduledPriority;
        this.gpuMemoryUsageInBytes = this.args.gpuMemoryUsage;
      }

      // This check is for backward compatability. It can probably
      // be removed once we're confident that most traces contain
      // content_rect.
      if (this.contentRect) {
        this.layerRect = this.contentRect.scale(1.0 / this.contentsScale);
      }

      if (this.isSolidColor) {
        this.type_ = tr.e.cc.tileTypes.solidColor;
      } else if (!this.hasResource) {
        this.type_ = tr.e.cc.tileTypes.missing;
      } else if (this.resolution === 'HIGH_RESOLUTION') {
        this.type_ = tr.e.cc.tileTypes.highRes;
      } else if (this.resolution === 'LOW_RESOLUTION') {
        this.type_ = tr.e.cc.tileTypes.lowRes;
      } else {
        this.type_ = tr.e.cc.tileTypes.unknown;
      }
    },

    getTypeForLayer(layer) {
      let type = this.type_;
      if (type === tr.e.cc.tileTypes.unknown) {
        if (this.contentsScale < layer.idealContentsScale) {
          type = tr.e.cc.tileTypes.extraLowRes;
        } else if (this.contentsScale > layer.idealContentsScale) {
          type = tr.e.cc.tileTypes.extraHighRes;
        }
      }
      return type;
    }
  };

  ObjectSnapshot.subTypes.register(TileSnapshot, {typeName: 'cc::Tile'});

  return {
    TileSnapshot,
  };
});


'use strict';

/**
 * @fileoverview Simple list view.
 */
tr.exportTo('tr.ui.b', function() {
  /**
   * @constructor
   */
  const ListView = tr.ui.b.define(
      'x-list-view', tr.ui.b.ContainerThatDecoratesItsChildren);

  ListView.prototype = {
    __proto__: tr.ui.b.ContainerThatDecoratesItsChildren.prototype,

    decorate() {
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.decorate.call(this);

      Polymer.dom(this).classList.add('x-list-view');
      this.onItemClicked_ = this.onItemClicked_.bind(this);
      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.tabIndex = 0;
      this.addEventListener('keydown', this.onKeyDown_);

      this.selectionChanged_ = false;
    },

    decorateChild_(item) {
      Polymer.dom(item).classList.add('list-item');
      item.addEventListener('click', this.onItemClicked_, true);

      Object.defineProperty(
          item,
          'selected', {
            configurable: true,
            get: () => item.hasAttribute('selected'),
            set: value => {
              // |this| is the ListView.
              const oldSelection = this.selectedElement;
              if (oldSelection && oldSelection !== item && value) {
                Polymer.dom(this.selectedElement).removeAttribute('selected');
              }
              if (value) {
                Polymer.dom(item).setAttribute('selected', 'selected');
              } else {
                Polymer.dom(item).removeAttribute('selected');
              }
              const newSelection = this.selectedElement;
              if (newSelection !== oldSelection) {
                tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
              }
            },
          });
    },

    undecorateChild_(item) {
      this.selectionChanged_ |= item.selected;

      Polymer.dom(item).classList.remove('list-item');
      item.removeEventListener('click', this.onItemClicked_);
      delete item.selected;
    },

    beginDecorating_() {
      this.selectionChanged_ = false;
    },

    doneDecoratingForNow_() {
      if (this.selectionChanged_) {
        tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
      }
    },

    get selectedElement() {
      const el = Polymer.dom(this).querySelector('.list-item[selected]');
      if (!el) return undefined;
      return el;
    },

    set selectedElement(el) {
      if (!el) {
        if (this.selectedElement) {
          this.selectedElement.selected = false;
        }
        return;
      }

      if (el.parentElement !== this) {
        throw new Error(
            'Can only select elements that are children of this list view');
      }
      el.selected = true;
    },

    getElementByIndex(index) {
      return Polymer.dom(this)
          .querySelector('.list-item:nth-child(' + index + ')');
    },

    clear() {
      const changed = this.selectedElement !== undefined;
      tr.ui.b.ContainerThatDecoratesItsChildren.prototype.clear.call(this);
      if (changed) {
        tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
      }
    },

    onItemClicked_(e) {
      const currentSelectedElement = this.selectedElement;
      if (currentSelectedElement) {
        Polymer.dom(currentSelectedElement).removeAttribute('selected');
      }
      let element = e.target;
      while (element.parentElement !== this) {
        element = element.parentElement;
      }
      if (element !== currentSelectedElement) {
        Polymer.dom(element).setAttribute('selected', 'selected');
      }
      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    onKeyDown_(e) {
      if (this.selectedElement === undefined) return;

      if (e.keyCode === 38) { // Up arrow.
        const prev = Polymer.dom(this.selectedElement).previousSibling;
        if (prev) {
          prev.selected = true;
          tr.ui.b.scrollIntoViewIfNeeded(prev);
          e.preventDefault();
          return true;
        }
      } else if (e.keyCode === 40) { // Down arrow.
        const next = Polymer.dom(this.selectedElement).nextSibling;
        if (next) {
          next.selected = true;
          tr.ui.b.scrollIntoViewIfNeeded(next);
          e.preventDefault();
          return true;
        }
      }
    },

    addItem(textContent) {
      const item = document.createElement('div');
      Polymer.dom(item).textContent = textContent;
      Polymer.dom(this).appendChild(item);
      return item;
    }

  };

  return {
    ListView,
  };
});


'use strict';
(function() {
  // Extracts the "type" and "details" parts of the unstructured (plaintext)
  // display item format, even if the details span multiple lines.
  // For example, given "FooDisplayItem type=hello\nworld", produces
  // "FooDisplayItem" as the first capture and "type=hello\nworld" as the
  // second. Either capture could be the empty string, but this regex will
  // still successfully match.
  const DETAILS_SPLIT_REGEX = /^(\S*)\s*([\S\s]*)$/;

  Polymer({
    is: 'tr-ui-e-chrome-cc-display-item-list-item',

    created() {
      // TODO(charliea): Why is setAttribute necessary here but not below? We
      // should reach out to the Polymer team to figure out.
      Polymer.dom(this).setAttribute('name', '');
      Polymer.dom(this).setAttribute('rawDetails', '');
      Polymer.dom(this).setAttribute('richDetails', undefined);
      Polymer.dom(this).setAttribute('data_', undefined);
    },

    get data() {
      return this.data_;
    },

    set data(data) {
      this.data_ = data;

      if (!data) {
        this.name = 'DATA MISSING';
        this.rawDetails = '';
        this.richDetails = undefined;
      } else if (typeof data === 'string') {
        const match = data.match(DETAILS_SPLIT_REGEX);
        this.name = match[1];
        this.rawDetails = match[2];
        this.richDetails = undefined;
      } else {
        this.name = data.name;
        this.rawDetails = '';
        this.richDetails = data;
      }
    },

    stopPropagation(e) {
      e.stopPropagation();
    },

    _computeIf(richDetails) {
      return richDetails && richDetails.skp64;
    },

    _computeHref(richDetails) {
      return 'data:application/octet-stream;base64,' + richDetails.skp64;
    }
  });
})();


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  function Selection() {
    this.selectionToSetIfClicked = undefined;
  }
  Selection.prototype = {
    /**
     * When two things are picked in the UI, one must occasionally tie-break
     * between them to decide what was really clicked. Things with higher
     * specicifity will win.
     */
    get specicifity() {
      throw new Error('Not implemented');
    },

    /**
     * If a selection is related to a specific layer, then this returns the
     * layerId of that layer. If the selection is not related to a layer, for
     * example if the device viewport is selected, then this returns undefined.
     */
    get associatedLayerId() {
      throw new Error('Not implemented');
    },

    /**
     * If a selection is related to a specific render pass, then this returns
     * the layerId of that layer. If the selection is not related to a layer,
     * for example if the device viewport is selected, then this returns
     * undefined.
     */
    get associatedRenderPassId() {
      throw new Error('Not implemented');
    },


    get highlightsByLayerId() {
      return {};
    },

    /**
     * Called when the selection is made active in the layer view. Must return
     * an HTMLElement that explains this selection in detail.
     */
    createAnalysis() {
      throw new Error('Not implemented');
    },

    /**
     * Should try to create the equivalent selection in the provided LTHI,
     * or undefined if it can't be done.
     */
    findEquivalent(lthi) {
      throw new Error('Not implemented');
    }
  };

  /**
   * @constructor
   */
  function RenderPassSelection(renderPass, renderPassId) {
    if (!renderPass || (renderPassId === undefined)) {
      throw new Error('Render pass (with id) is required');
    }
    this.renderPass_ = renderPass;
    this.renderPassId_ = renderPassId;
  }

  RenderPassSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 1;
    },

    get associatedLayerId() {
      return undefined;
    },

    get associatedRenderPassId() {
      return this.renderPassId_;
    },

    get renderPass() {
      return this.renderPass_;
    },

    createAnalysis() {
      const dataView = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      dataView.label = 'RenderPass ' + this.renderPassId_;
      dataView.object = this.renderPass_.args;
      return dataView;
    },

    get title() {
      return this.renderPass_.objectInstance.typeName;
    }
  };

  /**
   * @constructor
   */
  function LayerSelection(layer) {
    if (!layer) {
      throw new Error('Layer is required');
    }
    this.layer_ = layer;
  }

  LayerSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 1;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },

    get associatedRenderPassId() {
      return undefined;
    },

    get layer() {
      return this.layer_;
    },

    createAnalysis() {
      const dataView = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      dataView.label = 'Layer ' + this.layer_.layerId;
      if (this.layer_.usingGpuRasterization) {
        dataView.label += ' (GPU-rasterized)';
      }
      dataView.object = this.layer_.args;
      return dataView;
    },

    get title() {
      return this.layer_.objectInstance.typeName;
    },

    findEquivalent(lthi) {
      const layer = lthi.activeTree.findLayerWithId(this.layer_.layerId) ||
          lthi.pendingTree.findLayerWithId(this.layer_.layerId);
      if (!layer) return undefined;
      return new LayerSelection(layer);
    }
  };

  /**
   * @constructor
   */
  function TileSelection(tile, opt_data) {
    this.tile_ = tile;
    this.data_ = opt_data || {};
  }

  TileSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 2;
    },

    get associatedLayerId() {
      return this.tile_.layerId;
    },

    get highlightsByLayerId() {
      const highlights = {};
      highlights[this.tile_.layerId] = [
        {
          colorKey: this.tile_.objectInstance.typeName,
          rect: this.tile_.layerRect
        }
      ];
      return highlights;
    },

    createAnalysis() {
      const analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = 'Tile ' + this.tile_.objectInstance.id + ' on layer ' +
          this.tile_.layerId;
      if (this.data_) {
        analysis.object = {
          moreInfo: this.data_,
          tileArgs: this.tile_.args
        };
      } else {
        analysis.object = this.tile_.args;
      }
      return analysis;
    },

    findEquivalent(lthi) {
      const tileInstance = this.tile_.tileInstance;
      if (lthi.ts < tileInstance.creationTs ||
          lthi.ts >= tileInstance.deletionTs) {
        return undefined;
      }
      const tileSnapshot = tileInstance.getSnapshotAt(lthi.ts);
      if (!tileSnapshot) return undefined;
      return new TileSelection(tileSnapshot);
    }
  };

  /**
   * @constructor
   */
  function LayerRectSelection(layer, rectType, rect, opt_data) {
    this.layer_ = layer;
    this.rectType_ = rectType;
    this.rect_ = rect;
    this.data_ = opt_data !== undefined ? opt_data : rect;
  }

  LayerRectSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 2;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },


    get highlightsByLayerId() {
      const highlights = {};
      highlights[this.layer_.layerId] = [
        {
          colorKey: this.rectType_,
          rect: this.rect_
        }
      ];
      return highlights;
    },

    createAnalysis() {
      const analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = this.rectType_ + ' on layer ' + this.layer_.layerId;
      analysis.object = this.data_;
      return analysis;
    },

    findEquivalent(lthi) {
      return undefined;
    }
  };

  /**
   * @constructor
   */
  function AnimationRectSelection(layer, rect) {
    this.layer_ = layer;
    this.rect_ = rect;
  }

  AnimationRectSelection.prototype = {
    __proto__: Selection.prototype,

    get specicifity() {
      return 0;
    },

    get associatedLayerId() {
      return this.layer_.layerId;
    },

    createAnalysis() {
      const analysis = document.createElement(
          'tr-ui-a-generic-object-view-with-label');
      analysis.label = 'Animation Bounds of layer ' + this.layer_.layerId;
      analysis.object = this.rect_;
      return analysis;
    }
  };

  return {
    Selection,
    RenderPassSelection,
    LayerSelection,
    TileSelection,
    LayerRectSelection,
    AnimationRectSelection,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const OPS_TIMING_ITERATIONS = 3; // Iterations to average op timing info over.
  const ANNOTATION = 'Comment';
  const BEGIN_ANNOTATION = 'BeginCommentGroup';
  const END_ANNOTATION = 'EndCommentGroup';
  const ANNOTATION_ID = 'ID: ';
  const ANNOTATION_CLASS = 'CLASS: ';
  const ANNOTATION_TAG = 'TAG: ';

  const constants = tr.e.cc.constants;

  /**
   * @constructor
   */
  const PictureOpsListView =
      tr.ui.b.define('tr-ui-e-chrome-cc-picture-ops-list-view');

  PictureOpsListView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.opsList_ = new tr.ui.b.ListView();
      Polymer.dom(this).appendChild(this.opsList_);

      this.selectedOp_ = undefined;
      this.selectedOpIndex_ = undefined;
      this.opsList_.addEventListener(
          'selection-changed', this.onSelectionChanged_.bind(this));

      this.picture_ = undefined;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.updateContents_();
    },

    updateContents_() {
      this.opsList_.clear();

      if (!this.picture_) return;

      let ops = this.picture_.getOps();
      if (!ops) return;

      ops = this.picture_.tagOpsWithTimings(ops);

      ops = this.opsTaggedWithAnnotations_(ops);

      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        const item = document.createElement('div');
        item.opIndex = op.opIndex;
        Polymer.dom(item).textContent = i + ') ' + op.cmd_string;

        // Display the element info associated with the op, if available.
        if (op.elementInfo.tag || op.elementInfo.id || op.elementInfo.class) {
          const elementInfo = document.createElement('span');
          Polymer.dom(elementInfo).classList.add('elementInfo');
          const tag = op.elementInfo.tag ? op.elementInfo.tag : 'unknown';
          const id = op.elementInfo.id ? 'id=' + op.elementInfo.id : undefined;
          const className = op.elementInfo.class ? 'class=' +
              op.elementInfo.class : undefined;
          Polymer.dom(elementInfo).textContent =
              '<' + tag + (id ? ' ' : '') +
              (id ? id : '') + (className ? ' ' : '') +
              (className ? className : '') + '>';
          Polymer.dom(item).appendChild(elementInfo);
        }

        // Display the Skia params.
        // FIXME: now that we have structured data, we should format it.
        // (https://github.com/google/trace-viewer/issues/782)
        if (op.info.length > 0) {
          const infoItem = document.createElement('div');
          Polymer.dom(infoItem).textContent = JSON.stringify(op.info);
          Polymer.dom(item).appendChild(infoItem);
        }

        // Display the op timing, if available.
        if (op.cmd_time && op.cmd_time >= 0.0001) {
          const time = document.createElement('span');
          Polymer.dom(time).classList.add('time');
          const rounded = op.cmd_time.toFixed(4);
          Polymer.dom(time).textContent = '(' + rounded + 'ms)';
          Polymer.dom(item).appendChild(time);
        }

        Polymer.dom(this.opsList_).appendChild(item);
      }
    },

    onSelectionChanged_(e) {
      let beforeSelectedOp = true;

      // Deselect on re-selection.
      if (this.opsList_.selectedElement === this.selectedOp_) {
        this.opsList_.selectedElement = undefined;
        beforeSelectedOp = false;
        this.selectedOpIndex_ = undefined;
      }

      this.selectedOp_ = this.opsList_.selectedElement;

      // Set selection on all previous ops.
      const ops = this.opsList_.children;
      for (let i = 0; i < ops.length; i++) {
        const op = ops[i];
        if (op === this.selectedOp_) {
          beforeSelectedOp = false;
          this.selectedOpIndex_ = op.opIndex;
        } else if (beforeSelectedOp) {
          Polymer.dom(op).setAttribute('beforeSelection', 'beforeSelection');
        } else {
          Polymer.dom(op).removeAttribute('beforeSelection');
        }
      }

      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    get numOps() {
      return this.opsList_.children.length;
    },

    get selectedOpIndex() {
      return this.selectedOpIndex_;
    },

    set selectedOpIndex(s) {
      this.selectedOpIndex_ = s;

      if (s === undefined) {
        this.opsList_.selectedElement = this.selectedOp_;
        this.onSelectionChanged_();
      } else {
        if (s < 0) throw new Error('Invalid index');
        if (s >= this.numOps) throw new Error('Invalid index');
        this.opsList_.selectedElement = this.opsList_.getElementByIndex(s + 1);
        tr.ui.b.scrollIntoViewIfNeeded(this.opsList_.selectedElement);
      }
    },

    /**
     * Return Skia operations tagged by annotation.
     *
     * The ops returned from Picture.getOps() contain both Skia ops and
     * annotations threaded together. This function removes all annotations
     * from the list and tags each op with the associated annotations.
     * Additionally, the last {tag, id, class} is stored as elementInfo on
     * each op.
     *
     * @param {Array} ops Array of Skia operations and annotations.
     * @return {Array} Skia ops where op.annotations contains the associated
     *         annotations for a given op.
     */
    opsTaggedWithAnnotations_(ops) {
      // This algorithm works by walking all the ops and pushing any
      // annotations onto a stack. When a non-annotation op is found, the
      // annotations stack is traversed and stored with the op.
      const annotationGroups = [];
      const opsWithoutAnnotations = [];
      for (let opIndex = 0; opIndex < ops.length; opIndex++) {
        const op = ops[opIndex];
        op.opIndex = opIndex;
        switch (op.cmd_string) {
          case BEGIN_ANNOTATION:
            annotationGroups.push([]);
            break;
          case END_ANNOTATION:
            annotationGroups.pop();
            break;
          case ANNOTATION:
            annotationGroups[annotationGroups.length - 1].push(op);
            break;
          default: {
            const annotations = [];
            let elementInfo = {};
            annotationGroups.forEach(function(annotationGroup) {
              elementInfo = {};
              annotationGroup.forEach(function(annotation) {
                annotation.info.forEach(function(info) {
                  if (info.includes(ANNOTATION_TAG)) {
                    elementInfo.tag = info.substring(
                        info.indexOf(ANNOTATION_TAG) +
                        ANNOTATION_TAG.length).toLowerCase();
                  } else if (info.includes(ANNOTATION_ID)) {
                    elementInfo.id = info.substring(
                        info.indexOf(ANNOTATION_ID) +
                        ANNOTATION_ID.length);
                  } else if (info.includes(ANNOTATION_CLASS)) {
                    elementInfo.class = info.substring(
                        info.indexOf(ANNOTATION_CLASS) +
                        ANNOTATION_CLASS.length);
                  }

                  annotations.push(info);
                });
              });
            });
            op.annotations = annotations;
            op.elementInfo = elementInfo;
            opsWithoutAnnotations.push(op);
          }
        }
      }

      return opsWithoutAnnotations;
    }
  };

  return {
    PictureOpsListView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const THIS_DOC = document.currentScript.ownerDocument;

  /**
   * DisplayItemDebugger is a view of a DisplayItemListSnapshot for inspecting
   * a display item list and the pictures within it.
   *
   * @constructor
   */
  const DisplayItemDebugger = tr.ui.b.define(
      'tr-ui-e-chrome-cc-display-item-debugger');

  DisplayItemDebugger.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      const node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-display-item-debugger-template', THIS_DOC);

      Polymer.dom(this).appendChild(node);

      this.pictureAsImageData_ = undefined;
      this.zoomScaleValue_ = 1;

      this.sizeInfo_ = Polymer.dom(this).querySelector('.size');
      this.rasterArea_ = Polymer.dom(this).querySelector('raster-area');
      this.rasterCanvas_ =
          Polymer.dom(this.rasterArea_).querySelector('canvas');
      this.rasterCtx_ = this.rasterCanvas_.getContext('2d');

      this.trackMouse_();

      this.displayItemInfo_ =
          Polymer.dom(this).querySelector('display-item-info');
      this.displayItemInfo_.addEventListener(
          'click', this.onDisplayItemInfoClick_.bind(this), false);

      this.displayItemListView_ = new tr.ui.b.ListView();
      this.displayItemListView_.addEventListener('selection-changed',
          this.onDisplayItemListSelection_.bind(this));
      Polymer.dom(this.displayItemInfo_).appendChild(this.displayItemListView_);

      this.displayListFilename_ =
          Polymer.dom(this).querySelector('.dlfilename');
      this.displayListExportButton_ =
          Polymer.dom(this).querySelector('.dlexport');
      this.displayListExportButton_.addEventListener(
          'click', this.onExportDisplayListClicked_.bind(this));

      this.skpFilename_ = Polymer.dom(this).querySelector('.skpfilename');
      this.skpExportButton_ = Polymer.dom(this).querySelector('.skpexport');
      this.skpExportButton_.addEventListener(
          'click', this.onExportSkPictureClicked_.bind(this));

      const leftPanel = Polymer.dom(this).querySelector('left-panel');

      const middleDragHandle = document.createElement('tr-ui-b-drag-handle');
      middleDragHandle.horizontal = false;
      middleDragHandle.target = leftPanel;

      const rightPanel = Polymer.dom(this).querySelector('right-panel');

      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      Polymer.dom(this.rasterArea_).insertBefore(
          this.infoBar_, this.rasterCanvas_);

      Polymer.dom(this).insertBefore(middleDragHandle, rightPanel);

      this.picture_ = undefined;

      this.pictureOpsListView_ = new tr.ui.e.chrome.cc.PictureOpsListView();
      Polymer.dom(rightPanel).insertBefore(
          this.pictureOpsListView_, this.rasterArea_);

      this.pictureOpsListDragHandle_ =
          document.createElement('tr-ui-b-drag-handle');
      this.pictureOpsListDragHandle_.horizontal = false;
      this.pictureOpsListDragHandle_.target = this.pictureOpsListView_;
      Polymer.dom(rightPanel).insertBefore(
          this.pictureOpsListDragHandle_, this.rasterArea_);
    },

    get picture() {
      return this.picture_;
    },

    set displayItemList(displayItemList) {
      this.displayItemList_ = displayItemList;
      this.picture = this.displayItemList_;

      this.displayItemListView_.clear();
      this.displayItemList_.items.forEach(function(item) {
        const listItem = document.createElement(
            'tr-ui-e-chrome-cc-display-item-list-item');
        listItem.data = item;
        Polymer.dom(this.displayItemListView_).appendChild(listItem);
      }.bind(this));
    },

    set picture(picture) {
      this.picture_ = picture;

      // Hide the ops list if we are showing the "main" display item list.
      const showOpsList = picture && picture !== this.displayItemList_;
      this.updateDrawOpsList_(showOpsList);

      if (picture) {
        const size = this.getRasterCanvasSize_();
        this.rasterCanvas_.width = size.width;
        this.rasterCanvas_.height = size.height;
      }

      const bounds = this.rasterArea_.getBoundingClientRect();
      const selectorBounds = this.mouseModeSelector_.getBoundingClientRect();
      this.mouseModeSelector_.pos = {
        x: (bounds.right - selectorBounds.width - 10),
        y: bounds.top
      };

      this.rasterize_();

      this.scheduleUpdateContents_();
    },

    getRasterCanvasSize_() {
      const style = window.getComputedStyle(this.rasterArea_);
      let width = parseInt(style.width);
      let height = parseInt(style.height);
      if (this.picture_) {
        width = Math.max(width, this.picture_.layerRect.width);
        height = Math.max(height, this.picture_.layerRect.height);
      }

      return {
        width,
        height
      };
    },

    scheduleUpdateContents_() {
      if (this.updateContentsPending_) return;

      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_.bind(this)
      );
    },

    updateContents_() {
      this.updateContentsPending_ = false;

      if (this.picture_) {
        Polymer.dom(this.sizeInfo_).textContent = '(' +
            this.picture_.layerRect.width + ' x ' +
            this.picture_.layerRect.height + ')';
      }

      // Return if picture hasn't finished rasterizing.
      if (!this.pictureAsImageData_) return;

      this.infoBar_.visible = false;
      this.infoBar_.removeAllButtons();
      if (this.pictureAsImageData_.error) {
        this.infoBar_.message = 'Cannot rasterize...';
        this.infoBar_.addButton('More info...', function(e) {
          const overlay = new tr.ui.b.Overlay();
          Polymer.dom(overlay).textContent = this.pictureAsImageData_.error;
          overlay.visible = true;
          e.stopPropagation();
          return false;
        }.bind(this));
        this.infoBar_.visible = true;
      }

      this.drawPicture_();
    },

    drawPicture_() {
      const size = this.getRasterCanvasSize_();
      if (size.width !== this.rasterCanvas_.width) {
        this.rasterCanvas_.width = size.width;
      }
      if (size.height !== this.rasterCanvas_.height) {
        this.rasterCanvas_.height = size.height;
      }

      this.rasterCtx_.clearRect(0, 0, size.width, size.height);

      if (!this.picture_ || !this.pictureAsImageData_.imageData) return;

      const imgCanvas = this.pictureAsImageData_.asCanvas();
      const w = imgCanvas.width;
      const h = imgCanvas.height;
      this.rasterCtx_.drawImage(imgCanvas, 0, 0, w, h,
          0, 0, w * this.zoomScaleValue_,
          h * this.zoomScaleValue_);
    },

    rasterize_() {
      if (this.picture_) {
        this.picture_.rasterize(
            {
              showOverdraw: false
            },
            this.onRasterComplete_.bind(this));
      }
    },

    onRasterComplete_(pictureAsImageData) {
      this.pictureAsImageData_ = pictureAsImageData;
      this.scheduleUpdateContents_();
    },

    onDisplayItemListSelection_(e) {
      const selected = this.displayItemListView_.selectedElement;

      if (!selected) {
        this.picture = this.displayItemList_;
        return;
      }

      const index = Array.prototype.indexOf.call(
          this.displayItemListView_.children, selected);
      const displayItem = this.displayItemList_.items[index];
      if (displayItem && displayItem.skp64) {
        this.picture = new tr.e.cc.Picture(
            displayItem.skp64, this.displayItemList_.layerRect);
      } else {
        this.picture = undefined;
      }
    },

    onDisplayItemInfoClick_(e) {
      if (e && e.target === this.displayItemInfo_) {
        this.displayItemListView_.selectedElement = undefined;
      }
    },

    updateDrawOpsList_(showOpsList) {
      if (showOpsList) {
        this.pictureOpsListView_.picture = this.picture_;
        if (this.pictureOpsListView_.numOps > 0) {
          Polymer.dom(this.pictureOpsListView_).classList.add('hasPictureOps');
          Polymer.dom(this.pictureOpsListDragHandle_).classList.add(
              'hasPictureOps');
        }
      } else {
        Polymer.dom(this.pictureOpsListView_).classList.remove('hasPictureOps');
        Polymer.dom(this.pictureOpsListDragHandle_).classList.remove(
            'hasPictureOps');
      }
    },

    trackMouse_() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.rasterArea_;
      Polymer.dom(this.rasterArea_).appendChild(this.mouseModeSelector_);

      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.defaultMode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.settingsKey = 'pictureDebugger.mouseModeSelector';

      this.mouseModeSelector_.addEventListener('beginzoom',
          this.onBeginZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('updatezoom',
          this.onUpdateZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('endzoom',
          this.onEndZoom_.bind(this));
    },

    onBeginZoom_(e) {
      this.isZooming_ = true;

      this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);

      e.preventDefault();
    },

    onUpdateZoom_(e) {
      if (!this.isZooming_) return;

      const currentMouseViewPos = this.extractRelativeMousePosition_(e);

      // Take the distance the mouse has moved and we want to zoom at about
      // 1/1000th of that speed. 0.01 feels jumpy. This could possibly be tuned
      // more if people feel it's too slow.
      this.zoomScaleValue_ +=
          ((this.lastMouseViewPos_.y - currentMouseViewPos.y) * 0.001);
      this.zoomScaleValue_ = Math.max(this.zoomScaleValue_, 0.1);

      this.drawPicture_();

      this.lastMouseViewPos_ = currentMouseViewPos;
    },

    onEndZoom_(e) {
      this.lastMouseViewPos_ = undefined;
      this.isZooming_ = false;
      e.preventDefault();
    },

    extractRelativeMousePosition_(e) {
      return {
        x: e.clientX - this.rasterArea_.offsetLeft,
        y: e.clientY - this.rasterArea_.offsetTop
      };
    },

    saveFile_(filename, rawData) {
      if (!rawData) return;

      // Convert this String into an Uint8Array
      const length = rawData.length;
      const arrayBuffer = new ArrayBuffer(length);
      const uint8Array = new Uint8Array(arrayBuffer);
      for (let c = 0; c < length; c++) {
        uint8Array[c] = rawData.charCodeAt(c);
      }

      // Create a blob URL from the binary array.
      const blob = new Blob([uint8Array], {type: 'application/octet-binary'});
      const blobUrl = window.URL.createObjectURL(blob);

      // Create a link and click on it.
      const link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
      link.href = blobUrl;
      link.download = filename;
      const event = document.createEvent('MouseEvents');
      event.initMouseEvent(
          'click', true, false, window, 0, 0, 0, 0, 0,
          false, false, false, false, 0, null);
      link.dispatchEvent(event);
    },

    onExportDisplayListClicked_() {
      const rawData = JSON.stringify(this.displayItemList_.items);
      this.saveFile_(this.displayListFilename_.value, rawData);
    },

    onExportSkPictureClicked_() {
      const rawData = tr.b.Base64.atob(this.picture_.getBase64SkpData());
      this.saveFile_(this.skpFilename_.value, rawData);
    }
  };

  return {
    DisplayItemDebugger,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a display item snapshot in a human readable form.
   * @constructor
   */
  const DisplayItemSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-display-item-list-view',
      tr.ui.analysis.ObjectSnapshotView);

  DisplayItemSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add(
          'tr-ui-e-chrome-cc-display-item-list-view');
      this.displayItemDebugger_ = new tr.ui.e.chrome.cc.DisplayItemDebugger();
      Polymer.dom(this).appendChild(this.displayItemDebugger_);
    },

    updateContents() {
      if (this.objectSnapshot_ && this.displayItemDebugger_) {
        this.displayItemDebugger_.displayItemList = this.objectSnapshot_;
      }
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      DisplayItemSnapshotView,
      {
        typeNames: ['cc::DisplayItemList'],
        showInstances: false
      });

  return {
    DisplayItemSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const constants = tr.e.cc.constants;
  const RENDER_PASS_QUADS =
      Math.max(constants.ACTIVE_TREE, constants.PENDING_TREE) + 1;

  /**
   * @constructor
   */
  const LayerPicker = tr.ui.b.define('tr-ui-e-chrome-cc-layer-picker');

  LayerPicker.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate() {
      this.lthi_ = undefined;
      this.controls_ = document.createElement('top-controls');
      this.renderPassQuads_ = false;


      this.itemList_ = new tr.ui.b.ListView();
      Polymer.dom(this).appendChild(this.controls_);

      Polymer.dom(this).appendChild(this.itemList_);

      this.itemList_.addEventListener(
          'selection-changed', this.onItemSelectionChanged_.bind(this));

      Polymer.dom(this.controls_).appendChild(tr.ui.b.createSelector(
          this, 'whichTree',
          'layerPicker.whichTree', constants.ACTIVE_TREE,
          [{label: 'Active tree', value: constants.ACTIVE_TREE},
           {label: 'Pending tree', value: constants.PENDING_TREE},
           {label: 'Render pass quads', value: RENDER_PASS_QUADS}]));

      this.showPureTransformLayers_ = false;
      const showPureTransformLayers = tr.ui.b.createCheckBox(
          this, 'showPureTransformLayers',
          'layerPicker.showPureTransformLayers', false,
          'Transform layers');
      Polymer.dom(showPureTransformLayers).classList.add(
          'show-transform-layers');
      showPureTransformLayers.title =
          'When checked, pure transform layers are shown';
      Polymer.dom(this.controls_).appendChild(showPureTransformLayers);
    },

    get lthiSnapshot() {
      return this.lthiSnapshot_;
    },

    set lthiSnapshot(lthiSnapshot) {
      this.lthiSnapshot_ = lthiSnapshot;
      this.updateContents_();
    },

    get whichTree() {
      return this.renderPassQuads_ ? constants.ACTIVE_TREE : this.whichTree_;
    },

    set whichTree(whichTree) {
      this.whichTree_ = whichTree;
      this.renderPassQuads_ = (whichTree === RENDER_PASS_QUADS);
      this.updateContents_();
      tr.b.dispatchSimpleEvent(this, 'selection-change', false);
    },

    get layerTreeImpl() {
      if (this.lthiSnapshot === undefined) return undefined;

      return this.lthiSnapshot.getTree(this.whichTree);
    },

    get isRenderPassQuads() {
      return this.renderPassQuads_;
    },

    get showPureTransformLayers() {
      return this.showPureTransformLayers_;
    },

    set showPureTransformLayers(show) {
      if (this.showPureTransformLayers_ === show) return;

      this.showPureTransformLayers_ = show;
      this.updateContents_();
    },

    getRenderPassInfos_() {
      if (!this.lthiSnapshot_) return [];

      const renderPassInfo = [];
      if (!this.lthiSnapshot_.args.frame ||
          !this.lthiSnapshot_.args.frame.renderPasses) {
        return renderPassInfo;
      }

      const renderPasses = this.lthiSnapshot_.args.frame.renderPasses;
      for (let i = 0; i < renderPasses.length; ++i) {
        const info = {renderPass: renderPasses[i],
          depth: 0,
          id: i,
          name: 'cc::RenderPass'};
        renderPassInfo.push(info);
      }
      return renderPassInfo;
    },

    getLayerInfos_() {
      if (!this.lthiSnapshot_) return [];

      const tree = this.lthiSnapshot_.getTree(this.whichTree_);
      if (!tree) return [];

      const layerInfos = [];

      const showPureTransformLayers = this.showPureTransformLayers_;

      function isPureTransformLayer(layer) {
        if (layer.args.compositingReasons &&
            layer.args.compositingReasons.length !== 1 &&
            layer.args.compositingReasons[0] !== 'No reasons given') {
          return false;
        }

        if (layer.args.drawsContent) return false;

        return true;
      }
      const visitedLayers = {};
      function visitLayer(layer, depth, isMask, isReplica) {
        if (visitedLayers[layer.layerId]) return;

        visitedLayers[layer.layerId] = true;
        const info = {layer,
          depth};

        if (layer.args.drawsContent) {
          info.name = layer.objectInstance.name;
        } else {
          info.name = 'cc::LayerImpl';
        }

        if (layer.usingGpuRasterization) {
          info.name += ' (G)';
        }

        info.isMaskLayer = isMask;
        info.replicaLayer = isReplica;

        if (showPureTransformLayers || !isPureTransformLayer(layer)) {
          layerInfos.push(info);
        }
      }
      tree.iterLayers(visitLayer);
      return layerInfos;
    },

    updateContents_() {
      if (this.renderPassQuads_) {
        this.updateRenderPassContents_();
      } else {
        this.updateLayerContents_();
      }
    },

    updateRenderPassContents_() {
      this.itemList_.clear();

      let selectedRenderPassId;
      if (this.selection_ && this.selection_.associatedRenderPassId) {
        selectedRenderPassId = this.selection_.associatedRenderPassId;
      }

      const renderPassInfos = this.getRenderPassInfos_();
      renderPassInfos.forEach(function(renderPassInfo) {
        const renderPass = renderPassInfo.renderPass;
        const id = renderPassInfo.id;

        const item = this.createElementWithDepth_(renderPassInfo.depth);
        const labelEl = Polymer.dom(item).appendChild(tr.ui.b.createSpan());

        Polymer.dom(labelEl).textContent = renderPassInfo.name + ' ' + id;
        item.renderPass = renderPass;
        item.renderPassId = id;
        Polymer.dom(this.itemList_).appendChild(item);

        if (id === selectedRenderPassId) {
          renderPass.selectionState =
              tr.model.SelectionState.SELECTED;
        }
      }, this);
    },

    updateLayerContents_() {
      this.changingItemSelection_ = true;
      try {
        this.itemList_.clear();

        let selectedLayerId;
        if (this.selection_ && this.selection_.associatedLayerId) {
          selectedLayerId = this.selection_.associatedLayerId;
        }

        const layerInfos = this.getLayerInfos_();
        layerInfos.forEach(function(layerInfo) {
          const layer = layerInfo.layer;
          const id = layer.layerId;

          const item = this.createElementWithDepth_(layerInfo.depth);
          const labelEl = Polymer.dom(item).appendChild(tr.ui.b.createSpan());

          Polymer.dom(labelEl).textContent = layerInfo.name + ' ' + id;

          const notesEl = Polymer.dom(item).appendChild(tr.ui.b.createSpan());
          if (layerInfo.isMaskLayer) {
            Polymer.dom(notesEl).textContent += '(mask)';
          }
          if (layerInfo.isReplicaLayer) {
            Polymer.dom(notesEl).textContent += '(replica)';
          }

          if ((layer.gpuMemoryUsageInBytes !== undefined) &&
              (layer.gpuMemoryUsageInBytes > 0)) {
            const gpuUsageStr = tr.b.Unit.byName.sizeInBytes.format(
                layer.gpuMemoryUsageInBytes);
            Polymer.dom(notesEl).textContent += ' (' + gpuUsageStr + ' MiB)';
          }

          item.layer = layer;
          Polymer.dom(this.itemList_).appendChild(item);

          if (layer.layerId === selectedLayerId) {
            layer.selectionState = tr.model.SelectionState.SELECTED;
            item.selected = true;
          }
        }, this);
      } finally {
        this.changingItemSelection_ = false;
      }
    },

    createElementWithDepth_(depth) {
      const item = document.createElement('div');

      const indentEl = Polymer.dom(item).appendChild(tr.ui.b.createSpan());
      indentEl.style.whiteSpace = 'pre';
      for (let i = 0; i < depth; i++) {
        Polymer.dom(indentEl).textContent =
            Polymer.dom(indentEl).textContent + ' ';
      }
      return item;
    },

    onItemSelectionChanged_(e) {
      if (this.changingItemSelection_) return;
      if (this.renderPassQuads_) {
        this.onRenderPassSelected_(e);
      } else {
        this.onLayerSelected_(e);
      }
      tr.b.dispatchSimpleEvent(this, 'selection-change', false);
    },

    onRenderPassSelected_(e) {
      let selectedRenderPass;
      let selectedRenderPassId;
      if (this.itemList_.selectedElement) {
        selectedRenderPass = this.itemList_.selectedElement.renderPass;
        selectedRenderPassId =
            this.itemList_.selectedElement.renderPassId;
      }

      if (selectedRenderPass) {
        this.selection_ = new tr.ui.e.chrome.cc.RenderPassSelection(
            selectedRenderPass, selectedRenderPassId);
      } else {
        this.selection_ = undefined;
      }
    },

    onLayerSelected_(e) {
      let selectedLayer;
      if (this.itemList_.selectedElement) {
        selectedLayer = this.itemList_.selectedElement.layer;
      }

      if (selectedLayer) {
        this.selection_ = new tr.ui.e.chrome.cc.LayerSelection(selectedLayer);
      } else {
        this.selection_ = undefined;
      }
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection_ === selection) return;
      this.selection_ = selection;
      this.updateContents_();
    }
  };

  return {
    LayerPicker,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function RenderPassSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  RenderPassSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      tr.e.cc.preInitializeObject(this);
    },

    initialize() {
      tr.e.cc.moveRequiredFieldsFromArgsToToplevel(
          this, ['quadList']);
    }
  };

  ObjectSnapshot.subTypes.register(
      RenderPassSnapshot,
      {typeName: 'cc::RenderPass'});

  return {
    RenderPassSnapshot,
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const deg2rad = tr.b.math.deg2rad;

  const constants = {
    DEFAULT_SCALE: 0.5,
    DEFAULT_EYE_DISTANCE: 10000,
    MINIMUM_DISTANCE: 1000,
    MAXIMUM_DISTANCE: 100000,
    FOV: 15,
    RESCALE_TIMEOUT_MS: 200,
    MAXIMUM_TILT: 80,
    SETTINGS_NAMESPACE: 'tr.ui_camera'
  };

  const Camera = tr.ui.b.define('camera');

  Camera.prototype = {
    __proto__: HTMLUnknownElement.prototype,

    decorate(eventSource) {
      this.eventSource_ = eventSource;

      this.eventSource_.addEventListener('beginpan',
          this.onPanBegin_.bind(this));
      this.eventSource_.addEventListener('updatepan',
          this.onPanUpdate_.bind(this));
      this.eventSource_.addEventListener('endpan',
          this.onPanEnd_.bind(this));

      this.eventSource_.addEventListener('beginzoom',
          this.onZoomBegin_.bind(this));
      this.eventSource_.addEventListener('updatezoom',
          this.onZoomUpdate_.bind(this));
      this.eventSource_.addEventListener('endzoom',
          this.onZoomEnd_.bind(this));

      this.eventSource_.addEventListener('beginrotate',
          this.onRotateBegin_.bind(this));
      this.eventSource_.addEventListener('updaterotate',
          this.onRotateUpdate_.bind(this));
      this.eventSource_.addEventListener('endrotate',
          this.onRotateEnd_.bind(this));

      this.eye_ = [0, 0, constants.DEFAULT_EYE_DISTANCE];
      this.gazeTarget_ = [0, 0, 0];
      this.rotation_ = [0, 0];

      this.pixelRatio_ = window.devicePixelRatio || 1;
    },


    get modelViewMatrix() {
      const mvMatrix = mat4.create();

      mat4.lookAt(mvMatrix, this.eye_, this.gazeTarget_, [0, 1, 0]);
      return mvMatrix;
    },

    get projectionMatrix() {
      const rect =
          tr.ui.b.windowRectForElement(this.canvas_).
              scaleSize(this.pixelRatio_);

      const aspectRatio = rect.width / rect.height;
      const matrix = mat4.create();
      mat4.perspective(
          matrix, deg2rad(constants.FOV), aspectRatio, 1, 100000);

      return matrix;
    },

    set canvas(c) {
      this.canvas_ = c;
    },

    set deviceRect(rect) {
      this.deviceRect_ = rect;
    },

    get stackingDistanceDampening() {
      const gazeVector = [
        this.gazeTarget_[0] - this.eye_[0],
        this.gazeTarget_[1] - this.eye_[1],
        this.gazeTarget_[2] - this.eye_[2]];
      vec3.normalize(gazeVector, gazeVector);
      return 1 + gazeVector[2];
    },

    loadCameraFromSettings(settings) {
      this.eye_ = settings.get(
          'eye', this.eye_, constants.SETTINGS_NAMESPACE);
      this.gazeTarget_ = settings.get(
          'gaze_target', this.gazeTarget_, constants.SETTINGS_NAMESPACE);
      this.rotation_ = settings.get(
          'rotation', this.rotation_, constants.SETTINGS_NAMESPACE);

      this.dispatchRenderEvent_();
    },

    saveCameraToSettings(settings) {
      settings.set(
          'eye', this.eye_, constants.SETTINGS_NAMESPACE);
      settings.set(
          'gaze_target', this.gazeTarget_, constants.SETTINGS_NAMESPACE);
      settings.set(
          'rotation', this.rotation_, constants.SETTINGS_NAMESPACE);
    },

    resetCamera() {
      this.eye_ = [0, 0, constants.DEFAULT_EYE_DISTANCE];
      this.gazeTarget_ = [0, 0, 0];
      this.rotation_ = [0, 0];

      const settings = tr.b.SessionSettings();
      const keys = settings.keys(constants.SETTINGS_NAMESPACE);
      if (keys.length !== 0) {
        this.loadCameraFromSettings(settings);
        return;
      }

      if (this.deviceRect_) {
        const rect = tr.ui.b.windowRectForElement(this.canvas_).
            scaleSize(this.pixelRatio_);

        this.eye_[0] = this.deviceRect_.width / 2;
        this.eye_[1] = this.deviceRect_.height / 2;

        this.gazeTarget_[0] = this.deviceRect_.width / 2;
        this.gazeTarget_[1] = this.deviceRect_.height / 2;
      }

      this.saveCameraToSettings(settings);
      this.dispatchRenderEvent_();
    },

    updatePanByDelta(delta) {
      const rect =
          tr.ui.b.windowRectForElement(this.canvas_).
              scaleSize(this.pixelRatio_);

      // Get the eye vector, since we'll be adjusting gazeTarget.
      const eyeVector = [
        this.eye_[0] - this.gazeTarget_[0],
        this.eye_[1] - this.gazeTarget_[1],
        this.eye_[2] - this.gazeTarget_[2]];
      const length = vec3.length(eyeVector);
      vec3.normalize(eyeVector, eyeVector);

      const halfFov = constants.FOV / 2;
      const multiplier =
          2.0 * length * Math.tan(deg2rad(halfFov)) / rect.height;

      // Get the up and right vectors.
      const up = [0, 1, 0];
      const rotMatrix = mat4.create();
      mat4.rotate(
          rotMatrix, rotMatrix, deg2rad(this.rotation_[1]), [0, 1, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, deg2rad(this.rotation_[0]), [1, 0, 0]);
      vec3.transformMat4(up, up, rotMatrix);

      const right = [0, 0, 0];
      vec3.cross(right, eyeVector, up);
      vec3.normalize(right, right);

      // Update the gaze target.
      for (let i = 0; i < 3; ++i) {
        this.gazeTarget_[i] +=
            delta[0] * multiplier * right[i] - delta[1] * multiplier * up[i];

        this.eye_[i] = this.gazeTarget_[i] + length * eyeVector[i];
      }

      // If we have some z offset, we need to reposition gazeTarget
      // to be on the plane z = 0 with normal [0, 0, 1].
      if (Math.abs(this.gazeTarget_[2]) > 1e-6) {
        const gazeVector = [-eyeVector[0], -eyeVector[1], -eyeVector[2]];
        const newLength = tr.b.math.clamp(
            -this.eye_[2] / gazeVector[2],
            constants.MINIMUM_DISTANCE,
            constants.MAXIMUM_DISTANCE);

        for (let i = 0; i < 3; ++i) {
          this.gazeTarget_[i] = this.eye_[i] + newLength * gazeVector[i];
        }
      }

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },

    updateZoomByDelta(delta) {
      let deltaY = delta[1];
      deltaY = tr.b.math.clamp(deltaY, -50, 50);
      let scale = 1.0 - deltaY / 100.0;

      const eyeVector = [0, 0, 0];
      vec3.subtract(eyeVector, this.eye_, this.gazeTarget_);

      const length = vec3.length(eyeVector);

      // Clamp the length to allowed values by changing the scale.
      if (length * scale < constants.MINIMUM_DISTANCE) {
        scale = constants.MINIMUM_DISTANCE / length;
      } else if (length * scale > constants.MAXIMUM_DISTANCE) {
        scale = constants.MAXIMUM_DISTANCE / length;
      }

      vec3.scale(eyeVector, eyeVector, scale);
      vec3.add(this.eye_, this.gazeTarget_, eyeVector);

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },

    updateRotateByDelta(delta) {
      delta[0] *= 0.5;
      delta[1] *= 0.5;

      if (Math.abs(this.rotation_[0] + delta[1]) > constants.MAXIMUM_TILT) {
        return;
      }
      if (Math.abs(this.rotation_[1] - delta[0]) > constants.MAXIMUM_TILT) {
        return;
      }

      const eyeVector = [0, 0, 0, 0];
      vec3.subtract(eyeVector, this.eye_, this.gazeTarget_);

      // Undo the current rotation.
      const rotMatrix = mat4.create();
      mat4.rotate(
          rotMatrix, rotMatrix, -deg2rad(this.rotation_[0]), [1, 0, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, -deg2rad(this.rotation_[1]), [0, 1, 0]);
      vec4.transformMat4(eyeVector, eyeVector, rotMatrix);

      // Update rotation values.
      this.rotation_[0] += delta[1];
      this.rotation_[1] -= delta[0];

      // Redo the new rotation.
      mat4.identity(rotMatrix);
      mat4.rotate(
          rotMatrix, rotMatrix, deg2rad(this.rotation_[1]), [0, 1, 0]);
      mat4.rotate(
          rotMatrix, rotMatrix, deg2rad(this.rotation_[0]), [1, 0, 0]);
      vec4.transformMat4(eyeVector, eyeVector, rotMatrix);

      vec3.add(this.eye_, this.gazeTarget_, eyeVector);

      this.saveCameraToSettings(tr.b.SessionSettings());
      this.dispatchRenderEvent_();
    },


    // Event callbacks.
    onPanBegin_(e) {
      this.panning_ = true;
      this.lastMousePosition_ = this.getMousePosition_(e);
    },

    onPanUpdate_(e) {
      if (!this.panning_) return;

      const delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updatePanByDelta(delta);
    },

    onPanEnd_(e) {
      this.panning_ = false;
    },

    onZoomBegin_(e) {
      this.zooming_ = true;

      const p = this.getMousePosition_(e);

      this.lastMousePosition_ = p;
      this.zoomPoint_ = p;
    },

    onZoomUpdate_(e) {
      if (!this.zooming_) return;

      const delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updateZoomByDelta(delta);
    },

    onZoomEnd_(e) {
      this.zooming_ = false;
      this.zoomPoint_ = undefined;
    },

    onRotateBegin_(e) {
      this.rotating_ = true;
      this.lastMousePosition_ = this.getMousePosition_(e);
    },

    onRotateUpdate_(e) {
      if (!this.rotating_) return;

      const delta = this.getMouseDelta_(e, this.lastMousePosition_);
      this.lastMousePosition_ = this.getMousePosition_(e);
      this.updateRotateByDelta(delta);
    },

    onRotateEnd_(e) {
      this.rotating_ = false;
    },


    // Misc helper functions.
    getMousePosition_(e) {
      const rect = tr.ui.b.windowRectForElement(this.canvas_);
      return [(e.clientX - rect.x) * this.pixelRatio_,
        (e.clientY - rect.y) * this.pixelRatio_];
    },

    getMouseDelta_(e, p) {
      const newP = this.getMousePosition_(e);
      return [newP[0] - p[0], newP[1] - p[1]];
    },

    dispatchRenderEvent_() {
      tr.b.dispatchSimpleEvent(this, 'renderrequired', false, false);
    }
  };

  return {
    Camera,
  };
});


'use strict';

/**
 * @fileoverview QuadStackView controls the content and viewing angle a
 * QuadStack.
 */
tr.exportTo('tr.ui.b', function() {
  const THIS_DOC = document.currentScript.ownerDocument;

  const constants = {};
  constants.IMAGE_LOAD_RETRY_TIME_MS = 500;
  constants.SUBDIVISION_MINIMUM = 1;
  constants.SUBDIVISION_RECURSION_DEPTH = 3;
  constants.SUBDIVISION_DEPTH_THRESHOLD = 100;
  constants.FAR_PLANE_DISTANCE = 10000;

  // Care of bckenney@ via
  // http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
  function drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2) {
    const tmpP0 = [p0[0], p0[1]];
    const tmpP1 = [p1[0], p1[1]];
    const tmpP2 = [p2[0], p2[1]];
    const tmpT0 = [t0[0], t0[1]];
    const tmpT1 = [t1[0], t1[1]];
    const tmpT2 = [t2[0], t2[1]];

    ctx.beginPath();
    ctx.moveTo(tmpP0[0], tmpP0[1]);
    ctx.lineTo(tmpP1[0], tmpP1[1]);
    ctx.lineTo(tmpP2[0], tmpP2[1]);
    ctx.closePath();

    tmpP1[0] -= tmpP0[0];
    tmpP1[1] -= tmpP0[1];
    tmpP2[0] -= tmpP0[0];
    tmpP2[1] -= tmpP0[1];

    tmpT1[0] -= tmpT0[0];
    tmpT1[1] -= tmpT0[1];
    tmpT2[0] -= tmpT0[0];
    tmpT2[1] -= tmpT0[1];

    const det = 1 / (tmpT1[0] * tmpT2[1] - tmpT2[0] * tmpT1[1]);

    // linear transformation
    const a = (tmpT2[1] * tmpP1[0] - tmpT1[1] * tmpP2[0]) * det;
    const b = (tmpT2[1] * tmpP1[1] - tmpT1[1] * tmpP2[1]) * det;
    const c = (tmpT1[0] * tmpP2[0] - tmpT2[0] * tmpP1[0]) * det;
    const d = (tmpT1[0] * tmpP2[1] - tmpT2[0] * tmpP1[1]) * det;

    // translation
    const e = tmpP0[0] - a * tmpT0[0] - c * tmpT0[1];
    const f = tmpP0[1] - b * tmpT0[0] - d * tmpT0[1];

    ctx.save();
    ctx.transform(a, b, c, d, e, f);
    ctx.clip();
    ctx.drawImage(img, 0, 0);
    ctx.restore();
  }

  function drawTriangleSub(
      ctx, img, p0, p1, p2, t0, t1, t2, opt_recursionDepth) {
    const depth = opt_recursionDepth || 0;

    // We may subdivide if we are not at the limit of recursion.
    let subdivisionIndex = 0;
    if (depth < constants.SUBDIVISION_MINIMUM) {
      subdivisionIndex = 7;
    } else if (depth < constants.SUBDIVISION_RECURSION_DEPTH) {
      if (Math.abs(p0[2] - p1[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD) {
        subdivisionIndex += 1;
      }
      if (Math.abs(p0[2] - p2[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD) {
        subdivisionIndex += 2;
      }
      if (Math.abs(p1[2] - p2[2]) > constants.SUBDIVISION_DEPTH_THRESHOLD) {
        subdivisionIndex += 4;
      }
    }

    // These need to be created every time, since temporaries
    // outside of the scope will be rewritten in recursion.
    const p01 = vec4.create();
    const p02 = vec4.create();
    const p12 = vec4.create();
    const t01 = vec2.create();
    const t02 = vec2.create();
    const t12 = vec2.create();

    // Calculate the position before w-divide.
    for (let i = 0; i < 2; ++i) {
      p0[i] *= p0[2];
      p1[i] *= p1[2];
      p2[i] *= p2[2];
    }

    // Interpolate the 3d position.
    for (let i = 0; i < 4; ++i) {
      p01[i] = (p0[i] + p1[i]) / 2;
      p02[i] = (p0[i] + p2[i]) / 2;
      p12[i] = (p1[i] + p2[i]) / 2;
    }

    // Re-apply w-divide to the original points and the interpolated ones.
    for (let i = 0; i < 2; ++i) {
      p0[i] /= p0[2];
      p1[i] /= p1[2];
      p2[i] /= p2[2];

      p01[i] /= p01[2];
      p02[i] /= p02[2];
      p12[i] /= p12[2];
    }

    // Interpolate the texture coordinates.
    for (let i = 0; i < 2; ++i) {
      t01[i] = (t0[i] + t1[i]) / 2;
      t02[i] = (t0[i] + t2[i]) / 2;
      t12[i] = (t1[i] + t2[i]) / 2;
    }

    // Based on the index, we subdivide the triangle differently.
    // Assuming the triangle is p0, p1, p2 and points between i j
    // are represented as pij (that is, a point between p2 and p0
    // is p02, etc), then the new triangles are defined by
    // the 3rd 4th and 5th arguments into the function.
    switch (subdivisionIndex) {
      case 1:
        drawTriangleSub(ctx, img, p0, p01, p2, t0, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p2, t01, t1, t2, depth + 1);
        break;
      case 2:
        drawTriangleSub(ctx, img, p0, p1, p02, t0, t1, t02, depth + 1);
        drawTriangleSub(ctx, img, p1, p02, p2, t1, t02, t2, depth + 1);
        break;
      case 3:
        drawTriangleSub(ctx, img, p0, p01, p02, t0, t01, t02, depth + 1);
        drawTriangleSub(ctx, img, p02, p01, p2, t02, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p2, t01, t1, t2, depth + 1);
        break;
      case 4:
        drawTriangleSub(ctx, img, p0, p12, p2, t0, t12, t2, depth + 1);
        drawTriangleSub(ctx, img, p0, p1, p12, t0, t1, t12, depth + 1);
        break;
      case 5:
        drawTriangleSub(ctx, img, p0, p01, p2, t0, t01, t2, depth + 1);
        drawTriangleSub(ctx, img, p2, p01, p12, t2, t01, t12, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p12, t01, t1, t12, depth + 1);
        break;
      case 6:
        drawTriangleSub(ctx, img, p0, p12, p02, t0, t12, t02, depth + 1);
        drawTriangleSub(ctx, img, p0, p1, p12, t0, t1, t12, depth + 1);
        drawTriangleSub(ctx, img, p02, p12, p2, t02, t12, t2, depth + 1);
        break;
      case 7:
        drawTriangleSub(ctx, img, p0, p01, p02, t0, t01, t02, depth + 1);
        drawTriangleSub(ctx, img, p01, p12, p02, t01, t12, t02, depth + 1);
        drawTriangleSub(ctx, img, p01, p1, p12, t01, t1, t12, depth + 1);
        drawTriangleSub(ctx, img, p02, p12, p2, t02, t12, t2, depth + 1);
        break;
      default:
        // In the 0 case and all other cases, we simply draw the triangle.
        drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2);
        break;
    }
  }

  // Created to avoid creating garbage when doing bulk transforms.
  const tmpVec4 = vec4.create();
  function transform(transformed, point, matrix, viewport) {
    vec4.set(tmpVec4, point[0], point[1], 0, 1);
    vec4.transformMat4(tmpVec4, tmpVec4, matrix);

    let w = tmpVec4[3];
    if (w < 1e-6) w = 1e-6;

    transformed[0] = ((tmpVec4[0] / w) + 1) * viewport.width / 2;
    transformed[1] = ((tmpVec4[1] / w) + 1) * viewport.height / 2;
    transformed[2] = w;
  }

  function drawProjectedQuadBackgroundToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (quad.imageData) {
      quadCanvas.width = quad.imageData.width;
      quadCanvas.height = quad.imageData.height;
      quadCanvas.getContext('2d').putImageData(quad.imageData, 0, 0);
      const quadBBox = new tr.b.math.BBox2();
      quadBBox.addQuad(quad);
      const iw = quadCanvas.width;
      const ih = quadCanvas.height;
      drawTriangleSub(
          ctx, quadCanvas,
          p1, p2, p4,
          [0, 0], [iw, 0], [0, ih]);
      drawTriangleSub(
          ctx, quadCanvas,
          p2, p3, p4,
          [iw, 0], [iw, ih], [0, ih]);
    }

    if (quad.backgroundColor) {
      ctx.fillStyle = quad.backgroundColor;
      ctx.beginPath();
      ctx.moveTo(p1[0], p1[1]);
      ctx.lineTo(p2[0], p2[1]);
      ctx.lineTo(p3[0], p3[1]);
      ctx.lineTo(p4[0], p4[1]);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawProjectedQuadOutlineToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]);
    ctx.lineTo(p2[0], p2[1]);
    ctx.lineTo(p3[0], p3[1]);
    ctx.lineTo(p4[0], p4[1]);
    ctx.closePath();
    ctx.save();
    if (quad.borderColor) {
      ctx.strokeStyle = quad.borderColor;
    } else {
      ctx.strokeStyle = 'rgb(128,128,128)';
    }

    if (quad.shadowOffset) {
      ctx.shadowColor = 'rgb(0, 0, 0)';
      ctx.shadowOffsetX = quad.shadowOffset[0];
      ctx.shadowOffsetY = quad.shadowOffset[1];
      if (quad.shadowBlur) {
        ctx.shadowBlur = quad.shadowBlur;
      }
    }

    if (quad.borderWidth) {
      ctx.lineWidth = quad.borderWidth;
    } else {
      ctx.lineWidth = 1;
    }

    ctx.stroke();
    ctx.restore();
  }

  function drawProjectedQuadSelectionOutlineToContext(
      quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (!quad.upperBorderColor) return;

    ctx.lineWidth = 8;
    ctx.strokeStyle = quad.upperBorderColor;

    ctx.beginPath();
    ctx.moveTo(p1[0], p1[1]);
    ctx.lineTo(p2[0], p2[1]);
    ctx.lineTo(p3[0], p3[1]);
    ctx.lineTo(p4[0], p4[1]);
    ctx.closePath();
    ctx.stroke();
  }

  function drawProjectedQuadToContext(
      passNumber, quad, p1, p2, p3, p4, ctx, quadCanvas) {
    if (passNumber === 0) {
      drawProjectedQuadBackgroundToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else if (passNumber === 1) {
      drawProjectedQuadOutlineToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else if (passNumber === 2) {
      drawProjectedQuadSelectionOutlineToContext(
          quad, p1, p2, p3, p4, ctx, quadCanvas);
    } else {
      throw new Error('Invalid pass number');
    }
  }

  const tmpP1 = vec3.create();
  const tmpP2 = vec3.create();
  const tmpP3 = vec3.create();
  const tmpP4 = vec3.create();
  function transformAndProcessQuads(
      matrix, viewport, quads, numPasses, handleQuadFunc, opt_arg1, opt_arg2) {
    for (let passNumber = 0; passNumber < numPasses; passNumber++) {
      for (let i = 0; i < quads.length; i++) {
        const quad = quads[i];
        transform(tmpP1, quad.p1, matrix, viewport);
        transform(tmpP2, quad.p2, matrix, viewport);
        transform(tmpP3, quad.p3, matrix, viewport);
        transform(tmpP4, quad.p4, matrix, viewport);
        handleQuadFunc(passNumber, quad,
            tmpP1, tmpP2, tmpP3, tmpP4,
            opt_arg1, opt_arg2);
      }
    }
  }

  /**
   * @constructor
   */
  const QuadStackView = tr.ui.b.define('quad-stack-view');

  QuadStackView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.className = 'quad-stack-view';

      const node = tr.ui.b.instantiateTemplate('#quad-stack-view-template',
          THIS_DOC);
      Polymer.dom(this).appendChild(node);
      this.updateHeaderVisibility_();
      this.canvas_ = Polymer.dom(this).querySelector('#canvas');
      this.chromeImages_ = {
        left: Polymer.dom(this).querySelector('#chrome-left'),
        mid: Polymer.dom(this).querySelector('#chrome-mid'),
        right: Polymer.dom(this).querySelector('#chrome-right')
      };

      const stackingDistanceSlider = Polymer.dom(this).querySelector(
          '#stacking-distance-slider');
      stackingDistanceSlider.value = tr.b.Settings.get(
          'quadStackView.stackingDistance', 45);
      stackingDistanceSlider.addEventListener(
          'change', this.onStackingDistanceChange_.bind(this));
      stackingDistanceSlider.addEventListener(
          'input', this.onStackingDistanceChange_.bind(this));

      this.trackMouse_();

      this.camera_ = new tr.ui.b.Camera(this.mouseModeSelector_);
      this.camera_.addEventListener('renderrequired',
          this.onRenderRequired_.bind(this));
      this.cameraWasReset_ = false;
      this.camera_.canvas = this.canvas_;

      this.viewportRect_ = tr.b.math.Rect.fromXYWH(0, 0, 0, 0);

      this.pixelRatio_ = window.devicePixelRatio || 1;
    },

    updateHeaderVisibility_() {
      if (this.headerText) {
        Polymer.dom(this).querySelector('#header').style.display = '';
      } else {
        Polymer.dom(this).querySelector('#header').style.display = 'none';
      }
    },

    get headerText() {
      return Polymer.dom(this).querySelector('#header').textContent;
    },

    set headerText(headerText) {
      Polymer.dom(this).querySelector('#header').textContent = headerText;
      this.updateHeaderVisibility_();
    },

    onStackingDistanceChange_(e) {
      tr.b.Settings.set('quadStackView.stackingDistance',
          this.stackingDistance);
      this.scheduleRender();
      e.stopPropagation();
    },

    get stackingDistance() {
      return Polymer.dom(this).querySelector('#stacking-distance-slider').value;
    },

    get mouseModeSelector() {
      return this.mouseModeSelector_;
    },

    get camera() {
      return this.camera_;
    },

    set quads(q) {
      this.quads_ = q;
      this.scheduleRender();
    },

    set deviceRect(rect) {
      if (!rect || rect.equalTo(this.deviceRect_)) return;

      this.deviceRect_ = rect;
      this.camera_.deviceRect = rect;
      this.chromeQuad_ = undefined;
    },

    resize() {
      if (!this.offsetParent) return true;

      const width = parseInt(window.getComputedStyle(this.offsetParent).width);
      const height = parseInt(window.getComputedStyle(
          this.offsetParent).height);
      const rect = tr.b.math.Rect.fromXYWH(0, 0, width, height);

      if (rect.equalTo(this.viewportRect_)) return false;

      this.viewportRect_ = rect;
      this.style.width = width + 'px';
      this.style.height = height + 'px';
      this.canvas_.style.width = width + 'px';
      this.canvas_.style.height = height + 'px';
      this.canvas_.width = this.pixelRatio_ * width;
      this.canvas_.height = this.pixelRatio_ * height;
      if (!this.cameraWasReset_) {
        this.camera_.resetCamera();
        this.cameraWasReset_ = true;
      }
      return true;
    },

    readyToDraw() {
      // If src isn't set yet, set it to ensure we can use
      // the image to draw onto a canvas.
      if (!this.chromeImages_.left.src) {
        let leftContent =
            window.getComputedStyle(this.chromeImages_.left).backgroundImage;
        leftContent = tr.ui.b.extractUrlString(leftContent);

        let midContent =
            window.getComputedStyle(this.chromeImages_.mid).backgroundImage;
        midContent = tr.ui.b.extractUrlString(midContent);

        let rightContent =
            window.getComputedStyle(this.chromeImages_.right).backgroundImage;
        rightContent = tr.ui.b.extractUrlString(rightContent);

        this.chromeImages_.left.src = leftContent;
        this.chromeImages_.mid.src = midContent;
        this.chromeImages_.right.src = rightContent;
      }

      // If all of the images are loaded (height > 0), then
      // we are ready to draw.
      return (this.chromeImages_.left.height > 0) &&
             (this.chromeImages_.mid.height > 0) &&
             (this.chromeImages_.right.height > 0);
    },

    get chromeQuad() {
      if (this.chromeQuad_) return this.chromeQuad_;

      // Draw the chrome border into a separate canvas.
      const chromeCanvas = document.createElement('canvas');
      const offsetY = this.chromeImages_.left.height;

      chromeCanvas.width = this.deviceRect_.width;
      chromeCanvas.height = this.deviceRect_.height + offsetY;

      const leftWidth = this.chromeImages_.left.width;
      const midWidth = this.chromeImages_.mid.width;
      const rightWidth = this.chromeImages_.right.width;

      const chromeCtx = chromeCanvas.getContext('2d');
      chromeCtx.drawImage(this.chromeImages_.left, 0, 0);

      chromeCtx.save();
      chromeCtx.translate(leftWidth, 0);

      // Calculate the scale of the mid image.
      const s = (this.deviceRect_.width - leftWidth - rightWidth) / midWidth;
      chromeCtx.scale(s, 1);

      chromeCtx.drawImage(this.chromeImages_.mid, 0, 0);
      chromeCtx.restore();

      chromeCtx.drawImage(
          this.chromeImages_.right, leftWidth + s * midWidth, 0);

      // Construct the quad.
      const chromeRect = tr.b.math.Rect.fromXYWH(
          this.deviceRect_.x,
          this.deviceRect_.y - offsetY,
          this.deviceRect_.width,
          this.deviceRect_.height + offsetY);
      const chromeQuad = tr.b.math.Quad.fromRect(chromeRect);
      chromeQuad.stackingGroupId = this.maxStackingGroupId_ + 1;
      chromeQuad.imageData = chromeCtx.getImageData(
          0, 0, chromeCanvas.width, chromeCanvas.height);
      chromeQuad.shadowOffset = [0, 0];
      chromeQuad.shadowBlur = 5;
      chromeQuad.borderWidth = 3;
      this.chromeQuad_ = chromeQuad;
      return this.chromeQuad_;
    },

    scheduleRender() {
      if (this.redrawScheduled_) return false;
      this.redrawScheduled_ = true;
      tr.b.requestAnimationFrame(this.render, this);
    },

    onRenderRequired_(e) {
      this.scheduleRender();
    },

    stackTransformAndProcessQuads_(
        numPasses, handleQuadFunc, includeChromeQuad, opt_arg1, opt_arg2) {
      const mv = this.camera_.modelViewMatrix;
      const p = this.camera_.projectionMatrix;

      const viewport = tr.b.math.Rect.fromXYWH(
          0, 0, this.canvas_.width, this.canvas_.height);

      // Calculate the quad stacks.
      const quadStacks = [];
      for (let i = 0; i < this.quads_.length; ++i) {
        const quad = this.quads_[i];
        const stackingId = quad.stackingGroupId || 0;
        while (stackingId >= quadStacks.length) {
          quadStacks.push([]);
        }

        quadStacks[stackingId].push(quad);
      }

      const mvp = mat4.create();
      this.maxStackingGroupId_ = quadStacks.length;
      const effectiveStackingDistance =
          this.stackingDistance * this.camera_.stackingDistanceDampening;

      // Draw the quad stacks, raising each subsequent level.
      mat4.multiply(mvp, p, mv);
      for (let i = 0; i < quadStacks.length; ++i) {
        transformAndProcessQuads(mvp, viewport, quadStacks[i],
            numPasses, handleQuadFunc,
            opt_arg1, opt_arg2);

        mat4.translate(mv, mv, [0, 0, effectiveStackingDistance]);
        mat4.multiply(mvp, p, mv);
      }

      if (includeChromeQuad && this.deviceRect_) {
        transformAndProcessQuads(mvp, viewport, [this.chromeQuad],
            numPasses, drawProjectedQuadToContext,
            opt_arg1, opt_arg2);
      }
    },

    render() {
      this.redrawScheduled_ = false;

      if (!this.readyToDraw()) {
        setTimeout(this.scheduleRender.bind(this),
            constants.IMAGE_LOAD_RETRY_TIME_MS);
        return;
      }

      if (!this.quads_) return;

      const canvasCtx = this.canvas_.getContext('2d');
      if (!this.resize()) {
        canvasCtx.clearRect(0, 0, this.canvas_.width, this.canvas_.height);
      }

      const quadCanvas = document.createElement('canvas');
      this.stackTransformAndProcessQuads_(
          3, drawProjectedQuadToContext, true,
          canvasCtx, quadCanvas);
      quadCanvas.width = 0; // Hack: Frees the quadCanvas' resources.
    },

    trackMouse_() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.canvas_;
      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.SELECTION |
          tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN |
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM |
          tr.ui.b.MOUSE_SELECTOR_MODE.ROTATE;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN;
      this.mouseModeSelector_.pos = {x: 0, y: 100};
      Polymer.dom(this).appendChild(this.mouseModeSelector_);
      this.mouseModeSelector_.settingsKey =
          'quadStackView.mouseModeSelector';

      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.ROTATE, tr.ui.b.MODIFIER.SHIFT);
      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.PANSCAN, tr.ui.b.MODIFIER.SPACE);
      this.mouseModeSelector_.setModifierForAlternateMode(
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM, tr.ui.b.MODIFIER.CMD_OR_CTRL);

      this.mouseModeSelector_.addEventListener('updateselection',
          this.onSelectionUpdate_.bind(this));
      this.mouseModeSelector_.addEventListener('endselection',
          this.onSelectionUpdate_.bind(this));
    },

    extractRelativeMousePosition_(e) {
      const br = this.canvas_.getBoundingClientRect();
      return [
        this.pixelRatio_ * (e.clientX - this.canvas_.offsetLeft - br.left),
        this.pixelRatio_ * (e.clientY - this.canvas_.offsetTop - br.top)
      ];
    },

    onSelectionUpdate_(e) {
      const mousePos = this.extractRelativeMousePosition_(e);
      const res = [];
      function handleQuad(passNumber, quad, p1, p2, p3, p4) {
        if (tr.b.math.pointInImplicitQuad(mousePos, p1, p2, p3, p4)) {
          res.push(quad);
        }
      }
      this.stackTransformAndProcessQuads_(1, handleQuad, false);
      e = new tr.b.Event('selectionchange');
      e.quads = res;
      this.dispatchEvent(e);
    }
  };

  return {
    QuadStackView,
  };
});


'use strict';

/**
 * @fileoverview Graphical view of  LayerTreeImpl, with controls for
 * type of layer content shown and info bar for content-loading warnings.
 */
tr.exportTo('tr.ui.e.chrome.cc', function() {
  const ColorScheme = tr.b.ColorScheme;

  const THIS_DOC = document.currentScript.ownerDocument;
  const TILE_HEATMAP_TYPE = {};
  TILE_HEATMAP_TYPE.NONE = 'none';
  TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY = 'scheduledPriority';
  TILE_HEATMAP_TYPE.USING_GPU_MEMORY = 'usingGpuMemory';

  const cc = tr.ui.e.chrome.cc;

  function createTileRectsSelectorBaseOptions() {
    return [{label: 'None', value: 'none'},
            {label: 'Coverage Rects', value: 'coverage'}];
  }


  /**
   * @constructor
   */
  const LayerTreeQuadStackView =
      tr.ui.b.define('tr-ui-e-chrome-cc-layer-tree-quad-stack-view');

  LayerTreeQuadStackView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.isRenderPassQuads_ = false;
      this.pictureAsImageData_ = {}; // Maps picture.guid to PictureAsImageData.
      this.messages_ = [];
      this.controls_ = document.createElement('top-controls');
      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      this.quadStackView_ = new tr.ui.b.QuadStackView();
      this.quadStackView_.addEventListener(
          'selectionchange', this.onQuadStackViewSelectionChange_.bind(this));
      this.extraHighlightsByLayerId_ = undefined;
      this.inputEventImageData_ = undefined;

      const m = tr.ui.b.MOUSE_SELECTOR_MODE;
      const mms = this.quadStackView_.mouseModeSelector;
      mms.settingsKey = 'tr.e.cc.layerTreeQuadStackView.mouseModeSelector';
      mms.setKeyCodeForMode(m.SELECTION, 'Z'.charCodeAt(0));
      mms.setKeyCodeForMode(m.PANSCAN, 'X'.charCodeAt(0));
      mms.setKeyCodeForMode(m.ZOOM, 'C'.charCodeAt(0));
      mms.setKeyCodeForMode(m.ROTATE, 'V'.charCodeAt(0));

      const node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-layer-tree-quad-stack-view-template', THIS_DOC);
      Polymer.dom(this).appendChild(node);
      Polymer.dom(this).appendChild(this.controls_);
      Polymer.dom(this).appendChild(this.infoBar_);
      Polymer.dom(this).appendChild(this.quadStackView_);

      this.tileRectsSelector_ = tr.ui.b.createSelector(
          this, 'howToShowTiles',
          'layerView.howToShowTiles', 'none',
          createTileRectsSelectorBaseOptions());
      Polymer.dom(this.controls_).appendChild(this.tileRectsSelector_);

      const tileHeatmapText = tr.ui.b.createSpan({
        textContent: 'Tile heatmap:'
      });
      Polymer.dom(this.controls_).appendChild(tileHeatmapText);

      const tileHeatmapSelector = tr.ui.b.createSelector(
          this, 'tileHeatmapType',
          'layerView.tileHeatmapType', TILE_HEATMAP_TYPE.NONE,
          [{label: 'None',
            value: TILE_HEATMAP_TYPE.NONE},
          {label: 'Scheduled Priority',
            value: TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY},
          {label: 'Is using GPU memory',
            value: TILE_HEATMAP_TYPE.USING_GPU_MEMORY}
          ]);
      Polymer.dom(this.controls_).appendChild(tileHeatmapSelector);

      const showOtherLayersCheckbox = tr.ui.b.createCheckBox(
          this, 'showOtherLayers',
          'layerView.showOtherLayers', true,
          'Other layers/passes');
      showOtherLayersCheckbox.title =
          'When checked, show all layers, selected or not.';
      Polymer.dom(this.controls_).appendChild(showOtherLayersCheckbox);

      const showInvalidationsCheckbox = tr.ui.b.createCheckBox(
          this, 'showInvalidations',
          'layerView.showInvalidations', true,
          'Invalidations');
      showInvalidationsCheckbox.title =
          'When checked, compositing invalidations are highlighted in red';
      Polymer.dom(this.controls_).appendChild(showInvalidationsCheckbox);

      const showUnrecordedRegionCheckbox = tr.ui.b.createCheckBox(
          this, 'showUnrecordedRegion',
          'layerView.showUnrecordedRegion', true,
          'Unrecorded area');
      showUnrecordedRegionCheckbox.title =
          'When checked, unrecorded areas are highlighted in yellow';
      Polymer.dom(this.controls_).appendChild(showUnrecordedRegionCheckbox);

      const showBottlenecksCheckbox = tr.ui.b.createCheckBox(
          this, 'showBottlenecks',
          'layerView.showBottlenecks', true,
          'Bottlenecks');
      showBottlenecksCheckbox.title =
          'When checked, scroll bottlenecks are highlighted';
      Polymer.dom(this.controls_).appendChild(showBottlenecksCheckbox);

      const showLayoutRectsCheckbox = tr.ui.b.createCheckBox(
          this, 'showLayoutRects',
          'layerView.showLayoutRects', false,
          'Layout rects');
      showLayoutRectsCheckbox.title =
          'When checked, shows rects for regions where layout happened';
      Polymer.dom(this.controls_).appendChild(showLayoutRectsCheckbox);

      const showContentsCheckbox = tr.ui.b.createCheckBox(
          this, 'showContents',
          'layerView.showContents', true,
          'Contents');
      showContentsCheckbox.title =
          'When checked, show the rendered contents inside the layer outlines';
      Polymer.dom(this.controls_).appendChild(showContentsCheckbox);

      const showAnimationBoundsCheckbox = tr.ui.b.createCheckBox(
          this, 'showAnimationBounds',
          'layerView.showAnimationBounds', false,
          'Animation Bounds');
      showAnimationBoundsCheckbox.title = 'When checked, show a border around' +
          ' a layer showing the extent of its animation.';
      Polymer.dom(this.controls_).appendChild(showAnimationBoundsCheckbox);

      const showInputEventsCheckbox = tr.ui.b.createCheckBox(
          this, 'showInputEvents',
          'layerView.showInputEvents', true,
          'Input events');
      showInputEventsCheckbox.title = 'When checked, input events are ' +
          'displayed as circles.';
      Polymer.dom(this.controls_).appendChild(showInputEventsCheckbox);

      this.whatRasterizedLink_ = document.createElement('a');
      Polymer.dom(this.whatRasterizedLink_).classList.add('what-rasterized');
      Polymer.dom(this.whatRasterizedLink_).textContent = 'What rasterized?';
      this.whatRasterizedLink_.addEventListener(
          'click', this.onWhatRasterizedLinkClicked_.bind(this));
      Polymer.dom(this).appendChild(this.whatRasterizedLink_);
    },

    get layerTreeImpl() {
      return this.layerTreeImpl_;
    },

    set isRenderPassQuads(newValue) {
      this.isRenderPassQuads_ = newValue;
    },

    set layerTreeImpl(layerTreeImpl) {
      if (this.layerTreeImpl_ === layerTreeImpl) return;

      // FIXME(pdr): We may want to clear pictureAsImageData_ here to save
      //             memory at the cost of performance. Note that
      //             pictureAsImageData_ will be cleared when this is
      //             destructed, but this view might live for several
      //             layerTreeImpls.
      this.layerTreeImpl_ = layerTreeImpl;
      this.selection = undefined;
    },

    get extraHighlightsByLayerId() {
      return this.extraHighlightsByLayerId_;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.extraHighlightsByLayerId_ = extraHighlightsByLayerId;
      this.scheduleUpdateContents_();
    },

    get showOtherLayers() {
      return this.showOtherLayers_;
    },

    set showOtherLayers(show) {
      this.showOtherLayers_ = show;
      this.updateContents_();
    },

    get showAnimationBounds() {
      return this.showAnimationBounds_;
    },

    set showAnimationBounds(show) {
      this.showAnimationBounds_ = show;
      this.updateContents_();
    },

    get showInputEvents() {
      return this.showInputEvents_;
    },

    set showInputEvents(show) {
      this.showInputEvents_ = show;
      this.updateContents_();
    },

    get showContents() {
      return this.showContents_;
    },

    set showContents(show) {
      this.showContents_ = show;
      this.updateContents_();
    },

    get showInvalidations() {
      return this.showInvalidations_;
    },

    set showInvalidations(show) {
      this.showInvalidations_ = show;
      this.updateContents_();
    },

    get showUnrecordedRegion() {
      return this.showUnrecordedRegion_;
    },

    set showUnrecordedRegion(show) {
      this.showUnrecordedRegion_ = show;
      this.updateContents_();
    },

    get showBottlenecks() {
      return this.showBottlenecks_;
    },

    set showBottlenecks(show) {
      this.showBottlenecks_ = show;
      this.updateContents_();
    },

    get showLayoutRects() {
      return this.showLayoutRects_;
    },

    set showLayoutRects(show) {
      this.showLayoutRects_ = show;
      this.updateContents_();
    },

    get howToShowTiles() {
      return this.howToShowTiles_;
    },

    set howToShowTiles(val) {
      // Make sure val is something we expect.
      if (val !== 'none' && val !== 'coverage' && isNaN(parseFloat(val))) {
        throw new Error(
            'howToShowTiles requires "none" or "coverage" or a number');
      }

      this.howToShowTiles_ = val;
      this.updateContents_();
    },

    get tileHeatmapType() {
      return this.tileHeatmapType_;
    },

    set tileHeatmapType(val) {
      this.tileHeatmapType_ = val;
      this.updateContents_();
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection === selection) return;

      this.selection_ = selection;
      tr.b.dispatchSimpleEvent(this, 'selection-change');
      this.updateContents_();
    },

    regenerateContent() {
      this.updateTilesSelector_();
      this.updateContents_();
    },

    loadDataForImageElement_(image, callback) {
      const imageContent = window.getComputedStyle(image).backgroundImage;
      image.src = tr.ui.b.extractUrlString(imageContent);
      image.onload = function() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        const imageData = ctx.getImageData(
            0, 0, canvas.width, canvas.height);
        callback(imageData);
      };
    },

    onQuadStackViewSelectionChange_(e) {
      const selectableQuads = e.quads.filter(function(q) {
        return q.selectionToSetIfClicked !== undefined;
      });
      if (selectableQuads.length === 0) {
        this.selection = undefined;
        return;
      }

      // Sort the quads low to high on stackingGroupId.
      selectableQuads.sort(function(x, y) {
        const z = x.stackingGroupId - y.stackingGroupId;
        if (z !== 0) return z;

        return x.selectionToSetIfClicked.specicifity -
            y.selectionToSetIfClicked.specicifity;
      });

      // TODO(nduca): Support selecting N things at once.
      const quadToSelect = selectableQuads[selectableQuads.length - 1];
      this.selection = quadToSelect.selectionToSetIfClicked;
    },

    scheduleUpdateContents_() {
      if (this.updateContentsPending_) return;

      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_, this);
    },

    updateContents_() {
      if (!this.layerTreeImpl_) {
        this.quadStackView_.headerText = 'No tree';
        this.quadStackView_.quads = [];
        return;
      }


      const status = this.computePictureLoadingStatus_();
      if (!status.picturesComplete) return;

      const lthi = this.layerTreeImpl_.layerTreeHostImpl;
      const lthiInstance = lthi.objectInstance;
      const worldViewportRect = tr.b.math.Rect.fromXYWH(
          0, 0,
          lthi.deviceViewportSize.width, lthi.deviceViewportSize.height);
      this.quadStackView_.deviceRect = worldViewportRect;
      if (this.isRenderPassQuads_) {
        this.quadStackView_.quads = this.generateRenderPassQuads();
      } else {
        this.quadStackView_.quads = this.generateLayerQuads();
      }

      this.updateWhatRasterizedLinkState_();

      let message = '';
      if (lthi.tilesHaveGpuMemoryUsageInfo) {
        const thisTreeUsageInBytes = this.layerTreeImpl_.gpuMemoryUsageInBytes;
        const otherTreeUsageInBytes = lthi.gpuMemoryUsageInBytes -
            thisTreeUsageInBytes;
        message +=
            tr.b.convertUnit(thisTreeUsageInBytes,
                tr.b.UnitPrefixScale.BINARY.NONE,
                tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) +
            ' MiB on this tree';
        if (otherTreeUsageInBytes) {
          message += ', ' +
              tr.b.convertUnit(otherTreeUsageInBytes,
                  tr.b.UnitPrefixScale.BINARY.NONE,
                  tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) +
              ' MiB on the other tree';
        }
      } else {
        if (this.layerTreeImpl_) {
          const thisTreeUsageInBytes =
            this.layerTreeImpl_.gpuMemoryUsageInBytes;
          message +=
              tr.b.convertUnit(thisTreeUsageInBytes,
                  tr.b.UnitPrefixScale.BINARY.NONE,
                  tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) +
              ' MiB on this tree';

          if (this.layerTreeImpl_.otherTree) {
            // Older Chromes don't report enough data to know how much memory is
            // being used across both trees. We know the memory consumed by each
            // tree, but there is resource sharing *between the trees* so we
            // can't simply sum up the per-tree costs. We need either the total
            // plus one tree, to guess the unique on the other tree, etc. Newer
            // chromes report memory per tile, which allows LTHI to compute the
            // total tile memory usage, letting us figure things out properly.
            message += ', ??? MiB on other tree. ';
          }
        }
      }

      if (lthi.args.tileManagerBasicState) {
        const tmgs = lthi.args.tileManagerBasicState.globalState;
        message += ' (softMax=' +
            tr.b.convertUnit(tmgs.softMemoryLimitInBytes,
                tr.b.UnitPrefixScale.BINARY.NONE,
                tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) +
            ' MiB, hardMax=' +
            tr.b.convertUnit(tmgs.hardMemoryLimitInBytes,
                tr.b.UnitPrefixScale.BINARY.NONE,
                tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) + ' MiB, ' +
            tmgs.memoryLimitPolicy + ')';
      } else {
        // Old Chromes do not have a globalState on the LTHI dump.
        // But they do issue a DidManage event wiht the globalstate. Find that
        // event so that we show some global state.
        const thread = lthi.snapshottedOnThread;
        const didManageTilesSlices = thread.sliceGroup.slices.filter(s => {
          if (s.category !== 'tr.e.cc') return false;

          if (s.title !== 'DidManage') return false;

          if (s.end > lthi.ts) return false;

          return true;
        });
        didManageTilesSlices.sort(function(x, y) {
          return x.end - y.end;
        });
        if (didManageTilesSlices.length > 0) {
          const newest = didManageTilesSlices[didManageTilesSlices.length - 1];
          const tmgs = newest.args.state.global_state;
          message += ' (softMax=' +
            tr.b.convertUnit(tmgs.softMemoryLimitInBytes,
                tr.b.UnitPrefixScale.BINARY.NONE,
                tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) +
            ' MiB, hardMax=' +
            tr.b.convertUnit(tmgs.hardMemoryLimitInBytes,
                tr.b.UnitPrefixScale.BINARY.NONE,
                tr.b.UnitPrefixScale.BINARY.MEBI).toFixed(1) + ' MiB, ' +
            tmgs.memoryLimitPolicy + ')';
        }
      }

      if (this.layerTreeImpl_.otherTree) {
        message += ' (Another tree exists)';
      }

      if (message.length) {
        this.quadStackView_.headerText = message;
      } else {
        this.quadStackView_.headerText = undefined;
      }

      this.updateInfoBar_(status.messages);
    },

    updateTilesSelector_() {
      const data = createTileRectsSelectorBaseOptions();

      if (this.layerTreeImpl_) {
        // First get all of the scales information from LTHI.
        const lthi = this.layerTreeImpl_.layerTreeHostImpl;
        const scaleNames = lthi.getContentsScaleNames();
        for (const scale in scaleNames) {
          data.push({
            label: 'Scale ' + scale + ' (' + scaleNames[scale] + ')',
            value: scale
          });
        }
      }

      // Then create a new selector and replace the old one.
      const newSelector = tr.ui.b.createSelector(
          this, 'howToShowTiles',
          'layerView.howToShowTiles', 'none',
          data);
      this.controls_.replaceChild(newSelector, this.tileRectsSelector_);
      this.tileRectsSelector_ = newSelector;
    },

    computePictureLoadingStatus_() {
      // Figure out if we can draw the quads yet. While we're at it, figure out
      // if we have any warnings we need to show.
      const layers = this.layers;
      const status = {
        messages: [],
        picturesComplete: true
      };
      if (this.showContents) {
        let hasPendingRasterizeImage = false;
        let firstPictureError = undefined;
        let hasMissingLayerRect = false;
        let hasUnresolvedPictureRef = false;
        for (let i = 0; i < layers.length; i++) {
          const layer = layers[i];
          for (let ir = 0; ir < layer.pictures.length; ++ir) {
            const picture = layer.pictures[ir];

            if (picture.idRef) {
              hasUnresolvedPictureRef = true;
              continue;
            }
            if (!picture.layerRect) {
              hasMissingLayerRect = true;
              continue;
            }

            const pictureAsImageData = this.pictureAsImageData_[picture.guid];
            if (!pictureAsImageData) {
              hasPendingRasterizeImage = true;
              this.pictureAsImageData_[picture.guid] =
                  tr.e.cc.PictureAsImageData.Pending(this);
              picture.rasterize(
                  {stopIndex: undefined},
                  function(pictureImageData) {
                    const picture_ = pictureImageData.picture;
                    this.pictureAsImageData_[picture_.guid] = pictureImageData;
                    this.scheduleUpdateContents_();
                  }.bind(this));
              continue;
            }
            if (pictureAsImageData.isPending()) {
              hasPendingRasterizeImage = true;
              continue;
            }
            if (pictureAsImageData.error) {
              if (!firstPictureError) {
                firstPictureError = pictureAsImageData.error;
              }
              break;
            }
          }
        }
        if (hasPendingRasterizeImage) {
          status.picturesComplete = false;
        } else {
          if (hasUnresolvedPictureRef) {
            status.messages.push({
              header: 'Missing picture',
              details: 'Your trace didn\'t have pictures for every layer. ' +
                  'Old chrome versions had this problem'});
          }
          if (hasMissingLayerRect) {
            status.messages.push({
              header: 'Missing layer rect',
              details: 'Your trace may be corrupt or from a very old ' +
                  'Chrome revision.'});
          }
          if (firstPictureError) {
            status.messages.push({
              header: 'Cannot rasterize',
              details: firstPictureError});
          }
        }
      }
      if (this.showInputEvents && this.layerTreeImpl.tracedInputLatencies &&
          this.inputEventImageData_ === undefined) {
        const image = Polymer.dom(this).querySelector('#input-event');
        if (!image.src) {
          this.loadDataForImageElement_(image, function(imageData) {
            this.inputEventImageData_ = imageData;
            this.updateContentsPending_ = false;
            this.scheduleUpdateContents_();
          }.bind(this));
        }
        status.picturesComplete = false;
      }
      return status;
    },

    get selectedRenderPass() {
      if (this.selection) {
        return this.selection.renderPass_;
      }
    },

    get selectedLayer() {
      if (this.selection) {
        const selectedLayerId = this.selection.associatedLayerId;
        return this.layerTreeImpl_.findLayerWithId(selectedLayerId);
      }
    },

    get renderPasses() {
      let renderPasses =
          this.layerTreeImpl.layerTreeHostImpl.args.frame.renderPasses;
      if (!this.showOtherLayers) {
        const selectedRenderPass = this.selectedRenderPass;
        if (selectedRenderPass) {
          renderPasses = [selectedRenderPass];
        }
      }
      return renderPasses;
    },

    get layers() {
      let layers = this.layerTreeImpl.renderSurfaceLayerList;
      if (!this.showOtherLayers) {
        const selectedLayer = this.selectedLayer;
        if (selectedLayer) {
          layers = [selectedLayer];
        }
      }
      return layers;
    },

    appendImageQuads_(quads, layer, layerQuad) {
      // Generate image quads for the layer
      for (let ir = 0; ir < layer.pictures.length; ++ir) {
        const picture = layer.pictures[ir];
        if (!picture.layerRect) continue;

        const unitRect = picture.layerRect.asUVRectInside(layer.bounds);
        const iq = layerQuad.projectUnitRect(unitRect);

        const pictureData = this.pictureAsImageData_[picture.guid];
        if (this.showContents && pictureData && pictureData.imageData) {
          iq.imageData = pictureData.imageData;
          iq.borderColor = 'rgba(0,0,0,0)';
        } else {
          iq.imageData = undefined;
        }

        iq.stackingGroupId = layerQuad.stackingGroupId;
        quads.push(iq);
      }
    },

    appendAnimationQuads_(quads, layer, layerQuad) {
      if (!layer.animationBoundsRect) return;

      const rect = layer.animationBoundsRect;
      const abq = tr.b.math.Quad.fromRect(rect);

      abq.backgroundColor = 'rgba(164,191,48,0.5)';
      abq.borderColor = 'rgba(205,255,0,0.75)';
      abq.borderWidth = 3.0;
      abq.stackingGroupId = layerQuad.stackingGroupId;
      abq.selectionToSetIfClicked = new cc.AnimationRectSelection(
          layer, rect);
      quads.push(abq);
    },

    appendInvalidationQuads_(quads, layer, layerQuad) {
      if (layer.layerTreeImpl.hasSourceFrameBeenDrawnBefore) return;

      // Generate the invalidation rect quads.
      for (let ir = 0; ir < layer.annotatedInvalidation.rects.length; ir++) {
        const rect = layer.annotatedInvalidation.rects[ir];
        const unitRect = rect.asUVRectInside(layer.bounds);
        const iq = layerQuad.projectUnitRect(unitRect);
        iq.backgroundColor = 'rgba(0, 255, 0, 0.1)';
        if (rect.reason === 'renderer insertion') {
          iq.backgroundColor = 'rgba(0, 255, 128, 0.1)';
        }
        iq.borderColor = 'rgba(0, 255, 0, 1)';
        iq.stackingGroupId = layerQuad.stackingGroupId;
        iq.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, 'Invalidation rect (' + rect.reason + ')', rect, rect);
        quads.push(iq);
      }

      // Show unannotated invalidation rect quads if no annotated rects are
      // available.
      if (layer.annotatedInvalidation.rects.length === 0) {
        for (let ir = 0; ir < layer.invalidation.rects.length; ir++) {
          const rect = layer.invalidation.rects[ir];
          const unitRect = rect.asUVRectInside(layer.bounds);
          const iq = layerQuad.projectUnitRect(unitRect);
          iq.backgroundColor = 'rgba(0, 255, 0, 0.1)';
          iq.borderColor = 'rgba(0, 255, 0, 1)';
          iq.stackingGroupId = layerQuad.stackingGroupId;
          iq.selectionToSetIfClicked = new cc.LayerRectSelection(
              layer, 'Invalidation rect', rect, rect);
          quads.push(iq);
        }
      }
    },

    appendUnrecordedRegionQuads_(quads, layer, layerQuad) {
      // Generate the unrecorded region quads.
      for (let ir = 0; ir < layer.unrecordedRegion.rects.length; ir++) {
        const rect = layer.unrecordedRegion.rects[ir];
        const unitRect = rect.asUVRectInside(layer.bounds);
        const iq = layerQuad.projectUnitRect(unitRect);
        iq.backgroundColor = 'rgba(240, 230, 140, 0.3)';
        iq.borderColor = 'rgba(240, 230, 140, 1)';
        iq.stackingGroupId = layerQuad.stackingGroupId;
        iq.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, 'Unrecorded area', rect, rect);
        quads.push(iq);
      }
    },

    appendBottleneckQuads_(quads, layer, layerQuad, stackingGroupId) {
      function processRegion(region, label, borderColor) {
        const backgroundColor = borderColor.clone();
        backgroundColor.a = 0.4 * (borderColor.a || 1.0);

        if (!region || !region.rects) return;

        for (let ir = 0; ir < region.rects.length; ir++) {
          const rect = region.rects[ir];
          const unitRect = rect.asUVRectInside(layer.bounds);
          const iq = layerQuad.projectUnitRect(unitRect);
          iq.backgroundColor = backgroundColor.toString();
          iq.borderColor = borderColor.toString();
          iq.borderWidth = 4.0;
          iq.stackingGroupId = stackingGroupId;
          iq.selectionToSetIfClicked = new cc.LayerRectSelection(
              layer, label, rect, rect);
          quads.push(iq);
        }
      }

      processRegion(layer.touchEventHandlerRegion, 'Touch listener',
          tr.b.Color.fromString('rgb(228, 226, 27)'));
      processRegion(layer.wheelEventHandlerRegion, 'Wheel listener',
          tr.b.Color.fromString('rgb(176, 205, 29)'));
      processRegion(layer.nonFastScrollableRegion, 'Repaints on scroll',
          tr.b.Color.fromString('rgb(213, 134, 32)'));
    },

    appendTileCoverageRectQuads_(
        quads, layer, layerQuad, heatmapType) {
      if (!layer.tileCoverageRects) return;

      const tiles = [];
      for (let ct = 0; ct < layer.tileCoverageRects.length; ++ct) {
        const tile = layer.tileCoverageRects[ct].tile;
        if (tile !== undefined) tiles.push(tile);
      }

      const lthi = this.layerTreeImpl_.layerTreeHostImpl;
      const minMax =
          this.getMinMaxForHeatmap_(lthi.activeTiles, heatmapType);
      const heatmapResult =
          this.computeHeatmapColors_(tiles, minMax, heatmapType);
      let heatIndex = 0;

      for (let ct = 0; ct < layer.tileCoverageRects.length; ++ct) {
        let rect = layer.tileCoverageRects[ct].geometryRect;
        rect = rect.scale(1.0 / layer.geometryContentsScale);

        const tile = layer.tileCoverageRects[ct].tile;

        const unitRect = rect.asUVRectInside(layer.bounds);
        const quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;
        let type = tr.e.cc.tileTypes.missing;
        if (tile) {
          type = tile.getTypeForLayer(layer);
          quad.backgroundColor = heatmapResult[heatIndex].color;
          ++heatIndex;
        }

        quad.borderColor = tr.e.cc.tileBorder[type].color;
        quad.borderWidth = tr.e.cc.tileBorder[type].width;
        let label;
        if (tile) {
          label = 'coverageRect';
        } else {
          label = 'checkerboard coverageRect';
        }
        quad.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, label, rect, layer.tileCoverageRects[ct]);

        quads.push(quad);
      }
    },

    appendLayoutRectQuads_(quads, layer, layerQuad) {
      if (!layer.layoutRects) {
        return;
      }

      for (let ct = 0; ct < layer.layoutRects.length; ++ct) {
        let rect = layer.layoutRects[ct].geometryRect;
        rect = rect.scale(1.0 / layer.geometryContentsScale);

        const unitRect = rect.asUVRectInside(layer.bounds);
        const quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;

        quad.borderColor = 'rgba(0, 0, 200, 0.7)';
        quad.borderWidth = 2;
        const label = 'Layout rect';
        quad.selectionToSetIfClicked = new cc.LayerRectSelection(
            layer, label, rect);

        quads.push(quad);
      }
    },

    getValueForHeatmap_(tile, heatmapType) {
      if (heatmapType === TILE_HEATMAP_TYPE.SCHEDULED_PRIORITY) {
        return tile.scheduledPriority === 0 ?
            undefined :
            tile.scheduledPriority;
      } else if (heatmapType === TILE_HEATMAP_TYPE.USING_GPU_MEMORY) {
        if (tile.isSolidColor) return 0.5;
        return tile.isUsingGpuMemory ? 0 : 1;
      }
    },

    getMinMaxForHeatmap_(tiles, heatmapType) {
      const range = new tr.b.math.Range();
      if (heatmapType === TILE_HEATMAP_TYPE.USING_GPU_MEMORY) {
        range.addValue(0);
        range.addValue(1);
        return range;
      }

      for (let i = 0; i < tiles.length; ++i) {
        const value = this.getValueForHeatmap_(tiles[i], heatmapType);
        if (value === undefined) continue;
        range.addValue(value);
      }
      if (range.range === 0) {
        range.addValue(1);
      }
      return range;
    },

    computeHeatmapColors_(tiles, minMax, heatmapType) {
      const min = minMax.min;
      const max = minMax.max;

      const color = function(value) {
        let hue = 120 * (1 - (value - min) / (max - min));
        if (hue < 0) hue = 0;
        return 'hsla(' + hue + ', 100%, 50%, 0.5)';
      };

      const values = [];
      for (let i = 0; i < tiles.length; ++i) {
        const tile = tiles[i];
        const value = this.getValueForHeatmap_(tile, heatmapType);
        const res = {
          value,
          color: value !== undefined ? color(value) : undefined
        };
        values.push(res);
      }

      return values;
    },

    appendTilesWithScaleQuads_(
        quads, layer, layerQuad, scale, heatmapType) {
      const lthi = this.layerTreeImpl_.layerTreeHostImpl;

      const tiles = [];
      for (let i = 0; i < lthi.activeTiles.length; ++i) {
        const tile = lthi.activeTiles[i];

        if (Math.abs(tile.contentsScale - scale) > 1e-6) {
          continue;
        }

        // TODO(vmpstr): Make the stiching of tiles and layers a part of
        // tile construction (issue 346)
        if (layer.layerId !== tile.layerId) continue;

        tiles.push(tile);
      }

      const minMax =
          this.getMinMaxForHeatmap_(lthi.activeTiles, heatmapType);
      const heatmapResult =
          this.computeHeatmapColors_(tiles, minMax, heatmapType);

      for (let i = 0; i < tiles.length; ++i) {
        const tile = tiles[i];
        const rect = tile.layerRect;
        if (!tile.layerRect) continue;

        const unitRect = rect.asUVRectInside(layer.bounds);
        const quad = layerQuad.projectUnitRect(unitRect);

        quad.backgroundColor = 'rgba(0, 0, 0, 0)';
        quad.stackingGroupId = layerQuad.stackingGroupId;

        const type = tile.getTypeForLayer(layer);
        quad.borderColor = tr.e.cc.tileBorder[type].color;
        quad.borderWidth = tr.e.cc.tileBorder[type].width;

        quad.backgroundColor = heatmapResult[i].color;
        const data = {
          tileType: type
        };
        if (heatmapType !== TILE_HEATMAP_TYPE.NONE) {
          data[heatmapType] = heatmapResult[i].value;
        }
        quad.selectionToSetIfClicked = new cc.TileSelection(tile, data);
        quads.push(quad);
      }
    },

    appendHighlightQuadsForLayer_(
        quads, layer, layerQuad, highlights) {
      highlights.forEach(function(highlight) {
        const rect = highlight.rect;

        const unitRect = rect.asUVRectInside(layer.bounds);
        const quad = layerQuad.projectUnitRect(unitRect);

        let colorId = ColorScheme.getColorIdForGeneralPurposeString(
            highlight.colorKey);
        const offset = ColorScheme.properties.brightenedOffsets[0];
        colorId = ColorScheme.getVariantColorId(colorId, offset);

        const color = ColorScheme.colors[colorId];

        const quadForDrawing = quad.clone();
        quadForDrawing.backgroundColor = color.withAlpha(0.5).toString();
        quadForDrawing.borderColor = color.withAlpha(1.0).darken().toString();
        quadForDrawing.stackingGroupId = layerQuad.stackingGroupId;
        quads.push(quadForDrawing);
      }, this);
    },

    generateRenderPassQuads() {
      if (!this.layerTreeImpl.layerTreeHostImpl.args.frame) return [];
      const renderPasses = this.renderPasses;
      if (!renderPasses) return [];

      const quads = [];
      for (let i = 0; i < renderPasses.length; ++i) {
        const quadList = renderPasses[i].quadList;
        for (let j = 0; j < quadList.length; ++j) {
          const drawQuad = quadList[j];
          const quad = drawQuad.rectAsTargetSpaceQuad.clone();
          quad.borderColor = 'rgb(170, 204, 238)';
          quad.borderWidth = 2;
          quad.stackingGroupId = i;
          quads.push(quad);
        }
      }
      return quads;
    },

    generateLayerQuads() {
      this.updateContentsPending_ = false;

      // Generate the quads for the view.
      const layers = this.layers;
      const quads = [];
      let nextStackingGroupId = 0;
      const alreadyVisitedLayerIds = {};


      let selectionHighlightsByLayerId;
      if (this.selection) {
        selectionHighlightsByLayerId = this.selection.highlightsByLayerId;
      } else {
        selectionHighlightsByLayerId = {};
      }

      const extraHighlightsByLayerId = this.extraHighlightsByLayerId || {};

      for (let i = 1; i <= layers.length; i++) {
        // Generate quads back-to-front.
        const layer = layers[layers.length - i];
        alreadyVisitedLayerIds[layer.layerId] = true;
        if (layer.objectInstance.name === 'cc::NinePatchLayerImpl') {
          continue;
        }

        const layerQuad = layer.layerQuad.clone();
        if (layer.usingGpuRasterization) {
          const pixelRatio = window.devicePixelRatio || 1;
          layerQuad.borderWidth = 2.0 * pixelRatio;
          layerQuad.borderColor = 'rgba(154,205,50,0.75)';
        } else {
          layerQuad.borderColor = 'rgba(0,0,0,0.75)';
        }
        layerQuad.stackingGroupId = nextStackingGroupId++;
        layerQuad.selectionToSetIfClicked = new cc.LayerSelection(layer);
        layerQuad.layer = layer;
        if (this.showOtherLayers && this.selectedLayer === layer) {
          layerQuad.upperBorderColor = 'rgb(156,189,45)';
        }

        if (this.showAnimationBounds) {
          this.appendAnimationQuads_(quads, layer, layerQuad);
        }

        this.appendImageQuads_(quads, layer, layerQuad);
        quads.push(layerQuad);


        if (this.showInvalidations) {
          this.appendInvalidationQuads_(quads, layer, layerQuad);
        }
        if (this.showUnrecordedRegion) {
          this.appendUnrecordedRegionQuads_(quads, layer, layerQuad);
        }
        if (this.showBottlenecks) {
          this.appendBottleneckQuads_(quads, layer, layerQuad,
              layerQuad.stackingGroupId);
        }
        if (this.showLayoutRects) {
          this.appendLayoutRectQuads_(quads, layer, layerQuad);
        }

        if (this.howToShowTiles === 'coverage') {
          this.appendTileCoverageRectQuads_(
              quads, layer, layerQuad, this.tileHeatmapType);
        } else if (this.howToShowTiles !== 'none') {
          this.appendTilesWithScaleQuads_(
              quads, layer, layerQuad,
              this.howToShowTiles, this.tileHeatmapType);
        }

        let highlights;
        highlights = extraHighlightsByLayerId[layer.layerId];
        if (highlights) {
          this.appendHighlightQuadsForLayer_(
              quads, layer, layerQuad, highlights);
        }

        highlights = selectionHighlightsByLayerId[layer.layerId];
        if (highlights) {
          this.appendHighlightQuadsForLayer_(
              quads, layer, layerQuad, highlights);
        }
      }

      this.layerTreeImpl.iterLayers(function(layer, depth, isMask, isReplica) {
        if (!this.showOtherLayers && this.selectedLayer !== layer) return;
        if (alreadyVisitedLayerIds[layer.layerId]) return;

        const layerQuad = layer.layerQuad;
        const stackingGroupId = nextStackingGroupId++;
        if (this.showBottlenecks) {
          this.appendBottleneckQuads_(quads, layer, layerQuad, stackingGroupId);
        }
      }, this);

      const tracedInputLatencies = this.layerTreeImpl.tracedInputLatencies;
      if (this.showInputEvents && tracedInputLatencies) {
        for (let i = 0; i < tracedInputLatencies.length; i++) {
          const coordinatesArray =
            tracedInputLatencies[i].args.data.coordinates;
          for (let j = 0; j < coordinatesArray.length; j++) {
            const inputQuad = tr.b.math.Quad.fromXYWH(
                coordinatesArray[j].x - 25,
                coordinatesArray[j].y - 25,
                50,
                50);
            inputQuad.borderColor = 'rgba(0, 0, 0, 0)';
            inputQuad.imageData = this.inputEventImageData_;
            quads.push(inputQuad);
          }
        }
      }

      return quads;
    },

    updateInfoBar_(infoBarMessages) {
      if (infoBarMessages.length) {
        this.infoBar_.removeAllButtons();
        this.infoBar_.message = 'Some problems were encountered...';
        this.infoBar_.addButton('More info...', function(e) {
          const overlay = new tr.ui.b.Overlay();
          Polymer.dom(overlay).textContent = '';
          infoBarMessages.forEach(function(message) {
            const title = document.createElement('h3');
            Polymer.dom(title).textContent = message.header;

            const details = document.createElement('div');
            Polymer.dom(details).textContent = message.details;

            Polymer.dom(overlay).appendChild(title);
            Polymer.dom(overlay).appendChild(details);
          });
          overlay.visible = true;

          e.stopPropagation();
          return false;
        });
        this.infoBar_.visible = true;
      } else {
        this.infoBar_.removeAllButtons();
        this.infoBar_.message = '';
        this.infoBar_.visible = false;
      }
    },

    getWhatRasterized_() {
      const lthi = this.layerTreeImpl_.layerTreeHostImpl;
      const renderProcess = lthi.objectInstance.parent;
      const tasks = [];
      for (const event of renderProcess.getDescendantEvents()) {
        if (!(event instanceof tr.model.Slice)) continue;

        const tile = tr.e.cc.getTileFromRasterTaskSlice(event);
        if (tile === undefined) continue;

        if (tile.containingSnapshot === lthi) {
          tasks.push(event);
        }
      }
      return tasks;
    },

    updateWhatRasterizedLinkState_() {
      const tasks = this.getWhatRasterized_();
      if (tasks.length) {
        Polymer.dom(this.whatRasterizedLink_).textContent =
            tasks.length + ' raster tasks';
        this.whatRasterizedLink_.style.display = '';
      } else {
        Polymer.dom(this.whatRasterizedLink_).textContent = '';
        this.whatRasterizedLink_.style.display = 'none';
      }
    },

    onWhatRasterizedLinkClicked_() {
      const tasks = this.getWhatRasterized_();
      const event = new tr.model.RequestSelectionChangeEvent();
      event.selection = new tr.model.EventSet(tasks);
      this.dispatchEvent(event);
    }
  };

  return {
    LayerTreeQuadStackView,
  };
});


'use strict';

/**
 * @fileoverview LayerView coordinates graphical and analysis views of layers.
 */

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const constants = tr.e.cc.constants;

  /**
   * @constructor
   */
  const LayerView = tr.ui.b.define('tr-ui-e-chrome-cc-layer-view');

  LayerView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.layerTreeQuadStackView_ =
          new tr.ui.e.chrome.cc.LayerTreeQuadStackView();
      this.dragBar_ = document.createElement('tr-ui-b-drag-handle');
      this.analysisEl_ =
          document.createElement('tr-ui-e-chrome-cc-layer-view-analysis');
      this.analysisEl_.addEventListener('requestSelectionChange',
          this.onRequestSelectionChangeFromAnalysisEl_.bind(this));

      this.dragBar_.target = this.analysisEl_;

      Polymer.dom(this).appendChild(this.layerTreeQuadStackView_);
      Polymer.dom(this).appendChild(this.dragBar_);
      Polymer.dom(this).appendChild(this.analysisEl_);

      this.layerTreeQuadStackView_.addEventListener('selection-change',
          function() {
            this.layerTreeQuadStackViewSelectionChanged_();
          }.bind(this));
      this.layerTreeQuadStackViewSelectionChanged_();
    },

    get layerTreeImpl() {
      return this.layerTreeQuadStackView_.layerTreeImpl;
    },

    set layerTreeImpl(newValue) {
      return this.layerTreeQuadStackView_.layerTreeImpl = newValue;
    },

    set isRenderPassQuads(newValue) {
      return this.layerTreeQuadStackView_.isRenderPassQuads = newValue;
    },

    get selection() {
      return this.layerTreeQuadStackView_.selection;
    },

    set selection(newValue) {
      this.layerTreeQuadStackView_.selection = newValue;
    },

    regenerateContent() {
      this.layerTreeQuadStackView_.regenerateContent();
    },

    layerTreeQuadStackViewSelectionChanged_() {
      const selection = this.layerTreeQuadStackView_.selection;
      if (selection) {
        this.dragBar_.style.display = '';
        this.analysisEl_.style.display = '';
        Polymer.dom(this.analysisEl_).textContent = '';

        const layer = selection.layer;
        if (layer && layer.args && layer.args.pictures) {
          Polymer.dom(this.analysisEl_).appendChild(
              this.createPictureBtn_(layer.args.pictures));
        }

        const analysis = selection.createAnalysis();
        Polymer.dom(this.analysisEl_).appendChild(analysis);
      } else {
        this.dragBar_.style.display = 'none';
        this.analysisEl_.style.display = 'none';
        const analysis = Polymer.dom(this.analysisEl_).firstChild;
        if (analysis) {
          Polymer.dom(this.analysisEl_).removeChild(analysis);
        }
        this.layerTreeQuadStackView_.style.height =
            window.getComputedStyle(this).height;
      }
      tr.b.dispatchSimpleEvent(this, 'selection-change');
    },

    createPictureBtn_(pictures) {
      if (!(pictures instanceof Array)) {
        pictures = [pictures];
      }

      const link = document.createElement('tr-ui-a-analysis-link');
      link.selection = function() {
        const layeredPicture = new tr.e.cc.LayeredPicture(pictures);
        const snapshot = new tr.e.cc.PictureSnapshot(layeredPicture);
        snapshot.picture = layeredPicture;

        const selection = new tr.model.EventSet();
        selection.push(snapshot);
        return selection;
      };
      Polymer.dom(link).textContent = 'View in Picture Debugger';
      return link;
    },

    onRequestSelectionChangeFromAnalysisEl_(e) {
      if (!(e.selection instanceof tr.ui.e.chrome.cc.Selection)) {
        return;
      }

      e.stopPropagation();
      this.selection = e.selection;
    },

    get extraHighlightsByLayerId() {
      return this.layerTreeQuadStackView_.extraHighlightsByLayerId;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.layerTreeQuadStackView_.extraHighlightsByLayerId =
          extraHighlightsByLayerId;
    }
  };

  return {
    LayerView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a LayerTreeHostImpl snapshot in a human readable form.
   * @constructor
   */
  const LayerTreeHostImplSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-layer-tree-host-impl-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  LayerTreeHostImplSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add('tr-ui-e-chrome-cc-lthi-s-view');

      this.selection_ = undefined;

      this.layerPicker_ = new tr.ui.e.chrome.cc.LayerPicker();
      this.layerPicker_.addEventListener(
          'selection-change',
          this.onLayerPickerSelectionChanged_.bind(this));

      this.layerView_ = new tr.ui.e.chrome.cc.LayerView();
      this.layerView_.addEventListener(
          'selection-change',
          this.onLayerViewSelectionChanged_.bind(this));
      this.dragHandle_ = document.createElement('tr-ui-b-drag-handle');
      this.dragHandle_.horizontal = false;
      this.dragHandle_.target = this.layerView_;

      Polymer.dom(this).appendChild(this.layerPicker_);
      Polymer.dom(this).appendChild(this.dragHandle_);
      Polymer.dom(this).appendChild(this.layerView_);

      // Make sure we have the current values from layerView_ and layerPicker_,
      // since those might have been created before we added the listener.
      this.onLayerViewSelectionChanged_();
      this.onLayerPickerSelectionChanged_();
    },

    get objectSnapshot() {
      return this.objectSnapshot_;
    },

    set objectSnapshot(objectSnapshot) {
      this.objectSnapshot_ = objectSnapshot;

      const lthi = this.objectSnapshot;
      let layerTreeImpl;
      if (lthi) {
        layerTreeImpl = lthi.getTree(this.layerPicker_.whichTree);
      }

      this.layerPicker_.lthiSnapshot = lthi;
      this.layerView_.layerTreeImpl = layerTreeImpl;
      this.layerView_.regenerateContent();

      if (!this.selection_) return;

      this.selection = this.selection_.findEquivalent(lthi);
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (this.selection_ === selection) return;

      this.selection_ = selection;
      this.layerPicker_.selection = selection;
      this.layerView_.selection = selection;
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    onLayerPickerSelectionChanged_() {
      this.selection_ = this.layerPicker_.selection;
      this.layerView_.selection = this.selection;
      this.layerView_.layerTreeImpl = this.layerPicker_.layerTreeImpl;
      this.layerView_.isRenderPassQuads = this.layerPicker_.isRenderPassQuads;
      this.layerView_.regenerateContent();
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    onLayerViewSelectionChanged_() {
      this.selection_ = this.layerView_.selection;
      this.layerPicker_.selection = this.selection;
      tr.b.dispatchSimpleEvent(this, 'cc-selection-change');
    },

    get extraHighlightsByLayerId() {
      return this.layerView_.extraHighlightsByLayerId;
    },

    set extraHighlightsByLayerId(extraHighlightsByLayerId) {
      this.layerView_.extraHighlightsByLayerId = extraHighlightsByLayerId;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      LayerTreeHostImplSnapshotView, {typeName: 'cc::LayerTreeHostImpl'});

  return {
    LayerTreeHostImplSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const OPS_TIMING_ITERATIONS = 3;
  const CHART_PADDING_LEFT = 65;
  const CHART_PADDING_RIGHT = 40;
  const AXIS_PADDING_LEFT = 60;
  const AXIS_PADDING_RIGHT = 35;
  const AXIS_PADDING_TOP = 25;
  const AXIS_PADDING_BOTTOM = 45;
  const AXIS_LABEL_PADDING = 5;
  const AXIS_TICK_SIZE = 10;
  const LABEL_PADDING = 5;
  const LABEL_INTERLEAVE_OFFSET = 15;
  const BAR_PADDING = 5;
  const VERTICAL_TICKS = 5;
  const HUE_CHAR_CODE_ADJUSTMENT = 5.7;

  /**
   * Provides a chart showing the cumulative time spent in Skia operations
   * during picture rasterization.
   *
   * @constructor
   */
  const PictureOpsChartSummaryView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-picture-ops-chart-summary-view');

  PictureOpsChartSummaryView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.picture_ = undefined;
      this.pictureDataProcessed_ = false;

      this.chartScale_ = window.devicePixelRatio;

      this.chart_ = document.createElement('canvas');
      this.chartCtx_ = this.chart_.getContext('2d');
      Polymer.dom(this).appendChild(this.chart_);

      this.opsTimingData_ = [];

      this.chartWidth_ = 0;
      this.chartHeight_ = 0;
      this.requiresRedraw_ = true;

      this.currentBarMouseOverTarget_ = null;

      this.chart_.addEventListener('mousemove', this.onMouseMove_.bind(this));
    },

    get requiresRedraw() {
      return this.requiresRedraw_;
    },

    set requiresRedraw(requiresRedraw) {
      this.requiresRedraw_ = requiresRedraw;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.pictureDataProcessed_ = false;

      if (Polymer.dom(this).classList.contains('hidden')) return;

      this.processPictureData_();
      this.requiresRedraw = true;
      this.updateChartContents();
    },

    hide() {
      Polymer.dom(this).classList.add('hidden');
    },

    show() {
      Polymer.dom(this).classList.remove('hidden');

      if (this.pictureDataProcessed_) return;

      this.processPictureData_();
      this.requiresRedraw = true;
      this.updateChartContents();
    },

    onMouseMove_(e) {
      const lastBarMouseOverTarget = this.currentBarMouseOverTarget_;
      this.currentBarMouseOverTarget_ = null;

      const x = e.offsetX;
      const y = e.offsetY;

      const chartLeft = CHART_PADDING_LEFT;
      const chartRight = this.chartWidth_ - CHART_PADDING_RIGHT;
      const chartTop = AXIS_PADDING_TOP;
      const chartBottom = this.chartHeight_ - AXIS_PADDING_BOTTOM;
      const chartInnerWidth = chartRight - chartLeft;

      if (x > chartLeft && x < chartRight && y > chartTop && y < chartBottom) {
        this.currentBarMouseOverTarget_ = Math.floor(
            (x - chartLeft) / chartInnerWidth * this.opsTimingData_.length);

        this.currentBarMouseOverTarget_ = tr.b.math.clamp(
            this.currentBarMouseOverTarget_, 0, this.opsTimingData_.length - 1);
      }

      if (this.currentBarMouseOverTarget_ === lastBarMouseOverTarget) return;

      this.drawChartContents_();
    },

    updateChartContents() {
      if (this.requiresRedraw) {
        this.updateChartDimensions_();
      }

      this.drawChartContents_();
    },

    updateChartDimensions_() {
      this.chartWidth_ = this.offsetWidth;
      this.chartHeight_ = this.offsetHeight;

      // Scale up the canvas according to the devicePixelRatio, then reduce it
      // down again via CSS. Finally we apply a scale to the canvas so that
      // things are drawn at the correct size.
      this.chart_.width = this.chartWidth_ * this.chartScale_;
      this.chart_.height = this.chartHeight_ * this.chartScale_;

      this.chart_.style.width = this.chartWidth_ + 'px';
      this.chart_.style.height = this.chartHeight_ + 'px';

      this.chartCtx_.scale(this.chartScale_, this.chartScale_);
    },

    processPictureData_() {
      this.resetOpsTimingData_();
      this.pictureDataProcessed_ = true;

      if (!this.picture_) return;

      let ops = this.picture_.getOps();
      if (!ops) return;

      ops = this.picture_.tagOpsWithTimings(ops);

      // Check that there are valid times.
      if (ops[0].cmd_time === undefined) return;

      this.collapseOpsToTimingBuckets_(ops);
    },

    drawChartContents_() {
      this.clearChartContents_();

      if (this.opsTimingData_.length === 0) {
        this.showNoTimingDataMessage_();
        return;
      }

      this.drawChartAxes_();
      this.drawBars_();
      this.drawLineAtBottomOfChart_();

      if (this.currentBarMouseOverTarget_ === null) return;

      this.drawTooltip_();
    },

    drawLineAtBottomOfChart_() {
      this.chartCtx_.strokeStyle = '#AAA';
      this.chartCtx_.moveTo(0, this.chartHeight_ - 0.5);
      this.chartCtx_.lineTo(this.chartWidth_, this.chartHeight_ - 0.5);
      this.chartCtx_.stroke();
    },

    drawTooltip_() {
      const tooltipData = this.opsTimingData_[this.currentBarMouseOverTarget_];
      const tooltipTitle = tooltipData.cmd_string;
      const tooltipTime = tooltipData.cmd_time.toFixed(4);

      const tooltipWidth = 110;
      const tooltipHeight = 40;
      const chartInnerWidth = this.chartWidth_ - CHART_PADDING_RIGHT -
          CHART_PADDING_LEFT;
      const barWidth = chartInnerWidth / this.opsTimingData_.length;
      const tooltipOffset = Math.round((tooltipWidth - barWidth) * 0.5);

      const left = CHART_PADDING_LEFT + this.currentBarMouseOverTarget_ *
          barWidth - tooltipOffset;
      const top = Math.round((this.chartHeight_ - tooltipHeight) * 0.5);

      this.chartCtx_.save();

      this.chartCtx_.shadowOffsetX = 0;
      this.chartCtx_.shadowOffsetY = 5;
      this.chartCtx_.shadowBlur = 4;
      this.chartCtx_.shadowColor = 'rgba(0,0,0,0.4)';

      this.chartCtx_.strokeStyle = '#888';
      this.chartCtx_.fillStyle = '#EEE';
      this.chartCtx_.fillRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.shadowColor = 'transparent';
      this.chartCtx_.translate(0.5, 0.5);
      this.chartCtx_.strokeRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.restore();

      this.chartCtx_.fillStyle = '#222';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '800 12px Arial';
      this.chartCtx_.fillText(tooltipTitle, left + 8, top + 8);

      this.chartCtx_.fillStyle = '#555';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '400 italic 10px Arial';
      this.chartCtx_.fillText('Total: ' + tooltipTime + 'ms',
          left + 8, top + 22);
    },

    drawBars_() {
      const len = this.opsTimingData_.length;
      const max = this.opsTimingData_[0].cmd_time;
      const min = this.opsTimingData_[len - 1].cmd_time;

      const width = this.chartWidth_ - CHART_PADDING_LEFT - CHART_PADDING_RIGHT;
      const height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;
      const barWidth = Math.floor(width / len);

      let opData;
      let opTiming;
      let opHeight;
      let opLabel;
      let barLeft;

      for (let b = 0; b < len; b++) {
        opData = this.opsTimingData_[b];
        opTiming = opData.cmd_time / max;

        opHeight = Math.round(Math.max(1, opTiming * height));
        opLabel = opData.cmd_string;
        barLeft = CHART_PADDING_LEFT + b * barWidth;

        this.chartCtx_.fillStyle = this.getOpColor_(opLabel);

        this.chartCtx_.fillRect(barLeft + BAR_PADDING, AXIS_PADDING_TOP +
            height - opHeight, barWidth - 2 * BAR_PADDING, opHeight);
      }
    },

    getOpColor_(opName) {
      const characters = opName.split('');
      const hue = characters.reduce(this.reduceNameToHue, 0) % 360;

      return 'hsl(' + hue + ', 30%, 50%)';
    },

    reduceNameToHue(previousValue, currentValue, index, array) {
      // Get the char code and apply a magic adjustment value so we get
      // pretty colors from around the rainbow.
      return Math.round(previousValue + currentValue.charCodeAt(0) *
          HUE_CHAR_CODE_ADJUSTMENT);
    },

    drawChartAxes_() {
      const len = this.opsTimingData_.length;
      const max = this.opsTimingData_[0].cmd_time;
      const min = this.opsTimingData_[len - 1].cmd_time;

      const width = this.chartWidth_ - AXIS_PADDING_LEFT - AXIS_PADDING_RIGHT;
      const height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;

      const totalBarWidth = this.chartWidth_ - CHART_PADDING_LEFT -
          CHART_PADDING_RIGHT;
      const barWidth = Math.floor(totalBarWidth / len);
      const tickYInterval = height / (VERTICAL_TICKS - 1);
      let tickYPosition = 0;
      const tickValInterval = (max - min) / (VERTICAL_TICKS - 1);
      let tickVal = 0;

      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.strokeStyle = '#777';
      this.chartCtx_.save();

      // Translate half a pixel to avoid blurry lines.
      this.chartCtx_.translate(0.5, 0.5);

      // Sides.

      this.chartCtx_.save();

      this.chartCtx_.translate(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);
      this.chartCtx_.moveTo(0, 0);
      this.chartCtx_.lineTo(0, height);
      this.chartCtx_.lineTo(width, height);

      // Y-axis ticks.
      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'right';
      this.chartCtx_.textBaseline = 'middle';

      for (let t = 0; t < VERTICAL_TICKS; t++) {
        tickYPosition = Math.round(t * tickYInterval);
        tickVal = (max - t * tickValInterval).toFixed(4);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(-AXIS_TICK_SIZE, tickYPosition);
        this.chartCtx_.fillText(tickVal,
            -AXIS_TICK_SIZE - AXIS_LABEL_PADDING, tickYPosition);
      }

      this.chartCtx_.stroke();

      this.chartCtx_.restore();


      // Labels.

      this.chartCtx_.save();

      this.chartCtx_.translate(CHART_PADDING_LEFT + Math.round(barWidth * 0.5),
          AXIS_PADDING_TOP + height + LABEL_PADDING);

      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'top';

      let labelTickLeft;
      let labelTickBottom;
      for (let l = 0; l < len; l++) {
        labelTickLeft = Math.round(l * barWidth);
        labelTickBottom = l % 2 * LABEL_INTERLEAVE_OFFSET;

        this.chartCtx_.save();
        this.chartCtx_.moveTo(labelTickLeft, -LABEL_PADDING);
        this.chartCtx_.lineTo(labelTickLeft, labelTickBottom);
        this.chartCtx_.stroke();
        this.chartCtx_.restore();

        this.chartCtx_.fillText(this.opsTimingData_[l].cmd_string,
            labelTickLeft, labelTickBottom);
      }

      this.chartCtx_.restore();

      this.chartCtx_.restore();
    },

    clearChartContents_() {
      this.chartCtx_.clearRect(0, 0, this.chartWidth_, this.chartHeight_);
    },

    showNoTimingDataMessage_() {
      this.chartCtx_.font = '800 italic 14px Arial';
      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'middle';
      this.chartCtx_.fillText('No timing data available.',
          this.chartWidth_ * 0.5, this.chartHeight_ * 0.5);
    },

    collapseOpsToTimingBuckets_(ops) {
      const opsTimingDataIndexHash_ = {};
      const timingData = this.opsTimingData_;
      let op;
      let opIndex;

      for (let i = 0; i < ops.length; i++) {
        op = ops[i];

        if (op.cmd_time === undefined) continue;

        // Try to locate the entry for the current operation
        // based on its name. If that fails, then create one for it.
        opIndex = opsTimingDataIndexHash_[op.cmd_string] || null;

        if (opIndex === null) {
          timingData.push({
            cmd_time: 0,
            cmd_string: op.cmd_string
          });

          opIndex = timingData.length - 1;
          opsTimingDataIndexHash_[op.cmd_string] = opIndex;
        }

        timingData[opIndex].cmd_time += op.cmd_time;
      }

      timingData.sort(this.sortTimingBucketsByOpTimeDescending_);

      this.collapseTimingBucketsToOther_(4);
    },

    collapseTimingBucketsToOther_(count) {
      const timingData = this.opsTimingData_;
      const otherSource = timingData.splice(count, timingData.length - count);
      let otherDestination = null;

      if (!otherSource.length) return;

      timingData.push({
        cmd_time: 0,
        cmd_string: 'Other'
      });

      otherDestination = timingData[timingData.length - 1];
      for (let i = 0; i < otherSource.length; i++) {
        otherDestination.cmd_time += otherSource[i].cmd_time;
      }
    },

    sortTimingBucketsByOpTimeDescending_(a, b) {
      return b.cmd_time - a.cmd_time;
    },

    resetOpsTimingData_() {
      this.opsTimingData_.length = 0;
    }
  };

  return {
    PictureOpsChartSummaryView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const BAR_PADDING = 1;
  const BAR_WIDTH = 5;
  const CHART_PADDING_LEFT = 65;
  const CHART_PADDING_RIGHT = 30;
  const CHART_PADDING_BOTTOM = 35;
  const CHART_PADDING_TOP = 20;
  const AXIS_PADDING_LEFT = 55;
  const AXIS_PADDING_RIGHT = 30;
  const AXIS_PADDING_BOTTOM = 35;
  const AXIS_PADDING_TOP = 20;
  const AXIS_TICK_SIZE = 5;
  const AXIS_LABEL_PADDING = 5;
  const VERTICAL_TICKS = 5;
  const HUE_CHAR_CODE_ADJUSTMENT = 5.7;

  /**
   * Provides a chart showing the cumulative time spent in Skia operations
   * during picture rasterization.
   *
   * @constructor
   */
  const PictureOpsChartView =
      tr.ui.b.define('tr-ui-e-chrome-cc-picture-ops-chart-view');

  PictureOpsChartView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      this.picture_ = undefined;
      this.pictureOps_ = undefined;
      this.opCosts_ = undefined;

      this.chartScale_ = window.devicePixelRatio;

      this.chart_ = document.createElement('canvas');
      this.chartCtx_ = this.chart_.getContext('2d');
      Polymer.dom(this).appendChild(this.chart_);

      this.selectedOpIndex_ = undefined;
      this.chartWidth_ = 0;
      this.chartHeight_ = 0;
      this.dimensionsHaveChanged_ = true;

      this.currentBarMouseOverTarget_ = undefined;

      this.ninetyFifthPercentileCost_ = 0;
      this.totalOpCost_ = 0;

      this.chart_.addEventListener('click', this.onClick_.bind(this));
      this.chart_.addEventListener('mousemove', this.onMouseMove_.bind(this));

      this.usePercentileScale_ = false;
      this.usePercentileScaleCheckbox_ = tr.ui.b.createCheckBox(
          this, 'usePercentileScale',
          'PictureOpsChartView.usePercentileScale', false,
          'Limit to 95%-ile');
      Polymer.dom(this.usePercentileScaleCheckbox_).classList.add(
          'use-percentile-scale');
      Polymer.dom(this).appendChild(this.usePercentileScaleCheckbox_);
    },

    get dimensionsHaveChanged() {
      return this.dimensionsHaveChanged_;
    },

    set dimensionsHaveChanged(dimensionsHaveChanged) {
      this.dimensionsHaveChanged_ = dimensionsHaveChanged;
    },

    get usePercentileScale() {
      return this.usePercentileScale_;
    },

    set usePercentileScale(usePercentileScale) {
      this.usePercentileScale_ = usePercentileScale;
      this.drawChartContents_();
    },

    get numOps() {
      return this.opCosts_.length;
    },

    get selectedOpIndex() {
      return this.selectedOpIndex_;
    },

    set selectedOpIndex(selectedOpIndex) {
      if (selectedOpIndex < 0) throw new Error('Invalid index');
      if (selectedOpIndex >= this.numOps) throw new Error('Invalid index');

      this.selectedOpIndex_ = selectedOpIndex;
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.picture_ = picture;
      this.pictureOps_ = picture.tagOpsWithTimings(picture.getOps());
      this.currentBarMouseOverTarget_ = undefined;
      this.processPictureData_();
      this.dimensionsHaveChanged = true;
    },

    processPictureData_() {
      if (this.pictureOps_ === undefined) return;

      let totalOpCost = 0;

      // Take a copy of the picture ops data for sorting.
      this.opCosts_ = this.pictureOps_.map(function(op) {
        totalOpCost += op.cmd_time;
        return op.cmd_time;
      });
      this.opCosts_.sort();

      const ninetyFifthPercentileCostIndex = Math.floor(
          this.opCosts_.length * 0.95);
      this.ninetyFifthPercentileCost_ =
          this.opCosts_[ninetyFifthPercentileCostIndex];
      this.maxCost_ = this.opCosts_[this.opCosts_.length - 1];

      this.totalOpCost_ = totalOpCost;
    },

    extractBarIndex_(e) {
      let index = undefined;

      if (this.pictureOps_ === undefined ||
          this.pictureOps_.length === 0) {
        return index;
      }

      const x = e.offsetX;
      const y = e.offsetY;

      const totalBarWidth = (BAR_WIDTH + BAR_PADDING) * this.pictureOps_.length;

      const chartLeft = CHART_PADDING_LEFT;
      const chartTop = 0;
      const chartBottom = this.chartHeight_ - CHART_PADDING_BOTTOM;
      const chartRight = chartLeft + totalBarWidth;

      if (x < chartLeft || x > chartRight || y < chartTop || y > chartBottom) {
        return index;
      }

      index = Math.floor((x - chartLeft) / totalBarWidth *
          this.pictureOps_.length);

      index = tr.b.math.clamp(index, 0, this.pictureOps_.length - 1);

      return index;
    },

    onClick_(e) {
      const barClicked = this.extractBarIndex_(e);

      if (barClicked === undefined) return;

      // If we click on the already selected item we should deselect.
      if (barClicked === this.selectedOpIndex) {
        this.selectedOpIndex = undefined;
      } else {
        this.selectedOpIndex = barClicked;
      }

      e.preventDefault();

      tr.b.dispatchSimpleEvent(this, 'selection-changed', false);
    },

    onMouseMove_(e) {
      const lastBarMouseOverTarget = this.currentBarMouseOverTarget_;
      this.currentBarMouseOverTarget_ = this.extractBarIndex_(e);

      if (this.currentBarMouseOverTarget_ === lastBarMouseOverTarget) {
        return;
      }

      this.drawChartContents_();
    },

    scrollSelectedItemIntoViewIfNecessary() {
      if (this.selectedOpIndex === undefined) {
        return;
      }

      const width = this.offsetWidth;
      const left = this.scrollLeft;
      const right = left + width;
      const targetLeft = CHART_PADDING_LEFT +
          (BAR_WIDTH + BAR_PADDING) * this.selectedOpIndex;

      if (targetLeft > left && targetLeft < right) {
        return;
      }

      this.scrollLeft = (targetLeft - width * 0.5);
    },

    updateChartContents() {
      if (this.dimensionsHaveChanged) {
        this.updateChartDimensions_();
      }

      this.drawChartContents_();
    },

    updateChartDimensions_() {
      if (!this.pictureOps_) return;

      let width = CHART_PADDING_LEFT + CHART_PADDING_RIGHT +
          ((BAR_WIDTH + BAR_PADDING) * this.pictureOps_.length);

      if (width < this.offsetWidth) {
        width = this.offsetWidth;
      }

      // Allow the element to be its natural size as set by flexbox, then lock
      // the width in before we set the width of the canvas.
      this.chartWidth_ = width;
      this.chartHeight_ = this.getBoundingClientRect().height;

      // Scale up the canvas according to the devicePixelRatio, then reduce it
      // down again via CSS. Finally we apply a scale to the canvas so that
      // things are drawn at the correct size.
      this.chart_.width = this.chartWidth_ * this.chartScale_;
      this.chart_.height = this.chartHeight_ * this.chartScale_;

      this.chart_.style.width = this.chartWidth_ + 'px';
      this.chart_.style.height = this.chartHeight_ + 'px';

      this.chartCtx_.scale(this.chartScale_, this.chartScale_);

      this.dimensionsHaveChanged = false;
    },

    drawChartContents_() {
      this.clearChartContents_();

      if (this.pictureOps_ === undefined ||
          this.pictureOps_.length === 0 ||
          this.pictureOps_[0].cmd_time === undefined) {
        this.showNoTimingDataMessage_();
        return;
      }

      this.drawSelection_();
      this.drawBars_();
      this.drawChartAxes_();
      this.drawLinesAtTickMarks_();
      this.drawLineAtBottomOfChart_();

      if (this.currentBarMouseOverTarget_ === undefined) {
        return;
      }

      this.drawTooltip_();
    },

    drawSelection_() {
      if (this.selectedOpIndex === undefined) {
        return;
      }

      const width = (BAR_WIDTH + BAR_PADDING) * this.selectedOpIndex;
      this.chartCtx_.fillStyle = 'rgb(223, 235, 230)';
      this.chartCtx_.fillRect(CHART_PADDING_LEFT, CHART_PADDING_TOP,
          width, this.chartHeight_ - CHART_PADDING_TOP - CHART_PADDING_BOTTOM);
    },

    drawChartAxes_() {
      const min = this.opCosts_[0];
      const max = this.opCosts_[this.opCosts_.length - 1];
      const height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;

      const tickYInterval = height / (VERTICAL_TICKS - 1);
      let tickYPosition = 0;
      const tickValInterval = (max - min) / (VERTICAL_TICKS - 1);
      let tickVal = 0;

      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.strokeStyle = '#777';
      this.chartCtx_.save();

      // Translate half a pixel to avoid blurry lines.
      this.chartCtx_.translate(0.5, 0.5);

      // Sides.
      this.chartCtx_.beginPath();
      this.chartCtx_.moveTo(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);
      this.chartCtx_.lineTo(AXIS_PADDING_LEFT, this.chartHeight_ -
          AXIS_PADDING_BOTTOM);
      this.chartCtx_.lineTo(this.chartWidth_ - AXIS_PADDING_RIGHT,
          this.chartHeight_ - AXIS_PADDING_BOTTOM);
      this.chartCtx_.stroke();
      this.chartCtx_.closePath();

      // Y-axis ticks.
      this.chartCtx_.translate(AXIS_PADDING_LEFT, AXIS_PADDING_TOP);

      this.chartCtx_.font = '10px Arial';
      this.chartCtx_.textAlign = 'right';
      this.chartCtx_.textBaseline = 'middle';

      this.chartCtx_.beginPath();
      for (let t = 0; t < VERTICAL_TICKS; t++) {
        tickYPosition = Math.round(t * tickYInterval);
        tickVal = (max - t * tickValInterval).toFixed(4);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(-AXIS_TICK_SIZE, tickYPosition);
        this.chartCtx_.fillText(tickVal,
            -AXIS_TICK_SIZE - AXIS_LABEL_PADDING, tickYPosition);
      }

      this.chartCtx_.stroke();
      this.chartCtx_.closePath();

      this.chartCtx_.restore();
    },

    drawLinesAtTickMarks_() {
      const height = this.chartHeight_ - AXIS_PADDING_TOP - AXIS_PADDING_BOTTOM;
      const width = this.chartWidth_ - AXIS_PADDING_LEFT - AXIS_PADDING_RIGHT;
      const tickYInterval = height / (VERTICAL_TICKS - 1);
      let tickYPosition = 0;

      this.chartCtx_.save();

      this.chartCtx_.translate(AXIS_PADDING_LEFT + 0.5, AXIS_PADDING_TOP + 0.5);
      this.chartCtx_.beginPath();
      this.chartCtx_.strokeStyle = 'rgba(0,0,0,0.05)';

      for (let t = 0; t < VERTICAL_TICKS; t++) {
        tickYPosition = Math.round(t * tickYInterval);

        this.chartCtx_.moveTo(0, tickYPosition);
        this.chartCtx_.lineTo(width, tickYPosition);
        this.chartCtx_.stroke();
      }

      this.chartCtx_.restore();
      this.chartCtx_.closePath();
    },

    drawLineAtBottomOfChart_() {
      this.chartCtx_.strokeStyle = '#AAA';
      this.chartCtx_.beginPath();
      this.chartCtx_.moveTo(0, this.chartHeight_ - 0.5);
      this.chartCtx_.lineTo(this.chartWidth_, this.chartHeight_ - 0.5);
      this.chartCtx_.stroke();
      this.chartCtx_.closePath();
    },

    drawTooltip_() {
      const tooltipData = this.pictureOps_[this.currentBarMouseOverTarget_];
      const tooltipTitle = tooltipData.cmd_string;
      const tooltipTime = tooltipData.cmd_time.toFixed(4);
      const toolTipTimePercentage =
          ((tooltipData.cmd_time / this.totalOpCost_) * 100).toFixed(2);

      const tooltipWidth = 120;
      const tooltipHeight = 40;
      const chartInnerWidth = this.chartWidth_ - CHART_PADDING_RIGHT -
          CHART_PADDING_LEFT;
      const barWidth = BAR_WIDTH + BAR_PADDING;
      const tooltipOffset = Math.round((tooltipWidth - barWidth) * 0.5);

      const left = CHART_PADDING_LEFT + this.currentBarMouseOverTarget_ *
          barWidth - tooltipOffset;
      const top = Math.round((this.chartHeight_ - tooltipHeight) * 0.5);

      this.chartCtx_.save();

      this.chartCtx_.shadowOffsetX = 0;
      this.chartCtx_.shadowOffsetY = 5;
      this.chartCtx_.shadowBlur = 4;
      this.chartCtx_.shadowColor = 'rgba(0,0,0,0.4)';

      this.chartCtx_.strokeStyle = '#888';
      this.chartCtx_.fillStyle = '#EEE';
      this.chartCtx_.fillRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.shadowColor = 'transparent';
      this.chartCtx_.translate(0.5, 0.5);
      this.chartCtx_.strokeRect(left, top, tooltipWidth, tooltipHeight);

      this.chartCtx_.restore();

      this.chartCtx_.fillStyle = '#222';
      this.chartCtx_.textAlign = 'left';
      this.chartCtx_.textBaseline = 'top';
      this.chartCtx_.font = '800 12px Arial';
      this.chartCtx_.fillText(tooltipTitle, left + 8, top + 8);

      this.chartCtx_.fillStyle = '#555';
      this.chartCtx_.font = '400 italic 10px Arial';
      this.chartCtx_.fillText(tooltipTime + 'ms (' +
          toolTipTimePercentage + '%)', left + 8, top + 22);
    },

    drawBars_() {
      let op;
      let opColor = 0;
      let opHeight = 0;
      const opWidth = BAR_WIDTH + BAR_PADDING;
      let opHover = false;

      const bottom = this.chartHeight_ - CHART_PADDING_BOTTOM;
      const maxHeight = this.chartHeight_ - CHART_PADDING_BOTTOM -
          CHART_PADDING_TOP;

      let maxValue;
      if (this.usePercentileScale) {
        maxValue = this.ninetyFifthPercentileCost_;
      } else {
        maxValue = this.maxCost_;
      }

      for (let b = 0; b < this.pictureOps_.length; b++) {
        op = this.pictureOps_[b];
        opHeight = Math.round(
            (op.cmd_time / maxValue) * maxHeight);
        opHeight = Math.max(opHeight, 1);
        opHover = (b === this.currentBarMouseOverTarget_);
        opColor = this.getOpColor_(op.cmd_string, opHover);

        if (b === this.selectedOpIndex) {
          this.chartCtx_.fillStyle = '#FFFF00';
        } else {
          this.chartCtx_.fillStyle = opColor;
        }

        this.chartCtx_.fillRect(CHART_PADDING_LEFT + b * opWidth,
            bottom - opHeight, BAR_WIDTH, opHeight);
      }
    },

    getOpColor_(opName, hover) {
      const characters = opName.split('');

      const hue = characters.reduce(this.reduceNameToHue, 0) % 360;
      const saturation = 30;
      const lightness = hover ? '75%' : '50%';

      return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
    },

    reduceNameToHue(previousValue, currentValue, index, array) {
      // Get the char code and apply a magic adjustment value so we get
      // pretty colors from around the rainbow.
      return Math.round(previousValue + currentValue.charCodeAt(0) *
          HUE_CHAR_CODE_ADJUSTMENT);
    },

    clearChartContents_() {
      this.chartCtx_.clearRect(0, 0, this.chartWidth_, this.chartHeight_);
    },

    showNoTimingDataMessage_() {
      this.chartCtx_.font = '800 italic 14px Arial';
      this.chartCtx_.fillStyle = '#333';
      this.chartCtx_.textAlign = 'center';
      this.chartCtx_.textBaseline = 'middle';
      this.chartCtx_.fillText('No timing data available.',
          this.chartWidth_ * 0.5, this.chartHeight_ * 0.5);
    }
  };

  return {
    PictureOpsChartView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  const THIS_DOC = document.currentScript.ownerDocument;

  /**
   * PictureDebugger is a view of a PictureSnapshot for inspecting
   * the picture in detail. (e.g., timing information, etc.)
   *
   * @constructor
   */
  const PictureDebugger = tr.ui.b.define('tr-ui-e-chrome-cc-picture-debugger');

  PictureDebugger.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate() {
      const node = tr.ui.b.instantiateTemplate(
          '#tr-ui-e-chrome-cc-picture-debugger-template', THIS_DOC);

      Polymer.dom(this).appendChild(node);

      this.pictureAsImageData_ = undefined;
      this.showOverdraw_ = false;
      this.zoomScaleValue_ = 1;

      this.sizeInfo_ = Polymer.dom(this).querySelector('.size');
      this.rasterArea_ = Polymer.dom(this).querySelector('raster-area');
      this.rasterCanvas_ = Polymer.dom(this.rasterArea_)
          .querySelector('canvas');
      this.rasterCtx_ = this.rasterCanvas_.getContext('2d');

      this.filename_ = Polymer.dom(this).querySelector('.filename');

      this.drawOpsChartSummaryView_ =
          new tr.ui.e.chrome.cc.PictureOpsChartSummaryView();
      this.drawOpsChartView_ = new tr.ui.e.chrome.cc.PictureOpsChartView();
      this.drawOpsChartView_.addEventListener(
          'selection-changed', this.onChartBarClicked_.bind(this));

      this.exportButton_ = Polymer.dom(this).querySelector('.export');
      this.exportButton_.addEventListener(
          'click', this.onSaveAsSkPictureClicked_.bind(this));

      this.trackMouse_();

      const overdrawCheckbox = tr.ui.b.createCheckBox(
          this, 'showOverdraw',
          'pictureView.showOverdraw', false,
          'Show overdraw');

      const chartCheckbox = tr.ui.b.createCheckBox(
          this, 'showSummaryChart',
          'pictureView.showSummaryChart', false,
          'Show timing summary');

      const pictureInfo = Polymer.dom(this).querySelector('picture-info');
      Polymer.dom(pictureInfo).appendChild(overdrawCheckbox);
      Polymer.dom(pictureInfo).appendChild(chartCheckbox);

      this.drawOpsView_ = new tr.ui.e.chrome.cc.PictureOpsListView();
      this.drawOpsView_.addEventListener(
          'selection-changed', this.onChangeDrawOps_.bind(this));

      const leftPanel = Polymer.dom(this).querySelector('left-panel');
      Polymer.dom(leftPanel).appendChild(this.drawOpsChartSummaryView_);
      Polymer.dom(leftPanel).appendChild(this.drawOpsView_);

      const middleDragHandle = document.createElement('tr-ui-b-drag-handle');
      middleDragHandle.horizontal = false;
      middleDragHandle.target = leftPanel;

      const rightPanel = Polymer.dom(this).querySelector('right-panel');
      rightPanel.replaceChild(
          this.drawOpsChartView_, Polymer.dom(rightPanel)
              .querySelector('tr-ui-e-chrome-cc-picture-ops-chart-view'));

      this.infoBar_ = document.createElement('tr-ui-b-info-bar');
      Polymer.dom(this.rasterArea_).appendChild(this.infoBar_);

      Polymer.dom(this).insertBefore(middleDragHandle, rightPanel);

      this.picture_ = undefined;

      const hkc = document.createElement('tv-ui-b-hotkey-controller');
      hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        thisArg: this,
        keyCode: 'h'.charCodeAt(0),
        callback(e) {
          this.moveSelectedOpBy(-1);
          e.stopPropagation();
        }
      }));
      hkc.addHotKey(new tr.ui.b.HotKey({
        eventType: 'keypress',
        thisArg: this,
        keyCode: 'l'.charCodeAt(0),
        callback(e) {
          this.moveSelectedOpBy(1);
          e.stopPropagation();
        }
      }));
      Polymer.dom(this).appendChild(hkc);

      // Add a mutation observer so that when the view is resized we can
      // update the chart summary view.
      this.mutationObserver_ = new MutationObserver(
          this.onMutation_.bind(this));
      this.mutationObserver_.observe(leftPanel, { attributes: true });
    },

    onMutation_(mutations) {
      for (let m = 0; m < mutations.length; m++) {
        // A style change would indicate that the element has resized
        // so we should re-render the chart.
        if (mutations[m].attributeName === 'style') {
          this.drawOpsChartSummaryView_.requiresRedraw = true;
          this.drawOpsChartSummaryView_.updateChartContents();

          this.drawOpsChartView_.dimensionsHaveChanged = true;
          this.drawOpsChartView_.updateChartContents();
          break;
        }
      }
    },

    onSaveAsSkPictureClicked_() {
      // Decode base64 data into a String
      const rawData = tr.b.Base64.atob(this.picture_.getBase64SkpData());

      // Convert this String into an Uint8Array
      const length = rawData.length;
      const arrayBuffer = new ArrayBuffer(length);
      const uint8Array = new Uint8Array(arrayBuffer);
      for (let c = 0; c < length; c++) {
        uint8Array[c] = rawData.charCodeAt(c);
      }

      // Create a blob URL from the binary array.
      const blob = new Blob([uint8Array], {type: 'application/octet-binary'});
      const blobUrl = window.webkitURL.createObjectURL(blob);

      // Create a link and click on it. BEST API EVAR!
      const link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
      link.href = blobUrl;
      link.download = this.filename_.value;
      const event = document.createEvent('MouseEvents');
      event.initMouseEvent(
          'click', true, false, window, 0, 0, 0, 0, 0,
          false, false, false, false, 0, null);
      link.dispatchEvent(event);
    },

    get picture() {
      return this.picture_;
    },

    set picture(picture) {
      this.drawOpsView_.picture = picture;
      this.drawOpsChartView_.picture = picture;
      this.drawOpsChartSummaryView_.picture = picture;
      this.picture_ = picture;

      this.exportButton_.disabled = !this.picture_.canSave;

      if (picture) {
        const size = this.getRasterCanvasSize_();
        this.rasterCanvas_.width = size.width;
        this.rasterCanvas_.height = size.height;
      }

      const bounds = this.rasterArea_.getBoundingClientRect();
      const selectorBounds = this.mouseModeSelector_.getBoundingClientRect();
      this.mouseModeSelector_.pos = {
        x: (bounds.right - selectorBounds.width - 10),
        y: bounds.top
      };

      this.rasterize_();

      this.scheduleUpdateContents_();
    },

    getRasterCanvasSize_() {
      const style = window.getComputedStyle(this.rasterArea_);
      const width =
          Math.max(parseInt(style.width), this.picture_.layerRect.width);
      const height =
          Math.max(parseInt(style.height), this.picture_.layerRect.height);

      return {
        width,
        height
      };
    },

    scheduleUpdateContents_() {
      if (this.updateContentsPending_) return;

      this.updateContentsPending_ = true;
      tr.b.requestAnimationFrameInThisFrameIfPossible(
          this.updateContents_.bind(this)
      );
    },

    updateContents_() {
      this.updateContentsPending_ = false;

      if (this.picture_) {
        Polymer.dom(this.sizeInfo_).textContent = '(' +
            this.picture_.layerRect.width + ' x ' +
            this.picture_.layerRect.height + ')';
      }

      this.drawOpsChartView_.updateChartContents();
      this.drawOpsChartView_.scrollSelectedItemIntoViewIfNecessary();

      // Return if picture hasn't finished rasterizing.
      if (!this.pictureAsImageData_) return;

      this.infoBar_.visible = false;
      this.infoBar_.removeAllButtons();
      if (this.pictureAsImageData_.error) {
        this.infoBar_.message = 'Cannot rasterize...';
        this.infoBar_.addButton('More info...', function(e) {
          const overlay = new tr.ui.b.Overlay();
          Polymer.dom(overlay).textContent = this.pictureAsImageData_.error;
          overlay.visible = true;
          e.stopPropagation();
          return false;
        }.bind(this));
        this.infoBar_.visible = true;
      }

      this.drawPicture_();
    },

    drawPicture_() {
      const size = this.getRasterCanvasSize_();
      if (size.width !== this.rasterCanvas_.width) {
        this.rasterCanvas_.width = size.width;
      }
      if (size.height !== this.rasterCanvas_.height) {
        this.rasterCanvas_.height = size.height;
      }

      this.rasterCtx_.clearRect(0, 0, size.width, size.height);

      if (!this.pictureAsImageData_.imageData) return;

      const imgCanvas = this.pictureAsImageData_.asCanvas();
      const w = imgCanvas.width;
      const h = imgCanvas.height;
      this.rasterCtx_.drawImage(imgCanvas, 0, 0, w, h,
          0, 0, w * this.zoomScaleValue_,
          h * this.zoomScaleValue_);
    },

    rasterize_() {
      if (this.picture_) {
        this.picture_.rasterize(
            {
              stopIndex: this.drawOpsView_.selectedOpIndex,
              showOverdraw: this.showOverdraw_
            },
            this.onRasterComplete_.bind(this));
      }
    },

    onRasterComplete_(pictureAsImageData) {
      this.pictureAsImageData_ = pictureAsImageData;
      this.scheduleUpdateContents_();
    },

    moveSelectedOpBy(increment) {
      if (this.selectedOpIndex === undefined) {
        this.selectedOpIndex = 0;
        return;
      }
      this.selectedOpIndex = tr.b.math.clamp(
          this.selectedOpIndex + increment,
          0, this.numOps);
    },

    get numOps() {
      return this.drawOpsView_.numOps;
    },

    get selectedOpIndex() {
      return this.drawOpsView_.selectedOpIndex;
    },

    set selectedOpIndex(index) {
      this.drawOpsView_.selectedOpIndex = index;
      this.drawOpsChartView_.selectedOpIndex = index;
    },

    onChartBarClicked_(e) {
      this.drawOpsView_.selectedOpIndex =
          this.drawOpsChartView_.selectedOpIndex;
    },

    onChangeDrawOps_(e) {
      this.rasterize_();
      this.scheduleUpdateContents_();

      this.drawOpsChartView_.selectedOpIndex =
          this.drawOpsView_.selectedOpIndex;
    },

    set showOverdraw(v) {
      this.showOverdraw_ = v;
      this.rasterize_();
    },

    set showSummaryChart(chartShouldBeVisible) {
      if (chartShouldBeVisible) {
        this.drawOpsChartSummaryView_.show();
      } else {
        this.drawOpsChartSummaryView_.hide();
      }
    },

    trackMouse_() {
      this.mouseModeSelector_ = document.createElement(
          'tr-ui-b-mouse-mode-selector');
      this.mouseModeSelector_.targetElement = this.rasterArea_;
      Polymer.dom(this.rasterArea_).appendChild(this.mouseModeSelector_);

      this.mouseModeSelector_.supportedModeMask =
          tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.mode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.defaultMode = tr.ui.b.MOUSE_SELECTOR_MODE.ZOOM;
      this.mouseModeSelector_.settingsKey = 'pictureDebugger.mouseModeSelector';

      this.mouseModeSelector_.addEventListener('beginzoom',
          this.onBeginZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('updatezoom',
          this.onUpdateZoom_.bind(this));
      this.mouseModeSelector_.addEventListener('endzoom',
          this.onEndZoom_.bind(this));
    },

    onBeginZoom_(e) {
      this.isZooming_ = true;

      this.lastMouseViewPos_ = this.extractRelativeMousePosition_(e);

      e.preventDefault();
    },

    onUpdateZoom_(e) {
      if (!this.isZooming_) return;

      const currentMouseViewPos = this.extractRelativeMousePosition_(e);

      // Take the distance the mouse has moved and we want to zoom at about
      // 1/1000th of that speed. 0.01 feels jumpy. This could possibly be tuned
      // more if people feel it's too slow.
      this.zoomScaleValue_ +=
          ((this.lastMouseViewPos_.y - currentMouseViewPos.y) * 0.001);
      this.zoomScaleValue_ = Math.max(this.zoomScaleValue_, 0.1);

      this.drawPicture_();

      this.lastMouseViewPos_ = currentMouseViewPos;
    },

    onEndZoom_(e) {
      this.lastMouseViewPos_ = undefined;
      this.isZooming_ = false;
      e.preventDefault();
    },

    extractRelativeMousePosition_(e) {
      return {
        x: e.clientX - this.rasterArea_.offsetLeft,
        y: e.clientY - this.rasterArea_.offsetTop
      };
    }
  };

  return {
    PictureDebugger,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a picture snapshot in a human readable form.
   * @constructor
   */
  const PictureSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-picture-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  PictureSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add(
          'tr-ui-e-chrome-cc-picture-snapshot-view');
      this.pictureDebugger_ = new tr.ui.e.chrome.cc.PictureDebugger();
      Polymer.dom(this).appendChild(this.pictureDebugger_);
    },

    updateContents() {
      if (this.objectSnapshot_ && this.pictureDebugger_) {
        this.pictureDebugger_.picture = this.objectSnapshot_;
      }
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      PictureSnapshotView,
      {
        typeNames: ['cc::Picture', 'cc::LayeredPicture'],
        showInstances: false
      });

  return {
    PictureSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.e.cc', function() {
  const knownRasterTaskNames = [
    'TileManager::RunRasterTask',
    'RasterWorkerPoolTaskImpl::RunRasterOnThread',
    'RasterWorkerPoolTaskImpl::Raster',
    'RasterTaskImpl::Raster',
    'cc::RasterTask',
    'RasterTask'
  ];

  const knownAnalysisTaskNames = [
    'TileManager::RunAnalyzeTask',
    'RasterWorkerPoolTaskImpl::RunAnalysisOnThread',
    'RasterWorkerPoolTaskImpl::Analyze',
    'RasterTaskImpl::Analyze',
    'cc::AnalyzeTask',
    'AnalyzeTask'
  ];

  function getTileFromRasterTaskSlice(slice) {
    if (!(isSliceDoingRasterization(slice) || isSliceDoingAnalysis(slice))) {
      return undefined;
    }

    let tileData;
    if (slice.args.data) {
      tileData = slice.args.data;
    } else {
      tileData = slice.args.tileData;
    }
    if (tileData === undefined) return undefined;
    if (tileData.tile_id) return tileData.tile_id;

    const tile = tileData.tileId;
    if (!(tile instanceof tr.e.cc.TileSnapshot)) {
      return undefined;
    }
    return tileData.tileId;
  }

  function isSliceDoingRasterization(slice) {
    return knownRasterTaskNames.includes(slice.title);
  }

  function isSliceDoingAnalysis(slice) {
    return knownAnalysisTaskNames.includes(slice.title);
  }

  return {
    getTileFromRasterTaskSlice,
    isSliceDoingRasterization,
    isSliceDoingAnalysis
  };
});


'use strict';
Polymer({
  is: 'tr-ui-e-chrome-cc-raster-task-view',

  created() {
    this.selection_ = undefined;
  },

  set selection(selection) {
    this.selection_ = selection;

    this.updateContents_();
  },

  updateColumns_(hadCpuDurations) {
    const timeSpanConfig = {
      unit: tr.b.Unit.byName.timeDurationInMs,
      ownerDocument: this.ownerDocument
    };

    const columns = [
      {
        title: 'Layer',
        value(row) {
          if (row.isTotals) return 'Totals';
          if (row.layer) {
            const linkEl = document.createElement('tr-ui-a-analysis-link');
            linkEl.setSelectionAndContent(
                function() {
                  return new tr.ui.e.chrome.cc.LayerSelection(costs.layer);
                },
                'Layer ' + row.layerId);
            return linkEl;
          }
          return 'Layer ' + row.layerId;
        },
        width: '250px'
      },
      {
        title: 'Num Tiles',
        value(row) { return row.numTiles; },
        cmp(a, b) { return a.numTiles - b.numTiles; }
      },
      {
        title: 'Num Analysis Tasks',
        value(row) { return row.numAnalysisTasks; },
        cmp(a, b) {
          return a.numAnalysisTasks - b.numAnalysisTasks;
        }
      },
      {
        title: 'Num Raster Tasks',
        value(row) { return row.numRasterTasks; },
        cmp(a, b) { return a.numRasterTasks - b.numRasterTasks; }
      },
      {
        title: 'Wall Duration (ms)',
        value(row) {
          return tr.v.ui.createScalarSpan(row.duration, timeSpanConfig);
        },
        cmp(a, b) { return a.duration - b.duration; }
      }
    ];

    if (hadCpuDurations) {
      columns.push({
        title: 'CPU Duration (ms)',
        value(row) {
          return tr.v.ui.createScalarSpan(row.cpuDuration, timeSpanConfig);
        },
        cmp(a, b) { return a.cpuDuration - b.cpuDuration; }
      });
    }

    let colWidthPercentage;
    if (columns.length === 1) {
      colWidthPercentage = '100%';
    } else {
      colWidthPercentage = (100 / (columns.length - 1)).toFixed(3) + '%';
    }

    for (let i = 1; i < columns.length; i++) {
      columns[i].width = colWidthPercentage;
    }

    this.$.content.tableColumns = columns;
    this.$.content.sortColumnIndex = columns.length - 1;
  },

  updateContents_() {
    const table = this.$.content;

    if (this.selection_.length === 0) {
      this.$.link.setSelectionAndContent(undefined, '');
      table.tableRows = [];
      table.footerRows = [];
      table.rebuild();
      return;
    }
    // LTHI link.
    const lthi = tr.e.cc.getTileFromRasterTaskSlice(
        tr.b.getFirstElement(this.selection_)).containingSnapshot;
    this.$.link.setSelectionAndContent(function() {
      return new tr.model.EventSet(lthi);
    }, lthi.userFriendlyName);

    // Get costs by layer.
    const costsByLayerId = {};
    function getCurrentCostsForLayerId(tile) {
      const layerId = tile.layerId;
      const lthi = tile.containingSnapshot;
      let layer;
      if (lthi.activeTree) {
        layer = lthi.activeTree.findLayerWithId(layerId);
      }
      if (layer === undefined && lthi.pendingTree) {
        layer = lthi.pendingTree.findLayerWithId(layerId);
      }
      if (costsByLayerId[layerId] === undefined) {
        costsByLayerId[layerId] = {
          layerId,
          layer,
          numTiles: 0,
          numAnalysisTasks: 0,
          numRasterTasks: 0,
          duration: 0,
          cpuDuration: 0
        };
      }
      return costsByLayerId[layerId];
    }

    let totalDuration = 0;
    let totalCpuDuration = 0;
    let totalNumAnalyzeTasks = 0;
    let totalNumRasterizeTasks = 0;
    let hadCpuDurations = false;

    const tilesThatWeHaveSeen = {};

    this.selection_.forEach(function(slice) {
      const tile = tr.e.cc.getTileFromRasterTaskSlice(slice);
      const curCosts = getCurrentCostsForLayerId(tile);

      if (!tilesThatWeHaveSeen[tile.objectInstance.id]) {
        tilesThatWeHaveSeen[tile.objectInstance.id] = true;
        curCosts.numTiles += 1;
      }

      if (tr.e.cc.isSliceDoingAnalysis(slice)) {
        curCosts.numAnalysisTasks += 1;
        totalNumAnalyzeTasks += 1;
      } else {
        curCosts.numRasterTasks += 1;
        totalNumRasterizeTasks += 1;
      }
      curCosts.duration += slice.duration;
      totalDuration += slice.duration;
      if (slice.cpuDuration !== undefined) {
        curCosts.cpuDuration += slice.cpuDuration;
        totalCpuDuration += slice.cpuDuration;
        hadCpuDurations = true;
      }
    });

    // Apply to the table.
    this.updateColumns_(hadCpuDurations);
    table.tableRows = Object.values(costsByLayerId);
    table.rebuild();

    // Footer.
    table.footerRows = [
      {
        isTotals: true,
        numTiles: Object.keys(tilesThatWeHaveSeen).length,
        numAnalysisTasks: totalNumAnalyzeTasks,
        numRasterTasks: totalNumRasterizeTasks,
        duration: totalDuration,
        cpuDuration: totalCpuDuration
      }
    ];
  }
});


'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /**
   * @constructor
   */
  function RasterTaskSelection(selection) {
    tr.ui.e.chrome.cc.Selection.call(this);
    const whySupported = RasterTaskSelection.whySuported(selection);
    if (!whySupported.ok) {
      throw new Error('Fail: ' + whySupported.why);
    }
    this.slices_ = Array.from(selection);
    this.tiles_ = this.slices_.map(function(slice) {
      const tile = tr.e.cc.getTileFromRasterTaskSlice(slice);
      if (tile === undefined) {
        throw new Error('This should never happen due to .supports check.');
      }
      return tile;
    });
  }

  RasterTaskSelection.whySuported = function(selection) {
    if (!(selection instanceof tr.model.EventSet)) {
      return {ok: false, why: 'Must be selection'};
    }

    if (selection.length === 0) {
      return {ok: false, why: 'Selection must be non empty'};
    }

    let referenceSnapshot = undefined;
    for (const event of selection) {
      if (!(event instanceof tr.model.Slice)) {
        return {ok: false, why: 'Not a slice'};
      }

      const tile = tr.e.cc.getTileFromRasterTaskSlice(event);
      if (tile === undefined) {
        return {ok: false, why: 'No tile found'};
      }

      if (!referenceSnapshot) {
        referenceSnapshot = tile.containingSnapshot;
      } else {
        if (tile.containingSnapshot !== referenceSnapshot) {
          return {
            ok: false,
            why: 'Raster tasks are from different compositor instances'
          };
        }
      }
    }
    return {ok: true};
  };

  RasterTaskSelection.supports = function(selection) {
    return RasterTaskSelection.whySuported(selection).ok;
  };

  RasterTaskSelection.prototype = {
    __proto__: tr.ui.e.chrome.cc.Selection.prototype,

    get specicifity() {
      return 3;
    },

    get associatedLayerId() {
      const tile0 = this.tiles_[0];
      const allSameLayer = this.tiles_.every(function(tile) {
        tile.layerId === tile0.layerId;
      });
      if (allSameLayer) {
        return tile0.layerId;
      }
      return undefined;
    },

    get extraHighlightsByLayerId() {
      const highlights = {};
      this.tiles_.forEach(function(tile, i) {
        if (highlights[tile.layerId] === undefined) {
          highlights[tile.layerId] = [];
        }
        const slice = this.slices_[i];
        highlights[tile.layerId].push({
          colorKey: slice.title,
          rect: tile.layerRect
        });
      }, this);
      return highlights;
    },

    createAnalysis() {
      const sel = new tr.model.EventSet();
      this.slices_.forEach(function(slice) {
        sel.push(slice);
      });

      let analysis;
      if (sel.length === 1) {
        analysis = document.createElement('tr-ui-a-single-event-sub-view');
      } else {
        analysis = document.createElement('tr-ui-e-chrome-cc-raster-task-view');
      }
      analysis.selection = sel;
      return analysis;
    },

    findEquivalent(lthi) {
      // Raster tasks are only valid in one LTHI.
      return undefined;
    },

    // RasterTaskSelection specific stuff follows.
    get containingSnapshot() {
      return this.tiles_[0].containingSnapshot;
    }
  };

  return {
    RasterTaskSelection,
  };
});



'use strict';

tr.exportTo('tr.ui.e.chrome.cc', function() {
  /*
   * Displays a tile in a human readable form.
   * @constructor
   */
  const TileSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-cc-tile-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  TileSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add('tr-ui-e-chrome-cc-tile-snapshot-view');
      this.layerTreeView_ =
          new tr.ui.e.chrome.cc.LayerTreeHostImplSnapshotView();
      Polymer.dom(this).appendChild(this.layerTreeView_);
    },

    updateContents() {
      const tile = this.objectSnapshot_;
      const layerTreeHostImpl = tile.containingSnapshot;
      if (!layerTreeHostImpl) return;

      this.layerTreeView_.objectSnapshot = layerTreeHostImpl;
      this.layerTreeView_.selection = new tr.ui.e.chrome.cc.TileSelection(tile);
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      TileSnapshotView,
      {
        typeName: 'cc::Tile',
        showInTrackView: false
      });

  return {
    TileSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.e.gpu', function() {
  const AsyncSlice = tr.model.AsyncSlice;

  function GpuAsyncSlice() {
    AsyncSlice.apply(this, arguments);
  }

  GpuAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    get viewSubGroupTitle() {
      if (this.args.channel) {
        if (this.category === 'disabled-by-default-gpu.device') {
          return 'Device.' + this.args.channel;
        }
        return 'Service.' + this.args.channel;
      }
      return this.title;
    }
  };

  AsyncSlice.subTypes.register(
      GpuAsyncSlice,
      {
        categoryParts: ['disabled-by-default-gpu.device',
          'disabled-by-default-gpu.service']
      });

  return {
    GpuAsyncSlice,
  };
});


'use strict';

tr.exportTo('tr.e.gpu', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function StateSnapshot() {
    ObjectSnapshot.apply(this, arguments);
  }

  StateSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    preInitialize() {
      this.screenshot_ = undefined;
    },

    initialize() {
      if (this.args.screenshot) {
        this.screenshot_ = this.args.screenshot;
      }
    },

    /**
     * @return {String} a base64 encoded screenshot if available.
     */
    get screenshot() {
      return this.screenshot_;
    }
  };

  ObjectSnapshot.subTypes.register(
      StateSnapshot,
    {typeName: 'gpu::State'});

  return {
    StateSnapshot,
  };
});


'use strict';

tr.exportTo('tr.ui.e.chrome.gpu', function() {
  /*
   * Displays a GPU state snapshot in a human readable form.
   * @constructor
   */
  const StateSnapshotView = tr.ui.b.define(
      'tr-ui-e-chrome-gpu-state-snapshot-view',
      tr.ui.analysis.ObjectSnapshotView);

  StateSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add('tr-ui-e-chrome-gpu-state-snapshot-view');
      this.screenshotImage_ = document.createElement('img');
      Polymer.dom(this).appendChild(this.screenshotImage_);
    },

    updateContents() {
      if (this.objectSnapshot_ && this.objectSnapshot_.screenshot) {
        this.screenshotImage_.src = 'data:image/png;base64,' +
            this.objectSnapshot_.screenshot;
      }
    }
  };
  tr.ui.analysis.ObjectSnapshotView.register(
      StateSnapshotView,
    {typeName: 'gpu::State'});

  return {
    StateSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.ui.analysis', function() {
  Polymer({
    is: 'tr-ui-a-layout-tree-sub-view',
    behaviors: ['tr-ui-a-sub-view'],

    set selection(selection) {
      this.currentSelection_ = selection;
      this.updateContents_();
    },

    get selection() {
      return this.currentSelection_;
    },

    updateContents_() {
      this.set('$.content.textContent', '');
      if (!this.currentSelection_) return;

      const columns = [
        {
          title: 'Tag/Name',
          value(layoutObject) {
            return layoutObject.tag || ':' + layoutObject.name;
          }
        },

        {
          title: 'htmlId',
          value(layoutObject) {
            return layoutObject.htmlId || '';
          }
        },

        {
          title: 'classNames',
          value(layoutObject) {
            return layoutObject.classNames || '';
          }
        },

        {
          title: 'reasons',
          value(layoutObject) {
            return layoutObject.needsLayoutReasons.join(', ');
          }
        },

        {
          title: 'width',
          value(layoutObject) {
            return layoutObject.absoluteRect.width;
          }
        },

        {
          title: 'height',
          value(layoutObject) {
            return layoutObject.absoluteRect.height;
          }
        },

        {
          title: 'absX',
          value(layoutObject) {
            return layoutObject.absoluteRect.left;
          }
        },

        {
          title: 'absY',
          value(layoutObject) {
            return layoutObject.absoluteRect.top;
          }
        },

        {
          title: 'relX',
          value(layoutObject) {
            return layoutObject.relativeRect.left;
          }
        },

        {
          title: 'relY',
          value(layoutObject) {
            return layoutObject.relativeRect.top;
          }
        },

        {
          title: 'float',
          value(layoutObject) {
            return layoutObject.isFloat ? 'float' : '';
          }
        },

        {
          title: 'positioned',
          value(layoutObject) {
            return layoutObject.isPositioned ? 'positioned' : '';
          }
        },

        {
          title: 'relative',
          value(layoutObject) {
            return layoutObject.isRelativePositioned ? 'relative' : '';
          }
        },

        {
          title: 'sticky',
          value(layoutObject) {
            return layoutObject.isStickyPositioned ? 'sticky' : '';
          }
        },

        {
          title: 'anonymous',
          value(layoutObject) {
            return layoutObject.isAnonymous ? 'anonymous' : '';
          }
        },

        {
          title: 'row',
          value(layoutObject) {
            if (layoutObject.tableRow === undefined) {
              return '';
            }
            return layoutObject.tableRow;
          }
        },

        {
          title: 'col',
          value(layoutObject) {
            if (layoutObject.tableCol === undefined) {
              return '';
            }
            return layoutObject.tableCol;
          }
        },

        {
          title: 'rowSpan',
          value(layoutObject) {
            if (layoutObject.tableRowSpan === undefined) {
              return '';
            }
            return layoutObject.tableRowSpan;
          }
        },

        {
          title: 'colSpan',
          value(layoutObject) {
            if (layoutObject.tableColSpan === undefined) {
              return '';
            }
            return layoutObject.tableColSpan;
          }
        },

        {
          title: 'address',
          value(layoutObject) {
            return layoutObject.id.toString(16);
          }
        }
      ];

      const table = this.ownerDocument.createElement('tr-ui-b-table');
      table.defaultExpansionStateCallback = function(
          layoutObject, parentLayoutObject) {
        return true;
      };
      table.subRowsPropertyName = 'childLayoutObjects';
      table.tableColumns = columns;
      table.tableRows = this.currentSelection_.map(function(snapshot) {
        return snapshot.rootLayoutObject;
      });
      table.rebuild();
      Polymer.dom(this.$.content).appendChild(table);
    },
  });

  return {};
});
tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-layout-tree-sub-view',
    tr.e.chrome.LayoutTreeSnapshot,
    {
      multi: false,
      title: 'Layout Tree',
    });

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-a-layout-tree-sub-view',
    tr.e.chrome.LayoutTreeSnapshot,
    {
      multi: true,
      title: 'Layout Trees',
    });


'use strict';
tr.exportTo('tr.ui.e.s', function() {
  const BlameContextSnapshot = tr.e.chrome.BlameContextSnapshot;
  const FrameTreeNodeSnapshot = tr.e.chrome.FrameTreeNodeSnapshot;
  const RenderFrameSnapshot = tr.e.chrome.RenderFrameSnapshot;
  const TopLevelSnapshot = tr.e.chrome.TopLevelSnapshot;

  const BlameContextInstance = tr.e.chrome.BlameContextInstance;
  const FrameTreeNodeInstance = tr.e.chrome.FrameTreeNodeInstance;
  const RenderFrameInstance = tr.e.chrome.RenderFrameInstance;
  const TopLevelInstance = tr.e.chrome.TopLevelInstance;

  /**
   * @constructor
   * If |context| is provided, creates a row for the given context.
   * Otherwise, creates an empty Row template which can be used for aggregating
   * data from a group of subrows.
   */
  function Row(context) {
    this.subRows = undefined;
    this.contexts = [];
    this.type = undefined;
    this.renderer = 'N/A';
    this.url = undefined;
    this.time = 0;
    this.eventsOfInterest = new tr.model.EventSet();

    if (context === undefined) return;

    this.type = context.objectInstance.blameContextType;
    this.contexts.push(context);
    if (context instanceof FrameTreeNodeSnapshot) {
      if (context.renderFrame) {
        this.contexts.push(context.renderFrame);
        this.renderer = context.renderFrame.objectInstance.parent.pid;
      }
    } else if (context instanceof RenderFrameSnapshot) {
      if (context.frameTreeNode) {
        this.contexts.push(context.frameTreeNode);
      }
      this.renderer = context.objectInstance.parent.pid;
    } else if (context instanceof TopLevelSnapshot) {
      this.renderer = context.objectInstance.parent.pid;
    } else {
      throw new Error('Unknown context type');
    }
    this.eventsOfInterest.addEventSet(this.contexts);

    // TODO(xiaochengh): Handle the case where a subframe has a trivial url
    // (e.g., about:blank), but inherits the origin of its parent. This is not
    // needed now, but will be required if we want to group rows by origin.
    this.url = context.url;
  }

  const groupFunctions = {
    none: rows => rows,

    // Group the rows according to the frame tree structure.
    // Example: consider frame tree a(b, c(d)), where each frame has 1ms time
    // attributed to it. The resulting table should look like:
    //      Type     | Time | URL
    // --------------+------+-----
    // Frame Tree    |   4  |  a
    // +- Frame      |   1  |  a
    // +- Subframe   |   1  |  b
    // +- Frame Tree |   2  |  c
    //  +- Frame     |   1  |  c
    //  +- Subframe  |   1  |  d
    tree(rows, rowMap) {
      // Finds the parent of a specific row. When there is conflict between the
      // browser's dump of the frame tree and the renderers', use the browser's.
      const getParentRow = function(row) {
        let pivot;
        row.contexts.forEach(function(context) {
          if (context instanceof tr.e.chrome.FrameTreeNodeSnapshot) {
            pivot = context;
          }
        });
        if (pivot && pivot.parentContext) {
          return rowMap[pivot.parentContext.guid];
        }
        return undefined;
      };

      const rootRows = [];
      rows.forEach(function(row) {
        const parentRow = getParentRow(row);
        if (parentRow === undefined) {
          rootRows.push(row);
          return;
        }
        if (parentRow.subRows === undefined) {
          parentRow.subRows = [];
        }
        parentRow.subRows.push(row);
      });

      const aggregateAllDescendants = function(row) {
        if (!row.subRows) {
          if (getParentRow(row)) {
            row.type = 'Subframe';
          }
          return row;
        }
        const result = new Row();
        result.type = 'Frame Tree';
        result.renderer = row.renderer;
        result.url = row.url;
        result.subRows = [row];
        row.subRows.forEach(
            subRow => result.subRows.push(aggregateAllDescendants(subRow)));
        result.subRows.forEach(function(subRow) {
          result.time += subRow.time;
          result.eventsOfInterest.addEventSet(subRow.eventsOfInterest);
        });
        row.subRows = undefined;
        return result;
      };

      return rootRows.map(rootRow => aggregateAllDescendants(rootRow));
    }

    // TODO(xiaochengh): Add grouping by site and probably more...
  };

  Polymer({
    is: 'tr-ui-e-s-frame-data-side-panel',
    behaviors: [tr.ui.behaviors.SidePanel],

    ready() {
      this.model_ = undefined;
      this.rangeOfInterest_ = new tr.b.math.Range();

      this.$.table.showHeader = true;
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
      this.$.table.tableColumns = this.createFrameDataTableColumns_();

      this.$.table.addEventListener('selection-changed', function(e) {
        this.selectEventSet_(this.$.table.selectedTableRow.eventsOfInterest);
      }.bind(this));

      this.$.select.addEventListener('change', function(e) {
        this.updateContents_();
      }.bind(this));
    },

    selectEventSet_(eventSet) {
      const event = new tr.model.RequestSelectionChangeEvent();
      event.selection = eventSet;
      this.dispatchEvent(event);
    },

    createFrameDataTableColumns_() {
      return [
        {
          title: 'Renderer',
          value: row => row.renderer,
          cmp: (a, b) => a.renderer - b.renderer
        },
        {
          title: 'Type',
          value: row => row.type
        },
        // TODO(xiaochengh): Decide what details to show in the table:
        // - URL seems necessary, but we may also want origin instead/both.
        // - Distinguish between browser time and renderer time?
        // - Distinguish between CPU time and wall clock time?
        // - Memory? Network? ...
        {
          title: 'Time',
          value: row => tr.v.ui.createScalarSpan(row.time, {
            unit: tr.b.Unit.byName.timeStampInMs,
            ownerDocument: this.ownerDocument
          }),
          cmp: (a, b) => a.time - b.time
        },
        {
          title: 'URL',
          value: row => row.url,
          cmp: (a, b) => (a.url || '').localeCompare(b.url || '')
        }
      ];
    },

    createFrameDataTableRows_() {
      if (!this.model_) return [];

      // Gather contexts into skeletons of rows.
      const rows = [];
      const rowMap = {};
      for (const proc of Object.values(this.model_.processes)) {
        proc.objects.iterObjectInstances(function(objectInstance) {
          if (!(objectInstance instanceof BlameContextInstance)) {
            return;
          }
          objectInstance.snapshots.forEach(function(snapshot) {
            if (rowMap[snapshot.guid]) return;

            const row = new Row(snapshot);
            row.contexts.forEach(context => rowMap[context.guid] = row);
            rows.push(row);
          }, this);
        }, this);
      }

      // Find slices attributed to each row.
      // TODO(xiaochengh): We should implement a getter
      // BlameContextSnapshot.attributedEvents, instead of process the model in
      // a UI component.
      for (const proc of Object.values(this.model_.processes)) {
        for (const thread of Object.values(proc.threads)) {
          thread.sliceGroup.iterSlicesInTimeRange(function(topLevelSlice) {
            topLevelSlice.contexts.forEach(function(context) {
              if (!context.snapshot.guid || !rowMap[context.snapshot.guid]) {
                return;
              }
              const row = rowMap[context.snapshot.guid];
              row.eventsOfInterest.push(topLevelSlice);
              row.time += topLevelSlice.selfTime || 0;
            });
          }, this.currentRangeOfInterest.min, this.currentRangeOfInterest.max);
        }
      }

      // Apply grouping to rows.
      const select = this.$.select;
      const groupOption = select.options[select.selectedIndex].value;
      const groupFunction = groupFunctions[groupOption];
      return groupFunction(rows, rowMap);
    },

    updateContents_() {
      this.$.table.tableRows = this.createFrameDataTableRows_();
      this.$.table.rebuild();
    },

    supportsModel(m) {
      if (!m) {
        return {
          supported: false,
          reason: 'No model available.'
        };
      }

      const ans = {supported: false};
      for (const proc of Object.values(m.processes)) {
        proc.objects.iterObjectInstances(function(instance) {
          if (instance instanceof BlameContextInstance) {
            ans.supported = true;
          }
        });
      }

      if (!ans.supported) {
        ans.reason = 'No frame data available';
      }
      return ans;
    },

    get currentRangeOfInterest() {
      if (this.rangeOfInterest_.isEmpty) {
        return this.model_.bounds;
      }
      return this.rangeOfInterest_;
    },

    get rangeOfInterest() {
      return this.rangeOfInterest_;
    },

    set rangeOfInterest(rangeOfInterest) {
      this.rangeOfInterest_ = rangeOfInterest;
      this.updateContents_();
    },

    get selection() {
      // Not applicable.
    },

    set selection(_) {
      // Not applicable.
    },

    get textLabel() {
      return 'Frame Data';
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateContents_();
    }
  });

  tr.ui.side_panel.SidePanelRegistry.register(function() {
    return document.createElement('tr-ui-e-s-frame-data-side-panel');
  });
});


'use strict';

Polymer({
  is: 'tr-ui-e-s-input-latency-side-panel',
  behaviors: [tr.ui.behaviors.SidePanel],


  ready() {
    this.rangeOfInterest_ = new tr.b.math.Range();
    this.frametimeType_ = tr.model.helpers.IMPL_FRAMETIME_TYPE;
    this.latencyChart_ = undefined;
    this.frametimeChart_ = undefined;
    this.selectedProcessId_ = undefined;
    this.mouseDownIndex_ = undefined;
    this.curMouseIndex_ = undefined;
  },

  get model() {
    return this.model_;
  },

  set model(model) {
    this.model_ = model;
    if (this.model_) {
      this.modelHelper_ = this.model_.getOrCreateHelper(
          tr.model.helpers.ChromeModelHelper);
    } else {
      this.modelHelper_ = undefined;
    }

    this.updateToolbar_();
    this.updateContents_();
  },

  get frametimeType() {
    return this.frametimeType_;
  },

  set frametimeType(type) {
    if (this.frametimeType_ === type) return;

    this.frametimeType_ = type;
    this.updateContents_();
  },

  get selectedProcessId() {
    return this.selectedProcessId_;
  },

  set selectedProcessId(process) {
    if (this.selectedProcessId_ === process) return;

    this.selectedProcessId_ = process;
    this.updateContents_();
  },

  set selection(selection) {
    if (this.latencyChart_ === undefined) return;

    this.latencyChart_.brushedRange = selection.bounds;
  },

  // This function is for testing purpose.
  setBrushedIndices(mouseDownIndex, curIndex) {
    this.mouseDownIndex_ = mouseDownIndex;
    this.curMouseIndex_ = curIndex;
    this.updateBrushedRange_();
  },

  updateBrushedRange_() {
    if (this.latencyChart_ === undefined) return;

    let r = new tr.b.math.Range();
    if (this.mouseDownIndex_ === undefined) {
      this.latencyChart_.brushedRange = r;
      return;
    }
    r = this.latencyChart_.computeBrushRangeFromIndices(
        this.mouseDownIndex_, this.curMouseIndex_);
    this.latencyChart_.brushedRange = r;

    // Based on the brushed range, update the selection of LatencyInfo in
    // the timeline view by sending a selectionChange event.
    let latencySlices = [];
    for (const thread of this.model_.getAllThreads()) {
      for (const event of thread.getDescendantEvents()) {
        if (event.title.indexOf('InputLatency:') === 0) {
          latencySlices.push(event);
        }
      }
    }
    latencySlices = tr.model.helpers.getSlicesIntersectingRange(
        r, latencySlices);

    const event = new tr.model.RequestSelectionChangeEvent();
    event.selection = new tr.model.EventSet(latencySlices);
    this.latencyChart_.dispatchEvent(event);
  },

  registerMouseEventForLatencyChart_() {
    this.latencyChart_.addEventListener('item-mousedown', function(e) {
      this.mouseDownIndex_ = e.index;
      this.curMouseIndex_ = e.index;
      this.updateBrushedRange_();
    }.bind(this));

    this.latencyChart_.addEventListener('item-mousemove', function(e) {
      if (e.button === undefined) return;

      this.curMouseIndex_ = e.index;
      this.updateBrushedRange_();
    }.bind(this));

    this.latencyChart_.addEventListener('item-mouseup', function(e) {
      this.curMouseIndex = e.index;
      this.updateBrushedRange_();
    }.bind(this));
  },

  updateToolbar_() {
    const browserProcess = this.modelHelper_.browserProcess;
    const labels = [];

    if (browserProcess !== undefined) {
      const labelStr = 'Browser: ' + browserProcess.pid;
      labels.push({label: labelStr, value: browserProcess.pid});
    }

    for (const rendererHelper of
        Object.values(this.modelHelper_.rendererHelpers)) {
      const rendererProcess = rendererHelper.process;
      const labelStr = 'Renderer: ' + rendererProcess.userFriendlyName;
      labels.push({label: labelStr, value: rendererProcess.userFriendlyName});
    }

    if (labels.length === 0) return;

    this.selectedProcessId_ = labels[0].value;
    const toolbarEl = this.$.toolbar;
    Polymer.dom(toolbarEl).appendChild(tr.ui.b.createSelector(
        this, 'frametimeType',
        'inputLatencySidePanel.frametimeType', this.frametimeType_,
        [{label: 'Main Thread Frame Times',
          value: tr.model.helpers.MAIN_FRAMETIME_TYPE},
        {label: 'Impl Thread Frame Times',
          value: tr.model.helpers.IMPL_FRAMETIME_TYPE}
        ]));
    Polymer.dom(toolbarEl).appendChild(tr.ui.b.createSelector(
        this, 'selectedProcessId',
        'inputLatencySidePanel.selectedProcessId',
        this.selectedProcessId_,
        labels));
  },

  // TODO(charliea): Delete this function in favor of rangeOfInterest.
  get currentRangeOfInterest() {
    if (this.rangeOfInterest_.isEmpty) {
      return this.model_.bounds;
    }
    return this.rangeOfInterest_;
  },

  createLatencyLineChart(data, title, parentNode) {
    const chart = new tr.ui.b.LineChart();
    Polymer.dom(parentNode).appendChild(chart);
    let width = 600;
    if (document.body.clientWidth !== undefined) {
      width = document.body.clientWidth * 0.5;
    }
    chart.graphWidth = width;
    chart.chartTitle = title;
    chart.data = data;
    return chart;
  },

  updateContents_() {
    const resultArea = this.$.result_area;
    this.latencyChart_ = undefined;
    this.frametimeChart_ = undefined;
    Polymer.dom(resultArea).textContent = '';

    if (this.modelHelper_ === undefined) return;

    const rangeOfInterest = this.currentRangeOfInterest;

    let chromeProcess;
    if (this.modelHelper_.rendererHelpers[this.selectedProcessId_]) {
      chromeProcess = this.modelHelper_.rendererHelpers[
        this.selectedProcessId_
      ];
    } else {
      chromeProcess = this.modelHelper_.browserHelper;
    }

    const frameEvents = chromeProcess.getFrameEventsInRange(
        this.frametimeType, rangeOfInterest);

    const frametimeData = tr.model.helpers.getFrametimeDataFromEvents(
        frameEvents);
    const averageFrametime = tr.b.math.Statistics.mean(frametimeData, d =>
      d.frametime
    );

    const latencyEvents = this.modelHelper_.browserHelper.
      getLatencyEventsInRange(
        rangeOfInterest);

    const latencyData = [];
    latencyEvents.forEach(function(event) {
      if (event.inputLatency === undefined) return;

      latencyData.push({
        x: event.start,
        latency: event.inputLatency / 1000
      });
    });

    const averageLatency = tr.b.math.Statistics.mean(latencyData, function(d) {
      return d.latency;
    });

    // Create summary.
    const latencySummaryText = document.createElement('div');
    Polymer.dom(latencySummaryText).appendChild(tr.ui.b.createSpan({
      textContent: 'Average Latency ' + averageLatency + ' ms',
      bold: true}));
    Polymer.dom(resultArea).appendChild(latencySummaryText);

    const frametimeSummaryText = document.createElement('div');
    Polymer.dom(frametimeSummaryText).appendChild(tr.ui.b.createSpan({
      textContent: 'Average Frame Time ' + averageFrametime + ' ms',
      bold: true}));
    Polymer.dom(resultArea).appendChild(frametimeSummaryText);

    if (latencyData.length !== 0) {
      this.latencyChart_ = this.createLatencyLineChart(
          latencyData, 'Latency Over Time', resultArea);
      this.registerMouseEventForLatencyChart_();
    }

    if (frametimeData.length !== 0) {
      this.frametimeChart_ = this.createLatencyLineChart(
          frametimeData, 'Frame Times', resultArea);
    }
  },

  get rangeOfInterest() {
    return this.rangeOfInterest_;
  },

  set rangeOfInterest(rangeOfInterest) {
    this.rangeOfInterest_ = rangeOfInterest;
    this.updateContents_();
  },

  supportsModel(m) {
    if (m === undefined) {
      return {
        supported: false,
        reason: 'Unknown tracing model'
      };
    }

    if (!tr.model.helpers.ChromeModelHelper.supportsModel(m)) {
      return {
        supported: false,
        reason: 'No Chrome browser or renderer process found'
      };
    }

    const modelHelper = m.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    if (modelHelper.browserHelper &&
      modelHelper.browserHelper.hasLatencyEvents) {
      return {
        supported: true
      };
    }

    return {
      supported: false,
      reason: 'No InputLatency events trace. Consider enabling ' +
          'benchmark" and "input" category when recording the trace'
    };
  },

  get textLabel() {
    return 'Input Latency';
  }
});

tr.ui.side_panel.SidePanelRegistry.register(function() {
  return document.createElement('tr-ui-e-s-input-latency-side-panel');
});


'use strict';

tr.exportTo('tr.e.system_stats', function() {
  const ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * @constructor
   */
  function SystemStatsSnapshot(objectInstance, ts, args) {
    ObjectSnapshot.apply(this, arguments);
    this.objectInstance = objectInstance;
    this.ts = ts;
    this.args = args;
    this.stats = args;
  }

  SystemStatsSnapshot.prototype = {
    __proto__: ObjectSnapshot.prototype,

    initialize() {
      if (this.args.length === 0) {
        throw new Error('No system stats snapshot data.');
      }
      this.stats_ = this.args;
    },

    getStats() {
      return this.stats_;
    },

    setStats(stats) {
      this.stats_ = stats;
    }
  };

  ObjectSnapshot.subTypes.register(
      SystemStatsSnapshot,
    {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsSnapshot,
  };
});


'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays traces as stacked bars.
   * @constructor
   * @extends {Track}
   */
  const StackedBarsTrack = tr.ui.b.define(
      'stacked-bars-track', tr.ui.tracks.Track);

  StackedBarsTrack.prototype = {

    __proto__: tr.ui.tracks.Track.prototype,

    decorate(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('stacked-bars-track');
      this.objectInstance_ = null;

      this.heading_ = document.createElement('tr-ui-b-heading');
      Polymer.dom(this).appendChild(this.heading_);
    },

    set heading(heading) {
      this.heading_.heading = heading;
    },

    get heading() {
      return this.heading_.heading;
    },

    set tooltip(tooltip) {
      this.heading_.tooltip = tooltip;
    },

    addEventsToTrackMap(eventToTrackMap) {
      const objectSnapshots = this.objectInstance_.snapshots;
      objectSnapshots.forEach(function(obj) {
        eventToTrackMap.addEvent(obj, this);
      }, this);
    },

    /**
     * Used to hit-test clicks in the graph.
     */
    addIntersectingEventsInRangeToSelectionInWorldSpace(
        loWX, hiWX, viewPixWidthWorld, selection) {
      function onSnapshot(snapshot) {
        selection.push(snapshot);
      }

      const snapshots = this.objectInstance_.snapshots;
      const maxBounds = this.objectInstance_.parent.model.bounds.max;

      tr.b.iterateOverIntersectingIntervals(
          snapshots,
          function(x) { return x.ts; },
          function(x, i) {
            if (i === snapshots.length - 1) {
              if (snapshots.length === 1) {
                return maxBounds;
              }

              return snapshots[i].ts - snapshots[i - 1].ts;
            }

            return snapshots[i + 1].ts - snapshots[i].ts;
          },
          loWX, hiWX,
          onSnapshot);
    },

    /**
     * Add the item to the left or right of the provided item, if any, to the
     * selection.
     * @param {slice} The current slice.
     * @param {Number} offset Number of slices away from the object to look.
     * @param {Selection} selection The selection to add an event to,
     * if found.
     * @return {boolean} Whether an event was found.
     * @private
     */
    addEventNearToProvidedEventToSelection(event, offset, selection) {
      if (!(event instanceof tr.model.ObjectSnapshot)) {
        throw new Error('Unrecognized event');
      }
      const objectSnapshots = this.objectInstance_.snapshots;
      const index = objectSnapshots.indexOf(event);
      const newIndex = index + offset;
      if (newIndex >= 0 && newIndex < objectSnapshots.length) {
        selection.push(objectSnapshots[newIndex]);
        return true;
      }
      return false;
    },

    addAllEventsMatchingFilterToSelection(filter, selection) {
    },

    addClosestEventToSelection(worldX, worldMaxDist, loY, hiY,
        selection) {
      const snapshot = tr.b.findClosestElementInSortedArray(
          this.objectInstance_.snapshots,
          function(x) { return x.ts; },
          worldX,
          worldMaxDist);

      if (!snapshot) return;

      selection.push(snapshot);
    }
  };

  return {
    StackedBarsTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.e.system_stats', function() {
  const EventPresenter = tr.ui.b.EventPresenter;

  let statCount;

  const excludedStats = {'meminfo': {
    'pswpin': 0,
    'pswpout': 0,
    'pgmajfault': 0},
    'diskinfo': {
      'io': 0,
      'io_time': 0,
      'read_time': 0,
      'reads': 0,
      'reads_merged': 0,
      'sectors_read': 0,
      'sectors_written': 0,
      'weighted_io_time': 0,
      'write_time': 0,
      'writes': 0,
      'writes_merged': 0},
    'swapinfo': {}
  };

  /**
   * Tracks that display system stats data.
   *
   * @constructor
   * @extends {StackedBarsTrack}
   */

  const SystemStatsInstanceTrack = tr.ui.b.define(
      'tr-ui-e-system-stats-instance-track', tr.ui.tracks.StackedBarsTrack);

  SystemStatsInstanceTrack.prototype = {

    __proto__: tr.ui.tracks.StackedBarsTrack.prototype,

    decorate(viewport) {
      tr.ui.tracks.StackedBarsTrack.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('tr-ui-e-system-stats-instance-track');
      this.objectInstance_ = null;
    },

    set objectInstances(objectInstances) {
      if (!objectInstances) {
        this.objectInstance_ = [];
        return;
      }
      if (objectInstances.length !== 1) {
        throw new Error('Bad object instance count.');
      }
      this.objectInstance_ = objectInstances[0];
      if (this.objectInstance_ !== null) {
        this.computeRates_(this.objectInstance_.snapshots);
        this.maxStats_ = this.computeMaxStats_(
            this.objectInstance_.snapshots);
      }
    },

    computeRates_(snapshots) {
      for (let i = 0; i < snapshots.length; i++) {
        const snapshot = snapshots[i];
        const stats = snapshot.getStats();
        let prevSnapshot;

        if (i === 0) {
          // Deltas will be zero.
          prevSnapshot = snapshots[0];
        } else {
          prevSnapshot = snapshots[i - 1];
        }
        const prevStats = prevSnapshot.getStats();
        let timeIntervalSeconds = (snapshot.ts - prevSnapshot.ts) / 1000;
        // Prevent divide by zero.
        if (timeIntervalSeconds === 0) {
          timeIntervalSeconds = 1;
        }

        this.computeRatesRecursive_(prevStats, stats,
            timeIntervalSeconds);
      }
    },

    computeRatesRecursive_(prevStats, stats,
        timeIntervalSeconds) {
      for (const statName in stats) {
        if (stats[statName] instanceof Object) {
          this.computeRatesRecursive_(prevStats[statName],
              stats[statName],
              timeIntervalSeconds);
        } else {
          if (statName === 'sectors_read') {
            stats.bytes_read_per_sec = (stats.sectors_read -
                                           prevStats.sectors_read) *
                                          512 / timeIntervalSeconds;
          }
          if (statName === 'sectors_written') {
            stats.bytes_written_per_sec =
                (stats.sectors_written -
                 prevStats.sectors_written) *
                512 / timeIntervalSeconds;
          }
          if (statName === 'pgmajfault') {
            stats.pgmajfault_per_sec = (stats.pgmajfault -
                                           prevStats.pgmajfault) /
                                          timeIntervalSeconds;
          }
          if (statName === 'pswpin') {
            stats.bytes_swpin_per_sec = (stats.pswpin -
                                            prevStats.pswpin) *
                                           1000 / timeIntervalSeconds;
          }
          if (statName === 'pswpout') {
            stats.bytes_swpout_per_sec = (stats.pswpout -
                                             prevStats.pswpout) *
                                            1000 / timeIntervalSeconds;
          }
        }
      }
    },

    computeMaxStats_(snapshots) {
      const maxStats = {};
      statCount = 0;

      for (let i = 0; i < snapshots.length; i++) {
        const snapshot = snapshots[i];
        const stats = snapshot.getStats();

        this.computeMaxStatsRecursive_(stats, maxStats,
            excludedStats);
      }

      return maxStats;
    },

    computeMaxStatsRecursive_(stats, maxStats, excludedStats) {
      for (const statName in stats) {
        if (stats[statName] instanceof Object) {
          if (!(statName in maxStats)) {
            maxStats[statName] = {};
          }

          let excludedNested;
          if (excludedStats && statName in excludedStats) {
            excludedNested = excludedStats[statName];
          } else {
            excludedNested = null;
          }

          this.computeMaxStatsRecursive_(stats[statName],
              maxStats[statName],
              excludedNested);
        } else {
          if (excludedStats && statName in excludedStats) {
            continue;
          }
          if (!(statName in maxStats)) {
            maxStats[statName] = 0;
            statCount++;
          }
          if (stats[statName] > maxStats[statName]) {
            maxStats[statName] = stats[statName];
          }
        }
      }
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
    },

    draw(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GENERAL_EVENT:
          this.drawStatBars_(viewLWorld, viewRWorld);
          break;
      }
    },

    drawStatBars_(viewLWorld, viewRWorld) {
      const ctx = this.context();
      const pixelRatio = window.devicePixelRatio || 1;

      const bounds = this.getBoundingClientRect();
      const width = bounds.width * pixelRatio;
      const height = (bounds.height * pixelRatio) / statCount;

      // Culling parameters.
      const vp = this.viewport.currentDisplayTransform;

      // Scale by the size of the largest snapshot.
      const maxStats = this.maxStats_;

      const objectSnapshots = this.objectInstance_.snapshots;
      let lowIndex = tr.b.findLowIndexInSortedArray(
          objectSnapshots,
          function(snapshot) {
            return snapshot.ts;
          },
          viewLWorld);

      // Assure that the stack with the left edge off screen still gets drawn
      if (lowIndex > 0) lowIndex -= 1;

      for (let i = lowIndex; i < objectSnapshots.length; ++i) {
        const snapshot = objectSnapshots[i];
        const trace = snapshot.getStats();
        const currentY = height;

        const left = snapshot.ts;
        if (left > viewRWorld) break;

        let leftView = vp.xWorldToView(left);
        if (leftView < 0) leftView = 0;

        // Compute the edges for the column graph bar.
        let right;
        if (i !== objectSnapshots.length - 1) {
          right = objectSnapshots[i + 1].ts;
        } else {
          // If this is the last snaphot of multiple snapshots, use the width of
          // the previous snapshot for the width.
          if (objectSnapshots.length > 1) {
            right = objectSnapshots[i].ts + (objectSnapshots[i].ts -
                objectSnapshots[i - 1].ts);
          } else {
            // If there's only one snapshot, use max bounds as the width.
            right = this.objectInstance_.parent.model.bounds.max;
          }
        }

        let rightView = vp.xWorldToView(right);
        if (rightView > width) {
          rightView = width;
        }

        // Floor the bounds to avoid a small gap between stacks.
        leftView = Math.floor(leftView);
        rightView = Math.floor(rightView);

        // Descend into nested stats.
        this.drawStatBarsRecursive_(snapshot,
            leftView,
            rightView,
            height,
            trace,
            maxStats,
            currentY);

        if (i === lowIndex) {
          this.drawStatNames_(leftView, height, currentY, '', maxStats);
        }
      }
      ctx.lineWidth = 1;
    },

    drawStatBarsRecursive_(snapshot,
        leftView,
        rightView,
        height,
        stats,
        maxStats,
        currentY) {
      const ctx = this.context();

      for (const statName in maxStats) {
        if (stats[statName] instanceof Object) {
          // Use the y-position returned from the recursive call.
          currentY = this.drawStatBarsRecursive_(snapshot,
              leftView,
              rightView,
              height,
              stats[statName],
              maxStats[statName],
              currentY);
        } else {
          const maxStat = maxStats[statName];

          // Draw a bar for the stat. The height of the bar is scaled
          // against the largest value of the stat across all snapshots.
          ctx.fillStyle = EventPresenter.getBarSnapshotColor(
              snapshot, Math.round(currentY / height));

          let barHeight;
          if (maxStat > 0) {
            barHeight = height * Math.max(stats[statName], 0) / maxStat;
          } else {
            barHeight = 0;
          }

          ctx.fillRect(leftView, currentY - barHeight,
              Math.max(rightView - leftView, 1), barHeight);

          currentY += height;
        }
      }

      // Return the updated y-position.
      return currentY;
    },

    drawStatNames_(leftView, height, currentY, prefix, maxStats) {
      const ctx = this.context();

      ctx.textAlign = 'end';
      ctx.font = '12px Arial';
      ctx.fillStyle = '#000000';
      for (const statName in maxStats) {
        if (maxStats[statName] instanceof Object) {
          currentY = this.drawStatNames_(leftView, height, currentY,
              statName, maxStats[statName]);
        } else {
          let fullname = statName;

          if (prefix !== '') {
            fullname = prefix + ' :: ' + statName;
          }

          ctx.fillText(fullname, leftView - 10, currentY - height / 4);
          currentY += height;
        }
      }

      return currentY;
    }
  };

  tr.ui.tracks.ObjectInstanceTrack.register(
      SystemStatsInstanceTrack,
      {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsInstanceTrack,
  };
});


'use strict';

tr.exportTo('tr.ui.e.system_stats', function() {
  /*
   * Displays a system stats snapshot in a human readable form. @constructor
   */
  const SystemStatsSnapshotView = tr.ui.b.define(
      'tr-ui-e-system-stats-snapshot-view', tr.ui.analysis.ObjectSnapshotView);

  SystemStatsSnapshotView.prototype = {
    __proto__: tr.ui.analysis.ObjectSnapshotView.prototype,

    decorate() {
      Polymer.dom(this).classList.add('tr-ui-e-system-stats-snapshot-view');
    },

    updateContents() {
      const snapshot = this.objectSnapshot_;
      if (!snapshot || !snapshot.getStats()) {
        Polymer.dom(this).textContent = 'No system stats snapshot found.';
        return;
      }
      // Clear old snapshot view.
      Polymer.dom(this).textContent = '';

      const stats = snapshot.getStats();
      Polymer.dom(this).appendChild(this.buildList_(stats));
    },

    isFloat(n) {
      return typeof n === 'number' && n % 1 !== 0;
    },

    /**
     * Creates nested lists.
     *
     * @param {Object} stats The current trace system stats entry.
     * @return {Element} A ul list element.
     */
    buildList_(stats) {
      const statList = document.createElement('ul');

      for (const statName in stats) {
        const statText = document.createElement('li');
        Polymer.dom(statText).textContent = '' + statName + ': ';
        Polymer.dom(statList).appendChild(statText);

        if (stats[statName] instanceof Object) {
          Polymer.dom(statList).appendChild(this.buildList_(stats[statName]));
        } else {
          if (this.isFloat(stats[statName])) {
            Polymer.dom(statText).textContent += stats[statName].toFixed(2);
          } else {
            Polymer.dom(statText).textContent += stats[statName];
          }
        }
      }

      return statList;
    }
  };

  tr.ui.analysis.ObjectSnapshotView.register(
      SystemStatsSnapshotView,
      {typeName: 'base::TraceEventSystemStatsMonitor::SystemStats'});

  return {
    SystemStatsSnapshotView,
  };
});


'use strict';

tr.exportTo('tr.ui.e.v8', function() {
  // Instance types that should not be part of the overview as they are either
  // double-attributed (e.g. also part of some other instance type) or do not
  // make any sense in memory profiling.
  const IGNORED_ENTRIES = {
    // Ignore code aging entries as they are already accounted in their
    // respective code instance types.
    match: full => full.startsWith('*CODE_AGE_')
  };

  // Groups are matched on a first-matched basis, i.e., once a group matches we
  // are done with an entry.
  // Requires properties:
  // - match(full): Return true iff |full| should be part of the group and
  //   false otherwise.
  // - keyToName(key): Returns the human readable name for |key|.
  // - nameToKey(name): Returns the key for |name|.
  // Optional properties:
  // - realEntry: A string representing the actual entry in the trace. If this
  //   entry is present an additional entry UNKNOWN will be created holding all
  //   the unaccounted data.
  const INSTANCE_TYPE_GROUPS = {
    FIXED_ARRAY_TYPE: {
      match: full => full.startsWith('*FIXED_ARRAY_'),
      realEntry: 'FIXED_ARRAY_TYPE',
      keyToName: key => key.slice('*FIXED_ARRAY_'.length)
          .slice(0, -('_SUB_TYPE'.length)),
      nameToKey: name => '*FIXED_ARRAY_' + name + '_SUB_TYPE'
    },
    CODE_TYPE: {
      match: full => full.startsWith('*CODE_'),
      realEntry: 'CODE_TYPE',
      keyToName: key => key.slice('*CODE_'.length),
      nameToKey: name => '*CODE_' + name
    },
    JS_OBJECTS: {
      match: full => full.startsWith('JS_'),
      keyToName: key => key,
      nameToKey: name => name
    },
    Strings: {
      match: full => full.endsWith('STRING_TYPE'),
      keyToName: key => key,
      nameToKey: name => name
    }
  };

  const DIFF_COLOR = {
    GREEN: '#64DD17',
    RED: '#D50000'
  };

  function computePercentage(valueA, valueB) {
    if (valueA === 0) return 0;
    return valueA / valueB * 100;
  }

  class DiffEntry {
    constructor(originalEntry, diffEntry) {
      this.originalEntry_ = originalEntry;
      this.diffEntry_ = diffEntry;
    }
    get title() {
      return this.diffEntry_.title;
    }
    get overall() {
      return this.diffEntry_.overall;
    }
    get overAllocated() {
      return this.diffEntry_.overAllocated;
    }
    get count() {
      return this.diffEntry_.count;
    }
    get overallPercent() {
      return this.diffEntry_.overallPercent;
    }
    get overAllocatedPercent() {
      return this.diffEntry_.overAllocatedPercent;
    }
    get origin() {
      return this.originalEntry_;
    }
    get diff() {
      return this.diffEntry_;
    }
    get subRows() {
      return this.diffEntry_.subRows;
    }
  }

  class Entry {
    constructor(title, count, overall, overAllocated, histogram,
        overAllocatedHistogram) {
      this.title_ = title;
      this.overall_ = overall;
      this.count_ = count;
      this.overAllocated_ = overAllocated;
      this.histogram_ = histogram;
      this.overAllocatedHistogram_ = overAllocatedHistogram;
      this.bucketSize_ = this.histogram_.length;
      this.overallPercent_ = 100;
      this.overAllocatedPercent_ = 100;
    }

    get title() {
      return this.title_;
    }

    get overall() {
      return this.overall_;
    }

    get count() {
      return this.count_;
    }

    get overAllocated() {
      return this.overAllocated_;
    }

    get histogram() {
      return this.histogram_;
    }

    get overAllocatedHistogram() {
      return this.overAllocatedHistogram_;
    }

    get bucketSize() {
      return this.bucketSize_;
    }

    get overallPercent() {
      return this.overallPercent_;
    }

    set overallPercent(value) {
      this.overallPercent_ = value;
    }

    get overAllocatedPercent() {
      return this.overAllocatedPercent_;
    }

    set overAllocatedPercent(value) {
      this.overAllocatedPercent_ = value;
    }

    setFromObject(obj) {
      this.count_ = obj.count;
      // Calculate memory in KB.
      this.overall_ = obj.overall / 1024;
      this.overAllocated_ = obj.over_allocated / 1024;
      this.histogram_ = obj.histogram;
      this.overAllocatedHistogram_ = obj.over_allocated_histogram;
    }

    diff(other) {
      const entry = new Entry(this.title_, other.count_ - this.count,
                             other.overall_ - this.overall,
                             other.overAllocated_ - this.overAllocated, [], []);
      entry.overallPercent = computePercentage(entry.overall, this.overall);
      entry.overAllocatedPercent = computePercentage(entry.overAllocated,
          this.overAllocated);
      return new DiffEntry(this, entry);
    }
  }

  class GroupedEntry extends Entry {
    constructor(title, count, overall, overAllocated, histogram,
        overAllocatedHistogram) {
      super(title, count, overall, overAllocated, histogram,
          overAllocatedHistogram);
      this.histogram_.fill(0);
      this.overAllocatedHistogram_.fill(0);
      this.entries_ = new Map();
    }

    get title() {
      return this.title_;
    }

    set title(value) {
      this.title_ = value;
    }

    get subRows() {
      return Array.from(this.entries_.values());
    }

    getEntryFromTitle(title) {
      return this.entries_.get(title);
    }

    add(entry) {
      this.count_ += entry.count;
      this.overall_ += entry.overall;
      this.overAllocated_ += entry.overAllocated;
      if (this.bucketSize_ === entry.bucketSize) {
        for (let i = 0; i < this.bucketSize_; ++i) {
          this.histogram_[i] += entry.histogram[i];
          this.overAllocatedHistogram_[i] += entry.overAllocatedHistogram[i];
        }
      }
      this.entries_.set(entry.title, entry);
    }

    accumulateUnknown(title) {
      let unknownCount = this.count_;
      let unknownOverall = this.overall_;
      let unknownOverAllocated = this.overAllocated_;
      const unknownHistogram = tr.b.deepCopy(this.histogram_);
      const unknownOverAllocatedHistogram =
          tr.b.deepCopy(this.overAllocatedHistogram_);
      for (const entry of this.entries_.values()) {
        unknownCount -= entry.count;
        unknownOverall -= entry.overall;
        unknownOverAllocated -= entry.overAllocated;
        for (let i = 0; i < this.bucketSize_; ++i) {
          unknownHistogram[i] -= entry.histogram[i];
          unknownOverAllocatedHistogram[i] -= entry.overAllocatedHistogram[i];
        }
      }
      unknownOverAllocated =
        unknownOverAllocated < 0 ? 0 : unknownOverAllocated;
      this.entries_.set(title, new Entry(title, unknownCount, unknownOverall,
                                         unknownOverAllocated, unknownHistogram,
                                         unknownOverAllocatedHistogram));
    }

    calculatePercentage() {
      for (const entry of this.entries_.values()) {
        entry.overallPercent = computePercentage(entry.overall, this.overall_);
        entry.overAllocatedPercent =
          computePercentage(entry.overAllocated, this.overAllocated_);

        if (entry instanceof GroupedEntry) entry.calculatePercentage();
      }
    }

    diff(other) {
      let newTitle = '';
      if (this.title_.startsWith('Isolate')) {
        newTitle = 'Total';
      } else {
        newTitle = this.title_;
      }
      const result = new GroupedEntry(newTitle, 0, 0, 0, [], []);
      for (const entry of this.entries_) {
        const otherEntry = other.getEntryFromTitle(entry[0]);
        if (otherEntry === undefined) continue;
        result.add(entry[1].diff(otherEntry));
      }
      result.overallPercent = computePercentage(result.overall, this.overall);
      result.overAllocatedPercent = computePercentage(result.overAllocated,
          this.overAllocated);
      return new DiffEntry(this, result);
    }
  }

  function createSelector(targetEl, defaultValue, items, callback) {
    const selectorEl = document.createElement('select');
    selectorEl.addEventListener('change', callback.bind(targetEl));
    const defaultOptionEl = document.createElement('option');
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const optionEl = document.createElement('option');
      Polymer.dom(optionEl).textContent = item.label;
      optionEl.targetPropertyValue = item.value;
      optionEl.item = item;
      Polymer.dom(selectorEl).appendChild(optionEl);
    }
    selectorEl.__defineGetter__('selectedValue', function(v) {
      if (selectorEl.children[selectorEl.selectedIndex] === undefined) {
        return undefined;
      }
      return selectorEl.children[selectorEl.selectedIndex].targetPropertyValue;
    });
    selectorEl.__defineGetter__('selectedItem', function(v) {
      if (selectorEl.children[selectorEl.selectedIndex] === undefined) {
        return undefined;
      }
      return selectorEl.children[selectorEl.selectedIndex].item;
    });
    selectorEl.__defineSetter__('selectedValue', function(v) {
      for (let i = 0; i < selectorEl.children.length; i++) {
        const value = selectorEl.children[i].targetPropertyValue;
        if (value === v) {
          const changed = selectorEl.selectedIndex !== i;
          if (changed) {
            selectorEl.selectedIndex = i;
            callback();
          }
          return;
        }
      }
      throw new Error('Not a valid value');
    });
    selectorEl.selectedIndex = -1;

    return selectorEl;
  }

  function plusMinus(value, toFixed = 3) {
    return (value > 0 ? '+' : '') + value.toFixed(toFixed);
  }

  function addArrow(value) {
    if (value === 0) return value;
    if (value === Number.NEGATIVE_INFINITY) return '\u2193\u221E';
    if (value === Number.POSITIVE_INFINITY) return '\u2191\u221E';
    return (value > 0 ? '\u2191' : '\u2193') + Math.abs(value.toFixed(3));
  }

  Polymer({
    is: 'tr-ui-e-v8-gc-objects-stats-table',

    ready() {
      this.$.diffOption.style.display = 'none';
      this.isolateEntries_ = [];
      this.selector1_ = undefined;
      this.selector2_ = undefined;
    },

    constructDiffTable_(table) {
      this.$.diffTable.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
      this.$.diffTable.tableColumns = [
        {
          title: 'Component',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.title;
            return typeEl;
          },
          showExpandButtons: true
        },
        {
          title: 'Overall Memory(KB)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = row.origin.overall.toFixed(3);
            return spanEl;
          },
          cmp(a, b) {
            return a.origin.overall - b.origin.overall;
          }
        },
        {
          title: 'diff(KB)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = plusMinus(row.overall);
            if (row.overall > 0) {
              spanEl.style.color = DIFF_COLOR.RED;
            } else if (row.overall < 0) {
              spanEl.style.color = DIFF_COLOR.GREEN;
            }
            return spanEl;
          },
          cmp(a, b) {
            return a.overall - b.overall;
          }
        },
        {
          title: 'diff(%)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = addArrow(row.overallPercent);
            if (row.overall > 0) {
              spanEl.style.color = DIFF_COLOR.RED;
            } else if (row.overall < 0) {
              spanEl.style.color = DIFF_COLOR.GREEN;
            }
            return spanEl;
          },
          cmp(a, b) {
            return a.overall - b.overall;
          }
        },
        {
          title: 'Over Allocated Memory(KB)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = row.origin.overAllocated.toFixed(3);
            return spanEl;
          },
          cmp(a, b) {
            return a.origin.overAllocated - b.origin.overAllocated;
          }
        },
        {
          title: 'diff(KB)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = plusMinus(row.overAllocated);
            if (row.overAllocated > 0) {
              spanEl.style.color = DIFF_COLOR.RED;
            } else if (row.overAllocated < 0) {
              spanEl.style.color = DIFF_COLOR.GREEN;
            }
            return spanEl;
          },
          cmp(a, b) {
            return a.overAllocated - b.overAllocated;
          }
        },
        {
          title: 'diff(%)',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = addArrow(row.overAllocatedPercent);
            if (row.overAllocated > 0) {
              spanEl.style.color = DIFF_COLOR.RED;
            } else if (row.overAllocated < 0) {
              spanEl.style.color = DIFF_COLOR.GREEN;
            }
            return spanEl;
          },
          cmp(a, b) {
            return a.overAllocated - b.overAllocated;
          }
        },
        {
          title: 'Count',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = row.origin.count;
            return spanEl;
          },
          cmp(a, b) {
            return a.origin.count - b.origin.count;
          }
        },
        {
          title: 'diff',
          value(row) {
            const spanEl = tr.ui.b.createSpan();
            spanEl.innerText = plusMinus(row.count, 0);
            if (row.count > 0) {
              spanEl.style.color = DIFF_COLOR.RED;
            } else if (row.count < 0) {
              spanEl.style.color = DIFF_COLOR.GREEN;
            }
            return spanEl;
          },
          cmp(a, b) {
            return a.count - b.count;
          }
        },
      ];
    },

    buildOptions_() {
      const items = [];
      for (const isolateEntry of this.isolateEntries_) {
        items.push({
          label: isolateEntry.title,
          value: isolateEntry
        });
      }
      this.$.diffOption.style.display = 'inline-block';
      this.selector1_ = createSelector(
          this, '', items, this.diffOptionChanged_);
      Polymer.dom(this.$.diffOption).appendChild(this.selector1_);
      const spanEl = tr.ui.b.createSpan();
      spanEl.innerText = ' VS ';
      Polymer.dom(this.$.diffOption).appendChild(spanEl);
      this.selector2_ = createSelector(
          this, '', items, this.diffOptionChanged_);
      Polymer.dom(this.$.diffOption).appendChild(this.selector2_);
    },

    diffOptionChanged_() {
      const isolateEntry1 = this.selector1_.selectedValue;
      const isolateEntry2 = this.selector2_.selectedValue;
      if (isolateEntry1 === undefined || isolateEntry2 === undefined) {
        return;
      }
      if (isolateEntry1 === isolateEntry2) {
        this.$.diffTable.tableRows = [];
        this.$.diffTable.rebuild();
        return;
      }
      this.$.diffTable.tableRows = [isolateEntry1.diff(isolateEntry2)];
      this.$.diffTable.rebuild();
    },

    constructTable_() {
      this.$.table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
      this.$.table.tableColumns = [
        {
          title: 'Component',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.title;
            return typeEl;
          },
          showExpandButtons: true
        },
        {
          title: 'Overall Memory (KB)',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.overall.toFixed(3);
            return typeEl;
          },
          cmp(a, b) {
            return a.overall - b.overall;
          }
        },
        {
          title: 'Over Allocated Memory (KB)',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.overAllocated.toFixed(3);
            return typeEl;
          },
          cmp(a, b) {
            return a.overAllocated - b.overAllocated;
          }
        },
        {
          title: 'Overall Count',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.count;
            return typeEl;
          },
          cmp(a, b) {
            return a.count - b.count;
          }
        },
        {
          title: 'Overall Memory Percent',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.overallPercent.toFixed(3) + '%';
            return typeEl;
          },
          cmp(a, b) {
            return a.overall - b.overall;
          }
        },
        {
          title: 'Overall Allocated Memory Percent',
          value(row) {
            const typeEl = document.createElement('span');
            typeEl.innerText = row.overAllocatedPercent.toFixed(3) + '%';
            return typeEl;
          },
          cmp(a, b) {
            return a.overAllocated - b.overAllocated;
          }
        }
      ];

      this.$.table.sortColumnIndex = 1;
      this.$.table.sortDescending = true;
    },

    buildSubEntry_(objects, groupEntry, keyToName) {
      const typeGroup = INSTANCE_TYPE_GROUPS[groupEntry.title];
      for (const instanceType of typeGroup) {
        const e = objects[instanceType];
        if (e === undefined) continue;
        delete objects[instanceType];
        let title = instanceType;
        if (keyToName !== undefined) title = keyToName(title);
        // Represent memery in KB unit.
        groupEntry.add(new Entry(title, e.count, e.overall / 1024,
                                 e.over_allocated / 1024, e.histogram,
                                 e.over_allocated_histogram));
      }
    },

    buildUnGroupedEntries_(objects, objectEntry, bucketSize) {
      for (const title of Object.getOwnPropertyNames(objects)) {
        const obj = objects[title];
        const groupedEntry = new GroupedEntry(title, 0, 0, 0,
                                            new Array(bucketSize),
                                            new Array(bucketSize));
        groupedEntry.setFromObject(obj);
        objectEntry.add(groupedEntry);
      }
    },

    createGroupEntries_(groupEntries, objects, bucketSize) {
      for (const groupName of Object.getOwnPropertyNames(
          INSTANCE_TYPE_GROUPS)) {
        const groupEntry = new GroupedEntry(groupName, 0, 0, 0,
                                          new Array(bucketSize),
                                          new Array(bucketSize));
        if (INSTANCE_TYPE_GROUPS[groupName].realEntry !== undefined) {
          groupEntry.savedRealEntry =
              objects[INSTANCE_TYPE_GROUPS[groupName].realEntry];
          delete objects[INSTANCE_TYPE_GROUPS[groupName].realEntry];
        }
        groupEntries[groupName] = groupEntry;
      }
    },

    buildGroupEntries_(groupEntries, objectEntry) {
      for (const groupName of Object.getOwnPropertyNames(groupEntries)) {
        const groupEntry = groupEntries[groupName];
        if (groupEntry.savedRealEntry !== undefined) {
          groupEntry.setFromObject(groupEntry.savedRealEntry);
          groupEntry.accumulateUnknown('UNKNOWN');
          delete groupEntry.savedRealEntry;
        }
        objectEntry.add(groupEntry);
      }
    },

    buildSubEntriesForGroups_(groupEntries, objects) {
      for (const instanceType of Object.getOwnPropertyNames(objects)) {
        if (IGNORED_ENTRIES.match(instanceType)) {
          delete objects[instanceType];
          continue;
        }
        const e = objects[instanceType];
        for (const name of Object.getOwnPropertyNames(INSTANCE_TYPE_GROUPS)) {
          const group = INSTANCE_TYPE_GROUPS[name];
          if (group.match(instanceType)) {
            groupEntries[name].add(new Entry(
                group.keyToName(instanceType), e.count, e.overall / 1024,
                e.over_allocated / 1024, e.histogram,
                e.over_allocated_histogram));
            delete objects[instanceType];
          }
        }
      }
    },

    build_(objects, objectEntry, bucketSize) {
      delete objects.END;
      const groupEntries = {};
      this.createGroupEntries_(groupEntries, objects, bucketSize);
      this.buildSubEntriesForGroups_(groupEntries, objects);
      this.buildGroupEntries_(groupEntries, objectEntry);
      this.buildUnGroupedEntries_(objects, objectEntry, bucketSize);
    },

    set selection(slices) {
      slices.sortEvents(function(a, b) {
        return b.start - a.start;
      });
      const previous = undefined;
      for (const slice of slices) {
        if (!slice instanceof tr.e.v8.V8GCStatsThreadSlice) continue;
        const liveObjects = slice.liveObjects;
        const deadObjects = slice.deadObjects;
        const isolate = liveObjects.isolate;

        const isolateEntry =
            new GroupedEntry(
              'Isolate_' + isolate + ' at ' + slice.start.toFixed(3) + ' ms',
              0, 0, 0, [], []);
        const liveEntry = new GroupedEntry('live objects', 0, 0, 0, [], []);
        const deadEntry = new GroupedEntry('dead objects', 0, 0, 0, [], []);

        const liveBucketSize = liveObjects.bucket_sizes.length;
        const deadBucketSize = deadObjects.bucket_sizes.length;

        this.build_(tr.b.deepCopy(liveObjects.type_data), liveEntry,
            liveBucketSize);
        isolateEntry.add(liveEntry);

        this.build_(tr.b.deepCopy(deadObjects.type_data), deadEntry,
            deadBucketSize);
        isolateEntry.add(deadEntry);

        isolateEntry.calculatePercentage();
        this.isolateEntries_.push(isolateEntry);
      }
      this.updateTable_();

      if (slices.length > 1) {
        this.buildOptions_();
        this.constructDiffTable_();
      }
    },

    updateTable_() {
      this.constructTable_();
      this.$.table.tableRows = this.isolateEntries_;
      this.$.table.rebuild();
    },
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-e-multi-v8-gc-stats-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.gcObjectsStats.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-multi-v8-gc-stats-thread-slice-sub-view',
    tr.e.v8.V8GCStatsThreadSlice,
    {
      multi: true,
      title: 'V8 GC Stats slices'
    }
);



'use strict';

tr.exportTo('tr.e.v8', function() {
  const IC_STATS_PROPERTIES = [
    'type', 'category', 'scriptName', 'filePosition', 'state', 'isNative',
    'map', 'propertiesMode', 'numberOfOwnProperties', 'instanceType'
  ];

  class ICStatsEntry {
    constructor(obj) {
      this.type_ = obj.type;
      if (this.type_.includes('Store')) {
        this.category_ = 'Store';
      } else if (this.type_.includes('Load')) {
        this.category_ = 'Load';
      }
      this.state_ = obj.state;
      if (obj.functionName) {
        this.functionName_ = obj.optimized ? '*' : '~';
        this.functionName_ += obj.functionName.length === 0 ?
          '(anonymous function)' : obj.functionName;
      }
      this.offset_ = obj.offset;
      this.scriptName_ = obj.scriptName ? obj.scriptName : 'unknown';
      this.isNative_ = obj.scriptName && obj.scriptName.includes('native');
      this.lineNum_ = obj.lineNum ? obj.lineNum : 'unknown';
      this.filePosition_ = this.scriptName_ + ':' + this.lineNum_;
      if (this.functionName_) {
        this.filePosition_ += ' ' + this.functionName_ + '+' + this.offset_;
      }
      this.constructor_ = obj.constructor ? false : true;
      this.map_ = obj.map;
      if (this.map_) {
        this.propertiesMode_ = obj.dict === 0 ? 'slow' : 'fast';
      } else {
        this.propertiesMode_ = 'unknown';
      }
      this.numberOfOwnProperties_ = obj.own;
      this.instanceType_ = obj.instanceType;
      this.key_ = obj.key;
    }

    get type() {
      return this.type_;
    }

    get category() {
      return this.category_;
    }

    get state() {
      return this.state_;
    }

    get functionName() {
      return this.functionName_;
    }

    get offset() {
      return this.offset_;
    }

    get scriptName() {
      return this.scriptName_;
    }

    get isNative() {
      return this.isNative_;
    }

    get lineNumber() {
      return this.lineNum_;
    }

    get isConstructor() {
      return this.constructor_;
    }

    get map() {
      return this.map_;
    }

    get propertiesMode() {
      return this.propertiesMode_;
    }

    get numberOfOwnProperties() {
      return this.numberOfOwnProperties_;
    }

    get instanceType() {
      return this.instanceType_;
    }

    get filePosition() {
      return this.filePosition_;
    }
  }

  class ICStatsEntryGroup {
    constructor(property, key) {
      this.property_ = property;
      this.key_ = key;
      this.percentage_ = 0;
      this.entries_ = [];
      // This is map used to cache all sub grouping result
      this.subGroup_ = undefined;
    }

    static groupBy(groups, entries, property) {
      for (const entry of entries) {
        const key = entry[property];
        let group = groups.get(key);
        if (!group) {
          group = new ICStatsEntryGroup(property, key);
          groups.set(key, group);
        }
        group.add(entry);
      }
      for (const group of groups.values()) {
        group.percentage = group.length / entries.length;
      }
    }

    add(entry) {
      this.entries_.push(entry);
    }

    createSubGroup() {
      if (this.subGroup_) return this.subGroup_;
      this.subGroup_ = new Map();
      for (const property of IC_STATS_PROPERTIES) {
        if (property === this.property_) continue;
        const groups = new Map();
        this.subGroup_.set(property, groups);
        ICStatsEntryGroup.groupBy(groups, this.entries_, property);
      }
      return this.subGroup_;
    }

    get entries() {
      return this.entries_;
    }

    get key() {
      return this.key_;
    }

    get length() {
      return this.entries_.length;
    }

    get percentage() {
      return this.percentage_;
    }

    set percentage(value) {
      this.percentage_ = value;
    }
  }

  class ICStatsCollection {
    constructor() {
      this.entries_ = [];
      // Used to cache property grouping result.
      this.groupedEntries_ = new Map();
    }

    add(entry) {
      this.entries_.push(entry);
    }

    groupBy(property) {
      if (this.groupedEntries_.has(property)) {
        return Array.from(this.groupedEntries_.get(property).values());
      }
      const groups = new Map();
      this.groupedEntries_.set(property, groups);
      ICStatsEntryGroup.groupBy(groups, this.entries_, property);
      return Array.from(groups.values());
    }

    get entries() {
      return this.entries_;
    }

    get length() {
      return this.entries_.length;
    }
  }

  return {
    IC_STATS_PROPERTIES,
    ICStatsEntry,
    ICStatsEntryGroup,
    ICStatsCollection,
  };
});


'use strict';

tr.exportTo('tr.ui.e.v8', function() {
  const PROPERTIES = tr.e.v8.IC_STATS_PROPERTIES.map(
      x => {return {label: x, value: x};});
  const ICStatsEntry = tr.e.v8.ICStatsEntry;
  const ICStatsEntryGroup = tr.e.v8.ICStatsEntryGroup;
  const ICStatsCollection = tr.e.v8.ICStatsCollection;

  Polymer({
    is: 'tr-ui-e-v8-ic-stats-table',

    ready() {
      this.icStatsCollection_ = new ICStatsCollection();
      this.groupKey_ = PROPERTIES[0].value;
      this.selector_ = tr.ui.b.createSelector(this, 'groupKey',
          'v8ICStatsGroupKey',
          this.groupKey_, PROPERTIES);
      Polymer.dom(this.$.groupOption).appendChild(this.selector_);
    },

    get groupKey() {
      return this.groupKey_;
    },

    set groupKey(key) {
      this.groupKey_ = key;
      if (this.icStatsCollection_.length === 0) return;
      this.updateTable_(this.groupKey_);
    },

    constructTable_(table, groupKey) {
      table.tableColumns = [
        {
          title: '',
          value: row => {
            let expanded = false;
            const buttonEl = tr.ui.b.createButton('details', function() {
              const previousSibling = Polymer.dom(this).parentNode.parentNode;
              const parentNode = previousSibling.parentNode;
              if (expanded) {
                const trEls = parentNode.getElementsByClassName('subTable');
                Array.from(trEls).map(x => x.parentNode.removeChild(x));
                expanded = false;
                return;
              }
              expanded = true;
              const subGroups = row.createSubGroup();
              const tr = document.createElement('tr');
              tr.classList.add('subTable');
              tr.appendChild(document.createElement('td'));
              const td = document.createElement('td');
              td.colSpan = 3;
              for (const subGroup of subGroups) {
                const property = subGroup[0];
                const all = Array.from(subGroup[1].values());
                const group = all.slice(0, 20);
                const divEl = document.createElement('div');
                const spanEl = document.createElement('span');
                const subTableEl = document.createElement('tr-ui-b-table');

                spanEl.innerText = `Top 20 out of ${all.length}`;
                spanEl.style.fontWeight = 'bold';
                spanEl.style.fontSize = '14px';
                divEl.appendChild(spanEl);

                this.constructTable_(subTableEl, property);
                subTableEl.tableRows = group;
                subTableEl.rebuild();
                divEl.appendChild(subTableEl);
                td.appendChild(divEl);
              }
              tr.appendChild(td);
              parentNode.insertBefore(tr, previousSibling.nextSibling);
            });
            return buttonEl;
          }
        },
        {
          title: 'Percentage',
          value(row) {
            const spanEl = document.createElement('span');
            spanEl.innerText = (row.percentage * 100).toFixed(3) + '%';
            return spanEl;
          },
          cmp: (a, b) => a.percentage - b.percentage
        },
        {
          title: 'Count',
          value(row) {
            const spanEl = document.createElement('span');
            spanEl.innerText = row.length;
            return spanEl;
          },
          cmp: (a, b) => a.length - b.length
        },
        {
          title: groupKey,
          value(row) {
            const spanEl = document.createElement('span');
            spanEl.innerText = row.key ? row.key : '';
            return spanEl;
          }
        }
      ];

      table.sortColumnIndex = 1;
      table.sortDescending = true;
    },

    updateTable_(groupKey) {
      this.constructTable_(this.$.table, groupKey);
      this.$.table.tableRows = this.icStatsCollection_.groupBy(groupKey);
      this.$.table.rebuild();
    },

    set selection(slices) {
      for (const slice of slices) {
        for (const icStatsObj of slice.icStats) {
          const entry = new ICStatsEntry(icStatsObj);
          this.icStatsCollection_.add(entry);
        }
      }
      this.$.total.innerText = 'Total items: ' + this.icStatsCollection_.length;
      this.updateTable_(this.selector_.selectedValue);
    }
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-e-multi-v8-ic-stats-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.table.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-multi-v8-ic-stats-thread-slice-sub-view',
    tr.e.v8.V8ICStatsThreadSlice,
    {
      multi: true,
      title: 'V8 IC stats slices'
    }
);



'use strict';

tr.exportTo('tr.ui.e.v8', function() {
  const codeSearchURL_ = 'https://cs.chromium.org/search/?sq=package:chromium&type=cs&q=';

  function removeBlinkPrefix_(name) {
    if (name.startsWith('Blink_')) name = name.substring(6);
    return name;
  }

  function handleCodeSearchForV8_(event) {
    if (event.target.parentNode === undefined) return;
    let name = event.target.parentNode.entryName;
    if (name.startsWith('API_')) name = name.substring(4);
    const url = codeSearchURL_ + encodeURIComponent(name) + '+file:src/v8/src';
    window.open(url, '_blank');
  }

  function handleCodeSearchForBlink_(event) {
    if (event.target.parentNode === undefined) return;
    const name = event.target.parentNode.entryName;
    const url = codeSearchURL_ +
      encodeURIComponent('RuntimeCallStats::CounterId::k' + name) +
      '+file:src/third_party/WebKit/|src/out/Debug/';
    window.open(url, '_blank');
  }

  function createCodeSearchEl_(handleCodeSearch) {
    const codeSearchEl = document.createElement('span');
    codeSearchEl.innerText = '?';
    codeSearchEl.style.float = 'right';
    codeSearchEl.style.borderRadius = '5px';
    codeSearchEl.style.backgroundColor = '#EEE';
    codeSearchEl.addEventListener('click',
        handleCodeSearch.bind(this));
    return codeSearchEl;
  }

  const timeColumn_ = {
    title: 'Time',
    value(row) {
      const typeEl = document.createElement('span');
      typeEl.innerText = (row.time / 1000.0).toFixed(3) + ' ms';
      return typeEl;
    },
    width: '100px',
    cmp(a, b) {
      return a.time - b.time;
    }
  };

  const countColumn_ = {
    title: 'Count',
    value(row) {
      const typeEl = document.createElement('span');
      typeEl.innerText = row.count;
      return typeEl;
    },
    width: '100px',
    cmp(a, b) {
      return a.count - b.count;
    }
  };

  function percentColumn_(title, totalTime) {
    return {
      title,
      value(row) {
        const typeEl = document.createElement('span');
        typeEl.innerText = (row.time / totalTime * 100).toFixed(3) + '%';
        return typeEl;
      },
      width: '100px',
      cmp(a, b) {
        return a.time - b.time;
      }
    };
  }

  function nameColumn_(handleCodeSearch, modifyName) {
    return {
      title: 'Name',
      value(row) {
        const typeEl = document.createElement('span');
        let name = row.name;
        if (modifyName) name = modifyName(name);
        typeEl.innerText = name;
        if (!(row instanceof tr.e.v8.RuntimeStatsGroup)) {
          typeEl.title = 'click ? for code search';
          typeEl.entryName = name;
          const codeSearchEl = createCodeSearchEl_(handleCodeSearch);
          typeEl.appendChild(codeSearchEl);
        }
        return typeEl;
      },
      width: '200px',
      showExpandButtons: true
    };
  }

  function initializeCommonOptions_(table) {
    table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
    table.sortColumnIndex = 1;
    table.sortDescending = true;
    table.subRowsPropertyName = 'values';
  }

  Polymer({
    is: 'tr-ui-e-v8-runtime-call-stats-table',

    ready() {
      this.table_ = this.$.table;
      this.blink_rcs_table_ = this.$.blink_rcs_table;
      this.totalTime_ = 0;
    },

    constructV8RCSTable_(totalTime) {
      this.table_.tableColumns = [
        nameColumn_(handleCodeSearchForV8_),
        timeColumn_,
        countColumn_,
        percentColumn_('Percent', totalTime)
      ];

      initializeCommonOptions_(this.table_);
    },

    constructBlinkRCSTable_(blinkCppTotalTime) {
      this.blink_rcs_table_.tableColumns = [
        nameColumn_(handleCodeSearchForBlink_, removeBlinkPrefix_),
        timeColumn_,
        countColumn_,
        percentColumn_('Percent (of \'Blink C++\' + \'API\')',
            blinkCppTotalTime)
      ];

      initializeCommonOptions_(this.blink_rcs_table_);
    },

    set slices(slices) {
      const runtimeGroupCollection = new tr.e.v8.RuntimeStatsGroupCollection();
      runtimeGroupCollection.addSlices(slices);
      if (runtimeGroupCollection.totalTime > 0) {
        this.$.v8_rcs_heading.textContent = 'V8 Runtime Call Stats';
        this.constructV8RCSTable_(runtimeGroupCollection.totalTime);
        this.table_.tableRows = runtimeGroupCollection.runtimeGroups;
        this.table_.rebuild();
      }

      const blinkRCSGroupCollection =
        runtimeGroupCollection.blinkRCSGroupCollection;
      if (runtimeGroupCollection.blinkCppTotalTime > 0 &&
          blinkRCSGroupCollection.totalTime > 0) {
        this.$.blink_rcs_heading.textContent = 'Blink Runtime Call Stats';
        this.constructBlinkRCSTable_(runtimeGroupCollection.blinkCppTotalTime);
        this.blink_rcs_table_.tableRows = blinkRCSGroupCollection.runtimeGroups;
        this.blink_rcs_table_.rebuild();
      }
    }
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-e-multi-v8-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.runtimeCallStats.slices = selection;
    this.$.content.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-multi-v8-thread-slice-sub-view',
    tr.e.v8.V8ThreadSlice,
    {
      multi: true,
      title: 'V8 slices'
    }
);



'use strict';
Polymer({
  is: 'tr-ui-e-single-v8-gc-stats-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.content.selection = selection;
    this.$.gcObjectsStats.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-single-v8-gc-stats-thread-slice-sub-view',
    tr.e.v8.V8GCStatsThreadSlice,
    {
      multi: false,
      title: 'V8 GC stats slice'
    }
);



'use strict';
Polymer({
  is: 'tr-ui-e-single-v8-ic-stats-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.table.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-single-v8-ic-stats-thread-slice-sub-view',
    tr.e.v8.V8ICStatsThreadSlice,
    {
      multi: false,
      title: 'V8 IC stats slice'
    }
);



'use strict';
Polymer({
  is: 'tr-ui-e-single-v8-thread-slice-sub-view',
  behaviors: [tr.ui.analysis.AnalysisSubView],

  get selection() {
    return this.$.content.selection;
  },

  set selection(selection) {
    this.$.runtimeCallStats.slices = selection;
    this.$.content.selection = selection;
  }
});

tr.ui.analysis.AnalysisSubView.register(
    'tr-ui-e-single-v8-thread-slice-sub-view',
    tr.e.v8.V8ThreadSlice,
    {
      multi: false,
      title: 'V8 slice'
    }
);



'use strict';

tr.exportTo('tr.ui.b', function() {
  function Row(title, data, groupingKeyFuncs, rowStatsConstructor) {
    this.title = title;
    this.data_ = data;
    if (groupingKeyFuncs === undefined) {
      groupingKeyFuncs = [];
    }
    this.groupingKeyFuncs_ = groupingKeyFuncs;
    this.rowStatsConstructor_ = rowStatsConstructor;

    this.subRowsBuilt_ = false;
    this.subRows_ = undefined;

    this.rowStats_ = undefined;
  }

  Row.prototype = {
    getCurrentGroupingKeyFunc_() {
      if (this.groupingKeyFuncs_.length === 0) return undefined;
      return this.groupingKeyFuncs_[0];
    },

    get data() {
      return this.data_;
    },

    get rowStats() {
      if (this.rowStats_ === undefined) {
        this.rowStats_ = new this.rowStatsConstructor_(this);
      }
      return this.rowStats_;
    },

    rebuildSubRowsIfNeeded_() {
      if (this.subRowsBuilt_) return;
      this.subRowsBuilt_ = true;

      const groupingKeyFunc = this.getCurrentGroupingKeyFunc_();
      if (groupingKeyFunc === undefined) {
        this.subRows_ = undefined;
        return;
      }

      const dataByKey = {};
      let hasValues = false;
      this.data_.forEach(function(datum) {
        const key = groupingKeyFunc(datum);
        hasValues = hasValues || (key !== undefined);
        if (dataByKey[key] === undefined) {
          dataByKey[key] = [];
        }
        dataByKey[key].push(datum);
      });
      if (!hasValues) {
        this.subRows_ = undefined;
        return;
      }

      this.subRows_ = [];
      for (const key in dataByKey) {
        const row = new Row(key,
                          dataByKey[key],
                          this.groupingKeyFuncs_.slice(1),
                          this.rowStatsConstructor_);
        this.subRows_.push(row);
      }
    },

    get isExpanded() {
      return (this.subRows &&
              (this.subRows.length > 0) &&
              (this.subRows.length < 5));
    },

    get subRows() {
      this.rebuildSubRowsIfNeeded_();
      return this.subRows_;
    }
  };

  Polymer({
    is: 'tr-ui-b-grouping-table',

    created() {
      this.dataToGroup_ = undefined;
      this.groupBy_ = undefined;
      this.rowStatsConstructor_ = undefined;
    },

    get tableColumns() {
      return this.$.table.tableColumns;
    },

    set tableColumns(tableColumns) {
      this.$.table.tableColumns = tableColumns;
    },

    get tableRows() {
      return this.$.table.tableRows;
    },

    get sortColumnIndex() {
      return this.$.table.sortColumnIndex;
    },

    set sortColumnIndex(sortColumnIndex) {
      this.$.table.sortColumnIndex = sortColumnIndex;
    },

    get sortDescending() {
      return this.$.table.sortDescending;
    },

    set sortDescending(sortDescending) {
      this.$.table.sortDescending = sortDescending;
    },

    get selectionMode() {
      return this.$.table.selectionMode;
    },

    set selectionMode(selectionMode) {
      this.$.table.selectionMode = selectionMode;
    },

    get rowHighlightStyle() {
      return this.$.table.rowHighlightStyle;
    },

    set rowHighlightStyle(rowHighlightStyle) {
      this.$.table.rowHighlightStyle = rowHighlightStyle;
    },

    get cellHighlightStyle() {
      return this.$.table.cellHighlightStyle;
    },

    set cellHighlightStyle(cellHighlightStyle) {
      this.$.table.cellHighlightStyle = cellHighlightStyle;
    },

    get selectedColumnIndex() {
      return this.$.table.selectedColumnIndex;
    },

    set selectedColumnIndex(selectedColumnIndex) {
      this.$.table.selectedColumnIndex = selectedColumnIndex;
    },

    get selectedTableRow() {
      return this.$.table.selectedTableRow;
    },

    set selectedTableRow(selectedTableRow) {
      this.$.table.selectedTableRow = selectedTableRow;
    },

    get groupBy() {
      return this.groupBy_;
    },

    set groupBy(groupBy) {
      this.groupBy_ = groupBy;
      this.updateContents_();
    },

    get dataToGroup() {
      return this.dataToGroup_;
    },

    set dataToGroup(dataToGroup) {
      this.dataToGroup_ = dataToGroup;
      this.updateContents_();
    },

    get rowStatsConstructor() {
      return this.rowStatsConstructor_;
    },

    set rowStatsConstructor(rowStatsConstructor) {
      this.rowStatsConstructor_ = rowStatsConstructor;
      this.updateContents_();
    },

    rebuild() {
      this.$.table.rebuild();
    },

    updateContents_() {
      const groupBy = this.groupBy_ || [];
      const dataToGroup = this.dataToGroup_ || [];
      const rowStatsConstructor = this.rowStatsConstructor_ || function() {};

      const superRow = new Row('', dataToGroup, groupBy,
                             rowStatsConstructor);
      this.$.table.tableRows = superRow.subRows || [];
    }
  });

  return {
  };
});


'use strict';

tr.exportTo('tr.ui.b', function() {
  const THIS_DOC = document.currentScript.ownerDocument;

  Polymer({
    is: 'tr-ui-b-grouping-table-groupby-picker-group',

    created() {
      this.picker_ = undefined;
      this.group_ = undefined;
    },

    get picker() {
      return this.picker_;
    },

    set picker(picker) {
      this.picker_ = picker;
    },

    get group() {
      return this.group_;
    },

    set group(g) {
      this.group_ = g;
      this.$.label.textContent = g.label;
    },

    get enabled() {
      return this.$.enabled.checked;
    },

    set enabled(enabled) {
      this.$.enabled.checked = enabled;
      if (!this.enabled) {
        this.$.left.style.display = 'none';
        this.$.right.style.display = 'none';
      }
    },

    set isFirst(isFirst) {
      this.$.left.style.display = (!this.enabled || isFirst) ? 'none' :
        'inline';
    },

    set isLast(isLast) {
      this.$.right.style.display = (!this.enabled || isLast) ? 'none' :
        'inline';
    },

    moveLeft_() {
      this.picker.moveLeft_(this);
    },

    moveRight_() {
      this.picker.moveRight_(this);
    },

    onEnableChanged_() {
      if (!this.enabled) {
        this.$.left.style.display = 'none';
        this.$.right.style.display = 'none';
      }
      this.picker.onEnableChanged_(this);
    }
  });

  Polymer({
    is: 'tr-ui-b-grouping-table-groupby-picker',

    created() {
      this.settingsKey_ = undefined;
    },

    get settingsKey() {
      return this.settingsKey_;
    },

    set settingsKey(settingsKey) {
      this.settingsKey_ = settingsKey;
      if (this.$.container.children.length) {
        this.restoreSetting_();
      }
    },

    restoreSetting_() {
      if (this.settingsKey_ === undefined) return;
      this.currentGroupKeys = tr.b.Settings.get(this.settingsKey_,
          this.currentGroupKeys);
    },

    get possibleGroups() {
      return [...this.$.container.children].map(groupEl => groupEl.group);
    },

    set possibleGroups(possibleGroups) {
      Polymer.dom(this.$.container).textContent = '';
      for (let i = 0; i < possibleGroups.length; ++i) {
        const groupEl = document.createElement(
            'tr-ui-b-grouping-table-groupby-picker-group');
        groupEl.picker = this;
        groupEl.group = possibleGroups[i];
        Polymer.dom(this.$.container).appendChild(groupEl);
      }
      this.restoreSetting_();
      this.updateFirstLast_();
    },

    updateFirstLast_() {
      const groupEls = this.$.container.children;
      const enabledGroupEls = [...groupEls].filter(el => el.enabled);
      for (let i = 0; i < enabledGroupEls.length; ++i) {
        enabledGroupEls[i].isFirst = i === 0;
        enabledGroupEls[i].isLast = i === enabledGroupEls.length - 1;
      }
    },

    get currentGroupKeys() {
      return this.currentGroups.map(group => group.key);
    },

    get currentGroups() {
      const groups = [];
      for (const groupEl of this.$.container.children) {
        if (groupEl.enabled) {
          groups.push(groupEl.group);
        }
      }
      return groups;
    },

    set currentGroupKeys(newKeys) {
      if (!tr.b.compareArrays(this.currentGroupKeys, newKeys,
          (x, y) => x.localeCompare(y))) {
        return;
      }

      const possibleGroups = new Map();
      for (const group of this.possibleGroups) {
        possibleGroups.set(group.key, group);
      }

      const groupEls = this.$.container.children;

      let i = 0;
      for (i = 0; i < newKeys.length; ++i) {
        const group = possibleGroups.get(newKeys[i]);
        if (group === undefined) {
          newKeys.splice(i, 1);
          --i;
          continue;
        }
        groupEls[i].group = group;
        groupEls[i].enabled = true;
        possibleGroups.delete(newKeys[i]);
      }

      for (const group of possibleGroups.values()) {
        groupEls[i].group = group;
        groupEls[i].enabled = false;
        ++i;
      }

      this.updateFirstLast_();
      this.onCurrentGroupsChanged_();
    },

    moveLeft_(groupEl) {
      const reference = groupEl.previousSibling;
      Polymer.dom(this.$.container).removeChild(groupEl);
      Polymer.dom(this.$.container).insertBefore(groupEl, reference);
      this.updateFirstLast_();

      if (groupEl.enabled) {
        this.onCurrentGroupsChanged_();
      }
    },

    moveRight_(groupEl) {
      const reference = groupEl.nextSibling.nextSibling;
      Polymer.dom(this.$.container).removeChild(groupEl);
      if (reference) {
        Polymer.dom(this.$.container).insertBefore(groupEl, reference);
      } else {
        Polymer.dom(this.$.container).appendChild(groupEl);
      }
      this.updateFirstLast_();

      if (groupEl.enabled) {
        this.onCurrentGroupsChanged_();
      }
    },

    onCurrentGroupsChanged_() {
      this.dispatchEvent(new tr.b.Event('current-groups-changed'));
      tr.b.Settings.set(this.settingsKey_, this.currentGroupKeys);
    },

    onEnableChanged_(groupEl) {
      this.updateFirstLast_();
      this.onCurrentGroupsChanged_();
    }
  });

  return {
  };
});


'use strict';
(function() {
  Polymer({
    is: 'tr-ui-sp-file-size-stats-side-panel',
    behaviors: [tr.ui.behaviors.SidePanel],

    ready() {
      this.model_ = undefined;
      this.selection_ = new tr.model.EventSet();
      this.$.picker.settingsKey = 'tr-ui-sp-file-size-stats-side-panel-picker';
      this.$.picker.possibleGroups = [
        {
          key: 'phase', label: 'Event Type',
          dataFn(eventStat) { return eventStat.phase; }
        },
        {
          key: 'category', label: 'Category',
          dataFn(eventStat) { return eventStat.category; }
        },
        {
          key: 'title', label: 'Title',
          dataFn(eventStat) { return eventStat.title; }
        }
      ];
      // If the picker did not restore currentGroupKeys from Settings,
      // then set default currentGroupKeys.
      if (this.$.picker.currentGroupKeys.length === 0) {
        this.$.picker.currentGroupKeys = ['phase', 'title'];
      }
      this.$.picker.addEventListener('current-groups-changed',
          this.updateContents_.bind(this));
    },

    get textLabel() {
      return 'File Size Stats';
    },

    supportsModel(m) {
      if (!m) {
        return {
          supported: false,
          reason: 'No stats were collected for this file.'
        };
      }

      if (m.stats.allTraceEventStats.length === 0) {
        return {
          supported: false,
          reason: 'No stats were collected for this file.'
        };
      }
      return {
        supported: true
      };
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateContents_();
    },

    get rangeOfInterest() {
      return this.rangeOfInterest_;
    },

    set rangeOfInterest(rangeOfInterest) {
      this.rangeOfInterest_ = rangeOfInterest;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      this.selection_ = selection;
    },

    createColumns_(stats) {
      const columns = [
        {
          title: 'Title',
          value(row) {
            const titleEl = document.createElement('span');
            Polymer.dom(titleEl).textContent = row.title;
            titleEl.style.textOverflow = 'ellipsis';
            return titleEl;
          },
          cmp(a, b) {
            return a.title.localeCompare(b.title);
          },
          width: '400px'
        },
        {
          title: 'Num Events',
          align: tr.ui.b.TableFormat.ColumnAlignment.RIGHT,
          value(row) {
            return row.rowStats.numEvents;
          },
          cmp(a, b) {
            return a.rowStats.numEvents - b.rowStats.numEvents;
          },
          width: '80px'
        }
      ];

      if (stats && stats.hasEventSizesinBytes) {
        columns.push({
          title: 'Bytes',
          value(row) {
            const value = new tr.b.Scalar(tr.b.Unit.byName.sizeInBytes,
                row.rowStats.totalEventSizeinBytes);
            const spanEl = tr.v.ui.createScalarSpan(value);
            return spanEl;
          },
          cmp(a, b) {
            return a.rowStats.totalEventSizeinBytes -
                b.rowStats.totalEventSizeinBytes;
          },
          width: '80px'
        });
      }
      return columns;
    },

    updateContents_() {
      const table = this.$.table;

      const columns = this.createColumns_(this.model.stats);
      table.rowStatsConstructor = function ModelStatsRowStats(row) {
        const sum = tr.b.math.Statistics.sum(row.data, function(x) {
          return x.numEvents;
        });
        const totalEventSizeinBytes = tr.b.math.Statistics.sum(row.data, x =>
          x.totalEventSizeinBytes
        );
        return {
          numEvents: sum,
          totalEventSizeinBytes
        };
      };
      table.tableColumns = columns;
      table.sortColumnIndex = 1;
      table.sortDescending = true;
      table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;

      table.groupBy = this.$.picker.currentGroups.map(function(group) {
        return group.dataFn;
      });

      if (!this.model) {
        table.dataToGroup = [];
      } else {
        table.dataToGroup = this.model.stats.allTraceEventStats;
      }
      this.$.table.rebuild();
    }
  });

  tr.ui.side_panel.SidePanelRegistry.register(function() {
    return document.createElement('tr-ui-sp-file-size-stats-side-panel');
  });
})();


'use strict';

tr.exportTo('tr.mre', function() {
  const FunctionRegistry = {
    allFunctions_: [],
    allFunctionsByName_: {},
    get allFunctions() { return this.allFunctions_; },
    get allFunctionsByName() { return this.allFunctionsByName_; }
  };

  FunctionRegistry.getFunction = function(name) {
    return this.allFunctionsByName_[name];
  };

  FunctionRegistry.register = function(func) {
    if (func.name === '') {
      throw new Error('Registered functions must not be anonymous');
    }
    if (this.allFunctionsByName[func.name] !== undefined) {
      throw new Error('Function named ' + func.name + 'is already registered.');
    }
    this.allFunctionsByName[func.name] = func;
    this.allFunctions.push(func);
  };

  function ModuleToLoad(href, filename) {
    if ((href !== undefined) ? (filename !== undefined) :
        (filename === undefined)) {
      throw new Error('ModuleToLoad must specify exactly one of href or ' +
                      'filename');
    }
    this.href = href;
    this.filename = filename;
  }

  ModuleToLoad.prototype = {
    asDict() {
      if (this.href !== undefined) {
        return {'href': this.href};
      }
      return {'filename': this.filename};
    },

    toString() {
      if (this.href !== undefined) {
        return 'ModuleToLoad(href="' + this.href + '")';
      }
      return 'ModuleToLoad(filename="' + this.filename + '")';
    }
  };

  ModuleToLoad.fromDict = function(moduleDict) {
    return new ModuleToLoad(moduleDict.href, moduleDict.filename);
  };

  function FunctionHandle(modulesToLoad, functionName, opt_options) {
    if (!(modulesToLoad instanceof Array)) {
      throw new Error('modulesToLoad in FunctionHandle must be an array');
    }
    if (typeof(functionName) !== 'string') {
      throw new Error('functionName in FunctionHandle must be a string');
    }
    this.modulesToLoad = modulesToLoad;
    this.functionName = functionName;
    this.options_ = opt_options;
  }

  FunctionHandle.prototype = {
    get options() {
      return this.options_;
    },

    asDict() {
      return {
        'modules_to_load': this.modulesToLoad.map(
            function(m) {return m.asDict();}),
        'function_name': this.functionName,
        'options': this.options_
      };
    },

    asUserFriendlyString() {
      const parts = this.modulesToLoad.map(mtl => mtl.filename);
      parts.push(this.functionName);
      parts.push(JSON.stringify(this.options_));
      return parts.join(',');
    },

    hasHrefs() {
      for (const module in this.modulesToLoad) {
        if (this.modulesToLoad[module].href !== undefined) {
          return true;
        }
      }
      return false;
    },

    load() {
      if (this.hasHrefs()) {
        const err = new Error(
            'FunctionHandle named ' + this.functionName +
            ' specifies hrefs, which cannot be loaded.');
        err.name = 'FunctionLoadingError';
        throw err;
      }

      for (const module in this.modulesToLoad) {
        const filename = this.modulesToLoad[module].filename;
        try {
          HTMLImportsLoader.loadHTMLFile(filename);
        } catch (err) {
          err.name = 'FunctionLoadingError';
          throw err;
        }
      }

      const func = FunctionRegistry.getFunction(this.functionName);
      if (func === undefined) {
        const err = new Error(
            'No registered function named ' + this.functionName);
        err.name = 'FunctionNotDefinedError';
        throw err;
      }

      return func;
    },

    toString() {
      const modulesToLoadStr = this.modulesToLoad.map(function(module) {
        return module.toString();
      });
      return 'FunctionHandle(modulesToLoad=[' + modulesToLoadStr + '], ' +
          'functionName="' + this.functionName + '", options="' +
          JSON.stringify(this.options_) + '")';
    }
  };

  FunctionHandle.loadFromFilename_ = function(filename) {
    try {
      const numFunctionsBefore = FunctionRegistry.allFunctions.length;
      HTMLImportsLoader.loadHTMLFile(filename);
    } catch (err) {
      err.name = 'FunctionLoadingError';
      throw err;
    }

    // Verify a new function was registered.
    const numFunctionsNow = FunctionRegistry.allFunctions.length;
    if (numFunctionsNow !== (numFunctionsBefore + 1)) {
      const err = new Error(
          filename + ' didn\'t call FunctionRegistry.register');
      err.name = 'FunctionNotDefinedError';
      throw err;
    }

    return FunctionRegistry.allFunctions[numFunctionsNow - 1];
  };

  FunctionHandle.fromDict = function(handleDict) {
    const options = handleDict.options;
    let modulesToLoad;
    if (handleDict.modules_to_load !== undefined) {
      modulesToLoad = handleDict.modules_to_load.map(function(module) {
        return ModuleToLoad.fromDict(module);
      });
    }
    return new FunctionHandle(modulesToLoad, handleDict.function_name, options);
  };

  return {
    FunctionHandle,
    ModuleToLoad,
    FunctionRegistry,
  };
});


'use strict';

tr.exportTo('tr.metrics', function() {
  /**
   * @param {!tr.model.Model} model
   * @param {!Object} options
   * @param {!Array.<string>} options.metrics
   * @return {!tr.v.HistogramSet}
   */
  function runMetrics(model, options) {
    if (options === undefined) {
      throw new Error('Options are required.');
    }

    const metricNames = options.metrics;
    if (!metricNames) {
      throw new Error('Metric names should be specified.');
    }

    const histograms = new tr.v.HistogramSet();

    for (const metricName of metricNames) {
      const metric = tr.metrics.MetricRegistry.findTypeInfoWithName(metricName);
      if (metric === undefined) {
        throw new Error('"' + metricName + '" is not a registered metric.');
      }
      metric.constructor(histograms, model, options);
    }

    validateDiagnosticNames(histograms);

    return histograms;
  }

  /**
   * Ensure that metrics don't use reserved diagnostic names.
   *
   * @param {!tr.v.HistogramSet} histograms
   */
  function validateDiagnosticNames(histograms) {
    for (const hist of histograms) {
      for (const name of hist.diagnostics.keys()) {
        if (tr.v.d.RESERVED_NAMES_SET.has(name)) {
          throw new Error(
              `Illegal diagnostic name "${name}" on Histogram "${hist.name}"`);
        }
      }
    }
  }

  /**
   * @param {!tr.v.HistogramSet} histograms
   * @param {!tr.model.Model} model
   */
  function addTelemetryInfo(histograms, model) {
    for (const metadata of model.metadata) {
      if (!metadata.value || !metadata.value.telemetry) continue;

      for (const [name, value] of Object.entries(metadata.value.telemetry)) {
        const type = tr.v.d.RESERVED_NAMES_TO_TYPES.get(name);
        if (type === undefined) {
          throw new Error(`Unexpected telemetry.${name}`);
        }
        histograms.addSharedDiagnostic(name, new type(value));
      }
    }
  }

  /**
   * @param {!tr.mre.MreResult} result
   * @param {!tr.model.Model} model
   * @param {!Object} options
   * @param {!Array.<string>} options.metrics
   */
  function metricMapFunction(result, model, options) {
    const histograms = runMetrics(model, options);
    addTelemetryInfo(histograms, model);

    result.addPair('histograms', histograms.asDicts());

    const scalarDicts = [];
    for (const value of histograms) {
      for (const [statName, scalar] of value.statisticsScalars) {
        scalarDicts.push({
          name: value.name + '_' + statName,
          numeric: scalar.asDict(),
          description: value.description,
        });
      }
    }
    result.addPair('scalars', scalarDicts);
  }

  tr.mre.FunctionRegistry.register(metricMapFunction);

  return {
    metricMapFunction,
    runMetrics,
  };
});


'use strict';

tr.exportTo('tr.mre', function() {
  function Failure(job, functionHandleString, traceCanonicalUrl,
      failureTypeName, description, stack) {
    this.job = job;
    this.functionHandleString = functionHandleString;
    this.traceCanonicalUrl = traceCanonicalUrl;
    this.failureTypeName = failureTypeName;
    this.description = description;
    this.stack = stack;
  }

  Failure.prototype = {
    asDict() {
      // TODO(eakuefner): Serialize job once reduction is implemented.
      return {
        function_handle_string: this.functionHandleString,
        trace_canonical_url: this.traceCanonicalUrl,
        type: this.failureTypeName,
        description: this.description,
        stack: this.stack
      };
    }
  };

  Failure.fromDict = function(failureDict) {
    return new Failure(undefined, failureDict.function_handle_string,
                       failureDict.trace_canonical_url, failureDict.type,
                       failureDict.description, failureDict.stack);
  };

  return {
    Failure,
  };
});



'use strict';

tr.exportTo('tr.mre', function() {
  class MreResult {
    constructor(failures, pairs) {
      if (failures === undefined) {
        failures = [];
      }
      if (pairs === undefined) {
        pairs = {};
      }
      this.failures = failures;
      this.pairs = pairs;
    }

    addFailure(failure) {
      this.failures.push(failure);
    }

    addPair(key, value) {
      if (key in this.pairs) {
        throw new Error('Key ' + key + ' already exists in result.');
      }
      this.pairs[key] = value;
    }

    asDict() {
      const d = {
        pairs: this.pairs
      };

      if (this.failures) {
        d.failures = this.failures.map(function(f) {return f.asDict();});
      }

      return d;
    }

    hadFailures() {
      return this.failures.length > 0;
    }

    static fromDict(resultDict) {
      const failures = (resultDict.failures !== undefined) ?
        resultDict.failures.map(tr.mre.Failure.fromDict) : undefined;
      const pairs = resultDict.pairs;
      return new MreResult(failures, pairs);
    }
  }

  return {
    MreResult,
  };
});



'use strict';

tr.exportTo('tr.ui', function() {
  /*
   * Some elements such as analysis-links require at least one of their
   * ancestors to have a BrushingStateController.
   * Some clients of such elements, such as histogram-set-view, do not have a
   * timeline-view, which is required by the BrushingStateController.
   * This class provides the API of BrushingStateController but not the
   * implementation, unless there is a real BrushingStateController in the
   * owning element's ancestor chain, in which case the implementation is
   * delegated to the real BrushingStateController.
   */
  class NullBrushingStateController extends tr.c.BrushingStateController {
    constructor() {
      super(undefined);
      this.parentController = undefined;
    }

    dispatchChangeEvent_() {
      if (this.parentController) this.parentController.dispatchChangeEvent_();
    }

    get model() {
      if (!this.parentController) return undefined;
      return this.parentController.model;
    }

    get trackView() {
      if (!this.parentController) return undefined;
      return this.parentController.trackView;
    }

    get viewport() {
      if (!this.parentController) return undefined;
      return this.parentController.viewport;
    }

    get historyEnabled() {
      if (!this.parentController) return undefined;
      return this.parentController.historyEnabled;
    }

    set historyEnabled(historyEnabled) {
      if (this.parentController) {
        this.parentController.historyEnabled = historyEnabled;
      }
    }

    modelWillChange() {
      if (this.parentController) this.parentController.modelWillChange();
    }

    modelDidChange() {
      if (this.parentController) this.parentController.modelDidChange();
    }

    onUserInitiatedSelectionChange_() {
      if (this.parentController) {
        this.parentController.onUserInitiatedSelectionChange_();
      }
    }

    onPopState_(e) {
      if (this.parentController) this.parentController.onPopState_(e);
    }

    get selection() {
      if (!this.parentController) return undefined;
      return this.parentController.selection;
    }

    get findMatches() {
      if (!this.parentController) return undefined;
      return this.parentController.findMatches;
    }

    get selectionOfInterest() {
      if (!this.parentController) return undefined;
      return this.parentController.selectionOfInterest;
    }

    get currentBrushingState() {
      if (!this.parentController) return undefined;
      return this.parentController.currentBrushingState;
    }

    set currentBrushingState(newBrushingState) {
      if (this.parentController) {
        this.parentController.currentBrushingState = newBrushingState;
      }
    }

    addAllEventsMatchingFilterToSelectionAsTask(filter, selection) {
      if (this.parentController) {
        this.parentController.addAllEventsMatchingFilterToSelectionAsTask(
            filter, selection);
      }
    }

    findTextChangedTo(allPossibleMatches) {
      if (this.parentController) {
        this.parentController.findTextChangedTo(allPossibleMatches);
      }
    }

    findFocusChangedTo(currentFocus) {
      if (this.parentController) {
        this.parentController.findFocusChangedTo(currentFocus);
      }
    }

    findTextCleared() {
      if (this.parentController) {
        this.parentController.findTextCleared();
      }
    }

    uiStateFromString(string) {
      if (this.parentController) {
        this.parentController.uiStateFromString(string);
      }
    }

    navToPosition(uiState, showNavLine) {
      if (this.parentController) {
        this.parentController.navToPosition(uiState, showNavLine);
      }
    }

    changeSelectionFromTimeline(selection) {
      if (this.parentController) {
        this.parentController.changeSelectionFromTimeline(selection);
      }
    }

    showScriptControlSelection(selection) {
      if (this.parentController) {
        this.parentController.showScriptControlSelection(selection);
      }
    }

    changeSelectionFromRequestSelectionChangeEvent(selection) {
      if (this.parentController) {
        this.parentController.changeSelectionFromRequestSelectionChangeEvent(
            selection);
      }
    }

    changeAnalysisViewRelatedEvents(eventSet) {
      if (this.parentController && (eventSet instanceof tr.model.EventSet)) {
        this.parentController.changeAnalysisViewRelatedEvents(eventSet);
      }
    }

    changeAnalysisLinkHoveredEvents(eventSet) {
      if (this.parentController && (eventSet instanceof tr.model.EventSet)) {
        this.parentController.changeAnalysisLinkHoveredEvents(eventSet);
      }
    }

    getViewSpecificBrushingState(viewId) {
      if (this.parentController) {
        this.parentController.getViewSpecificBrushingState(viewId);
      }
    }

    changeViewSpecificBrushingState(viewId, newState) {
      if (this.parentController) {
        this.parentController.changeViewSpecificBrushingState(viewId, newState);
      }
    }
  }

  return {
    NullBrushingStateController,
  };
});


'use strict';
tr.exportTo('tr.v', function() {
  class CSVBuilder {
    /**
     * @param {!tr.v.HistogramSet} histograms
     */
    constructor(histograms) {
      this.histograms_ = histograms;
      this.table_ = [];
      this.statisticsNames_ = new Set();
      this.groupings_ = [];
    }

    build() {
      this.prepare_();
      this.buildHeader_();
      this.buildTable_();
    }

    prepare_() {
      for (const [key, grouping] of tr.v.HistogramGrouping.BY_KEY) {
        if (key === 'name') continue;
        this.groupings_.push(grouping);
      }
      this.groupings_.push(new tr.v.GenericSetGrouping(
          tr.v.d.RESERVED_NAMES.TRACE_URLS));

      this.groupings_.sort((a, b) => a.key.localeCompare(b.key));

      for (const hist of this.histograms_) {
        for (const name of hist.statisticsNames) {
          this.statisticsNames_.add(name);
        }
      }
      this.statisticsNames_ = Array.from(this.statisticsNames_);
      this.statisticsNames_.sort();
    }

    buildHeader_() {
      const header = ['name', 'unit'];
      for (const name of this.statisticsNames_) {
        header.push(name);
      }
      for (const grouping of this.groupings_) {
        header.push(grouping.key);
      }
      this.table_.push(header);
    }

    buildTable_() {
      for (const hist of this.histograms_) {
        const row = [hist.name, hist.unit.unitString];
        this.table_.push(row);

        for (const name of this.statisticsNames_) {
          const stat = hist.getStatisticScalar(name);
          if (stat) {
            row.push(stat.value);
          } else {
            row.push('');
          }
        }

        for (const grouping of this.groupings_) {
          row.push(grouping.callback(hist));
        }
      }
    }

    toString() {
      let str = '';
      for (const row of this.table_) {
        for (let i = 0; i < row.length; ++i) {
          if (i > 0) {
            str += ',';
          }
          let cell = '' + row[i];
          cell = cell.replace(/\n/g, ' ');
          if (cell.indexOf(',') >= 0 || cell.indexOf('"') >= 0) {
            cell = '"' + cell.replace(/"/g, '""') + '"';
          }
          str += cell;
        }
        str += '\n';
      }
      return str;
    }
  }

  return {
    CSVBuilder,
  };
});


'use strict';
tr.exportTo('tr.v', function() {
  const getDisplayLabel =
    tr.v.HistogramGrouping.DISPLAY_LABEL.callback;

  const DEFAULT_POSSIBLE_GROUPS = [];

  // Override HISTOGRAM_NAME so that we can display shortName.
  DEFAULT_POSSIBLE_GROUPS.push(new tr.v.HistogramGrouping(
      tr.v.HistogramGrouping.HISTOGRAM_NAME.key,
      h => h.shortName || h.name));

  const EXCLUDED_GROUPING_KEYS = [
    tr.v.HistogramGrouping.HISTOGRAM_NAME.key,
    tr.v.HistogramGrouping.DISPLAY_LABEL.key,
  ];
  // HISTOGRAM_NAME is overridden.
  // DISPLAY_LABEL is used to define the columns, so don't allow grouping rows
  // by it.
  for (const group of tr.v.HistogramGrouping.BY_KEY.values()) {
    if (EXCLUDED_GROUPING_KEYS.includes(group.key)) continue;
    DEFAULT_POSSIBLE_GROUPS.push(group);
  }

  // This Processor collects various parameters from a set of Histograms such as
  // their statistics, displayLabels, and grouping keys in a single pass.
  class HistogramParameterCollector {
    constructor() {
      this.statisticNames_ = new Set(['avg']);

      this.labelsToStartTimes_ = new Map();

      // @typedef {!Map.<string,!tr.v.HistogramGrouping>}
      this.keysToGroupings_ = new Map(DEFAULT_POSSIBLE_GROUPS.map(
          g => [g.key, g]));

      // Map from HistogramGrouping keys to Sets of return values from the
      // HistogramGroupings' callbacks.
      this.keysToValues_ = new Map(DEFAULT_POSSIBLE_GROUPS.map(
          g => [g.key, new Set()]));

      // Never remove 'name' from keysToGroupings.
      this.keysToValues_.delete(
          tr.v.HistogramGrouping.HISTOGRAM_NAME.key);
    }

    process(histograms) {
      const allStoryTags = new Set();
      let maxSampleCount = 0;
      for (const hist of histograms) {
        maxSampleCount = Math.max(maxSampleCount, hist.numValues);

        for (const statName of hist.statisticsNames) {
          this.statisticNames_.add(statName);
        }

        let startTime = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.BENCHMARK_START);
        if (startTime !== undefined) startTime = startTime.minDate.getTime();

        const displayLabel = getDisplayLabel(hist);

        if (this.labelsToStartTimes_.has(displayLabel)) {
          startTime = Math.min(startTime,
              this.labelsToStartTimes_.get(displayLabel));
        }
        this.labelsToStartTimes_.set(displayLabel, startTime);

        for (const [groupingKey, values] of this.keysToValues_) {
          const grouping = this.keysToGroupings_.get(groupingKey);
          const value = grouping.callback(hist);
          if (!value) continue;
          values.add(value);
          if (values.size > 1) {
            // This grouping will definitely stay in keysToGroupings_. We don't
            // need to see any more values in the rest of histograms. Remove
            // this groupingKey from this.keysToValues_ so that we don't compute
            // it for any more histograms and so that we don't delete it from
            // keysToGroupings_.
            this.keysToValues_.delete(groupingKey);
          }
        }

        const storyTags = hist.diagnostics.get(
            tr.v.d.RESERVED_NAMES.STORY_TAGS);
        for (const tag of (storyTags || [])) {
          allStoryTags.add(tag);
        }
      }
      tr.b.Timing.instant(
          'HistogramParameterCollector', 'maxSampleCount', maxSampleCount);

      for (const tagGrouping of tr.v.HistogramGrouping.buildFromTags(
          allStoryTags, tr.v.d.RESERVED_NAMES.STORY_TAGS)) {
        const values = new Set();
        for (const hist of histograms) {
          values.add(tagGrouping.callback(hist));
        }
        if (values.size > 1) {
          this.keysToGroupings_.set(tagGrouping.key, tagGrouping);
          this.keysToValues_.set(tagGrouping.key, values);
        }
      }
    }

    get statisticNames() {
      return Array.from(this.statisticNames_);
    }

    get labels() {
      const displayLabels = Array.from(this.labelsToStartTimes_.keys());
      displayLabels.sort((x, y) =>
          this.labelsToStartTimes_.get(x) - this.labelsToStartTimes_.get(y));
      return displayLabels;
    }

    get possibleGroupings() {
      for (const [key, values] of this.keysToValues_) {
        if (values.size >= 2) continue;
        // Remove this grouping from keysToGroupings_ if there is fewer than
        // 2 possible values.
        this.keysToGroupings_.delete(key);
      }

      return Array.from(this.keysToGroupings_.values());
    }
  }

  return {
    HistogramParameterCollector,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  const ALPHA_OPTIONS = [];
  for (let i = 1; i < 10; ++i) ALPHA_OPTIONS.push(i * 1e-3);
  for (let i = 1; i < 10; ++i) ALPHA_OPTIONS.push(i * 1e-2);
  ALPHA_OPTIONS.push(0.01);

  Polymer({
    is: 'tr-v-ui-histogram-set-controls',

    properties: {
      searchQuery: {
        type: String,
        value: '',
        observer: 'onUserChange_',
      },
      showAll: {
        type: Boolean,
        value: false,
        observer: 'onUserChange_',
      },
      referenceDisplayLabel: {
        type: String,
        value: '',
        observer: 'onUserChange_',
      },
      displayStatisticName: {
        type: String,
        value: '',
        observer: 'onUserChange_',
      },
      alphaString: {
        type: String,
        computed: 'getAlphaString_(alphaIndex)',
      },
      alphaIndex: {
        type: Number,
        value: 9,
        observer: 'onUserChange_',
      },
    },

    created() {
      this.viewState_ = undefined;
      this.rowListener_ = this.onRowViewStateUpdate_.bind(this);
      this.baseStatisticNames_ = [];

      // When onViewStateUpdate_() copies multiple properties from the viewState
      // to polymer properties, disable onUserChange_ until all properties are
      // copied in order to prevent nested mutations to the ViewState.
      this.isInOnViewStateUpdate_ = false;
    },

    ready() {
      this.$.picker.addEventListener('current-groups-changed',
          this.onGroupsChanged_.bind(this));
    },

    get viewState() {
      return this.viewState_;
    },

    set viewState(vs) {
      if (this.viewState_) {
        throw new Error('viewState must be set exactly once.');
      }
      this.viewState_ = vs;
      this.viewState.addUpdateListener(this.onViewStateUpdate_.bind(this));
      // It would be arduous to construct a delta and call viewStateListener_
      // here in case vs contains non-default values, so callers must set
      // viewState first and then update it.
    },

    async onUserChange_() {
      if (!this.viewState) return;
      if (this.isInOnViewStateUpdate_) return;

      const marks = [];
      if (this.searchQuery !== this.viewState.searchQuery) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'search'));
      }
      if (this.showAll !== this.viewState.showAll) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'showAll'));
      }
      if (this.referenceDisplayLabel !== this.viewState.referenceDisplayLabel) {
        marks.push(tr.b.Timing.mark(
            'histogram-set-controls', 'referenceColumn'));
      }
      if (this.displayStatisticName !== this.viewState.displayStatisticName) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'statistic'));
      }
      if (parseInt(this.alphaIndex) !== this.getAlphaIndexFromViewState_()) {
        marks.push(tr.b.Timing.mark('histogram-set-controls', 'alpha'));
      }

      let displayStatisticName = this.displayStatisticName;
      if (this.viewState.referenceDisplayLabel === '' &&
          this.referenceDisplayLabel !== '' &&
          this.baseStatisticNames.length) {
        // The user selected a reference display label.
        displayStatisticName = `${tr.v.DELTA}${this.displayStatisticName}`;
        // Can't set this.displayStatisticName before updating viewState -- that
        // would cause an infinite loop of onUserChange_().
      }
      if (this.referenceDisplayLabel === '' &&
          this.viewState.referenceDisplayLabel !== '' &&
          this.baseStatisticNames.length) {
        // The user unset the reference display label.
        // Ensure that displayStatisticName is not a delta statistic.
        const deltaIndex = displayStatisticName.indexOf(tr.v.DELTA);
        if (deltaIndex >= 0) {
          displayStatisticName = displayStatisticName.slice(deltaIndex + 1);
        } else if (!this.baseStatisticNames.includes(displayStatisticName)) {
          displayStatisticName = 'avg';
        }
      }

      // Propagate updates from the user to the view state.
      await this.viewState.update({
        searchQuery: this.searchQuery,
        showAll: this.showAll,
        referenceDisplayLabel: this.referenceDisplayLabel,
        displayStatisticName,
        alpha: ALPHA_OPTIONS[this.alphaIndex],
      });

      if (this.referenceDisplayLabel &&
          this.statisticNames.length === this.baseStatisticNames.length) {
        // When a reference column is selected, delta statistics should be
        // available.
        this.statisticNames = this.baseStatisticNames.concat(
            tr.v.Histogram.getDeltaStatisticsNames(this.baseStatisticNames));
      } else if (!this.referenceDisplayLabel &&
          this.statisticNames.length > this.baseStatisticNames.length) {
        // When a reference column is not selected, delta statistics should not
        // be available.
        this.statisticNames = this.baseStatisticNames;
      }

      for (const mark of marks) mark.end();
    },

    onViewStateUpdate_(event) {
      this.isInOnViewStateUpdate_ = true;

      if (event.delta.searchQuery) {
        this.searchQuery = this.viewState.searchQuery;
      }

      if (event.delta.showAll) this.showAll = this.viewState.showAll;

      if (event.delta.displayStatisticName) {
        this.displayStatisticName = this.viewState.displayStatisticName;
      }

      if (event.delta.referenceDisplayLabel) {
        this.referenceDisplayLabel = this.viewState.referenceDisplayLabel;
        this.$.alpha.style.display = this.referenceDisplayLabel ? 'inline' : '';
      }

      if (event.delta.groupings) {
        this.$.picker.currentGroupKeys = this.viewState.groupings.map(
            g => g.key);
      }

      if (event.delta.tableRowStates) {
        for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
            this.viewState.tableRowStates.values())) {
          row.addUpdateListener(this.rowListener_);
        }

        const anyShowing = this.anyOverviewCharts_;
        this.$.hide_overview.style.display = anyShowing ? 'inline' : 'none';
        this.$.show_overview.style.display = anyShowing ? 'none' : 'inline';
      }

      if (event.delta.alpha) {
        this.alphaIndex = this.getAlphaIndexFromViewState_();
      }

      this.isInOnViewStateUpdate_ = false;
      this.onUserChange_();
    },

    onRowViewStateUpdate_(event) {
      if (event.delta.isOverviewed) {
        const anyShowing = event.delta.isOverviewed.current ||
            this.anyOverviewCharts_;
        this.$.hide_overview.style.display = anyShowing ? 'inline' : 'none';
        this.$.show_overview.style.display = anyShowing ? 'none' : 'inline';
      }

      if (event.delta.subRows) {
        for (const subRow of event.delta.subRows.previous) {
          subRow.removeUpdateListener(this.rowListener_);
        }
        for (const subRow of event.delta.subRows.current) {
          subRow.addUpdateListener(this.rowListener_);
        }
      }
    },

    onGroupsChanged_() {
      if (this.$.picker.currentGroups.length === 0 &&
          this.$.picker.possibleGroups.length > 0) {
        // If the current groupings are now empty but there are possible
        // groupings, then force there to be at least one grouping.
        // The histogram-set-table requires there to be at least one grouping.
        this.$.picker.currentGroupKeys = [this.$.picker.possibleGroups[0].key];
      }
      this.viewState.groupings = this.$.picker.currentGroups;
    },

    set showAllEnabled(enable) {
      if (!enable) this.$.show_all.checked = true;
      this.$.show_all.disabled = !enable;
    },

    set possibleGroupings(groupings) {
      this.$.picker.possibleGroups = groupings;
      this.$.picker.style.display = (groupings.length < 2) ? 'none' : 'block';
      this.onGroupsChanged_();
    },

    set displayLabels(labels) {
      this.$.reference_display_label.style.display =
          (labels.length < 2) ? 'none' : 'inline';

      while (this.$.reference_display_label.children.length > 1) {
        this.$.reference_display_label.removeChild(
            this.$.reference_display_label.lastChild);
      }

      for (const displayLabel of labels) {
        const option = document.createElement('option');
        option.textContent = displayLabel;
        option.value = displayLabel;
        this.$.reference_display_label.appendChild(option);
      }

      if (labels.includes(this.viewState.referenceDisplayLabel)) {
        this.referenceDisplayLabel = this.viewState.referenceDisplayLabel;
      } else {
        this.viewState.referenceDisplayLabel = '';
      }
    },

    get baseStatisticNames() {
      return this.baseStatisticNames_;
    },

    set baseStatisticNames(names) {
      this.baseStatisticNames_ = names;
      this.statisticNames = names;
    },

    get statisticNames() {
      return Array.from(this.$.statistic.options).map(o => o.value);
    },

    set statisticNames(names) {
      this.$.statistic.style.display = (names.length < 2) ? 'none' : 'inline';

      while (this.$.statistic.children.length) {
        this.$.statistic.removeChild(this.$.statistic.lastChild);
      }

      for (const name of names) {
        const option = document.createElement('option');
        option.textContent = name;
        this.$.statistic.appendChild(option);
      }

      if (names.includes(this.viewState.displayStatisticName)) {
        this.displayStatisticName = this.viewState.displayStatisticName;
        // Polymer doesn't reset the value when the options change, so do that
        // manually.
        this.$.statistic.value = this.displayStatisticName;
      } else {
        this.viewState.displayStatisticName = names[0] || '';
      }
    },

    get anyOverviewCharts_() {
      for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
          this.viewState.tableRowStates.values())) {
        if (row.isOverviewed) return true;
      }
      return false;
    },

    async toggleOverviewLineCharts_() {
      const showOverviews = !this.anyOverviewCharts_;
      const mark = tr.b.Timing.mark('histogram-set-controls',
          (showOverviews ? 'show' : 'hide') + 'OverviewCharts');

      for (const row of tr.v.ui.HistogramSetTableRowState.walkAll(
          this.viewState.tableRowStates.values())) {
        await row.update({isOverviewed: showOverviews});
      }

      this.$.hide_overview.style.display = showOverviews ? 'inline' : 'none';
      this.$.show_overview.style.display = showOverviews ? 'none' : 'inline';

      await tr.b.animationFrame();
      mark.end();
    },

    set helpHref(href) {
      this.$.help.href = href;
      this.$.help.style.display = 'inline';
    },

    set feedbackHref(href) {
      this.$.feedback.href = href;
      this.$.feedback.style.display = 'inline';
    },

    downloadCSV_(event) {
      this.dispatchEvent(new tr.b.Event('download-csv'));
    },

    getAlphaString_(alphaIndex) {
      // (9 * 1e-3).toString() is "0.009000000000000001", so truncate.
      return ('' + ALPHA_OPTIONS[alphaIndex]).substr(0, 5);
    },

    openAlphaSlider_() {
      const alphaButtonRect = this.$.alpha.getBoundingClientRect();
      this.$.alpha_slider_container.style.display = 'flex';
      this.$.alpha_slider_container.style.top = alphaButtonRect.bottom + 'px';
      this.$.alpha_slider_container.style.left = alphaButtonRect.left + 'px';
      this.$.alpha_slider.focus();
    },

    closeAlphaSlider_() {
      this.$.alpha_slider_container.style.display = '';
    },

    updateAlpha_() {
      this.alphaIndex = this.$.alpha_slider.value;
    },

    getAlphaIndexFromViewState_() {
      for (let i = 0; i < ALPHA_OPTIONS.length; ++i) {
        if (ALPHA_OPTIONS[i] >= this.viewState.alpha) return i;
      }
      return ALPHA_OPTIONS.length - 1;
    },
  });

  return {
  };
});


'use strict';
tr.exportTo('tr.v', function() {
  function deleteMergedToDiagnostics(histogramArrayMap) {
    for (const [name, histograms] of histogramArrayMap) {
      if (histograms instanceof Array) {
        for (const histogram of histograms) {
          histogram.diagnostics.delete(tr.v.d.RESERVED_NAMES.MERGED_TO);
        }
      } else if (histograms instanceof Map) {
        deleteMergedToDiagnostics(histograms);
      }
    }
  }

  /*
   * See also HistogramSet.groupHistogramsRecursively().
   * See also tr.v.ui.HistogramSetTableRow.
   */
  class HistogramSetHierarchy {
    /**
     * @param {string} name
     */
    constructor(name) {
      this.name = name;
      this.description = '';
      this.depth = 0;
      this.subRows = [];
      this.columns = new Map();
      this.mergeRelationshipsForColumn_ = new Map();
    }

    * walk() {
      yield this;
      for (const row of this.subRows) yield* row.walk();
    }

    static* walkAll(rootRows) {
      for (const rootRow of rootRows) yield* rootRow.walk();
    }

    /**
     * Build table rows recursively from grouped Histograms.
     *
     * @param {!(HistogramArray|HistogramArrayMap)}
     * @returns {!Array.<!HistogramSetHierarchy>}
     */
    static build(histogramArrayMap) {
      const rootRows = [];
      HistogramSetHierarchy.buildInternal_(histogramArrayMap, [], rootRows);

      const histograms = new tr.v.HistogramSet();

      for (const row of HistogramSetHierarchy.walkAll(rootRows)) {
        for (const hist of row.columns.values()) {
          if (!(hist instanceof tr.v.Histogram)) continue;
          histograms.addHistogram(hist);
        }
      }

      histograms.deduplicateDiagnostics();

      for (const row of HistogramSetHierarchy.walkAll(rootRows)) {
        for (const [name, hist] of row.columns) {
          if (!(hist instanceof tr.v.Histogram)) continue;
          if (!row.mergeRelationshipsForColumn_.get(name)) continue;
          hist.diagnostics.mergeRelationships(hist);
        }
      }

      // Delete "mergedTo" diagnostics from the original Histograms, or else
      // they'll accumulate as the user re-groups them, and slow down future
      // mergeRelationships operations.
      deleteMergedToDiagnostics(histogramArrayMap);

      for (const row of HistogramSetHierarchy.walkAll(rootRows)) {
        row.maybeRebin_();
      }

      return rootRows;
    }

    maybeRebin_() {
      // if all of |this| row's columns are single-bin, then re-bin all of them.
      const dataRange = new tr.b.math.Range();
      for (const hist of this.columns.values()) {
        if (!(hist instanceof tr.v.Histogram)) continue;
        if (hist.allBins.length > 1) return;  // don't re-bin
        if (hist.numValues === 0) continue;  // ignore hist
        dataRange.addValue(hist.min);
        dataRange.addValue(hist.max);
      }

      dataRange.addValue(tr.b.math.lesserWholeNumber(dataRange.min));
      dataRange.addValue(tr.b.math.greaterWholeNumber(dataRange.max));

      if (dataRange.min === dataRange.max) return;  // don't rebin

      const boundaries = tr.v.HistogramBinBoundaries.createLinear(
          dataRange.min, dataRange.max, tr.v.DEFAULT_REBINNED_COUNT);

      for (const [name, hist] of this.columns) {
        if (!(hist instanceof tr.v.Histogram)) continue;
        this.columns.set(name, hist.rebin(boundaries));
      }
    }

    static mergeHistogramDownHierarchy_(histogram, hierarchy, columnName) {
      // Track the path down the grouping tree to each Histogram,
      // but only start tracking the path at the grouping level that
      // corresponds to the Histogram NAME Grouping. This groupingPath will be
      // attached to Histograms in order to help mergeRelationships() figure out
      // which merged Histograms should be related to which other merged
      // Histograms.
      let groupingPath = undefined;

      for (const row of hierarchy) {
        if (groupingPath !== undefined) {
          groupingPath.push(row.name);
        } else if (row.name === histogram.name) {
          // Start tracking the path, but don't add histogram.name to the path,
          // since related histograms won't have the same name.
          groupingPath = [];
        }

        if (!row.description) {
          row.description = histogram.description;
        }

        const existing = row.columns.get(columnName);

        if (existing === undefined) {
          const clone = histogram.clone();
          if (groupingPath !== undefined) {
            new tr.v.d.GroupingPath(groupingPath).addToHistogram(clone);
          }
          row.columns.set(columnName, clone);
          row.mergeRelationshipsForColumn_.set(columnName, true);
          continue;
        }

        if (existing instanceof tr.v.HistogramSet) {
          // There have already been unmergeable histograms.
          existing.addHistogram(histogram);
          continue;
        }

        if (!existing.canAddHistogram(histogram)) {
          // Remember all of the original unmergeable Histograms so that
          // filter() can keep the rows that match the given HistogramSet even
          // if the rows will only be able to display (unmergeable).
          const unmergeableHistograms = new tr.v.HistogramSet([histogram]);
          const mergedFrom = existing.diagnostics.get(
              tr.v.d.RESERVED_NAMES.MERGED_FROM);
          if (mergedFrom !== undefined) {
            for (const [unusedName, origHist] of mergedFrom) {
              unmergeableHistograms.addHistogram(origHist);
            }
          }
          row.columns.set(columnName, unmergeableHistograms);
          continue;
        }

        if (existing.name !== histogram.name) {
          // It won't make sense to merge relationships for this merged
          // Histogram.
          row.mergeRelationshipsForColumn_.set(name, false);
        }

        existing.addHistogram(histogram);
      }
    }

    static buildInternal_(
        histogramArrayMap, hierarchy, rootRows) {
      for (const [name, histograms] of histogramArrayMap) {
        if (histograms instanceof Array) {
          // This recursion base case corresponds to the recursion base case of
          // groupHistogramsRecursively(). The last groupingCallback is always
          // getDisplayLabel, which defines the columns of the table and is
          // unskippable.
          for (const histogram of histograms) {
            HistogramSetHierarchy.mergeHistogramDownHierarchy_(
                histogram, hierarchy, name);
          }
        } else if (histograms instanceof Map) {
          // |histograms| is actually a nested histogramArrayMap.
          const row = new HistogramSetHierarchy(name);
          row.depth = hierarchy.length;
          hierarchy.push(row);
          HistogramSetHierarchy.buildInternal_(histograms, hierarchy, rootRows);
          hierarchy.pop();

          if (hierarchy.length === 0) {
            rootRows.push(row);
          } else {
            const parentRow = hierarchy[hierarchy.length - 1];
            parentRow.subRows.push(row);
          }
        }
      }
    }

    /**
     * Clones and filters |rows| to contain only |histograms|.
     *
     * @param {!Array.<HistogramSetHierarchy>} rows
     * @param {!tr.v.HistogramSet} histograms
     * @returns {!Array.<HistogramSetHierarchy>}
     */
    static filter(rows, histograms) {
      const results = [];
      for (const row of rows) {
        let filteredSubRows = [];
        if (row.subRows.length > 0) {
          // This is a branch row. Drop it if all of its subrows were dropped.
          filteredSubRows = HistogramSetHierarchy.filter(
              row.subRows, histograms);
          if (filteredSubRows.length === 0) continue;
        } else {
          // This is a leaf row. Drop it if none of the Histograms in
          // |row.columns| were merged from any in |histograms|.
          let found = false;
          for (const testHist of row.columns.values()) {
            if (testHist instanceof tr.v.HistogramSet) {
              // Keep this unmergeable cell if it was merged from any of
              // |histograms|.
              for (const origHist of testHist) {
                if (histograms.lookupHistogram(origHist.guid) !== undefined) {
                  found = true;
                  break;
                }
              }
              if (found) break;

              continue;
            }

            if (!(testHist instanceof tr.v.Histogram)) {
              throw new Error(
                  'Cells can only contain Histogram or HistogramSet');
            }

            if (histograms.lookupHistogram(testHist.guid) !== undefined) {
              found = true;
              break;
            }

            const mergedFrom = testHist.diagnostics.get(
                tr.v.d.RESERVED_NAMES.MERGED_FROM);
            if (mergedFrom !== undefined) {
              for (const [unusedName, origHist] of mergedFrom) {
                if (histograms.lookupHistogram(origHist.guid) !== undefined) {
                  found = true;
                  break;
                }
              }
            }
            if (found) break;
          }
          // If none of the Histograms in |row| were merged from any of
          // |histograms|, then drop this row.
          if (!found) continue;
        }

        const clone = new HistogramSetHierarchy(row.name);
        clone.description = row.description;
        clone.depth = row.depth;
        clone.subRows = filteredSubRows;
        // Don't need to clone Histograms.
        clone.columns = row.columns;
        results.push(clone);
      }
      return results;
    }
  }

  return {
    HistogramSetHierarchy,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-histogram-set-table-cell',

    created() {
      this.viewState_ = undefined;
      this.rootListener_ = this.onRootStateUpdate_.bind(this);
      this.row_ = undefined;
      this.displayLabel_ = '';
      this.histogram_ = undefined;
      this.histogramSpan_ = undefined;
      this.overviewChart_ = undefined;
    },

    ready() {
      this.addEventListener('click', this.onClick_.bind(this));
    },

    attached() {
      if (this.row) {
        this.row.rootViewState.addUpdateListener(this.rootListener_);
      }
    },

    detached() {
      this.row.rootViewState.removeUpdateListener(this.rootListener_);
      // Don't need to removeUpdateListener for the row and cells; their
      // lifetimes are the same as |this|.
    },

    build(row, displayLabel, viewState) {
      this.row_ = row;
      this.displayLabel_ = displayLabel;
      this.viewState_ = viewState;
      this.histogram_ = this.row.columns.get(displayLabel);

      if (this.viewState) {
        // this.viewState is undefined when this.histogram_ is undefined.
        // In that case, onViewStateUpdate_ wouldn't be able to do anything
        // anyway.
        this.viewState.addUpdateListener(this.onViewStateUpdate_.bind(this));
      }
      this.row.viewState.addUpdateListener(this.onRowStateUpdate_.bind(this));
      if (this.isAttached) {
        this.row.rootViewState.addUpdateListener(this.rootListener_);
      }

      // this.histogram_ and this.referenceHistogram might be undefined,
      // a HistogramSet of unmergeable Histograms, or a Histogram.
      this.updateContents_();
    },

    get viewState() {
      return this.viewState_;
    },

    get row() {
      return this.row_;
    },

    get histogram() {
      return this.histogram_;
    },

    get referenceHistogram() {
      const referenceDisplayLabel =
        this.row.rootViewState.referenceDisplayLabel;
      if (!referenceDisplayLabel) return undefined;
      if (referenceDisplayLabel === this.displayLabel_) return undefined;
      return this.row.columns.get(referenceDisplayLabel);
    },

    get isHistogramOpen() {
      return (this.histogramSpan_ !== undefined) &&
        (this.$.histogram.style.display === 'block');
    },

    get brushedBinRange() {
      if (!this.isHistogramOpen) return new tr.b.math.Range();
      return this.histogramSpan_.brushedBinRange;
    },

    set brushedBinRange(r) {
      if (this.histogramSpan_ === undefined) return;
      this.histogramSpan_.brushedBinRange = r;
    },

    get mergeSampleDiagnostics() {
      if (!this.isHistogramOpen) return false;
      return this.histogramSpan_.mergeSampleDiagnostics;
    },

    set mergeSampleDiagnostics(m) {
      if (this.histogramSpan_ === undefined) return;
      this.histogramSpan_.mergeSampleDiagnostics = m;
    },

    set isHistogramOpen(open) {
      if (!(this.histogram instanceof tr.v.Histogram) ||
          (this.histogram.numValues === 0)) {
        return;
      }

      // Unfortunately, we can't use a css attribute for this since this stuff
      // is tied up in all the possible states of this.histogram. See
      // updateContents_().

      this.$.scalar.style.display = open ? 'none' : 'flex';
      this.$.open_histogram.style.display = open ? 'none' : 'block';

      this.$.close_histogram.style.display = open ? 'block' : 'none';
      this.$.histogram.style.display = open ? 'block' : 'none';

      // Wait to create the histogram-span until the user wants to display it
      // in order to speed up creating lots of histogram-set-table-cells when
      // building the table.
      // Wait to pass the Histogram to the histogram-span until it's displayed
      // so that it can size its BarChart appropriately.
      if (open && this.histogramSpan_ === undefined) {
        this.histogramSpan_ = document.createElement('tr-v-ui-histogram-span');
        this.histogramSpan_.rowState = this.row.viewState;
        this.histogramSpan_.viewState = this.viewState;
        this.histogramSpan_.referenceHistogram = this.referenceHistogram;
        this.histogramSpan_.histogram = this.histogram;
        this.histogramSpan_.alpha = this.row.rootViewState.alpha;
        this.$.histogram.appendChild(this.histogramSpan_);
      }

      this.viewState.isOpen = open;
    },

    onViewStateUpdate_(event) {
      if (event.delta.isOpen) {
        this.isHistogramOpen = this.viewState.isOpen;
      }
    },

    onRowStateUpdate_(event) {
      if (event.delta.isOverviewed === undefined) return;
      if (this.row.viewState.isOverviewed) {
        this.showOverview();
      } else {
        this.hideOverview();
      }
    },

    onRootStateUpdate_(event) {
      if (event.delta.displayStatisticName ||
          event.delta.referenceDisplayLabel ||
          event.delta.alpha) {
        this.updateContents_();
      }
      if (this.row.viewState.isOverviewed &&
          (event.delta.sortColumnIndex ||
           event.delta.sortDescending ||
           event.delta.displayStatisticName ||
           event.delta.referenceDisplayLabel)) {
        if (this.overviewChart_ !== undefined) {
          this.$.overview_container.removeChild(this.overviewChart_);
          this.overviewChart_ = undefined;
        }
        this.showOverview();
      }
    },

    onClick_(event) {
      // Since the histogram-set-table's table doesn't support any kind of
      // selection, clicking anywhere within a row that has subRows will
      // expand/collapse that row, which can relayout the table and move things
      // around. Prevent table relayout by preventing the tr-ui-b-table from
      // receiving the click event.
      event.stopPropagation();
    },

    openHistogram_() {
      this.isHistogramOpen = true;
      tr.b.Timing.instant('histogram-set-table-cell', 'open');
    },

    closeHistogram_() {
      this.isHistogramOpen = false;
      tr.b.Timing.instant('histogram-set-table-cell', 'close');
    },

    updateContents_() {
      const isOpen = this.isHistogramOpen;

      this.$.empty.style.display = 'none';
      this.$.unmergeable.style.display = 'none';
      this.$.scalar.style.display = 'none';
      this.$.histogram.style.display = 'none';
      this.$.close_histogram.style.display = 'none';
      this.$.open_histogram.style.visibility = 'hidden';

      if (!this.histogram) {
        this.$.missing.style.display = 'block';
        return;
      }

      this.$.missing.style.display = 'none';

      if (this.histogram instanceof tr.v.HistogramSet) {
        this.$.unmergeable.style.display = 'block';
        return;
      }

      if (!(this.histogram instanceof tr.v.Histogram)) {
        throw new Error('Invalid Histogram: ' + this.histogram);
      }

      if (this.histogram.numValues === 0) {
        this.$.empty.style.display = 'block';
        return;
      }

      this.$.open_histogram.style.display = 'block';
      this.$.open_histogram.style.visibility = 'visible';
      this.$.scalar.style.display = 'flex';

      const referenceHistogram = this.referenceHistogram;

      if (this.histogramSpan_) {
        // Reset in case HistogramSetViewState.referenceDisplayLabel changed.
        this.histogramSpan_.referenceHistogram = referenceHistogram;

        this.histogramSpan_.alpha = this.row.rootViewState.alpha;
      }

      if ((referenceHistogram instanceof tr.v.Histogram) &&
          (this.histogram.unit === referenceHistogram.unit) &&
          (referenceHistogram.numValues > 0)) {
        this.$.scalar.significance = this.histogram.getDifferenceSignificance(
            referenceHistogram, this.row.rootViewState.alpha);
      }

      const statName = this.histogram.getAvailableStatisticName(
          this.row.rootViewState.displayStatisticName, referenceHistogram);
      const statisticScalar = this.histogram.getStatisticScalar(
          statName, referenceHistogram);
      this.$.scalar.setValueAndUnit(
          statisticScalar.value, statisticScalar.unit);

      this.isHistogramOpen = isOpen;
    },

    showOverview() {
      this.$.overview_container.style.display = 'block';
      if (this.overviewChart_ !== undefined) return;

      this.row.sortSubRows();
      let referenceDisplayLabel =
        this.row.rootViewState.referenceDisplayLabel;
      if (referenceDisplayLabel === this.displayLabel_) {
        referenceDisplayLabel = undefined;
      }
      const displayStatisticName = this.row.rootViewState.displayStatisticName;
      const data = [];
      let unit;

      for (const subRow of this.row.subRows) {
        const subHist = subRow.columns.get(this.displayLabel_);
        if (!(subHist instanceof tr.v.Histogram)) continue;

        if (unit === undefined) {
          unit = subHist.unit;
        } else if (unit !== subHist.unit) {
          // The subrows have different units, so the overview chart cannot
          // use a single unit to format all of the values, so don't display
          // an overview chart at all.
          data.splice(0);
          break;
        }

        const refHist = subRow.columns.get(referenceDisplayLabel);
        const statName = subHist.getAvailableStatisticName(
            displayStatisticName, refHist);
        const statScalar = subHist.getStatisticScalar(
            statName, refHist);

        if (statScalar !== undefined) {
          data.push({
            x: subRow.name,
            y: statScalar.value,
          });
        }
      }
      if (data.length < 2) return;

      this.overviewChart_ = new tr.ui.b.NameLineChart();
      this.$.overview_container.appendChild(this.overviewChart_);
      this.overviewChart_.displayXInHover = true;
      this.overviewChart_.hideLegend = true;
      this.overviewChart_.unit = unit;
      this.overviewChart_.overrideDataRange = this.row.overviewDataRange;
      this.overviewChart_.data = data;
    },

    hideOverview() {
      this.$.overview_container.style.display = 'none';
    }
  });

  return {
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  const NAME_COLUMN_WIDTH_PX = 300;

  Polymer({
    is: 'tr-v-ui-histogram-set-table-name-cell',

    created() {
      this.row_ = undefined;
      this.overviewChart_ = undefined;
      this.cellListener_ = this.onCellStateUpdate_.bind(this);
      this.rootListener_ = this.onRootStateUpdate_.bind(this);
    },

    attached() {
      if (this.row) {
        this.row.rootViewState.addUpdateListener(this.rootListener_);
      }
    },

    detached() {
      this.row.rootViewState.removeUpdateListener(this.rootListener_);
      // Don't need to removeUpdateListener for the row and cells; their
      // lifetimes are the same as |this|.
    },

    get row() {
      return this.row_;
    },

    build(row) {
      if (this.row_ !== undefined) {
        throw new Error('row must be set exactly once.');
      }
      this.row_ = row;
      this.row.viewState.addUpdateListener(this.onRowStateUpdate_.bind(this));
      this.constrainWidth = this.row.rootViewState.constrainNameColumn;
      if (this.isAttached) {
        this.row.rootViewState.addUpdateListener(this.rootListener_);
      }

      for (const cellState of this.row.viewState.cells.values()) {
        cellState.addUpdateListener(this.cellListener_);
      }

      Polymer.dom(this.$.name).textContent = this.row.name;

      this.title = this.row.name;
      if (this.row.description) {
        this.title += '\n' + this.row.description;
      }

      if (this.row.overviewDataRange.isEmpty ||
          this.row.overviewDataRange.min === this.row.overviewDataRange.max) {
        // TODO(#3744) Also hide this button when column or subrow units don't
        // match.
        this.$.show_overview.style.display = 'none';
      }

      let histogramCount = 0;
      for (const cell of this.row.columns.values()) {
        if (cell instanceof tr.v.Histogram &&
            cell.numValues > 0) {
          ++histogramCount;
        }
      }
      if (histogramCount <= 1) {
        this.$.open_histograms.style.display = 'none';
      }
    },

    set constrainWidth(constrain) {
      this.$.name.style.maxWidth = constrain ?
        (this.nameWidthPx + 'px') : 'none';
    },

    get nameWidthPx() {
      // tr-ui-b-table adds 16px of padding for each additional level of subRows
      // nesting, so outer nameDivs can be wider than inner nameDivs.
      return NAME_COLUMN_WIDTH_PX - (16 * this.row.depth);
    },

    get isOverflowing() {
      return this.$.name.style.maxWidth !== 'none' &&
          this.$.name.getBoundingClientRect().width === this.nameWidthPx;
    },

    get isOverviewed() {
      return this.$.overview_container.style.display === 'block';
    },

    set isOverviewed(isOverviewed) {
      if (isOverviewed === this.isOverviewed) return;
      if (isOverviewed) {
        this.showOverview_();
      } else {
        this.hideOverview_();
      }
    },

    hideOverview_(opt_event) {
      this.$.overview_container.style.display = 'none';
      this.$.hide_overview.style.display = 'none';
      this.$.show_overview.style.display = 'block';

      if (opt_event !== undefined) {
        opt_event.stopPropagation();
        tr.b.Timing.instant('histogram-set-table-name-cell', 'hideOverview');
        this.row.viewState.isOverviewed = this.isOverviewed;
      }
    },

    showOverview_(opt_event) {
      if (opt_event !== undefined) {
        opt_event.stopPropagation();
        tr.b.Timing.instant('histogram-set-table-name-cell', 'showOverview');
        this.row.viewState.isOverviewed = true;
      }

      this.$.overview_container.style.display = 'block';
      this.$.hide_overview.style.display = 'block';
      this.$.show_overview.style.display = 'none';

      if (this.overviewChart_ === undefined) {
        const displayStatisticName =
          this.row.rootViewState.displayStatisticName;
        const data = [];
        let unit;

        for (const [displayLabel, hist] of this.row.columns) {
          if (!(hist instanceof tr.v.Histogram)) continue;

          if (unit === undefined) {
            unit = hist.unit;
          } else if (unit !== hist.unit) {
            // The columns have different units, so the overview chart cannot
            // use a single unit to format all of the values, so don't display
            // an overview chart at all.
            data.splice(0);
            break;
          }

          const statName = hist.getAvailableStatisticName(displayStatisticName);
          const statScalar = hist.getStatisticScalar(statName);

          if (statScalar !== undefined) {
            data.push({
              x: displayLabel,
              y: statScalar.value,
            });
          }
        }
        if (data.length < 2) {
          return;
        }

        this.overviewChart_ = new tr.ui.b.NameLineChart();
        this.$.overview_container.appendChild(this.overviewChart_);
        this.overviewChart_.displayXInHover = true;
        this.overviewChart_.hideLegend = true;
        this.overviewChart_.unit = unit;
        this.overviewChart_.overrideDataRange = this.row.overviewDataRange;
        this.overviewChart_.data = data;
      }
    },

    openHistograms_(event) {
      event.stopPropagation();
      tr.b.Timing.instant('histogram-set-table-name-cell', 'openHistograms');
      for (const cell of this.row.cells.values()) {
        cell.isHistogramOpen = true;
      }
      this.$.close_histograms.style.display = 'block';
      this.$.open_histograms.style.display = 'none';
    },

    closeHistograms_(event) {
      event.stopPropagation();
      tr.b.Timing.instant('histogram-set-table-name-cell', 'closeHistograms');
      for (const cell of this.row.cells.values()) {
        cell.isHistogramOpen = false;
      }
      this.$.open_histograms.style.display = 'block';
      this.$.close_histograms.style.display = 'none';
    },

    onRootStateUpdate_(event) {
      if (event.delta.constrainNameColumn) {
        this.constrainWidth = this.row.rootViewState.constrainNameColumn;
      }
      if (this.row.viewState.isOverviewed &&
          event.delta.displayStatisticName) {
        this.row.resetOverviewDataRange();
        if (this.overviewChart_ !== undefined) {
          this.$.overview_container.removeChild(this.overviewChart_);
          this.overviewChart_ = undefined;
        }
        this.showOverview_();
      }
    },

    onRowStateUpdate_(event) {
      if (event.delta.isOverviewed) {
        this.isOverviewed = this.row.viewState.isOverviewed;
      }
      // This assumes that cell states are not updated.
    },

    onCellStateUpdate_(event) {
      if (!event.delta.isOpen) return;

      let cellCount = 0;
      let openCellCount = 0;
      for (const cell of this.row.cells.values()) {
        if (!(cell.histogram instanceof tr.v.Histogram) ||
            (cell.histogram.numValues === 0)) {
          continue;
        }
        ++cellCount;
        if (cell.isHistogramOpen) ++openCellCount;
      }
      if (cellCount <= 1) return;
      const mostlyOpen = openCellCount > (cellCount / 2);
      this.$.open_histograms.style.display = mostlyOpen ? 'none' : 'block';
      this.$.close_histograms.style.display = mostlyOpen ? 'block' : 'none';
    }
  });

  return {
    NAME_COLUMN_WIDTH_PX,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  class HistogramSetTableRow {
    /**
     * @param {!tr.v.HistogramSetHierarchy} hierarchy
     * @param {!Element} baseTable tr-ui-b-table
     * @param {!tr.v.ui.HistogramSetViewState} rootViewState
     */
    constructor(hierarchy, baseTable, rootViewState) {
      this.hierarchy_ = hierarchy;
      this.baseTable_ = baseTable;
      this.rootViewState_ = rootViewState;
      this.viewState_ = new tr.v.ui.HistogramSetTableRowState();
      this.viewState_.addUpdateListener(this.onViewStateUpdate_.bind(this));
      this.overviewDataRange_ = undefined;
      this.nameCell_ = undefined;
      this.cells_ = new Map();
      this.subRows_ = [];

      // Don't assign viewState.subRows or cells. There can't be anything
      // listening to viewState, so avoid the overhead of dispatching an event.
      for (const subHierarchy of hierarchy.subRows) {
        const subRow = new HistogramSetTableRow(
            subHierarchy, baseTable, rootViewState);
        this.subRows_.push(subRow);
        this.viewState.subRows.set(subRow.name, subRow.viewState);
      }
      for (const columnName of this.columns.keys()) {
        this.viewState.cells.set(
            columnName, new tr.v.ui.HistogramSetTableCellState());
      }
    }

    /**
     * @return {string}
     */
    get name() {
      return this.hierarchy_.name;
    }

    /**
     * @return {number}
     */
    get depth() {
      return this.hierarchy_.depth;
    }

    /**
     * @return {string}
     */
    get description() {
      return this.hierarchy_.description;
    }

    /**
     * @return {!Map.<string, !(undefined|tr.v.Histogram|tr.v.HistogramSet)>}
     */
    get columns() {
      return this.hierarchy_.columns;
    }

    /**
     * @return {!tr.b.Range}
     */
    get overviewDataRange() {
      if (this.overviewDataRange_ === undefined) {
        this.overviewDataRange_ = new tr.b.math.Range();

        const displayStatisticName =
          this.rootViewState.displayStatisticName;
        const referenceDisplayLabel =
          this.rootViewState.referenceDisplayLabel;

        for (const [displayLabel, hist] of this.columns) {
          if (hist instanceof tr.v.Histogram) {
            const statName = hist.getAvailableStatisticName(
                displayStatisticName);
            const statScalar = hist.getStatisticScalar(statName);
            if (statScalar !== undefined) {
              this.overviewDataRange_.addValue(statScalar.value);
            }
          }

          for (const subRow of this.subRows) {
            const subHist = subRow.columns.get(displayLabel);
            if (!(subHist instanceof tr.v.Histogram)) continue;

            const refHist = subRow.columns.get(referenceDisplayLabel);
            const statName = subHist.getAvailableStatisticName(
                displayStatisticName, refHist);
            const statScalar = subHist.getStatisticScalar(
                statName, refHist);

            if (statScalar !== undefined) {
              this.overviewDataRange_.addValue(statScalar.value);
            }
          }
        }
      }
      return this.overviewDataRange_;
    }

    /**
     * overviewDataRange is used by histogram-set-table-cell (hstc) and
     * histogram-set-table-name-cell (hstnc) to display overview line charts
     * with consistent y-axes.
     * overviewDataRange depends on HistogramSetViewState.displayStatisticName
     * and referenceDisplayLabel, so it must be recomputed when either of those
     * changes.
     * overviewDataRange should not be recomputed for each hstc in the row; it
     * should only be computed once when necessary, and cached.
     * HistogramSetTableRow (HSTR) cannot listen to HistogramSetViewState
     * (HSVS) updates because there is no way for it to remove the listener.
     * However, Polymer has detached callbacks, so dom-modules can listen to
     * HSVS updates without leaking memory.
     * overviewDataRange should be recomputed only once whenever
     * displayStatisticName or referenceDisplayLabel changes.
     * There is exactly one hstnc per row.
     * histogram-set-table-name-cell resets overviewDataRange when
     * displayStatisticName or referenceDisplayLabel changes.
     */
    resetOverviewDataRange() {
      this.overviewDataRange_ = undefined;
    }

    /**
     * @return {!tr.v.ui.HistogramSetViewState}
     */
    get rootViewState() {
      return this.rootViewState_;
    }

    /**
     * @return {!Map.<string, !Element>} tr-v-ui-histogram-set-table-cell
     */
    get cells() {
      return this.cells_;
    }

    /**
     * @return {!Array.<tr.v.ui.HistogramSetTableRow>}
     */
    get subRows() {
      return this.subRows_;
    }

    /**
     * @return {!Array.<tr.v.ui.HistogramSetTableRowState>}
     */
    get viewState() {
      return this.viewState_;
    }

    * walk() {
      yield this;
      for (const row of this.subRows) yield* row.walk();
    }

    static* walkAll(rootRows) {
      for (const rootRow of rootRows) yield* rootRow.walk();
    }

    get nameCell() {
      if (this.nameCell_ === undefined) {
        this.nameCell_ = document.createElement(
            'tr-v-ui-histogram-set-table-name-cell');
        this.nameCell_.build(this);
      }
      return this.nameCell_;
    }

    getCell(columnName) {
      if (this.cells.has(columnName)) return this.cells.get(columnName);
      const cell = document.createElement('tr-v-ui-histogram-set-table-cell');
      cell.build(this, columnName, this.viewState.cells.get(columnName));
      this.cells.set(columnName, cell);
      return cell;
    }

    compareNames(other) {
      return this.name.localeCompare(other.name);
    }

    compareCells(other, displayLabel) {
      const cellA = this.columns.get(displayLabel);
      const cellB = other.columns.get(displayLabel);
      if (!(cellA instanceof tr.v.Histogram) ||
          !(cellB instanceof tr.v.Histogram)) {
        return undefined;
      }

      let referenceCellA;
      let referenceCellB;

      // If a reference column is selected, compare the absolute deltas
      // between the two cells and their references.
      const referenceDisplayLabel = this.rootViewState.referenceDisplayLabel;
      if (referenceDisplayLabel &&
          referenceDisplayLabel !== displayLabel) {
        referenceCellA = this.columns.get(referenceDisplayLabel);
        referenceCellB = other.columns.get(referenceDisplayLabel);
      }

      const statisticA = cellA.getAvailableStatisticName(
          this.rootViewState.displayStatisticName, referenceCellA);
      const statisticB = cellB.getAvailableStatisticName(
          this.rootViewState.displayStatisticName, referenceCellB);
      const scalarA = cellA.getStatisticScalar(statisticA, referenceCellA);
      const scalarB = cellB.getStatisticScalar(statisticB, referenceCellB);
      const valueA = scalarA ? scalarA.value : undefined;
      const valueB = scalarB ? scalarB.value : undefined;

      return valueA - valueB;
    }

    onViewStateUpdate_(event) {
      if (event.delta.isExpanded) {
        this.baseTable_.setExpandedForTableRow(this, this.viewState.isExpanded);
      }

      if (event.delta.subRows) {
        throw new Error('HistogramSetTableRow.subRows must not be reassigned.');
      }

      if (event.delta.cells) {
        // Only validate the cells that have already been built.
        // Cells may not have been built yet, so only validate the cells that
        // have been built.
        for (const [displayLabel, cell] of this.cells) {
          if (cell.viewState !== this.viewState.cells.get(displayLabel)) {
            throw new Error('Only HistogramSetTableRow may update cells');
          }
        }
      }
    }

    async restoreState(vs) {
      // Don't use updateFromViewState() because it would overwrite cells and
      // subRows, but we just want to restore them.
      await this.viewState.update({
        isExpanded: vs.isExpanded,
        isOverviewed: vs.isOverviewed,
      });

      // If cells haven't been built yet, then their state will be restored when
      // they are built.
      for (const [displayLabel, cell] of this.cells) {
        const previousState = vs.cells.get(displayLabel);
        if (!previousState) continue;
        await cell.viewState.updateFromViewState(previousState);
      }
      for (const row of this.subRows) {
        const previousState = vs.subRows.get(row.name);
        if (!previousState) continue;
        await row.restoreState(previousState);
      }
    }

    sortSubRows() {
      const sortColumn = this.baseTable_.tableColumns[
        this.rootViewState_.sortColumnIndex];
      if (sortColumn === undefined) return;
      this.subRows_.sort(sortColumn.cmp);
      if (this.rootViewState_.sortDescending) {
        this.subRows_.reverse();
      }
    }
  }

  return {
    HistogramSetTableRow,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  const MIDLINE_HORIZONTAL_ELLIPSIS = String.fromCharCode(0x22ef);

  // http://stackoverflow.com/questions/3446170
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
  }

  Polymer({
    is: 'tr-v-ui-histogram-set-table',

    created() {
      this.viewState_ = undefined;
      this.progress_ = () => Promise.resolve();
      this.nameColumnTitle_ = undefined;
      this.displayLabels_ = [];
      this.histograms_ = undefined;
      this.sourceHistograms_ = undefined;
      this.groupedHistograms_ = undefined;
      this.hierarchies_ = undefined;
      this.tableRows_ = undefined;
    },

    ready() {
      this.$.table.zebra = true;
      this.addEventListener('sort-column-changed',
          this.onSortColumnChanged_.bind(this));
      this.addEventListener('requestSelectionChange',
          this.onRequestSelectionChange_.bind(this));
      this.addEventListener('row-expanded-changed',
          this.onRowExpandedChanged_.bind(this));
    },

    get viewState() {
      return this.viewState_;
    },

    set viewState(vs) {
      if (this.viewState_) {
        throw new Error('viewState must be set exactly once.');
      }
      this.viewState_ = vs;
      this.viewState.addUpdateListener(this.onViewStateUpdate_.bind(this));
      // It would be arduous to construct a delta and call onViewStateUpdate_
      // here in case vs contains non-default values, so callers must set
      // viewState first and then update it.
    },

    get histograms() {
      return this.histograms_;
    },

    /**
     * @param {!tr.v.HistogramSet} histograms
     * @param {!tr.v.HistogramSet} sourceHistograms
     * @param {!Array.<string>} displayLabels
     * @param {function(string, function())=} opt_progress
     */
    async build(histograms, sourceHistograms, displayLabels, opt_progress) {
      this.histograms_ = histograms;
      this.sourceHistograms_ = sourceHistograms;
      this.groupedHistograms_ = undefined;
      this.displayLabels_ = displayLabels;

      if (opt_progress !== undefined) this.progress_ = opt_progress;

      if (histograms.length === 0) {
        throw new Error('histogram-set-table requires non-empty HistogramSet.');
      }

      await this.progress_('Building columns...');
      this.$.table.tableColumns = [
        {
          title: this.buildNameColumnTitle_(),
          value: row => row.nameCell,
          cmp: (a, b) => a.compareNames(b),
        }
      ].concat(displayLabels.map(l => this.buildColumn_(l)));

      tr.b.Timing.instant('histogram-set-table', 'columnCount',
          this.$.table.tableColumns.length);

      // updateContents_() displays its own progress.
      await this.updateContents_();

      // Building some elements requires being able to measure them, which is
      // impossible until they are displayed. If clients hide this table while
      // it is being built, then they must display it when this event fires.
      this.fire('display-ready');

      this.progress_ = () => Promise.resolve();

      this.checkNameColumnOverflow_(
          tr.v.ui.HistogramSetTableRow.walkAll(this.$.table.tableRows));
    },

    buildNameColumnTitle_() {
      this.nameColumnTitle_ = document.createElement('span');
      this.nameColumnTitle_.style.display = 'inline-flex';

      // Wrap the string in a span instead of using createTextNode() so that the
      // span can be styled later.
      const nameEl = document.createElement('span');
      nameEl.textContent = 'Name';
      this.nameColumnTitle_.appendChild(nameEl);

      const toggleWidthEl = document.createElement('span');
      toggleWidthEl.style.fontWeight = 'bold';
      toggleWidthEl.style.background = '#bbb';
      toggleWidthEl.style.color = '#333';
      toggleWidthEl.style.padding = '0px 3px';
      toggleWidthEl.style.marginRight = '8px';
      toggleWidthEl.style.display = 'none';
      toggleWidthEl.textContent = MIDLINE_HORIZONTAL_ELLIPSIS;
      toggleWidthEl.addEventListener('click',
          this.toggleNameColumnWidth_.bind(this));
      this.nameColumnTitle_.appendChild(toggleWidthEl);
      return this.nameColumnTitle_;
    },

    toggleNameColumnWidth_(opt_event) {
      this.viewState.update({
        constrainNameColumn: !this.viewState.constrainNameColumn,
      });

      if (opt_event !== undefined) {
        opt_event.stopPropagation();
        opt_event.preventDefault();
        tr.b.Timing.instant('histogram-set-table', 'nameColumn' +
            (this.viewState.constrainNameColumn ? 'Constrained' :
             'Unconstrained'));
      }
    },

    buildColumn_(displayLabel) {
      const title = document.createElement('span');
      title.textContent = displayLabel;
      title.style.whiteSpace = 'pre';

      return {
        title,
        value: row => row.getCell(displayLabel),
        cmp: (rowA, rowB) => rowA.compareCells(rowB, displayLabel),
      };
    },

    async updateContents_() {
      if (this.groupedHistograms_ === undefined) {
        await this.progress_('Grouping Histograms...');
        this.groupHistograms_();
      }

      if (this.hierarchies_ === undefined) {
        await this.progress_('Merging Histograms...');
        this.hierarchies_ = tr.v.HistogramSetHierarchy.build(
            this.groupedHistograms_);
        this.tableRows_ = undefined;
      }

      const tableRowsDirty = this.tableRows_ === undefined;
      const previousRowStates = this.viewState.tableRowStates;

      if (tableRowsDirty) {
        await this.progress_('Filtering rows...');

        let filteredHistograms = this.viewState.showAll ?
            this.histograms : this.sourceHistograms_;
        if (this.viewState.searchQuery) {
          let query = undefined;
          try {
            query = new RegExp(this.viewState.searchQuery);
          } catch (e) {
          }
          if (query !== undefined) {
            filteredHistograms = new tr.v.HistogramSet(
                [...filteredHistograms].filter(
                    hist => hist.name.match(query)));
          }
        }

        const filteredHierarchies = tr.v.HistogramSetHierarchy.filter(
            this.hierarchies_, filteredHistograms);

        // Wait to set this.$.table.tableRows until we're ready for it to build
        // DOM. When tableRows are set on it, tr-ui-b-table calls
        // setTimeout(..., 0) to schedule rebuild for the next interpreter tick,
        // but that can happen in between the next await, which is too early.
        this.tableRows_ = filteredHierarchies.map(hierarchy =>
            new tr.v.ui.HistogramSetTableRow(
              hierarchy, this.$.table, this.viewState));

        tr.b.Timing.instant('histogram-set-table', 'rootRowCount',
            this.tableRows_.length);

        const namesToRowStates = new Map();
        for (const row of this.tableRows_) {
          namesToRowStates.set(row.name, row.viewState);
        }
        await this.viewState.update({tableRowStates: namesToRowStates});
      }

      await this.progress_('Configuring table...');
      this.nameColumnTitle_.children[1].style.filter =
        this.viewState.constrainNameColumn ? 'invert(100%)' : '';

      const referenceDisplayLabelIndex = this.displayLabels_.indexOf(
          this.viewState.referenceDisplayLabel);
      this.$.table.selectedTableColumnIndex = (referenceDisplayLabelIndex < 0) ?
          undefined : (1 + referenceDisplayLabelIndex);

      this.$.table.sortColumnIndex = this.viewState.sortColumnIndex;
      this.$.table.sortDescending = this.viewState.sortDescending;

      // Each name-cell listens to this.viewState for updates to
      // constrainNameColumn.
      // Each table-cell listens to this.viewState for updates to
      // displayStatisticName and referenceDisplayLabel.

      if (tableRowsDirty) {
        await this.progress_('Building DOM...');
        this.$.table.tableRows = this.tableRows_;

        // Try to restore previous row state.
        // Wait to do this until after the base table has the new rows so that
        // setExpandedForTableRow doesn't get confused.
        for (const row of this.tableRows_) {
          const previousState = previousRowStates.get(row.name);
          if (!previousState) continue;
          await row.restoreState(previousState);
        }
      }

      // It's always safe to call this, it will only recompute what is dirty.
      // We want to make sure that the table is up to date when this async
      // function resolves.
      this.$.table.rebuild();
    },

    async onRowExpandedChanged_(event) {
      event.row.viewState.isExpanded =
        this.$.table.getExpandedForTableRow(event.row);
      tr.b.Timing.instant('histogram-set-table',
          'row' + (event.row.viewState.isExpanded ? 'Expanded' : 'Collapsed'));

      // When the user expands a row, the table builds subRows' name-cells.
      // If a subRow's name isOverflowing even though none of the top-level rows
      // are constrained, show the dots to allow the user to unconstrain the
      // name column.
      // Each name-cell.isOverflowing would force layout if we don't await
      // animationFrame here, which would be inefficient.
      if (this.nameColumnTitle_.children[1].style.display === 'block') return;
      await tr.b.animationFrame();
      this.checkNameColumnOverflow_(event.row.subRows);
    },

    checkNameColumnOverflow_(rows) {
      for (const row of rows) {
        if (!row.nameCell.isOverflowing) continue;

        const [nameSpan, dots] = this.nameColumnTitle_.children;
        dots.style.display = 'block';

        // Size the span containing 'Name' so that the dots align with the
        // ellipses in the name-cells.
        const labelWidthPx = tr.v.ui.NAME_COLUMN_WIDTH_PX -
          dots.getBoundingClientRect().width;
        nameSpan.style.width = labelWidthPx + 'px';

        return;
      }
    },

    groupHistograms_() {
      const groupings = this.viewState.groupings.slice();
      groupings.push(tr.v.HistogramGrouping.DISPLAY_LABEL);

      function canSkipGrouping(grouping, groupedHistograms) {
        // Never skip meaningful groupings.
        if (groupedHistograms.size > 1) return false;

        // Never skip the zero-th grouping.
        if (grouping.key === groupings[0].key) return false;

        // Never skip the grouping that defines the table columns.
        if (grouping.key === tr.v.HistogramGrouping.DISPLAY_LABEL.key) {
          return false;
        }

        // Skip meaningless groupings.
        return true;
      }

      this.groupedHistograms_ = this.histograms.groupHistogramsRecursively(
          groupings, canSkipGrouping);

      this.hierarchies_ = undefined;
    },

    /**
     * @param {!tr.b.Event} event
     * @param {!Object} event.delta
     * @param {!Object} event.delta.searchQuery
     * @param {!Object} event.delta.referenceDisplayLabel
     * @param {!Object} event.delta.displayStatisticName
     * @param {!Object} event.delta.showAll
     * @param {!Object} event.delta.groupings
     * @param {!Object} event.delta.sortColumnIndex
     * @param {!Object} event.delta.sortDescending
     * @param {!Object} event.delta.constrainNameColumn
     * @param {!Object} event.delta.tableRowStates
     */
    async onViewStateUpdate_(event) {
      if (this.histograms_ === undefined) return;

      if (event.delta.groupings !== undefined) {
        this.groupedHistograms_ = undefined;
      }

      if (event.delta.searchQuery !== undefined ||
          event.delta.showAll !== undefined) {
        this.tableRows_ = undefined;
      }

      if (event.delta.displayStatistic !== undefined &&
          this.$.table.sortColumnIndex > 0) {
        // Force re-sort.
        this.$.table.sortColumnIndex = undefined;
      }

      if (event.delta.referenceDisplayLabel !== undefined ||
          event.delta.displayStatisticName !== undefined) {
        // Force this.$.table.bodyDirty_ = true;
        this.$.table.tableRows = this.$.table.tableRows;
      }

      // updateContents_() always copies sortColumnIndex and sortDescending
      // from the viewState to the table. The table will only re-sort if
      // they change.

      // Name-cells listen to this.viewState to handle updates to
      // constrainNameColumn.

      if (event.delta.tableRowStates) {
        if (this.tableRows_.length !==
            this.viewState.tableRowStates.size) {
          throw new Error(
              'Only histogram-set-table may update tableRowStates');
        }
        for (const row of this.tableRows_) {
          if (this.viewState.tableRowStates.get(row.name) !== row.viewState) {
            throw new Error(
                'Only histogram-set-table may update tableRowStates');
          }
        }
      }

      await this.updateContents_();
    },

    onSortColumnChanged_(event) {
      tr.b.Timing.instant('histogram-set-table', 'sortColumn');
      this.viewState.update({
        sortColumnIndex: event.sortColumnIndex,
        sortDescending: event.sortDescending,
      });
    },

    onRequestSelectionChange_(event) {
      // This event may reference an EventSet or an array of Histogram names.
      // If EventSet, let the BrushingStateController handle it.
      if (event.selection instanceof tr.model.EventSet) return;

      event.stopPropagation();
      tr.b.Timing.instant('histogram-set-table', 'selectHistogramNames');

      let histogramNames = event.selection;
      histogramNames.sort();
      histogramNames = histogramNames.map(escapeRegExp).join('|');
      this.viewState.update({
        showAll: true,
        searchQuery: `^(${histogramNames})$`,
      });
    },

    /**
     * @return {!tr.v.HistogramSet}
     */
    get leafHistograms() {
      const histograms = new tr.v.HistogramSet();
      for (const row of
          tr.v.ui.HistogramSetTableRow.walkAll(this.$.table.tableRows)) {
        if (row.subRows.length) continue;
        for (const hist of row.columns.values()) {
          if (!(hist instanceof tr.v.Histogram)) continue;

          histograms.addHistogram(hist);
        }
      }
      return histograms;
    }
  });

  return {
    MIDLINE_HORIZONTAL_ELLIPSIS,
  };
});


'use strict';
tr.exportTo('tr.v.ui', function() {
  Polymer({
    is: 'tr-v-ui-histogram-set-view',

    created() {
      this.brushingStateController_ = new tr.ui.NullBrushingStateController();
      this.viewState_ = new tr.v.ui.HistogramSetViewState();
    },

    ready() {
      this.$.table.viewState = this.viewState;
      this.$.controls.viewState = this.viewState;
      this.$.controls.addEventListener(
          'download-csv', this.downloadCSV_.bind(this));
    },

    attached() {
      this.brushingStateController.parentController =
          tr.c.BrushingStateController.getControllerForElement(this.parentNode);
    },

    get brushingStateController() {
      return this.brushingStateController_;
    },

    get viewState() {
      return this.viewState_;
    },

    set helpHref(href) {
      this.$.controls.helpHref = href;
    },

    set feedbackHref(href) {
      this.$.controls.feedbackHref = href;
    },

    get histograms() {
      return this.$.table.histograms;
    },

    /**
     * @param {!tr.v.HistogramSet} histograms
     * @param {function(string):!Promise=} opt_progress
     */
    async build(histograms, opt_progress) {
      const progress = opt_progress || (() => Promise.resolve());

      if (histograms === undefined || histograms.length === 0) {
        this.$.container.style.display = 'none';
        this.$.zero.style.display = 'block';
        this.style.display = 'block';
        return;
      }
      this.$.zero.style.display = 'none';
      this.$.container.style.display = 'block';
      this.$.container.style.maxHeight = (window.innerHeight - 16) + 'px';

      const buildMark = tr.b.Timing.mark('histogram-set-view', 'build');
      await progress('Finding important Histograms...');
      const sourceHistogramsMark = tr.b.Timing.mark(
          'histogram-set-view', 'sourceHistograms');
      const sourceHistograms = histograms.sourceHistograms;
      sourceHistogramsMark.end();
      // Disable show_all if all values are sourceHistograms.
      this.$.controls.showAllEnabled = (
          sourceHistograms.length !== histograms.length);

      await progress('Collecting parameters...');
      const collectParametersMark = tr.b.Timing.mark(
          'histogram-set-view', 'collectParameters');
      const parameterCollector = new tr.v.HistogramParameterCollector();
      parameterCollector.process(histograms);
      this.$.controls.baseStatisticNames = parameterCollector.statisticNames;
      this.$.controls.possibleGroupings = parameterCollector.possibleGroupings;
      const displayLabels = parameterCollector.labels;
      this.$.controls.displayLabels = displayLabels;
      collectParametersMark.end();

      // Table.build() displays its own progress.
      await this.$.table.build(
          histograms, sourceHistograms, displayLabels, progress);

      buildMark.end();
    },

    downloadCSV_() {
      const downloadCSVMark = tr.b.Timing.mark(
          'histogram-set-view', 'downloadCSV');
      const anchor = document.createElement('a');

      const path = window.location.pathname.split('/');
      const basename = path[path.length - 1].split('.')[0] || 'histograms';
      anchor.download = basename + '.csv';

      const csv = new tr.v.CSVBuilder(this.$.table.leafHistograms);
      csv.build();
      const blob = new window.Blob([csv.toString()], {type: 'text/csv'});
      anchor.href = window.URL.createObjectURL(blob);

      anchor.click();
      downloadCSVMark.end();
    }
  });

  return {
  };
});


'use strict';
tr.exportTo('tr.ui', function() {
  Polymer({
    is: 'tr-ui-sp-metrics-side-panel',
    behaviors: [tr.ui.behaviors.SidePanel],

    ready() {
      this.model_ = undefined;

      this.rangeOfInterest_ = undefined;
      this.metricLatenciesMs_ = [];

      this.metrics_ = [];
      tr.metrics.MetricRegistry.getAllRegisteredTypeInfos().forEach(
          function(m) {
            if (m.constructor.name === 'sampleMetric') return;

            this.metrics_.push({
              label: m.constructor.name,
              value: m.constructor.name
            });
          }, this);

      this.metrics_.sort((x, y) => x.label.localeCompare(y.label));

      this.settingsKey_ = 'metrics-side-panel-metric-name';
      this.currentMetricName_ = 'responsivenessMetric';
      const metricSelector = tr.ui.b.createSelector(
          this, 'currentMetricName_',
          this.settingsKey_,
          this.currentMetricName_,
          this.metrics_);
      Polymer.dom(this.$.top_left_controls).appendChild(metricSelector);
      metricSelector.addEventListener('change',
          this.onMetricChange_.bind(this));
      this.currentMetricTypeInfo_ =
        tr.metrics.MetricRegistry.findTypeInfoWithName(
            this.currentMetricName_);

      this.recomputeButton_ = tr.ui.b.createButton(
          'Recompute', this.onRecompute_, this);
      Polymer.dom(this.$.top_left_controls).appendChild(this.recomputeButton_);

      this.$.results.addEventListener('display-ready', () => {
        this.$.results.style.display = '';
      });
    },

    async build(model) {
      this.model_ = model;
      await this.updateContents_();
    },

    /**
     * Return an estimate of how many milliseconds it would take to re-run the
     * metric. If the metric has not been run, return undefined.
     *
     * @return {undefined|number}
     */
    get metricLatencyMs() {
      return tr.b.math.Statistics.mean(this.metricLatenciesMs_);
    },

    onMetricChange_() {
      this.currentMetricTypeInfo_ =
        tr.metrics.MetricRegistry.findTypeInfoWithName(
            this.currentMetricName_);
      this.metricLatenciesMs_ = [];
      this.updateContents_();
    },

    onRecompute_() {
      this.updateContents_();
    },

    get textLabel() {
      return 'Metrics';
    },

    supportsModel(m) {
      if (!m) {
        return {
          supported: false,
          reason: 'No model available'
        };
      }

      return {
        supported: true
      };
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.build(model);
    },

    get selection() {
      // Not applicable to metrics.
    },

    set selection(_) {
      // Not applicable to metrics.
    },

    /**
     * @return {undefined|!tr.b.math.Range}
     */
    get rangeOfInterest() {
      return this.rangeOfInterest_;
    },

    /**
     * This may be called rapidly as the mouse is moved.
     * If the metric supportsRangeOfInterest and takes less than 100ms, then it
     * will be re-run immediately; otherwise, the Recompute button will be
     * enabled.
     *
     * @param {!tr.b.math.Range} range
     */
    set rangeOfInterest(range) {
      this.rangeOfInterest_ = range;

      if (this.currentMetricTypeInfo_ &&
          this.currentMetricTypeInfo_.metadata.supportsRangeOfInterest) {
        if ((this.metricLatencyMs === undefined) ||
            (this.metricLatencyMs < 100)) {
          this.updateContents_();
        } else {
          this.recomputeButton_.style.background = 'red';
        }
      }
    },

    async updateContents_() {
      Polymer.dom(this.$.error).textContent = '';
      this.$.results.style.display = 'none';

      if (!this.model_) {
        Polymer.dom(this.$.error).textContent = 'Missing model';
        return;
      }

      const options = {metrics: [this.currentMetricName_]};

      if (this.currentMetricTypeInfo_ &&
          this.currentMetricTypeInfo_.metadata.supportsRangeOfInterest &&
          this.rangeOfInterest &&
          !this.rangeOfInterest.isEmpty) {
        options.rangeOfInterest = this.rangeOfInterest;
      }

      const startDate = new Date();
      let histograms;
      try {
        histograms = tr.metrics.runMetrics(this.model_, options);
      } catch (err) {
        Polymer.dom(this.$.error).textContent = err.message;
        return;
      }

      this.metricLatenciesMs_.push(new Date() - startDate);
      while (this.metricLatenciesMs_.length > 20) {
        this.metricLatenciesMs_.shift();
      }

      this.recomputeButton_.style.background = '';

      await this.$.results.build(histograms);
    }
  });

  tr.ui.side_panel.SidePanelRegistry.register(function() {
    return document.createElement('tr-ui-sp-metrics-side-panel');
  });

  return {};
});


'use strict';

Polymer({
  is: 'tr-ui-e-s-alerts-side-panel',
  behaviors: [tr.ui.behaviors.SidePanel],


  ready() {
    this.rangeOfInterest_ = new tr.b.math.Range();
    this.selection_ = undefined;
  },

  get model() {
    return this.model_;
  },

  set model(model) {
    this.model_ = model;
    this.updateContents_();
  },

  set selection(selection) {
  },

  set rangeOfInterest(rangeOfInterest) {
  },

  /**
   * Fires a selection event selecting all alerts of the specified
   * type.
   */
  selectAlertsOfType(alertTypeString) {
    const alertsOfType = this.model_.alerts.filter(function(alert) {
      return alert.title === alertTypeString;
    });

    const event = new tr.model.RequestSelectionChangeEvent();
    event.selection = new tr.model.EventSet(alertsOfType);
    this.dispatchEvent(event);
  },

  /**
   * Returns a map for the specified alerts where each key is the
   * alert type string and each value is a list of alerts with that
   * type.
   */
  alertsByType_(alerts) {
    const alertsByType = {};
    alerts.forEach(function(alert) {
      if (!alertsByType[alert.title]) {
        alertsByType[alert.title] = [];
      }

      alertsByType[alert.title].push(alert);
    });
    return alertsByType;
  },

  alertsTableRows_(alertsByType) {
    return Object.keys(alertsByType).map(function(key) {
      return {
        alertType: key,
        count: alertsByType[key].length
      };
    });
  },

  alertsTableColumns_() {
    return [
      {
        title: 'Alert type',
        value(row) { return row.alertType; },
        width: '180px'
      },
      {
        title: 'Count',
        width: '100%',
        value(row) { return row.count; }
      }
    ];
  },

  createAlertsTable_(alerts) {
    const alertsByType = this.alertsByType_(alerts);

    const table = document.createElement('tr-ui-b-table');
    table.tableColumns = this.alertsTableColumns_();
    table.tableRows = this.alertsTableRows_(alertsByType);
    table.selectionMode = tr.ui.b.TableFormat.SelectionMode.ROW;
    table.addEventListener('selection-changed', function(e) {
      const row = table.selectedTableRow;
      if (row) {
        this.selectAlertsOfType(row.alertType);
      }
    }.bind(this));

    return table;
  },

  updateContents_() {
    Polymer.dom(this.$.result_area).textContent = '';
    if (this.model_ === undefined) return;

    const panel = this.createAlertsTable_(this.model_.alerts);
    Polymer.dom(this.$.result_area).appendChild(panel);
  },

  supportsModel(m) {
    if (m === undefined) {
      return {
        supported: false,
        reason: 'Unknown tracing model'
      };
    } else if (m.alerts.length === 0) {
      return {
        supported: false,
        reason: 'No alerts in tracing model'
      };
    }

    return {
      supported: true
    };
  },

  get textLabel() {
    return 'Alerts';
  }
});

tr.ui.side_panel.SidePanelRegistry.register(function() {
  return document.createElement('tr-ui-e-s-alerts-side-panel');
});

</script>
<script id="viewer-data" type="text/plain">
H4sIAAAAAAAC/7WWPU/DMBBAd36G5wxn+3xndwPRDcTSreoQtVaL1DYRtUAI8d9xGCoxJCaubonsJHp+uo/k1ndf6tyeolqo9X3fP8Zj3Lcpbk6fq3hJqlHbNuVn+fr7VqP6Q94+DIvXnVoQUaPSsHLMXuu8uQx3zXdTBV5Og61GN0o+xvd4fDnHSmkN2oVp+Oqjq4UbY/wf+OrwFtvdEIvNfi4Vr1RvsaCcj6mOCJownshLatPr9jmmQ7db1J7AhHo8LPOTeY0MBuRx8PxEXsGBrB0HP3VdX0k2gBPF/a9oF7rHGE10Q7mU8NYErG6gEhxBh+rWL8KRXV1Sl4WkagaWKReyU61zi7MHDCLOaHO/izijYy8TZ8xxlnF2AQFFnAkAWcSZbNBOxhnRBxlnCiDzySZGlqkNBmtAxJkhAMg4E7ORcWYbvIyzJ0MyzkF7mX+KB+9N1WxTAmvUpmoaK4I98/zpt0TNA8eQux883lvHwwwAAA==
</script>
</head>
  <body>
  </body>
</html>
